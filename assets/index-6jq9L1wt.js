function _mergeNamespaces(n,t){for(var r=0;r<t.length;r++){const i=t[r];if(typeof i!="string"&&!Array.isArray(i)){for(const s in i)if(s!=="default"&&!(s in n)){const o=Object.getOwnPropertyDescriptor(i,s);o&&Object.defineProperty(n,s,o.get?o:{enumerable:!0,get:()=>i[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const l of o.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&i(l)}).observe(document,{childList:!0,subtree:!0});function r(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(s){if(s.ep)return;s.ep=!0;const o=r(s);fetch(s.href,o)}})();function makeMap(n,t){const r=Object.create(null),i=n.split(",");for(let s=0;s<i.length;s++)r[i[s]]=!0;return t?s=>!!r[s.toLowerCase()]:s=>!!r[s]}const EMPTY_OBJ={},EMPTY_ARR=[],NOOP=()=>{},NO=()=>!1,isOn=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&(n.charCodeAt(2)>122||n.charCodeAt(2)<97),isModelListener=n=>n.startsWith("onUpdate:"),extend=Object.assign,remove=(n,t)=>{const r=n.indexOf(t);r>-1&&n.splice(r,1)},hasOwnProperty$1=Object.prototype.hasOwnProperty,hasOwn=(n,t)=>hasOwnProperty$1.call(n,t),isArray=Array.isArray,isMap=n=>toTypeString(n)==="[object Map]",isSet=n=>toTypeString(n)==="[object Set]",isFunction$1=n=>typeof n=="function",isString$1=n=>typeof n=="string",isSymbol=n=>typeof n=="symbol",isObject=n=>n!==null&&typeof n=="object",isPromise$1=n=>(isObject(n)||isFunction$1(n))&&isFunction$1(n.then)&&isFunction$1(n.catch),objectToString=Object.prototype.toString,toTypeString=n=>objectToString.call(n),toRawType=n=>toTypeString(n).slice(8,-1),isPlainObject=n=>toTypeString(n)==="[object Object]",isIntegerKey=n=>isString$1(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,isReservedProp=makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),cacheStringFunction=n=>{const t=Object.create(null);return r=>t[r]||(t[r]=n(r))},camelizeRE=/-(\w)/g,camelize=cacheStringFunction(n=>n.replace(camelizeRE,(t,r)=>r?r.toUpperCase():"")),hyphenateRE=/\B([A-Z])/g,hyphenate=cacheStringFunction(n=>n.replace(hyphenateRE,"-$1").toLowerCase()),capitalize=cacheStringFunction(n=>n.charAt(0).toUpperCase()+n.slice(1)),toHandlerKey=cacheStringFunction(n=>n?`on${capitalize(n)}`:""),hasChanged=(n,t)=>!Object.is(n,t),invokeArrayFns=(n,t)=>{for(let r=0;r<n.length;r++)n[r](t)},def=(n,t,r)=>{Object.defineProperty(n,t,{configurable:!0,enumerable:!1,value:r})},looseToNumber=n=>{const t=parseFloat(n);return isNaN(t)?n:t},toNumber=n=>{const t=isString$1(n)?Number(n):NaN;return isNaN(t)?n:t};let _globalThis;const getGlobalThis=()=>_globalThis||(_globalThis=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function normalizeStyle(n){if(isArray(n)){const t={};for(let r=0;r<n.length;r++){const i=n[r],s=isString$1(i)?parseStringStyle(i):normalizeStyle(i);if(s)for(const o in s)t[o]=s[o]}return t}else if(isString$1(n)||isObject(n))return n}const listDelimiterRE=/;(?![^(]*\))/g,propertyDelimiterRE=/:([^]+)/,styleCommentRE=/\/\*[^]*?\*\//g;function parseStringStyle(n){const t={};return n.replace(styleCommentRE,"").split(listDelimiterRE).forEach(r=>{if(r){const i=r.split(propertyDelimiterRE);i.length>1&&(t[i[0].trim()]=i[1].trim())}}),t}function normalizeClass(n){let t="";if(isString$1(n))t=n;else if(isArray(n))for(let r=0;r<n.length;r++){const i=normalizeClass(n[r]);i&&(t+=i+" ")}else if(isObject(n))for(const r in n)n[r]&&(t+=r+" ");return t.trim()}const specialBooleanAttrs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",isSpecialBooleanAttr=makeMap(specialBooleanAttrs);function includeBooleanAttr(n){return!!n||n===""}const toDisplayString=n=>isString$1(n)?n:n==null?"":isArray(n)||isObject(n)&&(n.toString===objectToString||!isFunction$1(n.toString))?JSON.stringify(n,replacer,2):String(n),replacer=(n,t)=>t&&t.__v_isRef?replacer(n,t.value):isMap(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((r,[i,s],o)=>(r[stringifySymbol(i,o)+" =>"]=s,r),{})}:isSet(t)?{[`Set(${t.size})`]:[...t.values()].map(r=>stringifySymbol(r))}:isSymbol(t)?stringifySymbol(t):isObject(t)&&!isArray(t)&&!isPlainObject(t)?String(t):t,stringifySymbol=(n,t="")=>{var r;return isSymbol(n)?`Symbol(${(r=n.description)!=null?r:t})`:n};let activeEffectScope;class EffectScope{constructor(t=!1){this.detached=t,this._active=!0,this.effects=[],this.cleanups=[],this.parent=activeEffectScope,!t&&activeEffectScope&&(this.index=(activeEffectScope.scopes||(activeEffectScope.scopes=[])).push(this)-1)}get active(){return this._active}run(t){if(this._active){const r=activeEffectScope;try{return activeEffectScope=this,t()}finally{activeEffectScope=r}}}on(){activeEffectScope=this}off(){activeEffectScope=this.parent}stop(t){if(this._active){let r,i;for(r=0,i=this.effects.length;r<i;r++)this.effects[r].stop();for(r=0,i=this.cleanups.length;r<i;r++)this.cleanups[r]();if(this.scopes)for(r=0,i=this.scopes.length;r<i;r++)this.scopes[r].stop(!0);if(!this.detached&&this.parent&&!t){const s=this.parent.scopes.pop();s&&s!==this&&(this.parent.scopes[this.index]=s,s.index=this.index)}this.parent=void 0,this._active=!1}}}function recordEffectScope(n,t=activeEffectScope){t&&t.active&&t.effects.push(n)}function getCurrentScope(){return activeEffectScope}const createDep=n=>{const t=new Set(n);return t.w=0,t.n=0,t},wasTracked=n=>(n.w&trackOpBit)>0,newTracked=n=>(n.n&trackOpBit)>0,initDepMarkers=({deps:n})=>{if(n.length)for(let t=0;t<n.length;t++)n[t].w|=trackOpBit},finalizeDepMarkers=n=>{const{deps:t}=n;if(t.length){let r=0;for(let i=0;i<t.length;i++){const s=t[i];wasTracked(s)&&!newTracked(s)?s.delete(n):t[r++]=s,s.w&=~trackOpBit,s.n&=~trackOpBit}t.length=r}},targetMap=new WeakMap;let effectTrackDepth=0,trackOpBit=1;const maxMarkerBits=30;let activeEffect;const ITERATE_KEY=Symbol(""),MAP_KEY_ITERATE_KEY=Symbol("");class ReactiveEffect{constructor(t,r=null,i){this.fn=t,this.scheduler=r,this.active=!0,this.deps=[],this.parent=void 0,recordEffectScope(this,i)}run(){if(!this.active)return this.fn();let t=activeEffect,r=shouldTrack;for(;t;){if(t===this)return;t=t.parent}try{return this.parent=activeEffect,activeEffect=this,shouldTrack=!0,trackOpBit=1<<++effectTrackDepth,effectTrackDepth<=maxMarkerBits?initDepMarkers(this):cleanupEffect(this),this.fn()}finally{effectTrackDepth<=maxMarkerBits&&finalizeDepMarkers(this),trackOpBit=1<<--effectTrackDepth,activeEffect=this.parent,shouldTrack=r,this.parent=void 0,this.deferStop&&this.stop()}}stop(){activeEffect===this?this.deferStop=!0:this.active&&(cleanupEffect(this),this.onStop&&this.onStop(),this.active=!1)}}function cleanupEffect(n){const{deps:t}=n;if(t.length){for(let r=0;r<t.length;r++)t[r].delete(n);t.length=0}}let shouldTrack=!0;const trackStack=[];function pauseTracking(){trackStack.push(shouldTrack),shouldTrack=!1}function resetTracking(){const n=trackStack.pop();shouldTrack=n===void 0?!0:n}function track(n,t,r){if(shouldTrack&&activeEffect){let i=targetMap.get(n);i||targetMap.set(n,i=new Map);let s=i.get(r);s||i.set(r,s=createDep()),trackEffects(s)}}function trackEffects(n,t){let r=!1;effectTrackDepth<=maxMarkerBits?newTracked(n)||(n.n|=trackOpBit,r=!wasTracked(n)):r=!n.has(activeEffect),r&&(n.add(activeEffect),activeEffect.deps.push(n))}function trigger(n,t,r,i,s,o){const l=targetMap.get(n);if(!l)return;let f=[];if(t==="clear")f=[...l.values()];else if(r==="length"&&isArray(n)){const u=Number(i);l.forEach((_,g)=>{(g==="length"||!isSymbol(g)&&g>=u)&&f.push(_)})}else switch(r!==void 0&&f.push(l.get(r)),t){case"add":isArray(n)?isIntegerKey(r)&&f.push(l.get("length")):(f.push(l.get(ITERATE_KEY)),isMap(n)&&f.push(l.get(MAP_KEY_ITERATE_KEY)));break;case"delete":isArray(n)||(f.push(l.get(ITERATE_KEY)),isMap(n)&&f.push(l.get(MAP_KEY_ITERATE_KEY)));break;case"set":isMap(n)&&f.push(l.get(ITERATE_KEY));break}if(f.length===1)f[0]&&triggerEffects(f[0]);else{const u=[];for(const _ of f)_&&u.push(..._);triggerEffects(createDep(u))}}function triggerEffects(n,t){const r=isArray(n)?n:[...n];for(const i of r)i.computed&&triggerEffect(i);for(const i of r)i.computed||triggerEffect(i)}function triggerEffect(n,t){(n!==activeEffect||n.allowRecurse)&&(n.scheduler?n.scheduler():n.run())}const isNonTrackableKeys=makeMap("__proto__,__v_isRef,__isVue"),builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).filter(n=>n!=="arguments"&&n!=="caller").map(n=>Symbol[n]).filter(isSymbol)),arrayInstrumentations=createArrayInstrumentations();function createArrayInstrumentations(){const n={};return["includes","indexOf","lastIndexOf"].forEach(t=>{n[t]=function(...r){const i=toRaw(this);for(let o=0,l=this.length;o<l;o++)track(i,"get",o+"");const s=i[t](...r);return s===-1||s===!1?i[t](...r.map(toRaw)):s}}),["push","pop","shift","unshift","splice"].forEach(t=>{n[t]=function(...r){pauseTracking();const i=toRaw(this)[t].apply(this,r);return resetTracking(),i}}),n}function hasOwnProperty(n){const t=toRaw(this);return track(t,"has",n),t.hasOwnProperty(n)}class BaseReactiveHandler{constructor(t=!1,r=!1){this._isReadonly=t,this._shallow=r}get(t,r,i){const s=this._isReadonly,o=this._shallow;if(r==="__v_isReactive")return!s;if(r==="__v_isReadonly")return s;if(r==="__v_isShallow")return o;if(r==="__v_raw")return i===(s?o?shallowReadonlyMap:readonlyMap:o?shallowReactiveMap:reactiveMap).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(i)?t:void 0;const l=isArray(t);if(!s){if(l&&hasOwn(arrayInstrumentations,r))return Reflect.get(arrayInstrumentations,r,i);if(r==="hasOwnProperty")return hasOwnProperty}const f=Reflect.get(t,r,i);return(isSymbol(r)?builtInSymbols.has(r):isNonTrackableKeys(r))||(s||track(t,"get",r),o)?f:isRef(f)?l&&isIntegerKey(r)?f:f.value:isObject(f)?s?readonly(f):reactive(f):f}}class MutableReactiveHandler extends BaseReactiveHandler{constructor(t=!1){super(!1,t)}set(t,r,i,s){let o=t[r];if(isReadonly(o)&&isRef(o)&&!isRef(i))return!1;if(!this._shallow&&(!isShallow(i)&&!isReadonly(i)&&(o=toRaw(o),i=toRaw(i)),!isArray(t)&&isRef(o)&&!isRef(i)))return o.value=i,!0;const l=isArray(t)&&isIntegerKey(r)?Number(r)<t.length:hasOwn(t,r),f=Reflect.set(t,r,i,s);return t===toRaw(s)&&(l?hasChanged(i,o)&&trigger(t,"set",r,i):trigger(t,"add",r,i)),f}deleteProperty(t,r){const i=hasOwn(t,r);t[r];const s=Reflect.deleteProperty(t,r);return s&&i&&trigger(t,"delete",r,void 0),s}has(t,r){const i=Reflect.has(t,r);return(!isSymbol(r)||!builtInSymbols.has(r))&&track(t,"has",r),i}ownKeys(t){return track(t,"iterate",isArray(t)?"length":ITERATE_KEY),Reflect.ownKeys(t)}}class ReadonlyReactiveHandler extends BaseReactiveHandler{constructor(t=!1){super(!0,t)}set(t,r){return!0}deleteProperty(t,r){return!0}}const mutableHandlers=new MutableReactiveHandler,readonlyHandlers=new ReadonlyReactiveHandler,shallowReactiveHandlers=new MutableReactiveHandler(!0),toShallow=n=>n,getProto=n=>Reflect.getPrototypeOf(n);function get(n,t,r=!1,i=!1){n=n.__v_raw;const s=toRaw(n),o=toRaw(t);r||(hasChanged(t,o)&&track(s,"get",t),track(s,"get",o));const{has:l}=getProto(s),f=i?toShallow:r?toReadonly:toReactive;if(l.call(s,t))return f(n.get(t));if(l.call(s,o))return f(n.get(o));n!==s&&n.get(t)}function has(n,t=!1){const r=this.__v_raw,i=toRaw(r),s=toRaw(n);return t||(hasChanged(n,s)&&track(i,"has",n),track(i,"has",s)),n===s?r.has(n):r.has(n)||r.has(s)}function size(n,t=!1){return n=n.__v_raw,!t&&track(toRaw(n),"iterate",ITERATE_KEY),Reflect.get(n,"size",n)}function add$3(n){n=toRaw(n);const t=toRaw(this);return getProto(t).has.call(t,n)||(t.add(n),trigger(t,"add",n,n)),this}function set(n,t){t=toRaw(t);const r=toRaw(this),{has:i,get:s}=getProto(r);let o=i.call(r,n);o||(n=toRaw(n),o=i.call(r,n));const l=s.call(r,n);return r.set(n,t),o?hasChanged(t,l)&&trigger(r,"set",n,t):trigger(r,"add",n,t),this}function deleteEntry(n){const t=toRaw(this),{has:r,get:i}=getProto(t);let s=r.call(t,n);s||(n=toRaw(n),s=r.call(t,n)),i&&i.call(t,n);const o=t.delete(n);return s&&trigger(t,"delete",n,void 0),o}function clear(){const n=toRaw(this),t=n.size!==0,r=n.clear();return t&&trigger(n,"clear",void 0,void 0),r}function createForEach(n,t){return function(i,s){const o=this,l=o.__v_raw,f=toRaw(l),u=t?toShallow:n?toReadonly:toReactive;return!n&&track(f,"iterate",ITERATE_KEY),l.forEach((_,g)=>i.call(s,u(_),u(g),o))}}function createIterableMethod(n,t,r){return function(...i){const s=this.__v_raw,o=toRaw(s),l=isMap(o),f=n==="entries"||n===Symbol.iterator&&l,u=n==="keys"&&l,_=s[n](...i),g=r?toShallow:t?toReadonly:toReactive;return!t&&track(o,"iterate",u?MAP_KEY_ITERATE_KEY:ITERATE_KEY),{next(){const{value:a,done:m}=_.next();return m?{value:a,done:m}:{value:f?[g(a[0]),g(a[1])]:g(a),done:m}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(n){return function(...t){return n==="delete"?!1:n==="clear"?void 0:this}}function createInstrumentations(){const n={get(o){return get(this,o)},get size(){return size(this)},has,add:add$3,set,delete:deleteEntry,clear,forEach:createForEach(!1,!1)},t={get(o){return get(this,o,!1,!0)},get size(){return size(this)},has,add:add$3,set,delete:deleteEntry,clear,forEach:createForEach(!1,!0)},r={get(o){return get(this,o,!0)},get size(){return size(this,!0)},has(o){return has.call(this,o,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!1)},i={get(o){return get(this,o,!0,!0)},get size(){return size(this,!0)},has(o){return has.call(this,o,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(o=>{n[o]=createIterableMethod(o,!1,!1),r[o]=createIterableMethod(o,!0,!1),t[o]=createIterableMethod(o,!1,!0),i[o]=createIterableMethod(o,!0,!0)}),[n,r,t,i]}const[mutableInstrumentations,readonlyInstrumentations,shallowInstrumentations,shallowReadonlyInstrumentations]=createInstrumentations();function createInstrumentationGetter(n,t){const r=t?n?shallowReadonlyInstrumentations:shallowInstrumentations:n?readonlyInstrumentations:mutableInstrumentations;return(i,s,o)=>s==="__v_isReactive"?!n:s==="__v_isReadonly"?n:s==="__v_raw"?i:Reflect.get(hasOwn(r,s)&&s in i?r:i,s,o)}const mutableCollectionHandlers={get:createInstrumentationGetter(!1,!1)},shallowCollectionHandlers={get:createInstrumentationGetter(!1,!0)},readonlyCollectionHandlers={get:createInstrumentationGetter(!0,!1)},reactiveMap=new WeakMap,shallowReactiveMap=new WeakMap,readonlyMap=new WeakMap,shallowReadonlyMap=new WeakMap;function targetTypeMap(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(n){return n.__v_skip||!Object.isExtensible(n)?0:targetTypeMap(toRawType(n))}function reactive(n){return isReadonly(n)?n:createReactiveObject(n,!1,mutableHandlers,mutableCollectionHandlers,reactiveMap)}function shallowReactive(n){return createReactiveObject(n,!1,shallowReactiveHandlers,shallowCollectionHandlers,shallowReactiveMap)}function readonly(n){return createReactiveObject(n,!0,readonlyHandlers,readonlyCollectionHandlers,readonlyMap)}function createReactiveObject(n,t,r,i,s){if(!isObject(n)||n.__v_raw&&!(t&&n.__v_isReactive))return n;const o=s.get(n);if(o)return o;const l=getTargetType(n);if(l===0)return n;const f=new Proxy(n,l===2?i:r);return s.set(n,f),f}function isReactive(n){return isReadonly(n)?isReactive(n.__v_raw):!!(n&&n.__v_isReactive)}function isReadonly(n){return!!(n&&n.__v_isReadonly)}function isShallow(n){return!!(n&&n.__v_isShallow)}function isProxy(n){return isReactive(n)||isReadonly(n)}function toRaw(n){const t=n&&n.__v_raw;return t?toRaw(t):n}function markRaw(n){return def(n,"__v_skip",!0),n}const toReactive=n=>isObject(n)?reactive(n):n,toReadonly=n=>isObject(n)?readonly(n):n;function trackRefValue(n){shouldTrack&&activeEffect&&(n=toRaw(n),trackEffects(n.dep||(n.dep=createDep())))}function triggerRefValue(n,t){n=toRaw(n);const r=n.dep;r&&triggerEffects(r)}function isRef(n){return!!(n&&n.__v_isRef===!0)}function ref(n){return createRef(n,!1)}function createRef(n,t){return isRef(n)?n:new RefImpl(n,t)}class RefImpl{constructor(t,r){this.__v_isShallow=r,this.dep=void 0,this.__v_isRef=!0,this._rawValue=r?t:toRaw(t),this._value=r?t:toReactive(t)}get value(){return trackRefValue(this),this._value}set value(t){const r=this.__v_isShallow||isShallow(t)||isReadonly(t);t=r?t:toRaw(t),hasChanged(t,this._rawValue)&&(this._rawValue=t,this._value=r?t:toReactive(t),triggerRefValue(this))}}function unref(n){return isRef(n)?n.value:n}const shallowUnwrapHandlers={get:(n,t,r)=>unref(Reflect.get(n,t,r)),set:(n,t,r,i)=>{const s=n[t];return isRef(s)&&!isRef(r)?(s.value=r,!0):Reflect.set(n,t,r,i)}};function proxyRefs(n){return isReactive(n)?n:new Proxy(n,shallowUnwrapHandlers)}class ComputedRefImpl{constructor(t,r,i,s){this._setter=r,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new ReactiveEffect(t,()=>{this._dirty||(this._dirty=!0,triggerRefValue(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!s,this.__v_isReadonly=i}get value(){const t=toRaw(this);return trackRefValue(t),(t._dirty||!t._cacheable)&&(t._dirty=!1,t._value=t.effect.run()),t._value}set value(t){this._setter(t)}}function computed$1(n,t,r=!1){let i,s;const o=isFunction$1(n);return o?(i=n,s=NOOP):(i=n.get,s=n.set),new ComputedRefImpl(i,s,o||!s,r)}function warn$1(n,...t){}function callWithErrorHandling(n,t,r,i){let s;try{s=i?n(...i):n()}catch(o){handleError(o,t,r)}return s}function callWithAsyncErrorHandling(n,t,r,i){if(isFunction$1(n)){const o=callWithErrorHandling(n,t,r,i);return o&&isPromise$1(o)&&o.catch(l=>{handleError(l,t,r)}),o}const s=[];for(let o=0;o<n.length;o++)s.push(callWithAsyncErrorHandling(n[o],t,r,i));return s}function handleError(n,t,r,i=!0){const s=t?t.vnode:null;if(t){let o=t.parent;const l=t.proxy,f=r;for(;o;){const _=o.ec;if(_){for(let g=0;g<_.length;g++)if(_[g](n,l,f)===!1)return}o=o.parent}const u=t.appContext.config.errorHandler;if(u){callWithErrorHandling(u,null,10,[n,l,f]);return}}logError(n,r,s,i)}function logError(n,t,r,i=!0){console.error(n)}let isFlushing=!1,isFlushPending=!1;const queue=[];let flushIndex=0;const pendingPostFlushCbs=[];let activePostFlushCbs=null,postFlushIndex=0;const resolvedPromise=Promise.resolve();let currentFlushPromise=null;function nextTick(n){const t=currentFlushPromise||resolvedPromise;return n?t.then(this?n.bind(this):n):t}function findInsertionIndex(n){let t=flushIndex+1,r=queue.length;for(;t<r;){const i=t+r>>>1,s=queue[i],o=getId(s);o<n||o===n&&s.pre?t=i+1:r=i}return t}function queueJob(n){(!queue.length||!queue.includes(n,isFlushing&&n.allowRecurse?flushIndex+1:flushIndex))&&(n.id==null?queue.push(n):queue.splice(findInsertionIndex(n.id),0,n),queueFlush())}function queueFlush(){!isFlushing&&!isFlushPending&&(isFlushPending=!0,currentFlushPromise=resolvedPromise.then(flushJobs))}function invalidateJob(n){const t=queue.indexOf(n);t>flushIndex&&queue.splice(t,1)}function queuePostFlushCb(n){isArray(n)?pendingPostFlushCbs.push(...n):(!activePostFlushCbs||!activePostFlushCbs.includes(n,n.allowRecurse?postFlushIndex+1:postFlushIndex))&&pendingPostFlushCbs.push(n),queueFlush()}function flushPreFlushCbs(n,t,r=isFlushing?flushIndex+1:0){for(;r<queue.length;r++){const i=queue[r];if(i&&i.pre){if(n&&i.id!==n.uid)continue;queue.splice(r,1),r--,i()}}}function flushPostFlushCbs(n){if(pendingPostFlushCbs.length){const t=[...new Set(pendingPostFlushCbs)];if(pendingPostFlushCbs.length=0,activePostFlushCbs){activePostFlushCbs.push(...t);return}for(activePostFlushCbs=t,activePostFlushCbs.sort((r,i)=>getId(r)-getId(i)),postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++)activePostFlushCbs[postFlushIndex]();activePostFlushCbs=null,postFlushIndex=0}}const getId=n=>n.id==null?1/0:n.id,comparator=(n,t)=>{const r=getId(n)-getId(t);if(r===0){if(n.pre&&!t.pre)return-1;if(t.pre&&!n.pre)return 1}return r};function flushJobs(n){isFlushPending=!1,isFlushing=!0,queue.sort(comparator);try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){const t=queue[flushIndex];t&&t.active!==!1&&callWithErrorHandling(t,null,14)}}finally{flushIndex=0,queue.length=0,flushPostFlushCbs(),isFlushing=!1,currentFlushPromise=null,(queue.length||pendingPostFlushCbs.length)&&flushJobs()}}function emit(n,t,...r){if(n.isUnmounted)return;const i=n.vnode.props||EMPTY_OBJ;let s=r;const o=t.startsWith("update:"),l=o&&t.slice(7);if(l&&l in i){const g=`${l==="modelValue"?"model":l}Modifiers`,{number:a,trim:m}=i[g]||EMPTY_OBJ;m&&(s=r.map(b=>isString$1(b)?b.trim():b)),a&&(s=r.map(looseToNumber))}let f,u=i[f=toHandlerKey(t)]||i[f=toHandlerKey(camelize(t))];!u&&o&&(u=i[f=toHandlerKey(hyphenate(t))]),u&&callWithAsyncErrorHandling(u,n,6,s);const _=i[f+"Once"];if(_){if(!n.emitted)n.emitted={};else if(n.emitted[f])return;n.emitted[f]=!0,callWithAsyncErrorHandling(_,n,6,s)}}function normalizeEmitsOptions(n,t,r=!1){const i=t.emitsCache,s=i.get(n);if(s!==void 0)return s;const o=n.emits;let l={},f=!1;if(!isFunction$1(n)){const u=_=>{const g=normalizeEmitsOptions(_,t,!0);g&&(f=!0,extend(l,g))};!r&&t.mixins.length&&t.mixins.forEach(u),n.extends&&u(n.extends),n.mixins&&n.mixins.forEach(u)}return!o&&!f?(isObject(n)&&i.set(n,null),null):(isArray(o)?o.forEach(u=>l[u]=null):extend(l,o),isObject(n)&&i.set(n,l),l)}function isEmitListener(n,t){return!n||!isOn(t)?!1:(t=t.slice(2).replace(/Once$/,""),hasOwn(n,t[0].toLowerCase()+t.slice(1))||hasOwn(n,hyphenate(t))||hasOwn(n,t))}let currentRenderingInstance=null,currentScopeId=null;function setCurrentRenderingInstance(n){const t=currentRenderingInstance;return currentRenderingInstance=n,currentScopeId=n&&n.type.__scopeId||null,t}function pushScopeId(n){currentScopeId=n}function popScopeId(){currentScopeId=null}function withCtx(n,t=currentRenderingInstance,r){if(!t||n._n)return n;const i=(...s)=>{i._d&&setBlockTracking(-1);const o=setCurrentRenderingInstance(t);let l;try{l=n(...s)}finally{setCurrentRenderingInstance(o),i._d&&setBlockTracking(1)}return l};return i._n=!0,i._c=!0,i._d=!0,i}function markAttrsAccessed(){}function renderComponentRoot(n){const{type:t,vnode:r,proxy:i,withProxy:s,props:o,propsOptions:[l],slots:f,attrs:u,emit:_,render:g,renderCache:a,data:m,setupState:b,ctx:v,inheritAttrs:c}=n;let w,k;const x=setCurrentRenderingInstance(n);try{if(r.shapeFlag&4){const O=s||i,A=O;w=normalizeVNode(g.call(A,O,a,o,b,m,v)),k=u}else{const O=t;w=normalizeVNode(O.length>1?O(o,{attrs:u,slots:f,emit:_}):O(o,null)),k=t.props?u:getFunctionalFallthrough(u)}}catch(O){blockStack.length=0,handleError(O,n,1),w=createVNode(Comment)}let E=w;if(k&&c!==!1){const O=Object.keys(k),{shapeFlag:A}=E;O.length&&A&7&&(l&&O.some(isModelListener)&&(k=filterModelListeners(k,l)),E=cloneVNode(E,k))}return r.dirs&&(E=cloneVNode(E),E.dirs=E.dirs?E.dirs.concat(r.dirs):r.dirs),r.transition&&(E.transition=r.transition),w=E,setCurrentRenderingInstance(x),w}const getFunctionalFallthrough=n=>{let t;for(const r in n)(r==="class"||r==="style"||isOn(r))&&((t||(t={}))[r]=n[r]);return t},filterModelListeners=(n,t)=>{const r={};for(const i in n)(!isModelListener(i)||!(i.slice(9)in t))&&(r[i]=n[i]);return r};function shouldUpdateComponent(n,t,r){const{props:i,children:s,component:o}=n,{props:l,children:f,patchFlag:u}=t,_=o.emitsOptions;if(t.dirs||t.transition)return!0;if(r&&u>=0){if(u&1024)return!0;if(u&16)return i?hasPropsChanged(i,l,_):!!l;if(u&8){const g=t.dynamicProps;for(let a=0;a<g.length;a++){const m=g[a];if(l[m]!==i[m]&&!isEmitListener(_,m))return!0}}}else return(s||f)&&(!f||!f.$stable)?!0:i===l?!1:i?l?hasPropsChanged(i,l,_):!0:!!l;return!1}function hasPropsChanged(n,t,r){const i=Object.keys(t);if(i.length!==Object.keys(n).length)return!0;for(let s=0;s<i.length;s++){const o=i[s];if(t[o]!==n[o]&&!isEmitListener(r,o))return!0}return!1}function updateHOCHostEl({vnode:n,parent:t},r){for(;t&&t.subTree===n;)(n=t.vnode).el=r,t=t.parent}const COMPONENTS="components",DIRECTIVES="directives";function resolveComponent(n,t){return resolveAsset(COMPONENTS,n,!0,t)||n}const NULL_DYNAMIC_COMPONENT=Symbol.for("v-ndc");function resolveDynamicComponent(n){return isString$1(n)?resolveAsset(COMPONENTS,n,!1)||n:n||NULL_DYNAMIC_COMPONENT}function resolveDirective(n){return resolveAsset(DIRECTIVES,n)}function resolveAsset(n,t,r=!0,i=!1){const s=currentRenderingInstance||currentInstance;if(s){const o=s.type;if(n===COMPONENTS){const f=getComponentName(o,!1);if(f&&(f===t||f===camelize(t)||f===capitalize(camelize(t))))return o}const l=resolve(s[n]||o[n],t)||resolve(s.appContext[n],t);return!l&&i?o:l}}function resolve(n,t){return n&&(n[t]||n[camelize(t)]||n[capitalize(camelize(t))])}const isSuspense=n=>n.__isSuspense;function queueEffectWithSuspense(n,t){t&&t.pendingBranch?isArray(n)?t.effects.push(...n):t.effects.push(n):queuePostFlushCb(n)}const INITIAL_WATCHER_VALUE={};function watch(n,t,r){return doWatch(n,t,r)}function doWatch(n,t,{immediate:r,deep:i,flush:s,onTrack:o,onTrigger:l}=EMPTY_OBJ){var f;const u=getCurrentScope()===((f=currentInstance)==null?void 0:f.scope)?currentInstance:null;let _,g=!1,a=!1;if(isRef(n)?(_=()=>n.value,g=isShallow(n)):isReactive(n)?(_=()=>n,i=!0):isArray(n)?(a=!0,g=n.some(O=>isReactive(O)||isShallow(O)),_=()=>n.map(O=>{if(isRef(O))return O.value;if(isReactive(O))return traverse(O);if(isFunction$1(O))return callWithErrorHandling(O,u,2)})):isFunction$1(n)?t?_=()=>callWithErrorHandling(n,u,2):_=()=>{if(!(u&&u.isUnmounted))return m&&m(),callWithAsyncErrorHandling(n,u,3,[b])}:_=NOOP,t&&i){const O=_;_=()=>traverse(O())}let m,b=O=>{m=x.onStop=()=>{callWithErrorHandling(O,u,4),m=x.onStop=void 0}},v;if(isInSSRComponentSetup)if(b=NOOP,t?r&&callWithAsyncErrorHandling(t,u,3,[_(),a?[]:void 0,b]):_(),s==="sync"){const O=useSSRContext();v=O.__watcherHandles||(O.__watcherHandles=[])}else return NOOP;let c=a?new Array(n.length).fill(INITIAL_WATCHER_VALUE):INITIAL_WATCHER_VALUE;const w=()=>{if(x.active)if(t){const O=x.run();(i||g||(a?O.some((A,T)=>hasChanged(A,c[T])):hasChanged(O,c)))&&(m&&m(),callWithAsyncErrorHandling(t,u,3,[O,c===INITIAL_WATCHER_VALUE?void 0:a&&c[0]===INITIAL_WATCHER_VALUE?[]:c,b]),c=O)}else x.run()};w.allowRecurse=!!t;let k;s==="sync"?k=w:s==="post"?k=()=>queuePostRenderEffect(w,u&&u.suspense):(w.pre=!0,u&&(w.id=u.uid),k=()=>queueJob(w));const x=new ReactiveEffect(_,k);t?r?w():c=x.run():s==="post"?queuePostRenderEffect(x.run.bind(x),u&&u.suspense):x.run();const E=()=>{x.stop(),u&&u.scope&&remove(u.scope.effects,x)};return v&&v.push(E),E}function instanceWatch(n,t,r){const i=this.proxy,s=isString$1(n)?n.includes(".")?createPathGetter(i,n):()=>i[n]:n.bind(i,i);let o;isFunction$1(t)?o=t:(o=t.handler,r=t);const l=currentInstance;setCurrentInstance(this);const f=doWatch(s,o.bind(i),r);return l?setCurrentInstance(l):unsetCurrentInstance(),f}function createPathGetter(n,t){const r=t.split(".");return()=>{let i=n;for(let s=0;s<r.length&&i;s++)i=i[r[s]];return i}}function traverse(n,t){if(!isObject(n)||n.__v_skip||(t=t||new Set,t.has(n)))return n;if(t.add(n),isRef(n))traverse(n.value,t);else if(isArray(n))for(let r=0;r<n.length;r++)traverse(n[r],t);else if(isSet(n)||isMap(n))n.forEach(r=>{traverse(r,t)});else if(isPlainObject(n))for(const r in n)traverse(n[r],t);return n}function withDirectives(n,t){const r=currentRenderingInstance;if(r===null)return n;const i=getExposeProxy(r)||r.proxy,s=n.dirs||(n.dirs=[]);for(let o=0;o<t.length;o++){let[l,f,u,_=EMPTY_OBJ]=t[o];l&&(isFunction$1(l)&&(l={mounted:l,updated:l}),l.deep&&traverse(f),s.push({dir:l,instance:i,value:f,oldValue:void 0,arg:u,modifiers:_}))}return n}function invokeDirectiveHook(n,t,r,i){const s=n.dirs,o=t&&t.dirs;for(let l=0;l<s.length;l++){const f=s[l];o&&(f.oldValue=o[l].value);let u=f.dir[i];u&&(pauseTracking(),callWithAsyncErrorHandling(u,r,8,[n.el,f,n,t]),resetTracking())}}const leaveCbKey=Symbol("_leaveCb"),enterCbKey=Symbol("_enterCb");function useTransitionState(){const n={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return onMounted(()=>{n.isMounted=!0}),onBeforeUnmount(()=>{n.isUnmounting=!0}),n}const TransitionHookValidator=[Function,Array],BaseTransitionPropsValidators={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:TransitionHookValidator,onEnter:TransitionHookValidator,onAfterEnter:TransitionHookValidator,onEnterCancelled:TransitionHookValidator,onBeforeLeave:TransitionHookValidator,onLeave:TransitionHookValidator,onAfterLeave:TransitionHookValidator,onLeaveCancelled:TransitionHookValidator,onBeforeAppear:TransitionHookValidator,onAppear:TransitionHookValidator,onAfterAppear:TransitionHookValidator,onAppearCancelled:TransitionHookValidator},BaseTransitionImpl={name:"BaseTransition",props:BaseTransitionPropsValidators,setup(n,{slots:t}){const r=getCurrentInstance(),i=useTransitionState();let s;return()=>{const o=t.default&&getTransitionRawChildren(t.default(),!0);if(!o||!o.length)return;let l=o[0];if(o.length>1){for(const c of o)if(c.type!==Comment){l=c;break}}const f=toRaw(n),{mode:u}=f;if(i.isLeaving)return emptyPlaceholder(l);const _=getKeepAliveChild(l);if(!_)return emptyPlaceholder(l);const g=resolveTransitionHooks(_,f,i,r);setTransitionHooks(_,g);const a=r.subTree,m=a&&getKeepAliveChild(a);let b=!1;const{getTransitionKey:v}=_.type;if(v){const c=v();s===void 0?s=c:c!==s&&(s=c,b=!0)}if(m&&m.type!==Comment&&(!isSameVNodeType(_,m)||b)){const c=resolveTransitionHooks(m,f,i,r);if(setTransitionHooks(m,c),u==="out-in")return i.isLeaving=!0,c.afterLeave=()=>{i.isLeaving=!1,r.update.active!==!1&&r.update()},emptyPlaceholder(l);u==="in-out"&&_.type!==Comment&&(c.delayLeave=(w,k,x)=>{const E=getLeavingNodesForType(i,m);E[String(m.key)]=m,w[leaveCbKey]=()=>{k(),w[leaveCbKey]=void 0,delete g.delayedLeave},g.delayedLeave=x})}return l}}},BaseTransition=BaseTransitionImpl;function getLeavingNodesForType(n,t){const{leavingVNodes:r}=n;let i=r.get(t.type);return i||(i=Object.create(null),r.set(t.type,i)),i}function resolveTransitionHooks(n,t,r,i){const{appear:s,mode:o,persisted:l=!1,onBeforeEnter:f,onEnter:u,onAfterEnter:_,onEnterCancelled:g,onBeforeLeave:a,onLeave:m,onAfterLeave:b,onLeaveCancelled:v,onBeforeAppear:c,onAppear:w,onAfterAppear:k,onAppearCancelled:x}=t,E=String(n.key),O=getLeavingNodesForType(r,n),A=(I,D)=>{I&&callWithAsyncErrorHandling(I,i,9,D)},T=(I,D)=>{const $=D[1];A(I,D),isArray(I)?I.every(N=>N.length<=1)&&$():I.length<=1&&$()},j={mode:o,persisted:l,beforeEnter(I){let D=f;if(!r.isMounted)if(s)D=c||f;else return;I[leaveCbKey]&&I[leaveCbKey](!0);const $=O[E];$&&isSameVNodeType(n,$)&&$.el[leaveCbKey]&&$.el[leaveCbKey](),A(D,[I])},enter(I){let D=u,$=_,N=g;if(!r.isMounted)if(s)D=w||u,$=k||_,N=x||g;else return;let M=!1;const W=I[enterCbKey]=F=>{M||(M=!0,F?A(N,[I]):A($,[I]),j.delayedLeave&&j.delayedLeave(),I[enterCbKey]=void 0)};D?T(D,[I,W]):W()},leave(I,D){const $=String(n.key);if(I[enterCbKey]&&I[enterCbKey](!0),r.isUnmounting)return D();A(a,[I]);let N=!1;const M=I[leaveCbKey]=W=>{N||(N=!0,D(),W?A(v,[I]):A(b,[I]),I[leaveCbKey]=void 0,O[$]===n&&delete O[$])};O[$]=n,m?T(m,[I,M]):M()},clone(I){return resolveTransitionHooks(I,t,r,i)}};return j}function emptyPlaceholder(n){if(isKeepAlive(n))return n=cloneVNode(n),n.children=null,n}function getKeepAliveChild(n){return isKeepAlive(n)?n.children?n.children[0]:void 0:n}function setTransitionHooks(n,t){n.shapeFlag&6&&n.component?setTransitionHooks(n.component.subTree,t):n.shapeFlag&128?(n.ssContent.transition=t.clone(n.ssContent),n.ssFallback.transition=t.clone(n.ssFallback)):n.transition=t}function getTransitionRawChildren(n,t=!1,r){let i=[],s=0;for(let o=0;o<n.length;o++){let l=n[o];const f=r==null?l.key:String(r)+String(l.key!=null?l.key:o);l.type===Fragment?(l.patchFlag&128&&s++,i=i.concat(getTransitionRawChildren(l.children,t,f))):(t||l.type!==Comment)&&i.push(f!=null?cloneVNode(l,{key:f}):l)}if(s>1)for(let o=0;o<i.length;o++)i[o].patchFlag=-2;return i}const isAsyncWrapper=n=>!!n.type.__asyncLoader,isKeepAlive=n=>n.type.__isKeepAlive;function onActivated(n,t){registerKeepAliveHook(n,"a",t)}function onDeactivated(n,t){registerKeepAliveHook(n,"da",t)}function registerKeepAliveHook(n,t,r=currentInstance){const i=n.__wdc||(n.__wdc=()=>{let s=r;for(;s;){if(s.isDeactivated)return;s=s.parent}return n()});if(injectHook(t,i,r),r){let s=r.parent;for(;s&&s.parent;)isKeepAlive(s.parent.vnode)&&injectToKeepAliveRoot(i,t,r,s),s=s.parent}}function injectToKeepAliveRoot(n,t,r,i){const s=injectHook(t,n,i,!0);onUnmounted(()=>{remove(i[t],s)},r)}function injectHook(n,t,r=currentInstance,i=!1){if(r){const s=r[n]||(r[n]=[]),o=t.__weh||(t.__weh=(...l)=>{if(r.isUnmounted)return;pauseTracking(),setCurrentInstance(r);const f=callWithAsyncErrorHandling(t,r,n,l);return unsetCurrentInstance(),resetTracking(),f});return i?s.unshift(o):s.push(o),o}}const createHook=n=>(t,r=currentInstance)=>(!isInSSRComponentSetup||n==="sp")&&injectHook(n,(...i)=>t(...i),r),onBeforeMount=createHook("bm"),onMounted=createHook("m"),onBeforeUpdate=createHook("bu"),onUpdated=createHook("u"),onBeforeUnmount=createHook("bum"),onUnmounted=createHook("um"),onServerPrefetch=createHook("sp"),onRenderTriggered=createHook("rtg"),onRenderTracked=createHook("rtc");function onErrorCaptured(n,t=currentInstance){injectHook("ec",n,t)}function renderList(n,t,r,i){let s;const o=r&&r[i];if(isArray(n)||isString$1(n)){s=new Array(n.length);for(let l=0,f=n.length;l<f;l++)s[l]=t(n[l],l,void 0,o&&o[l])}else if(typeof n=="number"){s=new Array(n);for(let l=0;l<n;l++)s[l]=t(l+1,l,void 0,o&&o[l])}else if(isObject(n))if(n[Symbol.iterator])s=Array.from(n,(l,f)=>t(l,f,void 0,o&&o[f]));else{const l=Object.keys(n);s=new Array(l.length);for(let f=0,u=l.length;f<u;f++){const _=l[f];s[f]=t(n[_],_,f,o&&o[f])}}else s=[];return r&&(r[i]=s),s}function createSlots(n,t){for(let r=0;r<t.length;r++){const i=t[r];if(isArray(i))for(let s=0;s<i.length;s++)n[i[s].name]=i[s].fn;else i&&(n[i.name]=i.key?(...s)=>{const o=i.fn(...s);return o&&(o.key=i.key),o}:i.fn)}return n}function renderSlot(n,t,r={},i,s){if(currentRenderingInstance.isCE||currentRenderingInstance.parent&&isAsyncWrapper(currentRenderingInstance.parent)&&currentRenderingInstance.parent.isCE)return t!=="default"&&(r.name=t),createVNode("slot",r,i&&i());let o=n[t];o&&o._c&&(o._d=!1),openBlock();const l=o&&ensureValidVNode(o(r)),f=createBlock(Fragment,{key:r.key||l&&l.key||`_${t}`},l||(i?i():[]),l&&n._===1?64:-2);return!s&&f.scopeId&&(f.slotScopeIds=[f.scopeId+"-s"]),o&&o._c&&(o._d=!0),f}function ensureValidVNode(n){return n.some(t=>isVNode(t)?!(t.type===Comment||t.type===Fragment&&!ensureValidVNode(t.children)):!0)?n:null}function toHandlers(n,t){const r={};for(const i in n)r[t&&/[A-Z]/.test(i)?`on:${i}`:toHandlerKey(i)]=n[i];return r}const getPublicInstance=n=>n?isStatefulComponent(n)?getExposeProxy(n)||n.proxy:getPublicInstance(n.parent):null,publicPropertiesMap=extend(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>n.props,$attrs:n=>n.attrs,$slots:n=>n.slots,$refs:n=>n.refs,$parent:n=>getPublicInstance(n.parent),$root:n=>getPublicInstance(n.root),$emit:n=>n.emit,$options:n=>resolveMergedOptions(n),$forceUpdate:n=>n.f||(n.f=()=>queueJob(n.update)),$nextTick:n=>n.n||(n.n=nextTick.bind(n.proxy)),$watch:n=>instanceWatch.bind(n)}),hasSetupBinding=(n,t)=>n!==EMPTY_OBJ&&!n.__isScriptSetup&&hasOwn(n,t),PublicInstanceProxyHandlers={get({_:n},t){const{ctx:r,setupState:i,data:s,props:o,accessCache:l,type:f,appContext:u}=n;let _;if(t[0]!=="$"){const b=l[t];if(b!==void 0)switch(b){case 1:return i[t];case 2:return s[t];case 4:return r[t];case 3:return o[t]}else{if(hasSetupBinding(i,t))return l[t]=1,i[t];if(s!==EMPTY_OBJ&&hasOwn(s,t))return l[t]=2,s[t];if((_=n.propsOptions[0])&&hasOwn(_,t))return l[t]=3,o[t];if(r!==EMPTY_OBJ&&hasOwn(r,t))return l[t]=4,r[t];shouldCacheAccess&&(l[t]=0)}}const g=publicPropertiesMap[t];let a,m;if(g)return t==="$attrs"&&track(n,"get",t),g(n);if((a=f.__cssModules)&&(a=a[t]))return a;if(r!==EMPTY_OBJ&&hasOwn(r,t))return l[t]=4,r[t];if(m=u.config.globalProperties,hasOwn(m,t))return m[t]},set({_:n},t,r){const{data:i,setupState:s,ctx:o}=n;return hasSetupBinding(s,t)?(s[t]=r,!0):i!==EMPTY_OBJ&&hasOwn(i,t)?(i[t]=r,!0):hasOwn(n.props,t)||t[0]==="$"&&t.slice(1)in n?!1:(o[t]=r,!0)},has({_:{data:n,setupState:t,accessCache:r,ctx:i,appContext:s,propsOptions:o}},l){let f;return!!r[l]||n!==EMPTY_OBJ&&hasOwn(n,l)||hasSetupBinding(t,l)||(f=o[0])&&hasOwn(f,l)||hasOwn(i,l)||hasOwn(publicPropertiesMap,l)||hasOwn(s.config.globalProperties,l)},defineProperty(n,t,r){return r.get!=null?n._.accessCache[t]=0:hasOwn(r,"value")&&this.set(n,t,r.value,null),Reflect.defineProperty(n,t,r)}};function normalizePropsOrEmits(n){return isArray(n)?n.reduce((t,r)=>(t[r]=null,t),{}):n}let shouldCacheAccess=!0;function applyOptions(n){const t=resolveMergedOptions(n),r=n.proxy,i=n.ctx;shouldCacheAccess=!1,t.beforeCreate&&callHook$1(t.beforeCreate,n,"bc");const{data:s,computed:o,methods:l,watch:f,provide:u,inject:_,created:g,beforeMount:a,mounted:m,beforeUpdate:b,updated:v,activated:c,deactivated:w,beforeDestroy:k,beforeUnmount:x,destroyed:E,unmounted:O,render:A,renderTracked:T,renderTriggered:j,errorCaptured:I,serverPrefetch:D,expose:$,inheritAttrs:N,components:M,directives:W,filters:F}=t;if(_&&resolveInjections(_,i,null),l)for(const Y in l){const X=l[Y];isFunction$1(X)&&(i[Y]=X.bind(r))}if(s){const Y=s.call(r,r);isObject(Y)&&(n.data=reactive(Y))}if(shouldCacheAccess=!0,o)for(const Y in o){const X=o[Y],J=isFunction$1(X)?X.bind(r,r):isFunction$1(X.get)?X.get.bind(r,r):NOOP,te=!isFunction$1(X)&&isFunction$1(X.set)?X.set.bind(r):NOOP,ie=computed({get:J,set:te});Object.defineProperty(i,Y,{enumerable:!0,configurable:!0,get:()=>ie.value,set:de=>ie.value=de})}if(f)for(const Y in f)createWatcher(f[Y],i,r,Y);if(u){const Y=isFunction$1(u)?u.call(r):u;Reflect.ownKeys(Y).forEach(X=>{provide(X,Y[X])})}g&&callHook$1(g,n,"c");function q(Y,X){isArray(X)?X.forEach(J=>Y(J.bind(r))):X&&Y(X.bind(r))}if(q(onBeforeMount,a),q(onMounted,m),q(onBeforeUpdate,b),q(onUpdated,v),q(onActivated,c),q(onDeactivated,w),q(onErrorCaptured,I),q(onRenderTracked,T),q(onRenderTriggered,j),q(onBeforeUnmount,x),q(onUnmounted,O),q(onServerPrefetch,D),isArray($))if($.length){const Y=n.exposed||(n.exposed={});$.forEach(X=>{Object.defineProperty(Y,X,{get:()=>r[X],set:J=>r[X]=J})})}else n.exposed||(n.exposed={});A&&n.render===NOOP&&(n.render=A),N!=null&&(n.inheritAttrs=N),M&&(n.components=M),W&&(n.directives=W)}function resolveInjections(n,t,r=NOOP){isArray(n)&&(n=normalizeInject(n));for(const i in n){const s=n[i];let o;isObject(s)?"default"in s?o=inject(s.from||i,s.default,!0):o=inject(s.from||i):o=inject(s),isRef(o)?Object.defineProperty(t,i,{enumerable:!0,configurable:!0,get:()=>o.value,set:l=>o.value=l}):t[i]=o}}function callHook$1(n,t,r){callWithAsyncErrorHandling(isArray(n)?n.map(i=>i.bind(t.proxy)):n.bind(t.proxy),t,r)}function createWatcher(n,t,r,i){const s=i.includes(".")?createPathGetter(r,i):()=>r[i];if(isString$1(n)){const o=t[n];isFunction$1(o)&&watch(s,o)}else if(isFunction$1(n))watch(s,n.bind(r));else if(isObject(n))if(isArray(n))n.forEach(o=>createWatcher(o,t,r,i));else{const o=isFunction$1(n.handler)?n.handler.bind(r):t[n.handler];isFunction$1(o)&&watch(s,o,n)}}function resolveMergedOptions(n){const t=n.type,{mixins:r,extends:i}=t,{mixins:s,optionsCache:o,config:{optionMergeStrategies:l}}=n.appContext,f=o.get(t);let u;return f?u=f:!s.length&&!r&&!i?u=t:(u={},s.length&&s.forEach(_=>mergeOptions(u,_,l,!0)),mergeOptions(u,t,l)),isObject(t)&&o.set(t,u),u}function mergeOptions(n,t,r,i=!1){const{mixins:s,extends:o}=t;o&&mergeOptions(n,o,r,!0),s&&s.forEach(l=>mergeOptions(n,l,r,!0));for(const l in t)if(!(i&&l==="expose")){const f=internalOptionMergeStrats[l]||r&&r[l];n[l]=f?f(n[l],t[l]):t[l]}return n}const internalOptionMergeStrats={data:mergeDataFn,props:mergeEmitsOrPropsOptions,emits:mergeEmitsOrPropsOptions,methods:mergeObjectOptions,computed:mergeObjectOptions,beforeCreate:mergeAsArray,created:mergeAsArray,beforeMount:mergeAsArray,mounted:mergeAsArray,beforeUpdate:mergeAsArray,updated:mergeAsArray,beforeDestroy:mergeAsArray,beforeUnmount:mergeAsArray,destroyed:mergeAsArray,unmounted:mergeAsArray,activated:mergeAsArray,deactivated:mergeAsArray,errorCaptured:mergeAsArray,serverPrefetch:mergeAsArray,components:mergeObjectOptions,directives:mergeObjectOptions,watch:mergeWatchOptions,provide:mergeDataFn,inject:mergeInject};function mergeDataFn(n,t){return t?n?function(){return extend(isFunction$1(n)?n.call(this,this):n,isFunction$1(t)?t.call(this,this):t)}:t:n}function mergeInject(n,t){return mergeObjectOptions(normalizeInject(n),normalizeInject(t))}function normalizeInject(n){if(isArray(n)){const t={};for(let r=0;r<n.length;r++)t[n[r]]=n[r];return t}return n}function mergeAsArray(n,t){return n?[...new Set([].concat(n,t))]:t}function mergeObjectOptions(n,t){return n?extend(Object.create(null),n,t):t}function mergeEmitsOrPropsOptions(n,t){return n?isArray(n)&&isArray(t)?[...new Set([...n,...t])]:extend(Object.create(null),normalizePropsOrEmits(n),normalizePropsOrEmits(t??{})):t}function mergeWatchOptions(n,t){if(!n)return t;if(!t)return n;const r=extend(Object.create(null),n);for(const i in t)r[i]=mergeAsArray(n[i],t[i]);return r}function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let uid$1=0;function createAppAPI(n,t){return function(i,s=null){isFunction$1(i)||(i=extend({},i)),s!=null&&!isObject(s)&&(s=null);const o=createAppContext(),l=new WeakSet;let f=!1;const u=o.app={_uid:uid$1++,_component:i,_props:s,_container:null,_context:o,_instance:null,version,get config(){return o.config},set config(_){},use(_,...g){return l.has(_)||(_&&isFunction$1(_.install)?(l.add(_),_.install(u,...g)):isFunction$1(_)&&(l.add(_),_(u,...g))),u},mixin(_){return o.mixins.includes(_)||o.mixins.push(_),u},component(_,g){return g?(o.components[_]=g,u):o.components[_]},directive(_,g){return g?(o.directives[_]=g,u):o.directives[_]},mount(_,g,a){if(!f){const m=createVNode(i,s);return m.appContext=o,g&&t?t(m,_):n(m,_,a),f=!0,u._container=_,_.__vue_app__=u,getExposeProxy(m.component)||m.component.proxy}},unmount(){f&&(n(null,u._container),delete u._container.__vue_app__)},provide(_,g){return o.provides[_]=g,u},runWithContext(_){currentApp=u;try{return _()}finally{currentApp=null}}};return u}}let currentApp=null;function provide(n,t){if(currentInstance){let r=currentInstance.provides;const i=currentInstance.parent&&currentInstance.parent.provides;i===r&&(r=currentInstance.provides=Object.create(i)),r[n]=t}}function inject(n,t,r=!1){const i=currentInstance||currentRenderingInstance;if(i||currentApp){const s=i?i.parent==null?i.vnode.appContext&&i.vnode.appContext.provides:i.parent.provides:currentApp._context.provides;if(s&&n in s)return s[n];if(arguments.length>1)return r&&isFunction$1(t)?t.call(i&&i.proxy):t}}function initProps(n,t,r,i=!1){const s={},o={};def(o,InternalObjectKey,1),n.propsDefaults=Object.create(null),setFullProps(n,t,s,o);for(const l in n.propsOptions[0])l in s||(s[l]=void 0);r?n.props=i?s:shallowReactive(s):n.type.props?n.props=s:n.props=o,n.attrs=o}function updateProps(n,t,r,i){const{props:s,attrs:o,vnode:{patchFlag:l}}=n,f=toRaw(s),[u]=n.propsOptions;let _=!1;if((i||l>0)&&!(l&16)){if(l&8){const g=n.vnode.dynamicProps;for(let a=0;a<g.length;a++){let m=g[a];if(isEmitListener(n.emitsOptions,m))continue;const b=t[m];if(u)if(hasOwn(o,m))b!==o[m]&&(o[m]=b,_=!0);else{const v=camelize(m);s[v]=resolvePropValue(u,f,v,b,n,!1)}else b!==o[m]&&(o[m]=b,_=!0)}}}else{setFullProps(n,t,s,o)&&(_=!0);let g;for(const a in f)(!t||!hasOwn(t,a)&&((g=hyphenate(a))===a||!hasOwn(t,g)))&&(u?r&&(r[a]!==void 0||r[g]!==void 0)&&(s[a]=resolvePropValue(u,f,a,void 0,n,!0)):delete s[a]);if(o!==f)for(const a in o)(!t||!hasOwn(t,a))&&(delete o[a],_=!0)}_&&trigger(n,"set","$attrs")}function setFullProps(n,t,r,i){const[s,o]=n.propsOptions;let l=!1,f;if(t)for(let u in t){if(isReservedProp(u))continue;const _=t[u];let g;s&&hasOwn(s,g=camelize(u))?!o||!o.includes(g)?r[g]=_:(f||(f={}))[g]=_:isEmitListener(n.emitsOptions,u)||(!(u in i)||_!==i[u])&&(i[u]=_,l=!0)}if(o){const u=toRaw(r),_=f||EMPTY_OBJ;for(let g=0;g<o.length;g++){const a=o[g];r[a]=resolvePropValue(s,u,a,_[a],n,!hasOwn(_,a))}}return l}function resolvePropValue(n,t,r,i,s,o){const l=n[r];if(l!=null){const f=hasOwn(l,"default");if(f&&i===void 0){const u=l.default;if(l.type!==Function&&!l.skipFactory&&isFunction$1(u)){const{propsDefaults:_}=s;r in _?i=_[r]:(setCurrentInstance(s),i=_[r]=u.call(null,t),unsetCurrentInstance())}else i=u}l[0]&&(o&&!f?i=!1:l[1]&&(i===""||i===hyphenate(r))&&(i=!0))}return i}function normalizePropsOptions(n,t,r=!1){const i=t.propsCache,s=i.get(n);if(s)return s;const o=n.props,l={},f=[];let u=!1;if(!isFunction$1(n)){const g=a=>{u=!0;const[m,b]=normalizePropsOptions(a,t,!0);extend(l,m),b&&f.push(...b)};!r&&t.mixins.length&&t.mixins.forEach(g),n.extends&&g(n.extends),n.mixins&&n.mixins.forEach(g)}if(!o&&!u)return isObject(n)&&i.set(n,EMPTY_ARR),EMPTY_ARR;if(isArray(o))for(let g=0;g<o.length;g++){const a=camelize(o[g]);validatePropName(a)&&(l[a]=EMPTY_OBJ)}else if(o)for(const g in o){const a=camelize(g);if(validatePropName(a)){const m=o[g],b=l[a]=isArray(m)||isFunction$1(m)?{type:m}:extend({},m);if(b){const v=getTypeIndex(Boolean,b.type),c=getTypeIndex(String,b.type);b[0]=v>-1,b[1]=c<0||v<c,(v>-1||hasOwn(b,"default"))&&f.push(a)}}}const _=[l,f];return isObject(n)&&i.set(n,_),_}function validatePropName(n){return n[0]!=="$"}function getType(n){const t=n&&n.toString().match(/^\s*(function|class) (\w+)/);return t?t[2]:n===null?"null":""}function isSameType(n,t){return getType(n)===getType(t)}function getTypeIndex(n,t){return isArray(t)?t.findIndex(r=>isSameType(r,n)):isFunction$1(t)&&isSameType(t,n)?0:-1}const isInternalKey=n=>n[0]==="_"||n==="$stable",normalizeSlotValue=n=>isArray(n)?n.map(normalizeVNode):[normalizeVNode(n)],normalizeSlot=(n,t,r)=>{if(t._n)return t;const i=withCtx((...s)=>normalizeSlotValue(t(...s)),r);return i._c=!1,i},normalizeObjectSlots=(n,t,r)=>{const i=n._ctx;for(const s in n){if(isInternalKey(s))continue;const o=n[s];if(isFunction$1(o))t[s]=normalizeSlot(s,o,i);else if(o!=null){const l=normalizeSlotValue(o);t[s]=()=>l}}},normalizeVNodeSlots=(n,t)=>{const r=normalizeSlotValue(t);n.slots.default=()=>r},initSlots=(n,t)=>{if(n.vnode.shapeFlag&32){const r=t._;r?(n.slots=toRaw(t),def(t,"_",r)):normalizeObjectSlots(t,n.slots={})}else n.slots={},t&&normalizeVNodeSlots(n,t);def(n.slots,InternalObjectKey,1)},updateSlots=(n,t,r)=>{const{vnode:i,slots:s}=n;let o=!0,l=EMPTY_OBJ;if(i.shapeFlag&32){const f=t._;f?r&&f===1?o=!1:(extend(s,t),!r&&f===1&&delete s._):(o=!t.$stable,normalizeObjectSlots(t,s)),l=t}else t&&(normalizeVNodeSlots(n,t),l={default:1});if(o)for(const f in s)!isInternalKey(f)&&l[f]==null&&delete s[f]};function setRef(n,t,r,i,s=!1){if(isArray(n)){n.forEach((m,b)=>setRef(m,t&&(isArray(t)?t[b]:t),r,i,s));return}if(isAsyncWrapper(i)&&!s)return;const o=i.shapeFlag&4?getExposeProxy(i.component)||i.component.proxy:i.el,l=s?null:o,{i:f,r:u}=n,_=t&&t.r,g=f.refs===EMPTY_OBJ?f.refs={}:f.refs,a=f.setupState;if(_!=null&&_!==u&&(isString$1(_)?(g[_]=null,hasOwn(a,_)&&(a[_]=null)):isRef(_)&&(_.value=null)),isFunction$1(u))callWithErrorHandling(u,f,12,[l,g]);else{const m=isString$1(u),b=isRef(u);if(m||b){const v=()=>{if(n.f){const c=m?hasOwn(a,u)?a[u]:g[u]:u.value;s?isArray(c)&&remove(c,o):isArray(c)?c.includes(o)||c.push(o):m?(g[u]=[o],hasOwn(a,u)&&(a[u]=g[u])):(u.value=[o],n.k&&(g[n.k]=u.value))}else m?(g[u]=l,hasOwn(a,u)&&(a[u]=l)):b&&(u.value=l,n.k&&(g[n.k]=l))};l?(v.id=-1,queuePostRenderEffect(v,r)):v()}}}const queuePostRenderEffect=queueEffectWithSuspense;function createRenderer(n){return baseCreateRenderer(n)}function baseCreateRenderer(n,t){const r=getGlobalThis();r.__VUE__=!0;const{insert:i,remove:s,patchProp:o,createElement:l,createText:f,createComment:u,setText:_,setElementText:g,parentNode:a,nextSibling:m,setScopeId:b=NOOP,insertStaticContent:v}=n,c=(z,Z,se,le=null,ue=null,pe=null,be=!1,ve=null,ge=!!Z.dynamicChildren)=>{if(z===Z)return;z&&!isSameVNodeType(z,Z)&&(le=Ae(z),de(z,ue,pe,!0),z=null),Z.patchFlag===-2&&(ge=!1,Z.dynamicChildren=null);const{type:L,ref:P,shapeFlag:R}=Z;switch(L){case Text:w(z,Z,se,le);break;case Comment:k(z,Z,se,le);break;case Static:z==null&&x(Z,se,le,be);break;case Fragment:M(z,Z,se,le,ue,pe,be,ve,ge);break;default:R&1?A(z,Z,se,le,ue,pe,be,ve,ge):R&6?W(z,Z,se,le,ue,pe,be,ve,ge):(R&64||R&128)&&L.process(z,Z,se,le,ue,pe,be,ve,ge,Oe)}P!=null&&ue&&setRef(P,z&&z.ref,pe,Z||z,!Z)},w=(z,Z,se,le)=>{if(z==null)i(Z.el=f(Z.children),se,le);else{const ue=Z.el=z.el;Z.children!==z.children&&_(ue,Z.children)}},k=(z,Z,se,le)=>{z==null?i(Z.el=u(Z.children||""),se,le):Z.el=z.el},x=(z,Z,se,le)=>{[z.el,z.anchor]=v(z.children,Z,se,le,z.el,z.anchor)},E=({el:z,anchor:Z},se,le)=>{let ue;for(;z&&z!==Z;)ue=m(z),i(z,se,le),z=ue;i(Z,se,le)},O=({el:z,anchor:Z})=>{let se;for(;z&&z!==Z;)se=m(z),s(z),z=se;s(Z)},A=(z,Z,se,le,ue,pe,be,ve,ge)=>{be=be||Z.type==="svg",z==null?T(Z,se,le,ue,pe,be,ve,ge):D(z,Z,ue,pe,be,ve,ge)},T=(z,Z,se,le,ue,pe,be,ve)=>{let ge,L;const{type:P,props:R,shapeFlag:V,transition:Q,dirs:oe}=z;if(ge=z.el=l(z.type,pe,R&&R.is,R),V&8?g(ge,z.children):V&16&&I(z.children,ge,null,le,ue,pe&&P!=="foreignObject",be,ve),oe&&invokeDirectiveHook(z,null,le,"created"),j(ge,z,z.scopeId,be,le),R){for(const xe in R)xe!=="value"&&!isReservedProp(xe)&&o(ge,xe,null,R[xe],pe,z.children,le,ue,Ee);"value"in R&&o(ge,"value",null,R.value),(L=R.onVnodeBeforeMount)&&invokeVNodeHook(L,le,z)}oe&&invokeDirectiveHook(z,null,le,"beforeMount");const ae=needTransition(ue,Q);ae&&Q.beforeEnter(ge),i(ge,Z,se),((L=R&&R.onVnodeMounted)||ae||oe)&&queuePostRenderEffect(()=>{L&&invokeVNodeHook(L,le,z),ae&&Q.enter(ge),oe&&invokeDirectiveHook(z,null,le,"mounted")},ue)},j=(z,Z,se,le,ue)=>{if(se&&b(z,se),le)for(let pe=0;pe<le.length;pe++)b(z,le[pe]);if(ue){let pe=ue.subTree;if(Z===pe){const be=ue.vnode;j(z,be,be.scopeId,be.slotScopeIds,ue.parent)}}},I=(z,Z,se,le,ue,pe,be,ve,ge=0)=>{for(let L=ge;L<z.length;L++){const P=z[L]=ve?cloneIfMounted(z[L]):normalizeVNode(z[L]);c(null,P,Z,se,le,ue,pe,be,ve)}},D=(z,Z,se,le,ue,pe,be)=>{const ve=Z.el=z.el;let{patchFlag:ge,dynamicChildren:L,dirs:P}=Z;ge|=z.patchFlag&16;const R=z.props||EMPTY_OBJ,V=Z.props||EMPTY_OBJ;let Q;se&&toggleRecurse(se,!1),(Q=V.onVnodeBeforeUpdate)&&invokeVNodeHook(Q,se,Z,z),P&&invokeDirectiveHook(Z,z,se,"beforeUpdate"),se&&toggleRecurse(se,!0);const oe=ue&&Z.type!=="foreignObject";if(L?$(z.dynamicChildren,L,ve,se,le,oe,pe):be||X(z,Z,ve,null,se,le,oe,pe,!1),ge>0){if(ge&16)N(ve,Z,R,V,se,le,ue);else if(ge&2&&R.class!==V.class&&o(ve,"class",null,V.class,ue),ge&4&&o(ve,"style",R.style,V.style,ue),ge&8){const ae=Z.dynamicProps;for(let xe=0;xe<ae.length;xe++){const De=ae[xe],Be=R[De],He=V[De];(He!==Be||De==="value")&&o(ve,De,Be,He,ue,z.children,se,le,Ee)}}ge&1&&z.children!==Z.children&&g(ve,Z.children)}else!be&&L==null&&N(ve,Z,R,V,se,le,ue);((Q=V.onVnodeUpdated)||P)&&queuePostRenderEffect(()=>{Q&&invokeVNodeHook(Q,se,Z,z),P&&invokeDirectiveHook(Z,z,se,"updated")},le)},$=(z,Z,se,le,ue,pe,be)=>{for(let ve=0;ve<Z.length;ve++){const ge=z[ve],L=Z[ve],P=ge.el&&(ge.type===Fragment||!isSameVNodeType(ge,L)||ge.shapeFlag&70)?a(ge.el):se;c(ge,L,P,null,le,ue,pe,be,!0)}},N=(z,Z,se,le,ue,pe,be)=>{if(se!==le){if(se!==EMPTY_OBJ)for(const ve in se)!isReservedProp(ve)&&!(ve in le)&&o(z,ve,se[ve],null,be,Z.children,ue,pe,Ee);for(const ve in le){if(isReservedProp(ve))continue;const ge=le[ve],L=se[ve];ge!==L&&ve!=="value"&&o(z,ve,L,ge,be,Z.children,ue,pe,Ee)}"value"in le&&o(z,"value",se.value,le.value)}},M=(z,Z,se,le,ue,pe,be,ve,ge)=>{const L=Z.el=z?z.el:f(""),P=Z.anchor=z?z.anchor:f("");let{patchFlag:R,dynamicChildren:V,slotScopeIds:Q}=Z;Q&&(ve=ve?ve.concat(Q):Q),z==null?(i(L,se,le),i(P,se,le),I(Z.children,se,P,ue,pe,be,ve,ge)):R>0&&R&64&&V&&z.dynamicChildren?($(z.dynamicChildren,V,se,ue,pe,be,ve),(Z.key!=null||ue&&Z===ue.subTree)&&traverseStaticChildren(z,Z,!0)):X(z,Z,se,P,ue,pe,be,ve,ge)},W=(z,Z,se,le,ue,pe,be,ve,ge)=>{Z.slotScopeIds=ve,z==null?Z.shapeFlag&512?ue.ctx.activate(Z,se,le,be,ge):F(Z,se,le,ue,pe,be,ge):H(z,Z,ge)},F=(z,Z,se,le,ue,pe,be)=>{const ve=z.component=createComponentInstance(z,le,ue);if(isKeepAlive(z)&&(ve.ctx.renderer=Oe),setupComponent(ve),ve.asyncDep){if(ue&&ue.registerDep(ve,q),!z.el){const ge=ve.subTree=createVNode(Comment);k(null,ge,Z,se)}return}q(ve,z,Z,se,ue,pe,be)},H=(z,Z,se)=>{const le=Z.component=z.component;if(shouldUpdateComponent(z,Z,se))if(le.asyncDep&&!le.asyncResolved){Y(le,Z,se);return}else le.next=Z,invalidateJob(le.update),le.update();else Z.el=z.el,le.vnode=Z},q=(z,Z,se,le,ue,pe,be)=>{const ve=()=>{if(z.isMounted){let{next:P,bu:R,u:V,parent:Q,vnode:oe}=z,ae=P,xe;toggleRecurse(z,!1),P?(P.el=oe.el,Y(z,P,be)):P=oe,R&&invokeArrayFns(R),(xe=P.props&&P.props.onVnodeBeforeUpdate)&&invokeVNodeHook(xe,Q,P,oe),toggleRecurse(z,!0);const De=renderComponentRoot(z),Be=z.subTree;z.subTree=De,c(Be,De,a(Be.el),Ae(Be),z,ue,pe),P.el=De.el,ae===null&&updateHOCHostEl(z,De.el),V&&queuePostRenderEffect(V,ue),(xe=P.props&&P.props.onVnodeUpdated)&&queuePostRenderEffect(()=>invokeVNodeHook(xe,Q,P,oe),ue)}else{let P;const{el:R,props:V}=Z,{bm:Q,m:oe,parent:ae}=z,xe=isAsyncWrapper(Z);if(toggleRecurse(z,!1),Q&&invokeArrayFns(Q),!xe&&(P=V&&V.onVnodeBeforeMount)&&invokeVNodeHook(P,ae,Z),toggleRecurse(z,!0),R&&Ce){const De=()=>{z.subTree=renderComponentRoot(z),Ce(R,z.subTree,z,ue,null)};xe?Z.type.__asyncLoader().then(()=>!z.isUnmounted&&De()):De()}else{const De=z.subTree=renderComponentRoot(z);c(null,De,se,le,z,ue,pe),Z.el=De.el}if(oe&&queuePostRenderEffect(oe,ue),!xe&&(P=V&&V.onVnodeMounted)){const De=Z;queuePostRenderEffect(()=>invokeVNodeHook(P,ae,De),ue)}(Z.shapeFlag&256||ae&&isAsyncWrapper(ae.vnode)&&ae.vnode.shapeFlag&256)&&z.a&&queuePostRenderEffect(z.a,ue),z.isMounted=!0,Z=se=le=null}},ge=z.effect=new ReactiveEffect(ve,()=>queueJob(L),z.scope),L=z.update=()=>ge.run();L.id=z.uid,toggleRecurse(z,!0),L()},Y=(z,Z,se)=>{Z.component=z;const le=z.vnode.props;z.vnode=Z,z.next=null,updateProps(z,Z.props,le,se),updateSlots(z,Z.children,se),pauseTracking(),flushPreFlushCbs(z),resetTracking()},X=(z,Z,se,le,ue,pe,be,ve,ge=!1)=>{const L=z&&z.children,P=z?z.shapeFlag:0,R=Z.children,{patchFlag:V,shapeFlag:Q}=Z;if(V>0){if(V&128){te(L,R,se,le,ue,pe,be,ve,ge);return}else if(V&256){J(L,R,se,le,ue,pe,be,ve,ge);return}}Q&8?(P&16&&Ee(L,ue,pe),R!==L&&g(se,R)):P&16?Q&16?te(L,R,se,le,ue,pe,be,ve,ge):Ee(L,ue,pe,!0):(P&8&&g(se,""),Q&16&&I(R,se,le,ue,pe,be,ve,ge))},J=(z,Z,se,le,ue,pe,be,ve,ge)=>{z=z||EMPTY_ARR,Z=Z||EMPTY_ARR;const L=z.length,P=Z.length,R=Math.min(L,P);let V;for(V=0;V<R;V++){const Q=Z[V]=ge?cloneIfMounted(Z[V]):normalizeVNode(Z[V]);c(z[V],Q,se,null,ue,pe,be,ve,ge)}L>P?Ee(z,ue,pe,!0,!1,R):I(Z,se,le,ue,pe,be,ve,ge,R)},te=(z,Z,se,le,ue,pe,be,ve,ge)=>{let L=0;const P=Z.length;let R=z.length-1,V=P-1;for(;L<=R&&L<=V;){const Q=z[L],oe=Z[L]=ge?cloneIfMounted(Z[L]):normalizeVNode(Z[L]);if(isSameVNodeType(Q,oe))c(Q,oe,se,null,ue,pe,be,ve,ge);else break;L++}for(;L<=R&&L<=V;){const Q=z[R],oe=Z[V]=ge?cloneIfMounted(Z[V]):normalizeVNode(Z[V]);if(isSameVNodeType(Q,oe))c(Q,oe,se,null,ue,pe,be,ve,ge);else break;R--,V--}if(L>R){if(L<=V){const Q=V+1,oe=Q<P?Z[Q].el:le;for(;L<=V;)c(null,Z[L]=ge?cloneIfMounted(Z[L]):normalizeVNode(Z[L]),se,oe,ue,pe,be,ve,ge),L++}}else if(L>V)for(;L<=R;)de(z[L],ue,pe,!0),L++;else{const Q=L,oe=L,ae=new Map;for(L=oe;L<=V;L++){const nt=Z[L]=ge?cloneIfMounted(Z[L]):normalizeVNode(Z[L]);nt.key!=null&&ae.set(nt.key,L)}let xe,De=0;const Be=V-oe+1;let He=!1,ze=0;const ot=new Array(Be);for(L=0;L<Be;L++)ot[L]=0;for(L=Q;L<=R;L++){const nt=z[L];if(De>=Be){de(nt,ue,pe,!0);continue}let gt;if(nt.key!=null)gt=ae.get(nt.key);else for(xe=oe;xe<=V;xe++)if(ot[xe-oe]===0&&isSameVNodeType(nt,Z[xe])){gt=xe;break}gt===void 0?de(nt,ue,pe,!0):(ot[gt-oe]=L+1,gt>=ze?ze=gt:He=!0,c(nt,Z[gt],se,null,ue,pe,be,ve,ge),De++)}const $t=He?getSequence(ot):EMPTY_ARR;for(xe=$t.length-1,L=Be-1;L>=0;L--){const nt=oe+L,gt=Z[nt],yn=nt+1<P?Z[nt+1].el:le;ot[L]===0?c(null,gt,se,yn,ue,pe,be,ve,ge):He&&(xe<0||L!==$t[xe]?ie(gt,se,yn,2):xe--)}}},ie=(z,Z,se,le,ue=null)=>{const{el:pe,type:be,transition:ve,children:ge,shapeFlag:L}=z;if(L&6){ie(z.component.subTree,Z,se,le);return}if(L&128){z.suspense.move(Z,se,le);return}if(L&64){be.move(z,Z,se,Oe);return}if(be===Fragment){i(pe,Z,se);for(let R=0;R<ge.length;R++)ie(ge[R],Z,se,le);i(z.anchor,Z,se);return}if(be===Static){E(z,Z,se);return}if(le!==2&&L&1&&ve)if(le===0)ve.beforeEnter(pe),i(pe,Z,se),queuePostRenderEffect(()=>ve.enter(pe),ue);else{const{leave:R,delayLeave:V,afterLeave:Q}=ve,oe=()=>i(pe,Z,se),ae=()=>{R(pe,()=>{oe(),Q&&Q()})};V?V(pe,oe,ae):ae()}else i(pe,Z,se)},de=(z,Z,se,le=!1,ue=!1)=>{const{type:pe,props:be,ref:ve,children:ge,dynamicChildren:L,shapeFlag:P,patchFlag:R,dirs:V}=z;if(ve!=null&&setRef(ve,null,se,z,!0),P&256){Z.ctx.deactivate(z);return}const Q=P&1&&V,oe=!isAsyncWrapper(z);let ae;if(oe&&(ae=be&&be.onVnodeBeforeUnmount)&&invokeVNodeHook(ae,Z,z),P&6)_e(z.component,se,le);else{if(P&128){z.suspense.unmount(se,le);return}Q&&invokeDirectiveHook(z,null,Z,"beforeUnmount"),P&64?z.type.remove(z,Z,se,ue,Oe,le):L&&(pe!==Fragment||R>0&&R&64)?Ee(L,Z,se,!1,!0):(pe===Fragment&&R&384||!ue&&P&16)&&Ee(ge,Z,se),le&&ke(z)}(oe&&(ae=be&&be.onVnodeUnmounted)||Q)&&queuePostRenderEffect(()=>{ae&&invokeVNodeHook(ae,Z,z),Q&&invokeDirectiveHook(z,null,Z,"unmounted")},se)},ke=z=>{const{type:Z,el:se,anchor:le,transition:ue}=z;if(Z===Fragment){we(se,le);return}if(Z===Static){O(z);return}const pe=()=>{s(se),ue&&!ue.persisted&&ue.afterLeave&&ue.afterLeave()};if(z.shapeFlag&1&&ue&&!ue.persisted){const{leave:be,delayLeave:ve}=ue,ge=()=>be(se,pe);ve?ve(z.el,pe,ge):ge()}else pe()},we=(z,Z)=>{let se;for(;z!==Z;)se=m(z),s(z),z=se;s(Z)},_e=(z,Z,se)=>{const{bum:le,scope:ue,update:pe,subTree:be,um:ve}=z;le&&invokeArrayFns(le),ue.stop(),pe&&(pe.active=!1,de(be,z,Z,se)),ve&&queuePostRenderEffect(ve,Z),queuePostRenderEffect(()=>{z.isUnmounted=!0},Z),Z&&Z.pendingBranch&&!Z.isUnmounted&&z.asyncDep&&!z.asyncResolved&&z.suspenseId===Z.pendingId&&(Z.deps--,Z.deps===0&&Z.resolve())},Ee=(z,Z,se,le=!1,ue=!1,pe=0)=>{for(let be=pe;be<z.length;be++)de(z[be],Z,se,le,ue)},Ae=z=>z.shapeFlag&6?Ae(z.component.subTree):z.shapeFlag&128?z.suspense.next():m(z.anchor||z.el),je=(z,Z,se)=>{z==null?Z._vnode&&de(Z._vnode,null,null,!0):c(Z._vnode||null,z,Z,null,null,null,se),flushPreFlushCbs(),flushPostFlushCbs(),Z._vnode=z},Oe={p:c,um:de,m:ie,r:ke,mt:F,mc:I,pc:X,pbc:$,n:Ae,o:n};let Pe,Ce;return t&&([Pe,Ce]=t(Oe)),{render:je,hydrate:Pe,createApp:createAppAPI(je,Pe)}}function toggleRecurse({effect:n,update:t},r){n.allowRecurse=t.allowRecurse=r}function needTransition(n,t){return(!n||n&&!n.pendingBranch)&&t&&!t.persisted}function traverseStaticChildren(n,t,r=!1){const i=n.children,s=t.children;if(isArray(i)&&isArray(s))for(let o=0;o<i.length;o++){const l=i[o];let f=s[o];f.shapeFlag&1&&!f.dynamicChildren&&((f.patchFlag<=0||f.patchFlag===32)&&(f=s[o]=cloneIfMounted(s[o]),f.el=l.el),r||traverseStaticChildren(l,f)),f.type===Text&&(f.el=l.el)}}function getSequence(n){const t=n.slice(),r=[0];let i,s,o,l,f;const u=n.length;for(i=0;i<u;i++){const _=n[i];if(_!==0){if(s=r[r.length-1],n[s]<_){t[i]=s,r.push(i);continue}for(o=0,l=r.length-1;o<l;)f=o+l>>1,n[r[f]]<_?o=f+1:l=f;_<n[r[o]]&&(o>0&&(t[i]=r[o-1]),r[o]=i)}}for(o=r.length,l=r[o-1];o-- >0;)r[o]=l,l=t[l];return r}const isTeleport=n=>n.__isTeleport,isTeleportDisabled=n=>n&&(n.disabled||n.disabled===""),isTargetSVG=n=>typeof SVGElement<"u"&&n instanceof SVGElement,resolveTarget=(n,t)=>{const r=n&&n.to;return isString$1(r)?t?t(r):null:r},TeleportImpl={name:"Teleport",__isTeleport:!0,process(n,t,r,i,s,o,l,f,u,_){const{mc:g,pc:a,pbc:m,o:{insert:b,querySelector:v,createText:c,createComment:w}}=_,k=isTeleportDisabled(t.props);let{shapeFlag:x,children:E,dynamicChildren:O}=t;if(n==null){const A=t.el=c(""),T=t.anchor=c("");b(A,r,i),b(T,r,i);const j=t.target=resolveTarget(t.props,v),I=t.targetAnchor=c("");j&&(b(I,j),l=l||isTargetSVG(j));const D=($,N)=>{x&16&&g(E,$,N,s,o,l,f,u)};k?D(r,T):j&&D(j,I)}else{t.el=n.el;const A=t.anchor=n.anchor,T=t.target=n.target,j=t.targetAnchor=n.targetAnchor,I=isTeleportDisabled(n.props),D=I?r:T,$=I?A:j;if(l=l||isTargetSVG(T),O?(m(n.dynamicChildren,O,D,s,o,l,f),traverseStaticChildren(n,t,!0)):u||a(n,t,D,$,s,o,l,f,!1),k)I?t.props&&n.props&&t.props.to!==n.props.to&&(t.props.to=n.props.to):moveTeleport(t,r,A,_,1);else if((t.props&&t.props.to)!==(n.props&&n.props.to)){const N=t.target=resolveTarget(t.props,v);N&&moveTeleport(t,N,null,_,0)}else I&&moveTeleport(t,T,j,_,1)}updateCssVars(t)},remove(n,t,r,i,{um:s,o:{remove:o}},l){const{shapeFlag:f,children:u,anchor:_,targetAnchor:g,target:a,props:m}=n;if(a&&o(g),l&&o(_),f&16){const b=l||!isTeleportDisabled(m);for(let v=0;v<u.length;v++){const c=u[v];s(c,t,r,b,!!c.dynamicChildren)}}},move:moveTeleport,hydrate:hydrateTeleport};function moveTeleport(n,t,r,{o:{insert:i},m:s},o=2){o===0&&i(n.targetAnchor,t,r);const{el:l,anchor:f,shapeFlag:u,children:_,props:g}=n,a=o===2;if(a&&i(l,t,r),(!a||isTeleportDisabled(g))&&u&16)for(let m=0;m<_.length;m++)s(_[m],t,r,2);a&&i(f,t,r)}function hydrateTeleport(n,t,r,i,s,o,{o:{nextSibling:l,parentNode:f,querySelector:u}},_){const g=t.target=resolveTarget(t.props,u);if(g){const a=g._lpa||g.firstChild;if(t.shapeFlag&16)if(isTeleportDisabled(t.props))t.anchor=_(l(n),t,f(n),r,i,s,o),t.targetAnchor=a;else{t.anchor=l(n);let m=a;for(;m;)if(m=l(m),m&&m.nodeType===8&&m.data==="teleport anchor"){t.targetAnchor=m,g._lpa=t.targetAnchor&&l(t.targetAnchor);break}_(a,t,g,r,i,s,o)}updateCssVars(t)}return t.anchor&&l(t.anchor)}const Teleport=TeleportImpl;function updateCssVars(n){const t=n.ctx;if(t&&t.ut){let r=n.children[0].el;for(;r&&r!==n.targetAnchor;)r.nodeType===1&&r.setAttribute("data-v-owner",t.uid),r=r.nextSibling;t.ut()}}const Fragment=Symbol.for("v-fgt"),Text=Symbol.for("v-txt"),Comment=Symbol.for("v-cmt"),Static=Symbol.for("v-stc"),blockStack=[];let currentBlock=null;function openBlock(n=!1){blockStack.push(currentBlock=n?null:[])}function closeBlock(){blockStack.pop(),currentBlock=blockStack[blockStack.length-1]||null}let isBlockTreeEnabled=1;function setBlockTracking(n){isBlockTreeEnabled+=n}function setupBlock(n){return n.dynamicChildren=isBlockTreeEnabled>0?currentBlock||EMPTY_ARR:null,closeBlock(),isBlockTreeEnabled>0&&currentBlock&&currentBlock.push(n),n}function createElementBlock(n,t,r,i,s,o){return setupBlock(createBaseVNode(n,t,r,i,s,o,!0))}function createBlock(n,t,r,i,s){return setupBlock(createVNode(n,t,r,i,s,!0))}function isVNode(n){return n?n.__v_isVNode===!0:!1}function isSameVNodeType(n,t){return n.type===t.type&&n.key===t.key}const InternalObjectKey="__vInternal",normalizeKey=({key:n})=>n??null,normalizeRef=({ref:n,ref_key:t,ref_for:r})=>(typeof n=="number"&&(n=""+n),n!=null?isString$1(n)||isRef(n)||isFunction$1(n)?{i:currentRenderingInstance,r:n,k:t,f:!!r}:n:null);function createBaseVNode(n,t=null,r=null,i=0,s=null,o=n===Fragment?0:1,l=!1,f=!1){const u={__v_isVNode:!0,__v_skip:!0,type:n,props:t,key:t&&normalizeKey(t),ref:t&&normalizeRef(t),scopeId:currentScopeId,slotScopeIds:null,children:r,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:i,dynamicProps:s,dynamicChildren:null,appContext:null,ctx:currentRenderingInstance};return f?(normalizeChildren(u,r),o&128&&n.normalize(u)):r&&(u.shapeFlag|=isString$1(r)?8:16),isBlockTreeEnabled>0&&!l&&currentBlock&&(u.patchFlag>0||o&6)&&u.patchFlag!==32&&currentBlock.push(u),u}const createVNode=_createVNode;function _createVNode(n,t=null,r=null,i=0,s=null,o=!1){if((!n||n===NULL_DYNAMIC_COMPONENT)&&(n=Comment),isVNode(n)){const f=cloneVNode(n,t,!0);return r&&normalizeChildren(f,r),isBlockTreeEnabled>0&&!o&&currentBlock&&(f.shapeFlag&6?currentBlock[currentBlock.indexOf(n)]=f:currentBlock.push(f)),f.patchFlag|=-2,f}if(isClassComponent(n)&&(n=n.__vccOpts),t){t=guardReactiveProps(t);let{class:f,style:u}=t;f&&!isString$1(f)&&(t.class=normalizeClass(f)),isObject(u)&&(isProxy(u)&&!isArray(u)&&(u=extend({},u)),t.style=normalizeStyle(u))}const l=isString$1(n)?1:isSuspense(n)?128:isTeleport(n)?64:isObject(n)?4:isFunction$1(n)?2:0;return createBaseVNode(n,t,r,i,s,l,o,!0)}function guardReactiveProps(n){return n?isProxy(n)||InternalObjectKey in n?extend({},n):n:null}function cloneVNode(n,t,r=!1){const{props:i,ref:s,patchFlag:o,children:l}=n,f=t?mergeProps(i||{},t):i;return{__v_isVNode:!0,__v_skip:!0,type:n.type,props:f,key:f&&normalizeKey(f),ref:t&&t.ref?r&&s?isArray(s)?s.concat(normalizeRef(t)):[s,normalizeRef(t)]:normalizeRef(t):s,scopeId:n.scopeId,slotScopeIds:n.slotScopeIds,children:l,target:n.target,targetAnchor:n.targetAnchor,staticCount:n.staticCount,shapeFlag:n.shapeFlag,patchFlag:t&&n.type!==Fragment?o===-1?16:o|16:o,dynamicProps:n.dynamicProps,dynamicChildren:n.dynamicChildren,appContext:n.appContext,dirs:n.dirs,transition:n.transition,component:n.component,suspense:n.suspense,ssContent:n.ssContent&&cloneVNode(n.ssContent),ssFallback:n.ssFallback&&cloneVNode(n.ssFallback),el:n.el,anchor:n.anchor,ctx:n.ctx,ce:n.ce}}function createTextVNode(n=" ",t=0){return createVNode(Text,null,n,t)}function createCommentVNode(n="",t=!1){return t?(openBlock(),createBlock(Comment,null,n)):createVNode(Comment,null,n)}function normalizeVNode(n){return n==null||typeof n=="boolean"?createVNode(Comment):isArray(n)?createVNode(Fragment,null,n.slice()):typeof n=="object"?cloneIfMounted(n):createVNode(Text,null,String(n))}function cloneIfMounted(n){return n.el===null&&n.patchFlag!==-1||n.memo?n:cloneVNode(n)}function normalizeChildren(n,t){let r=0;const{shapeFlag:i}=n;if(t==null)t=null;else if(isArray(t))r=16;else if(typeof t=="object")if(i&65){const s=t.default;s&&(s._c&&(s._d=!1),normalizeChildren(n,s()),s._c&&(s._d=!0));return}else{r=32;const s=t._;!s&&!(InternalObjectKey in t)?t._ctx=currentRenderingInstance:s===3&&currentRenderingInstance&&(currentRenderingInstance.slots._===1?t._=1:(t._=2,n.patchFlag|=1024))}else isFunction$1(t)?(t={default:t,_ctx:currentRenderingInstance},r=32):(t=String(t),i&64?(r=16,t=[createTextVNode(t)]):r=8);n.children=t,n.shapeFlag|=r}function mergeProps(...n){const t={};for(let r=0;r<n.length;r++){const i=n[r];for(const s in i)if(s==="class")t.class!==i.class&&(t.class=normalizeClass([t.class,i.class]));else if(s==="style")t.style=normalizeStyle([t.style,i.style]);else if(isOn(s)){const o=t[s],l=i[s];l&&o!==l&&!(isArray(o)&&o.includes(l))&&(t[s]=o?[].concat(o,l):l)}else s!==""&&(t[s]=i[s])}return t}function invokeVNodeHook(n,t,r,i=null){callWithAsyncErrorHandling(n,t,7,[r,i])}const emptyAppContext=createAppContext();let uid=0;function createComponentInstance(n,t,r){const i=n.type,s=(t?t.appContext:n.appContext)||emptyAppContext,o={uid:uid++,vnode:n,type:i,parent:t,appContext:s,root:null,next:null,subTree:null,effect:null,update:null,scope:new EffectScope(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(s.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:normalizePropsOptions(i,s),emitsOptions:normalizeEmitsOptions(i,s),emit:null,emitted:null,propsDefaults:EMPTY_OBJ,inheritAttrs:i.inheritAttrs,ctx:EMPTY_OBJ,data:EMPTY_OBJ,props:EMPTY_OBJ,attrs:EMPTY_OBJ,slots:EMPTY_OBJ,refs:EMPTY_OBJ,setupState:EMPTY_OBJ,setupContext:null,attrsProxy:null,slotsProxy:null,suspense:r,suspenseId:r?r.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=t?t.root:o,o.emit=emit.bind(null,o),n.ce&&n.ce(o),o}let currentInstance=null;const getCurrentInstance=()=>currentInstance||currentRenderingInstance;let internalSetCurrentInstance,globalCurrentInstanceSetters,settersKey="__VUE_INSTANCE_SETTERS__";(globalCurrentInstanceSetters=getGlobalThis()[settersKey])||(globalCurrentInstanceSetters=getGlobalThis()[settersKey]=[]),globalCurrentInstanceSetters.push(n=>currentInstance=n),internalSetCurrentInstance=n=>{globalCurrentInstanceSetters.length>1?globalCurrentInstanceSetters.forEach(t=>t(n)):globalCurrentInstanceSetters[0](n)};const setCurrentInstance=n=>{internalSetCurrentInstance(n),n.scope.on()},unsetCurrentInstance=()=>{currentInstance&&currentInstance.scope.off(),internalSetCurrentInstance(null)};function isStatefulComponent(n){return n.vnode.shapeFlag&4}let isInSSRComponentSetup=!1;function setupComponent(n,t=!1){isInSSRComponentSetup=t;const{props:r,children:i}=n.vnode,s=isStatefulComponent(n);initProps(n,r,s,t),initSlots(n,i);const o=s?setupStatefulComponent(n,t):void 0;return isInSSRComponentSetup=!1,o}function setupStatefulComponent(n,t){const r=n.type;n.accessCache=Object.create(null),n.proxy=markRaw(new Proxy(n.ctx,PublicInstanceProxyHandlers));const{setup:i}=r;if(i){const s=n.setupContext=i.length>1?createSetupContext(n):null;setCurrentInstance(n),pauseTracking();const o=callWithErrorHandling(i,n,0,[n.props,s]);if(resetTracking(),unsetCurrentInstance(),isPromise$1(o)){if(o.then(unsetCurrentInstance,unsetCurrentInstance),t)return o.then(l=>{handleSetupResult(n,l,t)}).catch(l=>{handleError(l,n,0)});n.asyncDep=o}else handleSetupResult(n,o,t)}else finishComponentSetup(n,t)}function handleSetupResult(n,t,r){isFunction$1(t)?n.type.__ssrInlineRender?n.ssrRender=t:n.render=t:isObject(t)&&(n.setupState=proxyRefs(t)),finishComponentSetup(n,r)}let compile;function finishComponentSetup(n,t,r){const i=n.type;if(!n.render){if(!t&&compile&&!i.render){const s=i.template||resolveMergedOptions(n).template;if(s){const{isCustomElement:o,compilerOptions:l}=n.appContext.config,{delimiters:f,compilerOptions:u}=i,_=extend(extend({isCustomElement:o,delimiters:f},l),u);i.render=compile(s,_)}}n.render=i.render||NOOP}{setCurrentInstance(n),pauseTracking();try{applyOptions(n)}finally{resetTracking(),unsetCurrentInstance()}}}function getAttrsProxy(n){return n.attrsProxy||(n.attrsProxy=new Proxy(n.attrs,{get(t,r){return track(n,"get","$attrs"),t[r]}}))}function createSetupContext(n){const t=r=>{n.exposed=r||{}};return{get attrs(){return getAttrsProxy(n)},slots:n.slots,emit:n.emit,expose:t}}function getExposeProxy(n){if(n.exposed)return n.exposeProxy||(n.exposeProxy=new Proxy(proxyRefs(markRaw(n.exposed)),{get(t,r){if(r in t)return t[r];if(r in publicPropertiesMap)return publicPropertiesMap[r](n)},has(t,r){return r in t||r in publicPropertiesMap}}))}function getComponentName(n,t=!0){return isFunction$1(n)?n.displayName||n.name:n.name||t&&n.__name}function isClassComponent(n){return isFunction$1(n)&&"__vccOpts"in n}const computed=(n,t)=>computed$1(n,t,isInSSRComponentSetup);function h(n,t,r){const i=arguments.length;return i===2?isObject(t)&&!isArray(t)?isVNode(t)?createVNode(n,null,[t]):createVNode(n,t):createVNode(n,null,t):(i>3?r=Array.prototype.slice.call(arguments,2):i===3&&isVNode(r)&&(r=[r]),createVNode(n,t,r))}const ssrContextKey=Symbol.for("v-scx"),useSSRContext=()=>inject(ssrContextKey),version="3.3.11",svgNS="http://www.w3.org/2000/svg",doc=typeof document<"u"?document:null,templateContainer=doc&&doc.createElement("template"),nodeOps={insert:(n,t,r)=>{t.insertBefore(n,r||null)},remove:n=>{const t=n.parentNode;t&&t.removeChild(n)},createElement:(n,t,r,i)=>{const s=t?doc.createElementNS(svgNS,n):doc.createElement(n,r?{is:r}:void 0);return n==="select"&&i&&i.multiple!=null&&s.setAttribute("multiple",i.multiple),s},createText:n=>doc.createTextNode(n),createComment:n=>doc.createComment(n),setText:(n,t)=>{n.nodeValue=t},setElementText:(n,t)=>{n.textContent=t},parentNode:n=>n.parentNode,nextSibling:n=>n.nextSibling,querySelector:n=>doc.querySelector(n),setScopeId(n,t){n.setAttribute(t,"")},insertStaticContent(n,t,r,i,s,o){const l=r?r.previousSibling:t.lastChild;if(s&&(s===o||s.nextSibling))for(;t.insertBefore(s.cloneNode(!0),r),!(s===o||!(s=s.nextSibling)););else{templateContainer.innerHTML=i?`<svg>${n}</svg>`:n;const f=templateContainer.content;if(i){const u=f.firstChild;for(;u.firstChild;)f.appendChild(u.firstChild);f.removeChild(u)}t.insertBefore(f,r)}return[l?l.nextSibling:t.firstChild,r?r.previousSibling:t.lastChild]}},TRANSITION="transition",ANIMATION="animation",vtcKey=Symbol("_vtc"),Transition=(n,{slots:t})=>h(BaseTransition,resolveTransitionProps(n),t);Transition.displayName="Transition";const DOMTransitionPropsValidators={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};Transition.props=extend({},BaseTransitionPropsValidators,DOMTransitionPropsValidators);const callHook=(n,t=[])=>{isArray(n)?n.forEach(r=>r(...t)):n&&n(...t)},hasExplicitCallback=n=>n?isArray(n)?n.some(t=>t.length>1):n.length>1:!1;function resolveTransitionProps(n){const t={};for(const M in n)M in DOMTransitionPropsValidators||(t[M]=n[M]);if(n.css===!1)return t;const{name:r="v",type:i,duration:s,enterFromClass:o=`${r}-enter-from`,enterActiveClass:l=`${r}-enter-active`,enterToClass:f=`${r}-enter-to`,appearFromClass:u=o,appearActiveClass:_=l,appearToClass:g=f,leaveFromClass:a=`${r}-leave-from`,leaveActiveClass:m=`${r}-leave-active`,leaveToClass:b=`${r}-leave-to`}=n,v=normalizeDuration(s),c=v&&v[0],w=v&&v[1],{onBeforeEnter:k,onEnter:x,onEnterCancelled:E,onLeave:O,onLeaveCancelled:A,onBeforeAppear:T=k,onAppear:j=x,onAppearCancelled:I=E}=t,D=(M,W,F)=>{removeTransitionClass(M,W?g:f),removeTransitionClass(M,W?_:l),F&&F()},$=(M,W)=>{M._isLeaving=!1,removeTransitionClass(M,a),removeTransitionClass(M,b),removeTransitionClass(M,m),W&&W()},N=M=>(W,F)=>{const H=M?j:x,q=()=>D(W,M,F);callHook(H,[W,q]),nextFrame(()=>{removeTransitionClass(W,M?u:o),addTransitionClass(W,M?g:f),hasExplicitCallback(H)||whenTransitionEnds(W,i,c,q)})};return extend(t,{onBeforeEnter(M){callHook(k,[M]),addTransitionClass(M,o),addTransitionClass(M,l)},onBeforeAppear(M){callHook(T,[M]),addTransitionClass(M,u),addTransitionClass(M,_)},onEnter:N(!1),onAppear:N(!0),onLeave(M,W){M._isLeaving=!0;const F=()=>$(M,W);addTransitionClass(M,a),forceReflow(),addTransitionClass(M,m),nextFrame(()=>{M._isLeaving&&(removeTransitionClass(M,a),addTransitionClass(M,b),hasExplicitCallback(O)||whenTransitionEnds(M,i,w,F))}),callHook(O,[M,F])},onEnterCancelled(M){D(M,!1),callHook(E,[M])},onAppearCancelled(M){D(M,!0),callHook(I,[M])},onLeaveCancelled(M){$(M),callHook(A,[M])}})}function normalizeDuration(n){if(n==null)return null;if(isObject(n))return[NumberOf(n.enter),NumberOf(n.leave)];{const t=NumberOf(n);return[t,t]}}function NumberOf(n){return toNumber(n)}function addTransitionClass(n,t){t.split(/\s+/).forEach(r=>r&&n.classList.add(r)),(n[vtcKey]||(n[vtcKey]=new Set)).add(t)}function removeTransitionClass(n,t){t.split(/\s+/).forEach(i=>i&&n.classList.remove(i));const r=n[vtcKey];r&&(r.delete(t),r.size||(n[vtcKey]=void 0))}function nextFrame(n){requestAnimationFrame(()=>{requestAnimationFrame(n)})}let endId=0;function whenTransitionEnds(n,t,r,i){const s=n._endId=++endId,o=()=>{s===n._endId&&i()};if(r)return setTimeout(o,r);const{type:l,timeout:f,propCount:u}=getTransitionInfo(n,t);if(!l)return i();const _=l+"end";let g=0;const a=()=>{n.removeEventListener(_,m),o()},m=b=>{b.target===n&&++g>=u&&a()};setTimeout(()=>{g<u&&a()},f+1),n.addEventListener(_,m)}function getTransitionInfo(n,t){const r=window.getComputedStyle(n),i=v=>(r[v]||"").split(", "),s=i(`${TRANSITION}Delay`),o=i(`${TRANSITION}Duration`),l=getTimeout(s,o),f=i(`${ANIMATION}Delay`),u=i(`${ANIMATION}Duration`),_=getTimeout(f,u);let g=null,a=0,m=0;t===TRANSITION?l>0&&(g=TRANSITION,a=l,m=o.length):t===ANIMATION?_>0&&(g=ANIMATION,a=_,m=u.length):(a=Math.max(l,_),g=a>0?l>_?TRANSITION:ANIMATION:null,m=g?g===TRANSITION?o.length:u.length:0);const b=g===TRANSITION&&/\b(transform|all)(,|$)/.test(i(`${TRANSITION}Property`).toString());return{type:g,timeout:a,propCount:m,hasTransform:b}}function getTimeout(n,t){for(;n.length<t.length;)n=n.concat(n);return Math.max(...t.map((r,i)=>toMs(r)+toMs(n[i])))}function toMs(n){return n==="auto"?0:Number(n.slice(0,-1).replace(",","."))*1e3}function forceReflow(){return document.body.offsetHeight}function patchClass(n,t,r){const i=n[vtcKey];i&&(t=(t?[t,...i]:[...i]).join(" ")),t==null?n.removeAttribute("class"):r?n.setAttribute("class",t):n.className=t}const vShowOldKey=Symbol("_vod");function patchStyle(n,t,r){const i=n.style,s=isString$1(r);if(r&&!s){if(t&&!isString$1(t))for(const o in t)r[o]==null&&setStyle(i,o,"");for(const o in r)setStyle(i,o,r[o])}else{const o=i.display;s?t!==r&&(i.cssText=r):t&&n.removeAttribute("style"),vShowOldKey in n&&(i.display=o)}}const importantRE=/\s*!important$/;function setStyle(n,t,r){if(isArray(r))r.forEach(i=>setStyle(n,t,i));else if(r==null&&(r=""),t.startsWith("--"))n.setProperty(t,r);else{const i=autoPrefix(n,t);importantRE.test(r)?n.setProperty(hyphenate(i),r.replace(importantRE,""),"important"):n[i]=r}}const prefixes=["Webkit","Moz","ms"],prefixCache={};function autoPrefix(n,t){const r=prefixCache[t];if(r)return r;let i=camelize(t);if(i!=="filter"&&i in n)return prefixCache[t]=i;i=capitalize(i);for(let s=0;s<prefixes.length;s++){const o=prefixes[s]+i;if(o in n)return prefixCache[t]=o}return t}const xlinkNS="http://www.w3.org/1999/xlink";function patchAttr(n,t,r,i,s){if(i&&t.startsWith("xlink:"))r==null?n.removeAttributeNS(xlinkNS,t.slice(6,t.length)):n.setAttributeNS(xlinkNS,t,r);else{const o=isSpecialBooleanAttr(t);r==null||o&&!includeBooleanAttr(r)?n.removeAttribute(t):n.setAttribute(t,o?"":r)}}function patchDOMProp(n,t,r,i,s,o,l){if(t==="innerHTML"||t==="textContent"){i&&l(i,s,o),n[t]=r??"";return}const f=n.tagName;if(t==="value"&&f!=="PROGRESS"&&!f.includes("-")){n._value=r;const _=f==="OPTION"?n.getAttribute("value"):n.value,g=r??"";_!==g&&(n.value=g),r==null&&n.removeAttribute(t);return}let u=!1;if(r===""||r==null){const _=typeof n[t];_==="boolean"?r=includeBooleanAttr(r):r==null&&_==="string"?(r="",u=!0):_==="number"&&(r=0,u=!0)}try{n[t]=r}catch{}u&&n.removeAttribute(t)}function addEventListener$1(n,t,r,i){n.addEventListener(t,r,i)}function removeEventListener$1(n,t,r,i){n.removeEventListener(t,r,i)}const veiKey=Symbol("_vei");function patchEvent(n,t,r,i,s=null){const o=n[veiKey]||(n[veiKey]={}),l=o[t];if(i&&l)l.value=i;else{const[f,u]=parseName(t);if(i){const _=o[t]=createInvoker(i,s);addEventListener$1(n,f,_,u)}else l&&(removeEventListener$1(n,f,l,u),o[t]=void 0)}}const optionsModifierRE=/(?:Once|Passive|Capture)$/;function parseName(n){let t;if(optionsModifierRE.test(n)){t={};let i;for(;i=n.match(optionsModifierRE);)n=n.slice(0,n.length-i[0].length),t[i[0].toLowerCase()]=!0}return[n[2]===":"?n.slice(3):hyphenate(n.slice(2)),t]}let cachedNow=0;const p$1=Promise.resolve(),getNow=()=>cachedNow||(p$1.then(()=>cachedNow=0),cachedNow=Date.now());function createInvoker(n,t){const r=i=>{if(!i._vts)i._vts=Date.now();else if(i._vts<=r.attached)return;callWithAsyncErrorHandling(patchStopImmediatePropagation(i,r.value),t,5,[i])};return r.value=n,r.attached=getNow(),r}function patchStopImmediatePropagation(n,t){if(isArray(t)){const r=n.stopImmediatePropagation;return n.stopImmediatePropagation=()=>{r.call(n),n._stopped=!0},t.map(i=>s=>!s._stopped&&i&&i(s))}else return t}const isNativeOn=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&n.charCodeAt(2)>96&&n.charCodeAt(2)<123,patchProp=(n,t,r,i,s=!1,o,l,f,u)=>{t==="class"?patchClass(n,i,s):t==="style"?patchStyle(n,r,i):isOn(t)?isModelListener(t)||patchEvent(n,t,r,i,l):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):shouldSetAsProp(n,t,i,s))?patchDOMProp(n,t,i,o,l,f,u):(t==="true-value"?n._trueValue=i:t==="false-value"&&(n._falseValue=i),patchAttr(n,t,i,s))};function shouldSetAsProp(n,t,r,i){if(i)return!!(t==="innerHTML"||t==="textContent"||t in n&&isNativeOn(t)&&isFunction$1(r));if(t==="spellcheck"||t==="draggable"||t==="translate"||t==="form"||t==="list"&&n.tagName==="INPUT"||t==="type"&&n.tagName==="TEXTAREA")return!1;if(t==="width"||t==="height"){const s=n.tagName;if(s==="IMG"||s==="VIDEO"||s==="CANVAS"||s==="SOURCE")return!1}return isNativeOn(t)&&isString$1(r)?!1:t in n}const rendererOptions=extend({patchProp},nodeOps);let renderer;function ensureRenderer(){return renderer||(renderer=createRenderer(rendererOptions))}const createApp=(...n)=>{const t=ensureRenderer().createApp(...n),{mount:r}=t;return t.mount=i=>{const s=normalizeContainer(i);if(!s)return;const o=t._component;!isFunction$1(o)&&!o.render&&!o.template&&(o.template=s.innerHTML),s.innerHTML="";const l=r(s,!1,s instanceof SVGElement);return s instanceof Element&&(s.removeAttribute("v-cloak"),s.setAttribute("data-v-app","")),l},t};function normalizeContainer(n){return isString$1(n)?document.querySelector(n):n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EPSILON_FLOAT32=1e-7,EPSILON_FLOAT16=1e-4;class DataStorage{constructor(t,r){this.backend=t,this.dataMover=r,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,r){this.dataIdsCount++,this.data.set(t,r)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class KernelBackend{refCount(t){return notYetImplemented("refCount")}incRef(t){return notYetImplemented("incRef")}timerAvailable(){return!0}time(t){return notYetImplemented("time")}read(t){return notYetImplemented("read")}readSync(t){return notYetImplemented("readSync")}readToGPU(t,r){return notYetImplemented("readToGPU")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(t,r){return notYetImplemented("disposeData")}write(t,r,i){return notYetImplemented("write")}move(t,r,i,s,o){return notYetImplemented("move")}createTensorFromGPUData(t,r,i){return notYetImplemented("createTensorFromGPUData")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32:EPSILON_FLOAT16}dispose(){return notYetImplemented("dispose")}}function notYetImplemented(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clamp(n,t,r){return Math.max(n,Math.min(t,r))}function swap(n,t,r){const i=n[t];n[t]=n[r],n[r]=i}function assert(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function assertShapesMatch(n,t,r=""){assert(arraysEqual(n,t),()=>r+` Shapes ${n} and ${t} must match`)}function sizeFromShape(n){if(n.length===0)return 1;let t=n[0];for(let r=1;r<n.length;r++)t*=n[r];return t}function arraysEqual(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let r=0;r<n.length;r++)if(n[r]!==t[r])return!1;return!0}function isInt(n){return n%1===0}function rightPad(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function inferFromImplicitShape(n,t){let r=1,i=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)r*=n[o];else if(n[o]===-1){if(i!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${i} and dim ${o}`);i=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(i===-1){if(t>0&&t!==r)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(r===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%r!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${r}`);const s=n.slice();return s[i]=t/r,s}function parseAxisParam(n,t){const r=t.length;return n=n==null?t.map((i,s)=>s):[].concat(n),assert(n.every(i=>i>=-r&&i<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${n}`),assert(n.every(i=>isInt(i)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(i=>i<0?r+i:i)}function getTypedArrayFromDType(n,t){return getArrayFromDType(n,t)}function getArrayFromDType(n,t){let r=null;if(n==null||n==="float32")r=new Float32Array(t);else if(n==="int32")r=new Int32Array(t);else if(n==="bool")r=new Uint8Array(t);else if(n==="string")r=new Array(t);else throw new Error(`Unknown data type ${n}`);return r}function checkConversionForErrors(n,t){for(let r=0;r<n.length;r++){const i=n[r];if(isNaN(i)||!isFinite(i))throw Error(`A tensor of type ${t} being uploaded contains ${i}.`)}}function isValidDtype(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function hasEncodingLoss(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function bytesPerElement(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function bytesFromStringArray(n){if(n==null)return 0;let t=0;return n.forEach(r=>t+=r.length),t}function isString(n){return typeof n=="string"||n instanceof String}function isBoolean(n){return typeof n=="boolean"}function isNumber(n){return typeof n=="number"}function inferDtype(n){return Array.isArray(n)?inferDtype(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":isNumber(n)?"float32":isString(n)?"string":isBoolean(n)?"bool":"float32"}function isFunction(n){return!!(n&&n.constructor&&n.call&&n.apply)}function computeStrides(n){const t=n.length;if(t<2)return[];const r=new Array(t-1);r[t-2]=n[t-1];for(let i=t-3;i>=0;--i)r[i]=r[i+1]*n[i+1];return r}function createNestedArray(n,t,r,i=!1){const s=new Array;if(t.length===1){const o=t[0]*(i?2:1);for(let l=0;l<o;l++)s[l]=r[n+l]}else{const o=t[0],l=t.slice(1),f=l.reduce((u,_)=>u*_)*(i?2:1);for(let u=0;u<o;u++)s[u]=createNestedArray(n+u*f,l,r,i)}return s}function toNestedArray(n,t,r=!1){if(n.length===0)return t[0];const i=n.reduce((s,o)=>s*o)*(r?2:1);if(i===0)return[];if(i!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${r?" for a complex tensor":""}.`);return createNestedArray(0,n,t,r)}function convertBackendValuesAndArrayBuffer(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function makeOnesTypedArray(n,t){const r=makeZerosTypedArray(n,t);for(let i=0;i<r.length;i++)r[i]=1;return r}function makeZerosTypedArray(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function makeZerosNestedTypedArray(n,t){const r=n.reduce((i,s)=>i*s,1);if(t==null||t==="float32")return toNestedArray(n,new Float32Array(r));if(t==="int32")return toNestedArray(n,new Int32Array(r));if(t==="bool")return toNestedArray(n,new Uint8Array(r));throw new Error(`Unknown data type ${t}`)}function assertNonNegativeIntegerDimensions(n){n.forEach(t=>{assert(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function locToIndex(n,t,r){if(t===0)return 0;if(t===1)return n[0];let i=n[n.length-1];for(let s=0;s<n.length-1;++s)i+=r[s]*n[s];return i}function indexToLoc(n,t,r){if(t===0)return[];if(t===1)return[n];const i=new Array(t);for(let s=0;s<i.length-1;++s)i[s]=Math.floor(n/r[s]),n-=i[s]*r[s];return i[i.length-1]=n,i}function isPromise(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TENSORFLOWJS_FLAGS_PREFIX="tfjsflags";class Environment{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=getQueryParams,this.populateURLFlags()}setPlatform(t,r){this.platform!=null&&(env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=r}registerFlag(t,r,i){if(this.flagRegistry[t]={evaluationFn:r,setHook:i},this.urlFlags[t]!=null){const s=this.urlFlags[t];env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const r=this.evaluateFlag(t);if(isPromise(r))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=r,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,r){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=r,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(r)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);TENSORFLOWJS_FLAGS_PREFIX in t&&t[TENSORFLOWJS_FLAGS_PREFIX].split(",").forEach(i=>{const[s,o]=i.split(":");this.urlFlags[s]=parseValue(s,o)})}}function getQueryParams(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(r,...i)=>(decodeParam(t,i[0],i[1]),i.join("="))),t}function decodeParam(n,t,r){n[decodeURIComponent(t)]=decodeURIComponent(r||"")}function parseValue(n,t){const r=t.toLowerCase();return r==="true"||r==="false"?r==="true":`${+r}`===r?+r:t}function env(){return ENV$1}let ENV$1=null;function setEnvironmentGlobal(n){ENV$1=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let globalNameSpace;function getGlobalNamespace(){if(globalNameSpace==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");globalNameSpace=n}return globalNameSpace}function getGlobalMap(){const n=getGlobalNamespace();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function getGlobal(n,t){const r=getGlobalMap();if(r.has(n))return r.get(n);{const i=t();return r.set(n,i),r.get(n)}}const Abs="Abs",Acos="Acos",Acosh="Acosh",Add="Add",AddN="AddN",All="All",Any="Any",ArgMax="ArgMax",ArgMin="ArgMin",Asin="Asin",Asinh="Asinh",Atan="Atan",Atanh="Atanh",Atan2="Atan2",AvgPool="AvgPool",AvgPoolGrad="AvgPoolGrad",AvgPool3D="AvgPool3D",AvgPool3DGrad="AvgPool3DGrad",BatchMatMul="BatchMatMul",BatchToSpaceND="BatchToSpaceND",Bincount="Bincount",BitwiseAnd="BitwiseAnd",BroadcastArgs="BroadcastArgs",Cast="Cast",Ceil="Ceil",ClipByValue="ClipByValue",Complex="Complex",ComplexAbs="ComplexAbs",Concat="Concat",Conv2D="Conv2D",Conv2DBackpropFilter="Conv2DBackpropFilter",Conv2DBackpropInput="Conv2DBackpropInput",Conv3D="Conv3D",Conv3DBackpropFilterV2="Conv3DBackpropFilterV2",Conv3DBackpropInputV2="Conv3DBackpropInputV2",Cos="Cos",Cosh="Cosh",Cumprod="Cumprod",Cumsum="Cumsum",CropAndResize="CropAndResize",DenseBincount="DenseBincount",DepthToSpace="DepthToSpace",DepthwiseConv2dNative="DepthwiseConv2dNative",DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter",DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput",Diag="Diag",Dilation2D="Dilation2D",Dilation2DBackpropInput="Dilation2DBackpropInput",Dilation2DBackpropFilter="Dilation2DBackpropFilter",Draw="Draw",RealDiv="RealDiv",Einsum="Einsum",Elu="Elu",EluGrad="EluGrad",Erf="Erf",Equal="Equal",Exp="Exp",ExpandDims="ExpandDims",Expm1="Expm1",FFT="FFT",Fill="Fill",FlipLeftRight="FlipLeftRight",Floor="Floor",FloorDiv="FloorDiv",FusedBatchNorm="FusedBatchNorm",GatherV2="GatherV2",GatherNd="GatherNd",Greater="Greater",GreaterEqual="GreaterEqual",Identity="Identity",IFFT="IFFT",Imag="Imag",IsFinite="IsFinite",IsInf="IsInf",IsNan="IsNan",LeakyRelu="LeakyRelu",Less="Less",LessEqual="LessEqual",LinSpace="LinSpace",Log="Log",Log1p="Log1p",LogicalAnd="LogicalAnd",LogicalNot="LogicalNot",LogicalOr="LogicalOr",LRN="LRN",LRNGrad="LRNGrad",Max="Max",Maximum="Maximum",MaxPool="MaxPool",MaxPoolGrad="MaxPoolGrad",MaxPool3D="MaxPool3D",MaxPool3DGrad="MaxPool3DGrad",MaxPoolWithArgmax="MaxPoolWithArgmax",Mean="Mean",Min="Min",Minimum="Minimum",MirrorPad="MirrorPad",Mod="Mod",Multinomial="Multinomial",Multiply="Multiply",Neg="Neg",NotEqual="NotEqual",NonMaxSuppressionV3="NonMaxSuppressionV3",NonMaxSuppressionV4="NonMaxSuppressionV4",NonMaxSuppressionV5="NonMaxSuppressionV5",OnesLike="OnesLike",OneHot="OneHot",Pack="Pack",PadV2="PadV2",Pow="Pow",Prelu="Prelu",Prod="Prod",RaggedGather="RaggedGather",RaggedRange="RaggedRange",RaggedTensorToTensor="RaggedTensorToTensor",Range="Range",Real="Real",Reciprocal="Reciprocal",Relu="Relu",Reshape="Reshape",ResizeNearestNeighbor="ResizeNearestNeighbor",ResizeNearestNeighborGrad="ResizeNearestNeighborGrad",ResizeBilinear="ResizeBilinear",ResizeBilinearGrad="ResizeBilinearGrad",Relu6="Relu6",Reverse="Reverse",Round="Round",Rsqrt="Rsqrt",ScatterNd="ScatterNd",TensorScatterUpdate="TensorScatterUpdate",SearchSorted="SearchSorted",Select="Select",Selu="Selu",Slice="Slice",Sin="Sin",Sinh="Sinh",Sign="Sign",Sigmoid="Sigmoid",Softplus="Softplus",Sqrt="Sqrt",Sum="Sum",SpaceToBatchND="SpaceToBatchND",SplitV="SplitV",Softmax="Softmax",SparseFillEmptyRows="SparseFillEmptyRows",SparseReshape="SparseReshape",SparseSegmentMean="SparseSegmentMean",SparseSegmentSum="SparseSegmentSum",SparseToDense="SparseToDense",SquaredDifference="SquaredDifference",Square="Square",StaticRegexReplace="StaticRegexReplace",StridedSlice="StridedSlice",StringNGrams="StringNGrams",StringSplit="StringSplit",StringToHashBucketFast="StringToHashBucketFast",Sub="Sub",Tan="Tan",Tanh="Tanh",Tile="Tile",TopK="TopK",Transform="Transform",Transpose="Transpose",Unique="Unique",Unpack="Unpack",UnsortedSegmentSum="UnsortedSegmentSum",ZerosLike="ZerosLike",Step="Step",RotateWithOffset="RotateWithOffset",_FusedMatMul="_FusedMatMul",FusedConv2D="FusedConv2D",FusedDepthwiseConv2D="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function warn(...n){env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kernelRegistry=getGlobal("kernelRegistry",()=>new Map),gradRegistry=getGlobal("gradRegistry",()=>new Map);function getKernel(n,t){const r=makeKey(n,t);return kernelRegistry.get(r)}function getGradient(n){return gradRegistry.get(n)}function getKernelsForBackend(n){const t=kernelRegistry.entries(),r=[];for(;;){const{done:i,value:s}=t.next();if(i)break;const[o,l]=s,[f]=o.split("_");f===n&&r.push(l)}return r}function registerKernel(n){const{kernelName:t,backendName:r}=n,i=makeKey(t,r);kernelRegistry.has(i)&&warn(`The kernel '${t}' for backend '${r}' is already registered`),kernelRegistry.set(i,n)}function makeKey(n,t){return`${t}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isTypedArrayBrowser(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function getAugmentedNamespace(n){if(n.__esModule)return n;var t=n.default;if(typeof t=="function"){var r=function i(){return this instanceof i?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};r.prototype=t.prototype}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(n).forEach(function(i){var s=Object.getOwnPropertyDescriptor(n,i);Object.defineProperty(r,i,s.get?s:{enumerable:!0,get:function(){return n[i]}})}),r}var long=Long$1,wasm=null;try{wasm=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Long$1(n,t,r){this.low=n|0,this.high=t|0,this.unsigned=!!r}Long$1.prototype.__isLong__;Object.defineProperty(Long$1.prototype,"__isLong__",{value:!0});function isLong(n){return(n&&n.__isLong__)===!0}Long$1.isLong=isLong;var INT_CACHE={},UINT_CACHE={};function fromInt(n,t){var r,i,s;return t?(n>>>=0,(s=0<=n&&n<256)&&(i=UINT_CACHE[n],i)?i:(r=fromBits(n,(n|0)<0?-1:0,!0),s&&(UINT_CACHE[n]=r),r)):(n|=0,(s=-128<=n&&n<128)&&(i=INT_CACHE[n],i)?i:(r=fromBits(n,n<0?-1:0,!1),s&&(INT_CACHE[n]=r),r))}Long$1.fromInt=fromInt;function fromNumber(n,t){if(isNaN(n))return t?UZERO:ZERO;if(t){if(n<0)return UZERO;if(n>=TWO_PWR_64_DBL)return MAX_UNSIGNED_VALUE}else{if(n<=-TWO_PWR_63_DBL)return MIN_VALUE;if(n+1>=TWO_PWR_63_DBL)return MAX_VALUE}return n<0?fromNumber(-n,t).neg():fromBits(n%TWO_PWR_32_DBL|0,n/TWO_PWR_32_DBL|0,t)}Long$1.fromNumber=fromNumber;function fromBits(n,t,r){return new Long$1(n,t,r)}Long$1.fromBits=fromBits;var pow_dbl=Math.pow;function fromString(n,t,r){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return ZERO;if(typeof t=="number"?(r=t,t=!1):t=!!t,r=r||10,r<2||36<r)throw RangeError("radix");var i;if((i=n.indexOf("-"))>0)throw Error("interior hyphen");if(i===0)return fromString(n.substring(1),t,r).neg();for(var s=fromNumber(pow_dbl(r,8)),o=ZERO,l=0;l<n.length;l+=8){var f=Math.min(8,n.length-l),u=parseInt(n.substring(l,l+f),r);if(f<8){var _=fromNumber(pow_dbl(r,f));o=o.mul(_).add(fromNumber(u))}else o=o.mul(s),o=o.add(fromNumber(u))}return o.unsigned=t,o}Long$1.fromString=fromString;function fromValue(n,t){return typeof n=="number"?fromNumber(n,t):typeof n=="string"?fromString(n,t):fromBits(n.low,n.high,typeof t=="boolean"?t:n.unsigned)}Long$1.fromValue=fromValue;var TWO_PWR_16_DBL=65536,TWO_PWR_24_DBL=1<<24,TWO_PWR_32_DBL=TWO_PWR_16_DBL*TWO_PWR_16_DBL,TWO_PWR_64_DBL=TWO_PWR_32_DBL*TWO_PWR_32_DBL,TWO_PWR_63_DBL=TWO_PWR_64_DBL/2,TWO_PWR_24=fromInt(TWO_PWR_24_DBL),ZERO=fromInt(0);Long$1.ZERO=ZERO;var UZERO=fromInt(0,!0);Long$1.UZERO=UZERO;var ONE=fromInt(1);Long$1.ONE=ONE;var UONE=fromInt(1,!0);Long$1.UONE=UONE;var NEG_ONE=fromInt(-1);Long$1.NEG_ONE=NEG_ONE;var MAX_VALUE=fromBits(-1,2147483647,!1);Long$1.MAX_VALUE=MAX_VALUE;var MAX_UNSIGNED_VALUE=fromBits(-1,-1,!0);Long$1.MAX_UNSIGNED_VALUE=MAX_UNSIGNED_VALUE;var MIN_VALUE=fromBits(0,-2147483648,!1);Long$1.MIN_VALUE=MIN_VALUE;var LongPrototype=Long$1.prototype;LongPrototype.toInt=function(){return this.unsigned?this.low>>>0:this.low};LongPrototype.toNumber=function(){return this.unsigned?(this.high>>>0)*TWO_PWR_32_DBL+(this.low>>>0):this.high*TWO_PWR_32_DBL+(this.low>>>0)};LongPrototype.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(MIN_VALUE)){var r=fromNumber(t),i=this.div(r),s=i.mul(r).sub(this);return i.toString(t)+s.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var o=fromNumber(pow_dbl(t,6),this.unsigned),l=this,f="";;){var u=l.div(o),_=l.sub(u.mul(o)).toInt()>>>0,g=_.toString(t);if(l=u,l.isZero())return g+f;for(;g.length<6;)g="0"+g;f=""+g+f}};LongPrototype.getHighBits=function(){return this.high};LongPrototype.getHighBitsUnsigned=function(){return this.high>>>0};LongPrototype.getLowBits=function(){return this.low};LongPrototype.getLowBitsUnsigned=function(){return this.low>>>0};LongPrototype.getNumBitsAbs=function(){if(this.isNegative())return this.eq(MIN_VALUE)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,r=31;r>0&&!(t&1<<r);r--);return this.high!=0?r+33:r+1};LongPrototype.isZero=function(){return this.high===0&&this.low===0};LongPrototype.eqz=LongPrototype.isZero;LongPrototype.isNegative=function(){return!this.unsigned&&this.high<0};LongPrototype.isPositive=function(){return this.unsigned||this.high>=0};LongPrototype.isOdd=function(){return(this.low&1)===1};LongPrototype.isEven=function(){return(this.low&1)===0};LongPrototype.equals=function(t){return isLong(t)||(t=fromValue(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};LongPrototype.eq=LongPrototype.equals;LongPrototype.notEquals=function(t){return!this.eq(t)};LongPrototype.neq=LongPrototype.notEquals;LongPrototype.ne=LongPrototype.notEquals;LongPrototype.lessThan=function(t){return this.comp(t)<0};LongPrototype.lt=LongPrototype.lessThan;LongPrototype.lessThanOrEqual=function(t){return this.comp(t)<=0};LongPrototype.lte=LongPrototype.lessThanOrEqual;LongPrototype.le=LongPrototype.lessThanOrEqual;LongPrototype.greaterThan=function(t){return this.comp(t)>0};LongPrototype.gt=LongPrototype.greaterThan;LongPrototype.greaterThanOrEqual=function(t){return this.comp(t)>=0};LongPrototype.gte=LongPrototype.greaterThanOrEqual;LongPrototype.ge=LongPrototype.greaterThanOrEqual;LongPrototype.compare=function(t){if(isLong(t)||(t=fromValue(t)),this.eq(t))return 0;var r=this.isNegative(),i=t.isNegative();return r&&!i?-1:!r&&i?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};LongPrototype.comp=LongPrototype.compare;LongPrototype.negate=function(){return!this.unsigned&&this.eq(MIN_VALUE)?MIN_VALUE:this.not().add(ONE)};LongPrototype.neg=LongPrototype.negate;LongPrototype.add=function(t){isLong(t)||(t=fromValue(t));var r=this.high>>>16,i=this.high&65535,s=this.low>>>16,o=this.low&65535,l=t.high>>>16,f=t.high&65535,u=t.low>>>16,_=t.low&65535,g=0,a=0,m=0,b=0;return b+=o+_,m+=b>>>16,b&=65535,m+=s+u,a+=m>>>16,m&=65535,a+=i+f,g+=a>>>16,a&=65535,g+=r+l,g&=65535,fromBits(m<<16|b,g<<16|a,this.unsigned)};LongPrototype.subtract=function(t){return isLong(t)||(t=fromValue(t)),this.add(t.neg())};LongPrototype.sub=LongPrototype.subtract;LongPrototype.multiply=function(t){if(this.isZero())return ZERO;if(isLong(t)||(t=fromValue(t)),wasm){var r=wasm.mul(this.low,this.high,t.low,t.high);return fromBits(r,wasm.get_high(),this.unsigned)}if(t.isZero())return ZERO;if(this.eq(MIN_VALUE))return t.isOdd()?MIN_VALUE:ZERO;if(t.eq(MIN_VALUE))return this.isOdd()?MIN_VALUE:ZERO;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(TWO_PWR_24)&&t.lt(TWO_PWR_24))return fromNumber(this.toNumber()*t.toNumber(),this.unsigned);var i=this.high>>>16,s=this.high&65535,o=this.low>>>16,l=this.low&65535,f=t.high>>>16,u=t.high&65535,_=t.low>>>16,g=t.low&65535,a=0,m=0,b=0,v=0;return v+=l*g,b+=v>>>16,v&=65535,b+=o*g,m+=b>>>16,b&=65535,b+=l*_,m+=b>>>16,b&=65535,m+=s*g,a+=m>>>16,m&=65535,m+=o*_,a+=m>>>16,m&=65535,m+=l*u,a+=m>>>16,m&=65535,a+=i*g+s*_+o*u+l*f,a&=65535,fromBits(b<<16|v,a<<16|m,this.unsigned)};LongPrototype.mul=LongPrototype.multiply;LongPrototype.divide=function(t){if(isLong(t)||(t=fromValue(t)),t.isZero())throw Error("division by zero");if(wasm){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var r=(this.unsigned?wasm.div_u:wasm.div_s)(this.low,this.high,t.low,t.high);return fromBits(r,wasm.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?UZERO:ZERO;var i,s,o;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return UZERO;if(t.gt(this.shru(1)))return UONE;o=UZERO}else{if(this.eq(MIN_VALUE)){if(t.eq(ONE)||t.eq(NEG_ONE))return MIN_VALUE;if(t.eq(MIN_VALUE))return ONE;var l=this.shr(1);return i=l.div(t).shl(1),i.eq(ZERO)?t.isNegative()?ONE:NEG_ONE:(s=this.sub(t.mul(i)),o=i.add(s.div(t)),o)}else if(t.eq(MIN_VALUE))return this.unsigned?UZERO:ZERO;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();o=ZERO}for(s=this;s.gte(t);){i=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var f=Math.ceil(Math.log(i)/Math.LN2),u=f<=48?1:pow_dbl(2,f-48),_=fromNumber(i),g=_.mul(t);g.isNegative()||g.gt(s);)i-=u,_=fromNumber(i,this.unsigned),g=_.mul(t);_.isZero()&&(_=ONE),o=o.add(_),s=s.sub(g)}return o};LongPrototype.div=LongPrototype.divide;LongPrototype.modulo=function(t){if(isLong(t)||(t=fromValue(t)),wasm){var r=(this.unsigned?wasm.rem_u:wasm.rem_s)(this.low,this.high,t.low,t.high);return fromBits(r,wasm.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};LongPrototype.mod=LongPrototype.modulo;LongPrototype.rem=LongPrototype.modulo;LongPrototype.not=function(){return fromBits(~this.low,~this.high,this.unsigned)};LongPrototype.and=function(t){return isLong(t)||(t=fromValue(t)),fromBits(this.low&t.low,this.high&t.high,this.unsigned)};LongPrototype.or=function(t){return isLong(t)||(t=fromValue(t)),fromBits(this.low|t.low,this.high|t.high,this.unsigned)};LongPrototype.xor=function(t){return isLong(t)||(t=fromValue(t)),fromBits(this.low^t.low,this.high^t.high,this.unsigned)};LongPrototype.shiftLeft=function(t){return isLong(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?fromBits(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):fromBits(0,this.low<<t-32,this.unsigned)};LongPrototype.shl=LongPrototype.shiftLeft;LongPrototype.shiftRight=function(t){return isLong(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?fromBits(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):fromBits(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};LongPrototype.shr=LongPrototype.shiftRight;LongPrototype.shiftRightUnsigned=function(t){if(isLong(t)&&(t=t.toInt()),t&=63,t===0)return this;var r=this.high;if(t<32){var i=this.low;return fromBits(i>>>t|r<<32-t,r>>>t,this.unsigned)}else return t===32?fromBits(r,0,this.unsigned):fromBits(r>>>t-32,0,this.unsigned)};LongPrototype.shru=LongPrototype.shiftRightUnsigned;LongPrototype.shr_u=LongPrototype.shiftRightUnsigned;LongPrototype.toSigned=function(){return this.unsigned?fromBits(this.low,this.high,!1):this};LongPrototype.toUnsigned=function(){return this.unsigned?this:fromBits(this.low,this.high,!0)};LongPrototype.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};LongPrototype.toBytesLE=function(){var t=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};LongPrototype.toBytesBE=function(){var t=this.high,r=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,r>>>24,r>>>16&255,r>>>8&255,r&255]};Long$1.fromBytes=function(t,r,i){return i?Long$1.fromBytesLE(t,r):Long$1.fromBytesBE(t,r)};Long$1.fromBytesLE=function(t,r){return new Long$1(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,r)};Long$1.fromBytesBE=function(t,r){return new Long$1(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],r)};const long$1=getDefaultExportFromCjs(long),LongExports=_mergeNamespaces({__proto__:null,default:long$1},[long]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Long=long$1||LongExports;function hexToLong(n){return Long.fromString(n,!0,16)}const k0=hexToLong("c3a5c85c97cb3127"),k1=hexToLong("b492b66fbe98f273"),k2=hexToLong("9ae16a3b2f90404f");function shiftMix(n){return n.xor(n.shru(47))}function fetch$2(n,t,r){const i=n.slice(t,t+r);return Long.fromBytes(Array.from(i),!0,!0)}function fetch64(n,t){return fetch$2(n,t,8)}function fetch32(n,t){return fetch$2(n,t,4)}function rotate64(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function hashLen16(n,t,r=hexToLong("9ddfea08eb382d69")){let i=n.xor(t).mul(r);i=i.xor(i.shru(47));let s=t.xor(i).mul(r);return s=s.xor(s.shru(47)),s=s.mul(r),s}function weakHashLen32WithSeeds(n,t,r,i,s,o){s=s.add(n),o=rotate64(o.add(s).add(i),21);const l=s;return s=s.add(t),s=s.add(r),o=o.add(rotate64(s,44)),[s.add(i),o.add(l)]}function weakHashLen32WithSeedsStr(n,t,r,i){return weakHashLen32WithSeeds(fetch64(n,t),fetch64(n,t+8),fetch64(n,t+16),fetch64(n,t+24),r,i)}function hashLen0to16(n,t=n.length){if(t>=8){const r=k2.add(t*2),i=fetch64(n,0).add(k2),s=fetch64(n,t-8),o=rotate64(s,37).mul(r).add(i),l=rotate64(i,25).add(s).mul(r);return hashLen16(o,l,r)}if(t>=4){const r=k2.add(t*2),i=fetch32(n,0);return hashLen16(i.shl(3).add(t),fetch32(n,t-4),r)}if(t>0){const r=n[0],i=n[t>>1],s=n[t-1],o=r+(i<<8),l=t+(s<<2);return shiftMix(k2.mul(o).xor(k0.mul(l))).mul(k2)}return k2}function hashLen17to32(n,t=n.length){const r=k2.add(t*2),i=fetch64(n,0).mul(k1),s=fetch64(n,8),o=fetch64(n,t-8).mul(r),l=fetch64(n,t-16).mul(k2);return hashLen16(rotate64(i.add(s),43).add(rotate64(o,30)).add(l),i.add(rotate64(s.add(k2),18)).add(o),r)}function hashLen33to64(n,t=n.length){const r=k2.add(t*2),i=fetch64(n,0).mul(k2),s=fetch64(n,8),o=fetch64(n,t-8).mul(r),l=fetch64(n,t-16).mul(k2),f=rotate64(i.add(s),43).add(rotate64(o,30)).add(l),u=hashLen16(f,i.add(rotate64(s.add(k2),18)).add(o),r),_=fetch64(n,16).mul(r),g=fetch64(n,24),a=f.add(fetch64(n,t-32)).mul(r),m=u.add(fetch64(n,t-24)).mul(r);return hashLen16(rotate64(_.add(g),43).add(rotate64(a,30)).add(m),_.add(rotate64(g.add(i),18)).add(a),r)}function fingerPrint64(n,t=n.length){const r=Long.fromNumber(81,!0);if(t<=32)return t<=16?hashLen0to16(n,t):hashLen17to32(n,t);if(t<=64)return hashLen33to64(n,t);let i=r,s=r.mul(k1).add(113),o=shiftMix(s.mul(k2).add(113)).mul(k2),l=[Long.UZERO,Long.UZERO],f=[Long.UZERO,Long.UZERO];i=i.mul(k2).add(fetch64(n,0));let u=0;const _=(t-1>>6)*64,g=_+(t-1&63)-63;do i=rotate64(i.add(s).add(l[0]).add(fetch64(n,u+8)),37).mul(k1),s=rotate64(s.add(l[1]).add(fetch64(n,u+48)),42).mul(k1),i=i.xor(f[1]),s=s.add(l[0]).add(fetch64(n,u+40)),o=rotate64(o.add(f[0]),33).mul(k1),l=weakHashLen32WithSeedsStr(n,u,l[1].mul(k1),i.add(f[0])),f=weakHashLen32WithSeedsStr(n,u+32,o.add(f[1]),s.add(fetch64(n,u+16))),[o,i]=[i,o],u+=64;while(u!==_);const a=k1.add(o.and(255).shl(1));return u=g,f[0]=f[0].add(t-1&63),l[0]=l[0].add(f[0]),f[0]=f[0].add(l[0]),i=rotate64(i.add(s).add(l[0]).add(fetch64(n,u+8)),37).mul(a),s=rotate64(s.add(l[1]).add(fetch64(n,u+48)),42).mul(a),i=i.xor(f[1].mul(9)),s=s.add(l[0].mul(9).add(fetch64(n,u+40))),o=rotate64(o.add(f[0]),33).mul(a),l=weakHashLen32WithSeedsStr(n,u,l[1].mul(a),i.add(f[0])),f=weakHashLen32WithSeedsStr(n,u+32,o.add(f[1]),s.add(fetch64(n,u+16))),[o,i]=[i,o],hashLen16(hashLen16(l[0],f[0],a).add(shiftMix(s).mul(k0)).add(o),hashLen16(l[1],f[1],a).add(i),a)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createScalarValue(n,t){return t==="string"?encodeString(n):toTypedArray([n],t)}function noConversionNeeded(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function toTypedArray(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=flatten(n)),env().getBool("DEBUG")&&checkConversionForErrors(n,t),noConversionNeeded(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const r=new Uint8Array(n.length);for(let i=0;i<r.length;++i)Math.round(n[i])!==0&&(r[i]=1);return r}else throw new Error(`Unknown data type ${t}`)}function now(){return env().platform.now()}function encodeString(n,t="utf-8"){return t=t||"utf-8",env().platform.encode(n,t)}function decodeString(n,t="utf-8"){return t=t||"utf-8",env().platform.decode(n,t)}function isTypedArray(n){return env().platform.isTypedArray!=null?env().platform.isTypedArray(n):isTypedArrayBrowser(n)}function flatten(n,t=[],r=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||isPromise(n)||n==null||isTypedArray(n)&&r)t.push(n);else if(Array.isArray(n)||isTypedArray(n))for(let i=0;i<n.length;++i)flatten(n[i],t,r);else{let i=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(i=Math.max(i,Number(s)));for(let s=0;s<=i;s++)flatten(n[s],t,r)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Profiler{constructor(t,r){this.backendTimer=t,this.logger=r,r==null&&(this.logger=new Logger)}profileKernel(t,r,i){let s;const o=()=>{s=i()};let l;const f=now();if(this.backendTimer.timerAvailable())l=this.backendTimer.time(o);else{o();for(const _ of s)_.dataSync();l=Promise.resolve({kernelMs:now()-f})}if(env().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let _=0;_<s.length;_++){const g=s[_];g.data().then(a=>{checkComputationForErrors(a,g.dtype,t)})}return{kernelName:t,outputs:s,inputs:r,timeMs:l.then(_=>_.kernelMs),extraInfo:l.then(_=>_.getExtraProfileInfo!=null?_.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:r,outputs:i,timeMs:s,inputs:o,extraInfo:l}=t;i.forEach(f=>{Promise.all([f.data(),s,l]).then(u=>{this.logger.logKernelProfile(r,f,u[0],u[1],o,u[2])})})}}function checkComputationForErrors(n,t,r){if(t!=="float32")return!1;for(let i=0;i<n.length;i++){const s=n[i];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${r}'`),!0}return!1}class Logger{logKernelProfile(t,r,i,s,o,l){const f=typeof s=="number"?rightPad(`${s}ms`,9):s.error,u=rightPad(t,25),_=r.rank,g=r.size,a=rightPad(r.shape.toString(),14);let m="";for(const b in o){const v=o[b];if(v!=null){const c=v.shape||r.shape,w=c.length;m+=`${b}: ${w}D ${w>0?c:""} `}}console.log(`%c${u}	%c${f}	%c${_}D ${a}	%c${g}	%c${m}	%c${l}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getFilteredNodesXToY(n,t,r){const i={},s={};for(let u=0;u<t.length;u++)i[t[u].id]=!0;for(let u=0;u<n.length;u++){const _=n[u],g=_.inputs;for(const a in g){const m=g[a];let b=!1;for(let v=0;v<t.length;v++)if(i[m.id]){_.outputs.forEach(c=>i[c.id]=!0),b=!0,s[_.id]=!0;break}if(b)break}}const o={};o[r.id]=!0;const l={};for(let u=n.length-1;u>=0;u--){const _=n[u],g=_.inputs;for(let a=0;a<_.outputs.length;a++)if(o[_.outputs[a].id]){for(const m in g)o[g[m].id]=!0,l[_.id]=!0;break}}const f=[];for(let u=0;u<n.length;u++){const _=n[u];if(s[_.id]&&l[_.id]){const g={};for(const m in _.inputs){const b=_.inputs[m];i[b.id]&&(g[m]=b)}const a=Object.assign({},_);a.inputs=g,a.outputs=_.outputs,f.push(a)}}return f}function backpropagateGradients(n,t,r,i){for(let s=t.length-1;s>=0;s--){const o=t[s],l=[];if(o.outputs.forEach(u=>{const _=n[u.id];_!=null?l.push(_):l.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const f=o.gradient(l);for(const u in o.inputs){if(!(u in f))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(f)}.`);const _=r(()=>f[u]());if(_.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${_.dtype}'`);const g=o.inputs[u];if(!arraysEqual(_.shape,g.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${_.shape}', which does not match the shape of the input '${g.shape}'`);if(n[g.id]==null)n[g.id]=_;else{const a=n[g.id];n[g.id]=i(a,_),a.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7;function tensorToString(n,t,r,i){const s=computeStrides(t),o=computeMaxSizePerColumn(n,t,r,s),l=t.length,f=subTensorToString(n,t,r,s,o),u=["Tensor"];return i&&(u.push(`  dtype: ${r}`),u.push(`  rank: ${l}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(f.map(_=>"    "+_).join(`
`)),u.join(`
`)}function computeMaxSizePerColumn(n,t,r,i){const s=sizeFromShape(t),o=i[i.length-1],l=new Array(o).fill(0),f=t.length,u=r==="complex64"?createComplexTuples(n):n;if(f>1)for(let _=0;_<s/o;_++){const g=_*o;for(let a=0;a<o;a++)l[a]=Math.max(l[a],valToString(u[g+a],0,r).length)}return l}function valToString(n,t,r){let i;return Array.isArray(n)?i=`${parseFloat(n[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(n[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`:isString(n)?i=`'${n}'`:r==="bool"?i=boolNumToString(n):i=parseFloat(n.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(),rightPad(i,t)}function boolNumToString(n){return n===0?"false":"true"}function subTensorToString(n,t,r,i,s,o=!0){const l=r==="complex64"?2:1,f=t[0],u=t.length;if(u===0){if(r==="complex64"){const c=createComplexTuples(n);return[valToString(c[0],0,r)]}return r==="bool"?[boolNumToString(n[0])]:[n[0].toString()]}if(u===1){if(f>FORMAT_LIMIT_NUM_VALS){const w=FORMAT_NUM_FIRST_LAST_VALS*l;let k=Array.from(n.slice(0,w)),x=Array.from(n.slice((f-FORMAT_NUM_FIRST_LAST_VALS)*l,f*l));return r==="complex64"&&(k=createComplexTuples(k),x=createComplexTuples(x)),["["+k.map((E,O)=>valToString(E,s[O],r)).join(", ")+", ..., "+x.map((E,O)=>valToString(E,s[f-FORMAT_NUM_FIRST_LAST_VALS+O],r)).join(", ")+"]"]}return["["+(r==="complex64"?createComplexTuples(n):Array.from(n)).map((w,k)=>valToString(w,s[k],r)).join(", ")+"]"]}const _=t.slice(1),g=i.slice(1),a=i[0]*l,m=[];if(f>FORMAT_LIMIT_NUM_VALS){for(let c=0;c<FORMAT_NUM_FIRST_LAST_VALS;c++){const w=c*a,k=w+a;m.push(...subTensorToString(n.slice(w,k),_,r,g,s,!1))}m.push("...");for(let c=f-FORMAT_NUM_FIRST_LAST_VALS;c<f;c++){const w=c*a,k=w+a;m.push(...subTensorToString(n.slice(w,k),_,r,g,s,c===f-1))}}else for(let c=0;c<f;c++){const w=c*a,k=w+a;m.push(...subTensorToString(n.slice(w,k),_,r,g,s,c===f-1))}const b=u===2?",":"";m[0]="["+(f>0?m[0]+b:"");for(let c=1;c<m.length-1;c++)m[c]=" "+m[c]+b;let v=`,
`;for(let c=2;c<u;c++)v+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(o?"":v),m}function createComplexTuples(n){const t=[];for(let r=0;r<n.length;r+=2)t.push([n[r],n[r+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TensorBuffer{constructor(t,r,i){if(this.dtype=r,this.shape=t.slice(),this.size=sizeFromShape(t),i!=null){const s=i.length;assert(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(r==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=i||getArrayFromDType(r,this.size),this.strides=computeStrides(t)}set(t,...r){r.length===0&&(r=[0]),assert(r.length===this.rank,()=>`The number of provided coordinates (${r.length}) must match the rank (${this.rank})`);const i=this.locToIndex(r);this.values[i]=t}get(...t){t.length===0&&(t=[0]);let r=0;for(const s of t){if(s<0||s>=this.shape[r]){const o=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(o)}r++}let i=t[t.length-1];for(let s=0;s<t.length-1;++s)i+=this.strides[s]*t[s];return this.values[i]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=this.strides[i]*t[i];return r}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const r=new Array(this.shape.length);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(t/this.strides[i]),t-=r[i]*this.strides[i];return r[r.length-1]=t,r}get rank(){return this.shape.length}toTensor(){return trackerFn().makeTensor(this.values,this.shape,this.dtype)}}let trackerFn=null,opHandler$1=null;function setTensorTracker(n){trackerFn=n}function setOpHandler(n){opHandler$1=n}class Tensor{constructor(t,r,i,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=r||"float32",this.size=sizeFromShape(t),this.strides=computeStrides(t),this.dataId=i,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return opHandler$1.buffer(this.shape,this.dtype,t)}bufferSync(){return opHandler$1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return toNestedArray(this.shape,t,this.dtype==="complex64")}arraySync(){return toNestedArray(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=trackerFn().read(this.dataId);if(this.dtype==="string"){const r=await t;try{return r.map(i=>decodeString(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),trackerFn().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=trackerFn().readSync(this.dataId);if(this.dtype==="string")try{return t.map(r=>decodeString(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await trackerFn().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),trackerFn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return opHandler$1.print(this,t)}clone(){return this.throwIfDisposed(),opHandler$1.clone(this)}toString(t=!1){const r=this.dataSync();return tensorToString(r,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),opHandler$1.cast(this,t)}variable(t=!0,r,i){return this.throwIfDisposed(),trackerFn().makeVariable(this,t,r,i)}}Object.defineProperty(Tensor,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function getGlobalTensorClass(){return getGlobal("Tensor",()=>Tensor)}getGlobalTensorClass();class Variable extends Tensor{constructor(t,r,i,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=r,this.name=i}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!arraysEqual(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);trackerFn().disposeTensor(this),this.dataId=t.dataId,trackerFn().incRef(this,null)}dispose(){trackerFn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Variable,Symbol.hasInstance,{value:n=>n instanceof Tensor&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Rank;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Rank||(Rank={}));var UpcastInt32AndMap;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(UpcastInt32AndMap||(UpcastInt32AndMap={}));var UpcastBoolAndMap;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(UpcastBoolAndMap||(UpcastBoolAndMap={}));var UpcastFloat32AndMap;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(UpcastFloat32AndMap||(UpcastFloat32AndMap={}));var UpcastComplex64AndMap;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));const upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return upcastTypeMap[n][t]}function isWebGLData(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function isWebGPUData(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTypesMatch(n,t){if(n.dtype===t.dtype)return[n,t];const r=upcastType(n.dtype,t.dtype);return[n.cast(r),t.cast(r)]}function getTensorsInContainer(n){const t=[];return walkTensorContainer(n,t,new Set),t}function walkTensorContainer(n,t,r){if(n==null)return;if(n instanceof Tensor){t.push(n);return}if(!isIterable(n))return;const i=n;for(const s in i){const o=i[s];r.has(o)||(r.add(o),walkTensorContainer(o,t,r))}}function isIterable(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isRegisteredKernelInvocation(n){return n.kernelName!=null}class EngineState{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Engine{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new EngineState}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let r=0;r<t.length;r++){const i=t[r];if(await this.initializeBackend(i).success){await this.setBackend(i);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:r}=this.initializeBackend(t);if(r)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,r,i=1){return t in this.registryFactory?(warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:r,priority:i},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:r,asyncInit:i}=this.initializeBackend(t);if(!(i?await r:r))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Profiler(this.backendInstance),!0}setupRegisteredKernels(){getKernelsForBackend(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){getKernelsForBackend(t).forEach(i=>{i.disposeFunc!=null&&i.disposeFunc(this.registry[t])})}initializeBackend(t){const r=this.registryFactory[t];if(r==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const i=r.factory();if(i&&!(i instanceof KernelBackend)&&typeof i.then=="function"){const s=++this.pendingBackendInitId,o=i.then(l=>s<this.pendingBackendInitId?!1:(this.registry[t]=l,this.pendingBackendInit=null,!0)).catch(l=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,warn(`Initialization of backend ${t} failed`),warn(l.stack||l.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[t]=i,{success:!0,asyncInit:!1}}catch(i){return warn(`Initialization of backend ${t} failed`),warn(i.stack||i.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,r)=>this.registryFactory[r].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let r=0;r<t.length;r++){const i=t[r],{success:s,asyncInit:o}=this.initializeBackend(i);if(o||s)return{name:i,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,r){const i=this.state.tensorInfo.get(r),s=i.backend,o=this.readSync(r),l=s.refCount(r);s.disposeData(r,!0),i.backend=t,t.move(r,o,i.shape,i.dtype,l),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,r){let i=null;if(r==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");r=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");i=t}let s;return this.scopedRun(()=>this.startScope(i),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,r,i){t();try{const s=i();return r(),s}catch(s){throw r(),s}}nextTensorId(){return Engine.nextTensorId++}nextVariableId(){return Engine.nextVariableId++}clone(t){const r=ENGINE.runKernel(Identity,{x:t}),i={x:t},s=l=>({x:()=>{const f="float32",u={x:l},_={dtype:f};return ENGINE.runKernel(Cast,u,_)}}),o=[];return this.addTapeNode(this.state.activeScope.name,i,[r],s,o,{}),r}runKernel(t,r,i){if(this.backendName==null&&this.backend,!(getKernel(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:r,attrs:i})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,r,i){const s=this.backend.numDataIds();let o=0;i.forEach(u=>{o+=u.dtype==="complex64"?3:1});const l=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],f=s-r-o-l;if(f>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${f} data ids) after running '${t}'`)}runKernelFunc(t){let r,i=[];const s=this.isTapeOn(),o=this.state.numBytes,l=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let f;this.backendName==null&&this.backend;let u;const _=isRegisteredKernelInvocation(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(isRegisteredKernelInvocation(t)){const{kernelName:v,inputs:c,attrs:w}=t;this.backendName==null&&this.backend;const k=getKernel(v,this.backendName);assert(k!=null,()=>`Cannot find registered kernel '${v}' for backend '${this.backendName}'`),f=()=>{const x=this.backend.numDataIds();u=k.kernelFunc({inputs:c,attrs:w,backend:this.backend});const E=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(v,x,E);const O=E.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(s){const A=this.getTensorsForGradient(v,c,O);i=this.saveTensorsForBackwardMode(A)}return O}}else{const{forwardFunc:v}=t,c=w=>{s&&(i=w.map(k=>this.keep(this.clone(k))))};f=()=>{const w=this.backend.numDataIds();u=this.tidy(()=>v(this.backend,c));const k=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(_,w,k),k}}const{inputs:g,attrs:a}=t,m=isRegisteredKernelInvocation(t)?null:t.backwardsFunc;let b;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=f():(b=this.profiler.profileKernel(_,g,()=>f()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(b),r=b.outputs)}),s&&this.addTapeNode(_,g,r,m,i,a),this.state.profiling&&this.state.activeProfile.kernels.push({name:_,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-l,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(g).map(v=>g[v]!=null?g[v].shape:null),outputShapes:r.map(v=>v.shape),kernelTimeMs:b.timeMs,extraInfo:b.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(t){return t.map(i=>this.keep(this.clone(i)))}getTensorsForGradient(t,r,i){const s=getGradient(t);if(s!=null){const o=s.inputsToSave||[],l=s.outputsToSave||[];let f;s.saveAllInputs?(assert(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),f=Object.keys(r).map(_=>r[_])):f=o.map(_=>r[_]);const u=i.filter((_,g)=>l[g]);return f.concat(u)}return[]}makeTensor(t,r,i,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");i=i||"float32",s=s||this.backend;let o=t;i==="string"&&isString(t[0])&&(o=t.map(u=>encodeString(u)));const l=s.write(o,r,i),f=new Tensor(r,i,l,this.nextTensorId());if(this.trackTensor(f,s),i==="string"){const u=this.state.tensorInfo.get(l),_=bytesFromStringArray(o);this.state.numBytes+=_-u.bytes,u.bytes=_}return f}makeTensorFromDataId(t,r,i,s){i=i||"float32";const o={dataId:t,shape:r,dtype:i};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(t,r){const{dataId:i,shape:s,dtype:o}=t,l=new Tensor(s,o,i,this.nextTensorId());return this.trackTensor(l,r),l}makeVariable(t,r=!0,i,s){i=i||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));const o=new Variable(t,r,i,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(t,r){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let i=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(i=t.size*bytesPerElement(t.dtype)),this.state.numBytes+=i,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:r||this.backend,dtype:t.dtype,shape:t.shape,bytes:i})),t instanceof Variable||this.track(t)}incRef(t,r){this.trackTensor(t,r),this.backend.incRef(t.dataId)}removeDataId(t,r){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===r&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const r=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const i=t.size*bytesPerElement(t.dtype);this.state.numBytes-=i}r.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,r.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const r=this.state.registeredVariables[t];this.disposeVariable(r)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const r=this.state.numBytes,i=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-i;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,r,i,s,o,l){const f={id:this.state.nextTapeNodeId++,kernelName:t,inputs:r,outputs:i,saved:o},u=getGradient(t);u!=null&&(s=u.gradFunc),s!=null&&(f.gradient=_=>(_=_.map((g,a)=>{if(g==null){const m=i[a],b=makeZerosTypedArray(m.size,m.dtype);return this.makeTensor(b,m.shape,m.dtype)}return g}),s(_.length>1?_:_[0],o,l))),this.state.activeTape.push(f)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(r.name=t),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(t){const r=getTensorsInContainer(t),i=new Set(r.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const l=this.state.activeScope.track[o];!l.kept&&!i.has(l.id)&&l.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(t,r,i,s=!1){if(assert(r.length>0,()=>"gradients() received an empty list of xs."),i!=null&&i.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${i.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));assert(o instanceof Tensor,()=>"The result y returned by f() must be a tensor.");const l=getFilteredNodesXToY(this.state.activeTape,r,o);if(!s&&l.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const f={};f[o.id]=i??ones(o.shape),backpropagateGradients(f,l,_=>this.tidy(_),add$2);const u=r.map(_=>f[_.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(_=>{for(const g of _.saved)g.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(t){return assert(isFunction(t),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{assert(r.every(f=>f instanceof Tensor),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let i;const s={};r.forEach((f,u)=>{s[u]=f});const o=(f,u)=>(i=t(...r,u),assert(i.value instanceof Tensor,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),assert(isFunction(i.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),i.value),l=(f,u)=>{const _=i.gradFunc(f,u),g=Array.isArray(_)?_:[_];assert(g.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),assert(g.every(m=>m instanceof Tensor),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const a={};return g.forEach((m,b)=>{a[b]=()=>m}),a};return this.runKernelFunc({forwardFunc:o,backwardsFunc:l,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,r){return this.state.tensorInfo.get(t).backend.readToGPU(t,r)}async time(t){const r=now(),i=await this.backend.time(t);return i.wallMs=now()-r,i}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new EngineState;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Engine.nextTensorId=0;Engine.nextVariableId=0;function ones(n){const t=makeOnesTypedArray(sizeFromShape(n),"float32");return ENGINE.makeTensor(t,n,"float32")}function getOrMakeEngine(){const n=getGlobalNamespace();if(n._tfengine==null){const t=new Environment(n);n._tfengine=new Engine(t)}return setEnvironmentGlobal(n._tfengine.ENV),setTensorTracker(()=>n._tfengine),n._tfengine}const ENGINE=getOrMakeEngine();function add$2(n,t){const r={a:n,b:t};return ENGINE.runKernel(Add,r)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isBrowser(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ENV=env();ENV.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ENV.registerFlag("IS_BROWSER",()=>isBrowser());ENV.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ENV.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ENV.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ENV.registerFlag("PROD",()=>!1);ENV.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ENV.getBool("DEBUG"));ENV.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ENV.registerFlag("IS_TEST",()=>!1);ENV.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ENV.getBool("DEBUG"));ENV.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ENV.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ENV.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function inferShape(n,t){let r=n;if(isTypedArray(n))return t==="string"?[]:[n.length];if(isWebGLData(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(isWebGPUData(n))return[n.buffer.size/(t==null?4:bytesPerElement(t))];if(!Array.isArray(n))return[];const i=[];for(;Array.isArray(r)||isTypedArray(r)&&t!=="string";)i.push(r.length),r=r[0];return Array.isArray(n)&&env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(n,i,[]),i}function deepAssertShapeConsistency(n,t,r){if(r=r||[],!Array.isArray(n)&&!isTypedArray(n)){assert(t.length===0,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}assert(t.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${n.length} elements`),assert(n.length===t[0],()=>`Element arr[${r.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const i=t.slice(1);for(let s=0;s<n.length;++s)deepAssertShapeConsistency(n[s],i,r.concat(s))}function assertDtype(n,t,r,i){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${r}' passed to '${i}' must be ${n} tensor, but got ${t} tensor`)}}function convertToTensor(n,t,r,i="numeric"){if(n instanceof getGlobalTensorClass())return assertDtype(i,n.dtype,t,r),n;let s=inferDtype(n);if(s!=="string"&&["bool","int32","float32"].indexOf(i)>=0&&(s=i),assertDtype(i,s,t,r),n==null||!isTypedArray(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${r}' must be a Tensor or TensorLike, but got '${u}'`)}const o=inferShape(n,s);!isTypedArray(n)&&!Array.isArray(n)&&(n=[n]);const f=s!=="string"?toTypedArray(n,s):flatten(n,[],!0);return ENGINE.makeTensor(f,o,s)}function convertToTensorArray(n,t,r,i="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,l)=>convertToTensor(o,`${t}[${l}]`,r,i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OP_SCOPE_SUFFIX="__op";function op(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let r=t[0];const i=n[r];r.endsWith("_")&&(r=r.substring(0,r.length-1)),r=r+OP_SCOPE_SUFFIX;const s=(...o)=>{ENGINE.startScope(r);try{const l=i(...o);return isPromise(l)&&console.error("Cannot return a Promise inside of tidy."),ENGINE.endScope(l),l}catch(l){throw ENGINE.endScope(null),l}};return Object.defineProperty(s,"name",{value:r,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex_(n,t){const r=convertToTensor(n,"real","complex"),i=convertToTensor(t,"imag","complex");assertShapesMatch(r.shape,i.shape,`real and imag shapes, ${r.shape} and ${i.shape}, must match in call to tf.complex().`);const s={real:r,imag:i};return ENGINE.runKernel(Complex,s)}const complex$1=op({complex_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTensor(n,t,r,i){if(i==null)i=inferDtype(n);else if(i==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(isWebGPUData(n)||isWebGLData(n)){if(i!=="float32"&&i!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${i}.`);return ENGINE.backend.createTensorFromGPUData(n,t||r,i)}if(!isTypedArray(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){assertNonNegativeIntegerDimensions(t);const s=sizeFromShape(t),o=sizeFromShape(r);assert(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let l=0;l<r.length;++l){const f=r[l],u=l===r.length-1?f!==sizeFromShape(t.slice(l)):!0;assert(r[l]===t[l]||!u,()=>`Error creating a new Tensor. Inferred shape (${r}) does not match the provided shape (${t}). `)}}return!isTypedArray(n)&&!Array.isArray(n)&&(n=[n]),t=t||r,n=i!=="string"?toTypedArray(n,i):flatten(n,[],!0),ENGINE.makeTensor(n,t,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor(n,t,r){const i=inferShape(n,r);return makeTensor(n,t,i,r)}class CompositeArrayBuffer{static join(t){return new CompositeArrayBuffer(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(i=>isTypedArray(i)?i.buffer:i),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let r=0;for(let i=0;i<t.length;i++){const s=t[i];i!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=r+s.byteLength;this.shards.push({buffer:s,start:r,end:o}),r=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,r=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,r=isNaN(Number(r))?0:r,t=Math.max(0,t),r=Math.min(this.byteLength,r),r<=t)return new ArrayBuffer(0);const i=this.findShardForByte(t);if(i===-1)throw new Error(`Could not find start shard for byte ${t}`);const s=r-t,o=new ArrayBuffer(s),l=new Uint8Array(o);let f=0;for(let u=i;u<this.shards.length;u++){const _=this.shards[u],a=t+f-_.start,m=f,v=Math.min(r,_.end)-_.start,c=new Uint8Array(_.buffer,a,v-a);if(l.set(c,m),f+=c.length,r<_.end)break}return o}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function r(s){return t<s.start?-1:t>=s.end?1:0}if(r(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const i=search(this.shards,r);return i===-1?-1:(this.previousShardIndex=i,this.previousShardIndex)}}function search(n,t){let r=0,i=n.length;for(;r<=i;){const s=Math.floor((i-r)/2)+r,o=t(n[s]);if(o===0)return s;o<0?i=s:r=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const useNodeBuffer=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function stringByteLength(n){return useNodeBuffer?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function arrayBufferToBase64String(n){if(useNodeBuffer)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let r="";for(let i=0,s=t.length;i<s;i++)r+=String.fromCharCode(t[i]);return btoa(r)}function base64StringToArrayBuffer(n){if(useNodeBuffer){const i=Buffer.from(n,"base64");return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}const t=atob(n),r=new Uint8Array(t.length);for(let i=0;i<t.length;++i)r.set([t.charCodeAt(i)],i);return r.buffer}function getModelArtifactsInfoForJSON(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:stringByteLength(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:stringByteLength(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new CompositeArrayBuffer(n.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IORouterRegistry{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return IORouterRegistry.instance==null&&(IORouterRegistry.instance=new IORouterRegistry),IORouterRegistry.instance}static registerSaveRouter(t){IORouterRegistry.getInstance().saveRouters.push(t)}static registerLoadRouter(t){IORouterRegistry.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return IORouterRegistry.getHandlers(t,"save")}static getLoadHandlers(t,r){return IORouterRegistry.getHandlers(t,"load",r)}static getHandlers(t,r,i){const s=[];return(r==="load"?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters).forEach(l=>{const f=l(t,i);f!==null&&s.push(f)}),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DATABASE_NAME="tensorflowjs",DATABASE_VERSION=1,MODEL_STORE_NAME="models_store",INFO_STORE_NAME="model_info_store";function getIndexedDBFactory(){if(!env().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function setUpDatabase(n){const t=n.result;t.createObjectStore(MODEL_STORE_NAME,{keyPath:"modelPath"}),t.createObjectStore(INFO_STORE_NAME,{keyPath:"modelPath"})}class BrowserIndexedDB{constructor(t){if(this.indexedDB=getIndexedDBFactory(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,r){return new Promise((i,s)=>{const o=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);o.onupgradeneeded=()=>setUpDatabase(o),o.onsuccess=()=>{const l=o.result;if(r==null){const f=l.transaction(MODEL_STORE_NAME,"readonly"),_=f.objectStore(MODEL_STORE_NAME).get(this.modelPath);_.onsuccess=()=>{if(_.result==null)return l.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));i(_.result.modelArtifacts)},_.onerror=g=>(l.close(),s(_.error)),f.oncomplete=()=>l.close()}else{r.weightData=CompositeArrayBuffer.join(r.weightData);const f=getModelArtifactsInfoForJSON(r),u=l.transaction(INFO_STORE_NAME,"readwrite");let _=u.objectStore(INFO_STORE_NAME),g;try{g=_.put({modelPath:this.modelPath,modelArtifactsInfo:f})}catch(m){return s(m)}let a;g.onsuccess=()=>{a=l.transaction(MODEL_STORE_NAME,"readwrite");const m=a.objectStore(MODEL_STORE_NAME);let b;try{b=m.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:f})}catch(v){return s(v)}b.onsuccess=()=>i({modelArtifactsInfo:f}),b.onerror=v=>{_=u.objectStore(INFO_STORE_NAME);const c=_.delete(this.modelPath);c.onsuccess=()=>(l.close(),s(b.error)),c.onerror=w=>(l.close(),s(b.error))}},g.onerror=m=>(l.close(),s(g.error)),u.oncomplete=()=>{a==null?l.close():a.oncomplete=()=>l.close()}}},o.onerror=l=>s(o.error)})}}BrowserIndexedDB.URL_SCHEME="indexeddb://";const indexedDBRouter=n=>env().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(n.slice(BrowserIndexedDB.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(indexedDBRouter);IORouterRegistry.registerLoadRouter(indexedDBRouter);function browserIndexedDB(n){return new BrowserIndexedDB(n)}function maybeStripScheme$1(n){return n.startsWith(BrowserIndexedDB.URL_SCHEME)?n.slice(BrowserIndexedDB.URL_SCHEME.length):n}class BrowserIndexedDBManager{constructor(){this.indexedDB=getIndexedDBFactory()}async listModels(){return new Promise((t,r)=>{const i=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);i.onupgradeneeded=()=>setUpDatabase(i),i.onsuccess=()=>{const s=i.result,o=s.transaction(INFO_STORE_NAME,"readonly"),f=o.objectStore(INFO_STORE_NAME).getAll();f.onsuccess=()=>{const u={};for(const _ of f.result)u[_.modelPath]=_.modelArtifactsInfo;t(u)},f.onerror=u=>(s.close(),r(f.error)),o.oncomplete=()=>s.close()},i.onerror=s=>r(i.error)})}async removeModel(t){return t=maybeStripScheme$1(t),new Promise((r,i)=>{const s=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);s.onupgradeneeded=()=>setUpDatabase(s),s.onsuccess=()=>{const o=s.result,l=o.transaction(INFO_STORE_NAME,"readwrite"),f=l.objectStore(INFO_STORE_NAME),u=f.get(t);let _;u.onsuccess=()=>{if(u.result==null)return o.close(),i(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const g=f.delete(t),a=()=>{_=o.transaction(MODEL_STORE_NAME,"readwrite");const b=_.objectStore(MODEL_STORE_NAME).delete(t);b.onsuccess=()=>r(u.result.modelArtifactsInfo),b.onerror=v=>i(u.error)};g.onsuccess=a,g.onerror=m=>(a(),o.close(),i(u.error))}},u.onerror=g=>(o.close(),i(u.error)),l.oncomplete=()=>{_==null?o.close():_.oncomplete=()=>o.close()}},s.onerror=o=>i(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PATH_SEPARATOR="/",PATH_PREFIX="tensorflowjs_models",INFO_SUFFIX="info",MODEL_TOPOLOGY_SUFFIX="model_topology",WEIGHT_SPECS_SUFFIX="weight_specs",WEIGHT_DATA_SUFFIX="weight_data",MODEL_METADATA_SUFFIX="model_metadata";function getModelKeys(n){return{info:[PATH_PREFIX,n,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,n,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,n,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,n,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),modelMetadata:[PATH_PREFIX,n,MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)}}function removeItems(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function getModelPathFromKey(n){const t=n.split(PATH_SEPARATOR);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(PATH_SEPARATOR)}function maybeStripScheme(n){return n.startsWith(BrowserLocalStorage.URL_SCHEME)?n.slice(BrowserLocalStorage.URL_SCHEME.length):n}class BrowserLocalStorage{constructor(t){if(!env().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=getModelKeys(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(t.modelTopology),i=JSON.stringify(t.weightSpecs),s=getModelArtifactsInfoForJSON(t),o=CompositeArrayBuffer.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,i),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(o));const l={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(l)),{modelArtifactsInfo:s}}catch{throw removeItems(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const r={},i=JSON.parse(this.LS.getItem(this.keys.topology));if(i==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=i;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const f=JSON.parse(o);r.format=f.format,r.generatedBy=f.generatedBy,r.convertedBy=f.convertedBy,f.signature!=null&&(r.signature=f.signature),f.userDefinedMetadata!=null&&(r.userDefinedMetadata=f.userDefinedMetadata),f.modelInitializer!=null&&(r.modelInitializer=f.modelInitializer),f.initializerSignature!=null&&(r.initializerSignature=f.initializerSignature),f.trainingConfig!=null&&(r.trainingConfig=f.trainingConfig)}const l=this.LS.getItem(this.keys.weightData);if(l==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=base64StringToArrayBuffer(l),r}}BrowserLocalStorage.URL_SCHEME="localstorage://";const localStorageRouter=n=>env().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(n.slice(BrowserLocalStorage.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(localStorageRouter);IORouterRegistry.registerLoadRouter(localStorageRouter);function browserLocalStorage(n){return new BrowserLocalStorage(n)}class BrowserLocalStorageManager{constructor(){assert(env().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),assert(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},r=PATH_PREFIX+PATH_SEPARATOR,i=PATH_SEPARATOR+INFO_SUFFIX;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(r)&&o.endsWith(i)){const l=getModelPathFromKey(o);t[l]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=maybeStripScheme(t);const r=getModelKeys(t);if(this.LS.getItem(r.info)==null)throw new Error(`Cannot find model at path '${t}'`);const i=JSON.parse(this.LS.getItem(r.info));return removeItems(r),i}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const URL_SCHEME_SUFFIX="://";class ModelStoreManagerRegistry{constructor(){this.managers={}}static getInstance(){return ModelStoreManagerRegistry.instance==null&&(ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry),ModelStoreManagerRegistry.instance}static registerManager(t,r){assert(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(URL_SCHEME_SUFFIX)&&(t=t.slice(0,t.indexOf(URL_SCHEME_SUFFIX))),assert(t.length>0,()=>"scheme must not be an empty string.");const i=ModelStoreManagerRegistry.getInstance();assert(i.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),i.managers[t]=r}static getManager(t){const r=ModelStoreManagerRegistry.getInstance().managers[t];if(r==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return r}static getSchemes(){return Object.keys(ModelStoreManagerRegistry.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PlatformBrowser{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,r){return fetch(t,r)}now(){return performance.now()}encode(t,r){if(r!=="utf-8"&&r!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${r}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,r){return new TextDecoder(r).decode(t)}setTimeoutCustom(t,r){if(typeof window>"u"||!env().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,r);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},r),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",i=>{if(i.source===window&&i.data.name===this.messageName){i.stopPropagation();const s=this.functionRefs[i.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return isTypedArrayBrowser(t)}}if(env().get("IS_BROWSER")){env().setPlatform("browser",new PlatformBrowser);try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch{}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const getNodeFetch={importFetch:()=>require("node-fetch")};let systemFetch;class PlatformNode{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,r){return env().global.fetch!=null?env().global.fetch(t,r):(systemFetch==null&&(systemFetch=getNodeFetch.importFetch()),systemFetch(t,r))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,r){if(r!=="utf-8"&&r!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${r}`);return this.textEncoder.encode(t)}decode(t,r){return t.length===0?"":new this.util.TextDecoder(r).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}env().get("IS_NODE")&&!env().get("IS_BROWSER")&&env().setPlatform("node",new PlatformNode);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function buffer(n,t="float32",r){return t=t||"float32",assertNonNegativeIntegerDimensions(n),new TensorBuffer(n,t,r)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cast_(n,t){const r=convertToTensor(n,"x","cast");if(!isValidDtype(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&r.dtype!=="string"||t!=="string"&&r.dtype==="string")throw new Error("Only strings can be casted to strings");const i={x:r},s={dtype:t};return ENGINE.runKernel(Cast,i,s)}const cast$1=op({cast_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clone_(n){const r={x:convertToTensor(n,"x","clone","string_or_numeric")};return ENGINE.runKernel(Identity,r)}const clone=op({clone_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function print(n,t=!1){console.log(n.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getOrMakeEngine();const opHandler={buffer,cast:cast$1,clone,print};setOpHandler(opHandler);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function engine(){return ENGINE}function tidy(n,t){return ENGINE.tidy(n,t)}function dispose(n){getTensorsInContainer(n).forEach(r=>r.dispose())}function keep(n){return ENGINE.keep(n)}function registerBackend(n,t,r=1){return ENGINE.registerBackend(n,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function add_(n,t){let r=convertToTensor(n,"a","add"),i=convertToTensor(t,"b","add");[r,i]=makeTypesMatch(r,i);const s={a:r,b:i};return ENGINE.runKernel(Add,s)}const add$1=op({add_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function floorDiv_(n,t){let r=convertToTensor(n,"a","floorDiv"),i=convertToTensor(t,"b","floorDiv");[r,i]=makeTypesMatch(r,i);const s={a:r,b:i};return ENGINE.runKernel(FloorDiv,s)}const floorDiv$1=op({floorDiv_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function div_(n,t){let r=convertToTensor(n,"a","div"),i=convertToTensor(t,"b","div");if([r,i]=makeTypesMatch(r,i),r.dtype==="int32"&&i.dtype==="int32")return floorDiv$1(r,i);const s={a:r,b:i},o={};return ENGINE.runKernel(RealDiv,s,o)}const div$1=op({div_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mul_(n,t){let r=convertToTensor(n,"a","mul"),i=convertToTensor(t,"b","mul");[r,i]=makeTypesMatch(r,i);const s={a:r,b:i};return ENGINE.runKernel(Multiply,s)}const mul=op({mul_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abs_(n){const t=convertToTensor(n,"x","abs");if(t.dtype==="complex64"){const r={x:t};return ENGINE.runKernel(ComplexAbs,r)}else{const r={x:t};return ENGINE.runKernel(Abs,r)}}const abs$1=op({abs_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function computeDilation2DInfo(n,t,r,i,s="NHWC",o){const l=n[3],f=[...t,l],u=convertConv2DDataFormat(s);return computeConv2DInfo(n,f,r,o,i,null,null,u)}function computePool2DInfo(n,t,r,i,s,o,l="channelsLast"){const[f,u]=parseTupleParam(t);let _;if(l==="channelsLast")_=[f,u,n[3],n[3]];else if(l==="channelsFirst")_=[f,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${l}`);return computeConv2DInfo(n,_,r,i,s,o,!1,l)}function computePool3DInfo(n,t,r,i,s,o,l="NDHWC"){const[f,u,_]=parse3TupleParam(t);let g,a;if(l==="NDHWC")a="channelsLast",g=[f,u,_,n[4],n[4]];else if(l==="NCDHW")a="channelsFirst",g=[f,u,_,n[1],n[1]];else throw new Error(`Unknown dataFormat ${l}`);return computeConv3DInfo(n,g,r,i,s,!1,a,o)}function computeConv2DInfo(n,t,r,i,s,o,l=!1,f="channelsLast"){let[u,_,g,a]=[-1,-1,-1,-1];if(f==="channelsLast")[u,_,g,a]=n;else if(f==="channelsFirst")[u,a,_,g]=n;else throw new Error(`Unknown dataFormat ${f}`);const[m,b,,v]=t,[c,w]=parseTupleParam(r),[k,x]=parseTupleParam(i),E=getEffectiveFilterSize(m,k),O=getEffectiveFilterSize(b,x),{padInfo:A,outHeight:T,outWidth:j}=getPadAndOutInfo(s,_,g,c,w,E,O,o,f),I=l?v*a:v;let D;return f==="channelsFirst"?D=[u,I,T,j]:f==="channelsLast"&&(D=[u,T,j,I]),{batchSize:u,dataFormat:f,inHeight:_,inWidth:g,inChannels:a,outHeight:T,outWidth:j,outChannels:I,padInfo:A,strideHeight:c,strideWidth:w,filterHeight:m,filterWidth:b,effectiveFilterHeight:E,effectiveFilterWidth:O,dilationHeight:k,dilationWidth:x,inShape:n,outShape:D,filterShape:t}}function computeConv3DInfo(n,t,r,i,s,o=!1,l="channelsLast",f){let[u,_,g,a,m]=[-1,-1,-1,-1,-1];if(l==="channelsLast")[u,_,g,a,m]=n;else if(l==="channelsFirst")[u,m,_,g,a]=n;else throw new Error(`Unknown dataFormat ${l}`);const[b,v,c,,w]=t,[k,x,E]=parse3TupleParam(r),[O,A,T]=parse3TupleParam(i),j=getEffectiveFilterSize(b,O),I=getEffectiveFilterSize(v,A),D=getEffectiveFilterSize(c,T),{padInfo:$,outDepth:N,outHeight:M,outWidth:W}=get3DPadAndOutInfo(s,_,g,a,k,x,E,j,I,D,f),F=o?w*m:w;let H;return l==="channelsFirst"?H=[u,F,N,M,W]:l==="channelsLast"&&(H=[u,N,M,W,F]),{batchSize:u,dataFormat:l,inDepth:_,inHeight:g,inWidth:a,inChannels:m,outDepth:N,outHeight:M,outWidth:W,outChannels:F,padInfo:$,strideDepth:k,strideHeight:x,strideWidth:E,filterDepth:b,filterHeight:v,filterWidth:c,effectiveFilterDepth:j,effectiveFilterHeight:I,effectiveFilterWidth:D,dilationDepth:O,dilationHeight:A,dilationWidth:T,inShape:n,outShape:H,filterShape:t}}function computeOutputShape2D(n,t,r,i,s){i==null&&(i=computeDefaultPad(n,t,r));const o=n[0],l=n[1],f=round$1((o-t+2*i)/r+1,s),u=round$1((l-t+2*i)/r+1,s);return[f,u]}function computeOutputShape4D(n,t,r,i,s,o){s==null&&(s=computeDefaultPad(n,t[0],i[0]));const l=[0,0,0,r];for(let f=0;f<3;f++)n[f]+2*s>=t[f]&&(l[f]=round$1((n[f]-t[f]+2*s)/i[f]+1,o));return l}function computeDefaultPad(n,t,r,i=1){const s=getEffectiveFilterSize(t,i);return Math.floor((n[0]*(r-1)-r+s)/2)}function parseTupleParam(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function parse3TupleParam(n){return typeof n=="number"?[n,n,n]:n}function getEffectiveFilterSize(n,t){return t<=1?n:n+(n-1)*(t-1)}function getPadAndOutInfo(n,t,r,i,s,o,l,f,u){let _,g,a;if(typeof n=="number"){_={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const b=computeOutputShape2D([t,r],o,i,n,f);g=b[0],a=b[1]}else if(n==="same"){g=Math.ceil(t/i),a=Math.ceil(r/s);const m=Math.max(0,(g-1)*i+o-t),b=Math.max(0,(a-1)*s+l-r),v=Math.floor(m/2),c=m-v,w=Math.floor(b/2),k=b-w;_={top:v,bottom:c,left:w,right:k,type:"SAME"}}else if(n==="valid")_={top:0,bottom:0,left:0,right:0,type:"VALID"},g=Math.ceil((t-o+1)/i),a=Math.ceil((r-l+1)/s);else if(typeof n=="object"){const m=u==="channelsLast"?n[1][0]:n[2][0],b=u==="channelsLast"?n[1][1]:n[2][1],v=u==="channelsLast"?n[2][0]:n[3][0],c=u==="channelsLast"?n[2][1]:n[3][1];_={top:m,bottom:b,left:v,right:c,type:m===0&&b===0&&v===0&&c===0?"VALID":"EXPLICIT"},g=round$1((t-o+m+b)/i+1,f),a=round$1((r-l+v+c)/s+1,f)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:_,outHeight:g,outWidth:a}}function get3DPadAndOutInfo(n,t,r,i,s,o,l,f,u,_,g){let a,m,b,v;if(n==="valid"&&(n=0),typeof n=="number"){a={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=computeOutputShape4D([t,r,i,1],[f,u,_],1,[s,o,l],n,g);m=w[0],b=w[1],v=w[2]}else if(n==="same"){m=Math.ceil(t/s),b=Math.ceil(r/o),v=Math.ceil(i/l);const c=(m-1)*s+f-t,w=(b-1)*o+u-r,k=(v-1)*l+_-i,x=Math.floor(c/2),E=c-x,O=Math.floor(w/2),A=w-O,T=Math.floor(k/2),j=k-T;a={top:O,bottom:A,left:T,right:j,front:x,back:E,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:a,outDepth:m,outHeight:b,outWidth:v}}function round$1(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function tupleValuesAreOne(n){const[t,r,i]=parseTupleParam(n);return t===1&&r===1&&i===1}function eitherStridesOrDilationsAreOne(n,t){return tupleValuesAreOne(n)||tupleValuesAreOne(t)}function convertConv2DDataFormat(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape_(n,t){const i={x:convertToTensor(n,"x","reshape","string_or_numeric")},s={shape:t};return ENGINE.runKernel(Reshape,i,s)}const reshape$1=op({reshape_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat_(n,t=0){assert(n.length>=1,()=>"Pass at least one tensor to concat");const r=convertToTensorArray(n,"tensors","concat","string_or_numeric");if(r[0].dtype==="complex64"&&r.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),r.length===1)return clone(r[0]);const i=r,s={axis:t};return ENGINE.runKernel(Concat,i,s)}const concat$1=op({concat_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice_(n,t,r){const i=convertToTensor(n,"x","slice","string_or_numeric");if(i.rank===0)throw new Error("Slicing scalar is not possible");const s={x:i},o={begin:t,size:r};return ENGINE.runKernel(Slice,s,o)}const slice$1=op({slice_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function broadcastTo_(n,t){let r=convertToTensor(n,"broadcastTo","x");const i=r.shape;if(assertNonNegativeIntegerDimensions(t),t.length<r.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${r.rank}.`);if(t.length>r.rank){const _=r.shape.slice();for(;_.length<t.length;)_.unshift(1);r=reshape$1(r,_)}const s=r.shape,o=Array.from(t);for(let _=t.length-1;_>=0;_--)if(s[_]===t[_])o[_]=1;else if(r.shape[_]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${t}].`);if(o.map((_,g)=>_>1?g:-1).filter(_=>_>=0).length===0)return clone(r);const f={x:r},u={reps:o};return ENGINE.runKernel(Tile,f,u)}const broadcastTo=op({broadcastTo_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill$1(n,t,r){assertNonNegativeIntegerDimensions(n),r=r||inferDtype(t);const i={shape:n,value:t,dtype:r};return ENGINE.runKernel(Fill,{},i)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getBroadcastDims(n,t){const r=n.length,i=[];for(let s=0;s<r;s++){const o=r-1-s,l=n[o]||1;(t[t.length-1-s]||1)>1&&l===1&&i.unshift(o)}return i}function assertAndGetBroadcastShape(n,t){const r=Math.max(n.length,t.length),i=new Array(r);for(let s=0;s<r;s++){let o=n[n.length-s-1];o==null&&(o=1);let l=t[t.length-s-1];if(l==null&&(l=1),o===1)i[r-s-1]=l;else if(l===1)i[r-s-1]=o;else if(o!==l){const f=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(f)}else i[r-s-1]=o}return i}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike_(n){const r={x:convertToTensor(n,"x","zerosLike")};return ENGINE.runKernel(ZerosLike,r)}const zerosLike$1=op({zerosLike_});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axesAreInnerMostDims(n,t){for(let r=0;r<n.length;++r)if(n[n.length-r-1]!==t-1-r)return!1;return!0}function combineLocations(n,t,r){const i=n.length+t.length,s=[];let o=0,l=0;for(let f=0;f<i;f++)r.indexOf(f)===-1?s.push(n[o++]):s.push(t[l++]);return s}function computeOutAndReduceShapes(n,t){const r=[],i=n.length;for(let o=0;o<i;o++)t.indexOf(o)===-1&&r.push(n[o]);const s=t.map(o=>n[o]);return[r,s]}function expandShapeToKeepDim(n,t){const r=t.map(i=>1);return combineLocations(n,r,t)}function assertAxesAreInnerMostDims(n,t,r){assert(axesAreInnerMostDims(t,r),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${r} input.`)}function getAxesPermutation(n,t){if(axesAreInnerMostDims(n,t))return null;const r=[];for(let i=0;i<t;++i)n.indexOf(i)===-1&&r.push(i);return n.forEach(i=>r.push(i)),r}function getUndoAxesPermutation(n){return n.map((t,r)=>[r,t]).sort((t,r)=>t[1]-r[1]).map(t=>t[0])}function getInnerMostAxes(n,t){const r=[];for(let i=t-n;i<t;++i)r.push(i);return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pow_(n,t){let r=convertToTensor(n,"base","pow"),i=convertToTensor(t,"exp","pow");[r,i]=makeTypesMatch(r,i);const s={a:r,b:i};return ENGINE.runKernel(Pow,s)}const pow$1=op({pow_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scalar(n,t){if((isTypedArray(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&isTypedArray(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return makeTensor(n,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sqrt_(n){const r={x:convertToTensor(n,"x","sqrt","float32")};return ENGINE.runKernel(Sqrt,r)}const sqrt$1=op({sqrt_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function square_(n){const t=convertToTensor(n,"x","square"),r={};return ENGINE.runKernel("Square",{x:t},r)}const square=op({square_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag_(n){const r={input:convertToTensor(n,"input","imag")};return ENGINE.runKernel(Imag,r)}const imag$1=op({imag_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function variableGrads(n,t){assert(isFunction(n),()=>"The f passed in variableGrads(f) must be a function"),assert(t==null||Array.isArray(t)&&t.every(_=>_ instanceof Variable),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const r=t!=null;if(!r){t=[];for(const _ in ENGINE.registeredVariables)t.push(ENGINE.registeredVariables[_])}const i=r?t.filter(_=>!_.trainable):null,s=t.length;t=t.filter(_=>_.trainable),assert(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const o=!0,{value:l,grads:f}=ENGINE.gradients(n,t,null,o);assert(f.some(_=>_!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),assert(l.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`);const u={};return t.forEach((_,g)=>{f[g]!=null&&(u[_.name]=f[g])}),i!=null&&i.forEach(_=>u[_.name]=null),{value:l,grads:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function neg_(n){const r={x:convertToTensor(n,"x","neg")};return ENGINE.runKernel(Neg,r)}const neg$1=op({neg_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sub_(n,t){let r=convertToTensor(n,"a","sub"),i=convertToTensor(t,"b","sub");[r,i]=makeTypesMatch(r,i);const s={a:r,b:i};return ENGINE.runKernel(Sub,s)}const sub$1=op({sub_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maximum_(n,t){let r=convertToTensor(n,"a","maximum"),i=convertToTensor(t,"b","maximum");[r,i]=makeTypesMatch(r,i),r.dtype==="bool"&&(r=cast$1(r,"int32"),i=cast$1(i,"int32")),assertAndGetBroadcastShape(r.shape,i.shape);const s={a:r,b:i};return ENGINE.runKernel(Maximum,s)}const maximum$1=op({maximum_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pad_(n,t,r=0){const i=convertToTensor(n,"x","pad");if(i.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:r},o={x:i};return ENGINE.runKernel(PadV2,o,s)}const pad=op({pad_});var alea$1={exports:{}};alea$1.exports;(function(n){(function(t,r,i){function s(u){var _=this,g=f();_.next=function(){var a=2091639*_.s0+_.c*23283064365386963e-26;return _.s0=_.s1,_.s1=_.s2,_.s2=a-(_.c=a|0)},_.c=1,_.s0=g(" "),_.s1=g(" "),_.s2=g(" "),_.s0-=g(u),_.s0<0&&(_.s0+=1),_.s1-=g(u),_.s1<0&&(_.s1+=1),_.s2-=g(u),_.s2<0&&(_.s2+=1),g=null}function o(u,_){return _.c=u.c,_.s0=u.s0,_.s1=u.s1,_.s2=u.s2,_}function l(u,_){var g=new s(u),a=_&&_.state,m=g.next;return m.int32=function(){return g.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,a&&(typeof a=="object"&&o(a,g),m.state=function(){return o(g,{})}),m}function f(){var u=4022871197,_=function(g){g=String(g);for(var a=0;a<g.length;a++){u+=g.charCodeAt(a);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return _}r&&r.exports?r.exports=l:i&&i.amd?i(function(){return l}):this.alea=l})(commonjsGlobal,n,!1)})(alea$1);var aleaExports=alea$1.exports,xor128$1={exports:{}};xor128$1.exports;(function(n){(function(t,r,i){function s(f){var u=this,_="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var a=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^a^a>>>8},f===(f|0)?u.x=f:_+=f;for(var g=0;g<_.length+64;g++)u.x^=_.charCodeAt(g)|0,u.next()}function o(f,u){return u.x=f.x,u.y=f.y,u.z=f.z,u.w=f.w,u}function l(f,u){var _=new s(f),g=u&&u.state,a=function(){return(_.next()>>>0)/4294967296};return a.double=function(){do var m=_.next()>>>11,b=(_.next()>>>0)/4294967296,v=(m+b)/(1<<21);while(v===0);return v},a.int32=_.next,a.quick=a,g&&(typeof g=="object"&&o(g,_),a.state=function(){return o(_,{})}),a}r&&r.exports?r.exports=l:i&&i.amd?i(function(){return l}):this.xor128=l})(commonjsGlobal,n,!1)})(xor128$1);var xor128Exports=xor128$1.exports,xorwow$1={exports:{}};xorwow$1.exports;(function(n){(function(t,r,i){function s(f){var u=this,_="";u.next=function(){var a=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(a^a<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,f===(f|0)?u.x=f:_+=f;for(var g=0;g<_.length+64;g++)u.x^=_.charCodeAt(g)|0,g==_.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(f,u){return u.x=f.x,u.y=f.y,u.z=f.z,u.w=f.w,u.v=f.v,u.d=f.d,u}function l(f,u){var _=new s(f),g=u&&u.state,a=function(){return(_.next()>>>0)/4294967296};return a.double=function(){do var m=_.next()>>>11,b=(_.next()>>>0)/4294967296,v=(m+b)/(1<<21);while(v===0);return v},a.int32=_.next,a.quick=a,g&&(typeof g=="object"&&o(g,_),a.state=function(){return o(_,{})}),a}r&&r.exports?r.exports=l:i&&i.amd?i(function(){return l}):this.xorwow=l})(commonjsGlobal,n,!1)})(xorwow$1);var xorwowExports=xorwow$1.exports,xorshift7$1={exports:{}};xorshift7$1.exports;(function(n){(function(t,r,i){function s(f){var u=this;u.next=function(){var g=u.x,a=u.i,m,b;return m=g[a],m^=m>>>7,b=m^m<<24,m=g[a+1&7],b^=m^m>>>10,m=g[a+3&7],b^=m^m>>>3,m=g[a+4&7],b^=m^m<<7,m=g[a+7&7],m=m^m<<13,b^=m^m<<9,g[a]=b,u.i=a+1&7,b};function _(g,a){var m,b=[];if(a===(a|0))b[0]=a;else for(a=""+a,m=0;m<a.length;++m)b[m&7]=b[m&7]<<15^a.charCodeAt(m)+b[m+1&7]<<13;for(;b.length<8;)b.push(0);for(m=0;m<8&&b[m]===0;++m);for(m==8?b[7]=-1:b[m],g.x=b,g.i=0,m=256;m>0;--m)g.next()}_(u,f)}function o(f,u){return u.x=f.x.slice(),u.i=f.i,u}function l(f,u){f==null&&(f=+new Date);var _=new s(f),g=u&&u.state,a=function(){return(_.next()>>>0)/4294967296};return a.double=function(){do var m=_.next()>>>11,b=(_.next()>>>0)/4294967296,v=(m+b)/(1<<21);while(v===0);return v},a.int32=_.next,a.quick=a,g&&(g.x&&o(g,_),a.state=function(){return o(_,{})}),a}r&&r.exports?r.exports=l:i&&i.amd?i(function(){return l}):this.xorshift7=l})(commonjsGlobal,n,!1)})(xorshift7$1);var xorshift7Exports=xorshift7$1.exports,xor4096$1={exports:{}};xor4096$1.exports;(function(n){(function(t,r,i){function s(f){var u=this;u.next=function(){var g=u.w,a=u.X,m=u.i,b,v;return u.w=g=g+1640531527|0,v=a[m+34&127],b=a[m=m+1&127],v^=v<<13,b^=b<<17,v^=v>>>15,b^=b>>>12,v=a[m]=v^b,u.i=m,v+(g^g>>>16)|0};function _(g,a){var m,b,v,c,w,k=[],x=128;for(a===(a|0)?(b=a,a=null):(a=a+"\0",b=0,x=Math.max(x,a.length)),v=0,c=-32;c<x;++c)a&&(b^=a.charCodeAt((c+32)%a.length)),c===0&&(w=b),b^=b<<10,b^=b>>>15,b^=b<<4,b^=b>>>13,c>=0&&(w=w+1640531527|0,m=k[c&127]^=b+w,v=m==0?v+1:0);for(v>=128&&(k[(a&&a.length||0)&127]=-1),v=127,c=4*128;c>0;--c)b=k[v+34&127],m=k[v=v+1&127],b^=b<<13,m^=m<<17,b^=b>>>15,m^=m>>>12,k[v]=b^m;g.w=w,g.X=k,g.i=v}_(u,f)}function o(f,u){return u.i=f.i,u.w=f.w,u.X=f.X.slice(),u}function l(f,u){f==null&&(f=+new Date);var _=new s(f),g=u&&u.state,a=function(){return(_.next()>>>0)/4294967296};return a.double=function(){do var m=_.next()>>>11,b=(_.next()>>>0)/4294967296,v=(m+b)/(1<<21);while(v===0);return v},a.int32=_.next,a.quick=a,g&&(g.X&&o(g,_),a.state=function(){return o(_,{})}),a}r&&r.exports?r.exports=l:i&&i.amd?i(function(){return l}):this.xor4096=l})(commonjsGlobal,n,!1)})(xor4096$1);var xor4096Exports=xor4096$1.exports,tychei$1={exports:{}};tychei$1.exports;(function(n){(function(t,r,i){function s(f){var u=this,_="";u.next=function(){var a=u.b,m=u.c,b=u.d,v=u.a;return a=a<<25^a>>>7^m,m=m-b|0,b=b<<24^b>>>8^v,v=v-a|0,u.b=a=a<<20^a>>>12^m,u.c=m=m-b|0,u.d=b<<16^m>>>16^v,u.a=v-a|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,f===Math.floor(f)?(u.a=f/4294967296|0,u.b=f|0):_+=f;for(var g=0;g<_.length+20;g++)u.b^=_.charCodeAt(g)|0,u.next()}function o(f,u){return u.a=f.a,u.b=f.b,u.c=f.c,u.d=f.d,u}function l(f,u){var _=new s(f),g=u&&u.state,a=function(){return(_.next()>>>0)/4294967296};return a.double=function(){do var m=_.next()>>>11,b=(_.next()>>>0)/4294967296,v=(m+b)/(1<<21);while(v===0);return v},a.int32=_.next,a.quick=a,g&&(typeof g=="object"&&o(g,_),a.state=function(){return o(_,{})}),a}r&&r.exports?r.exports=l:i&&i.amd?i(function(){return l}):this.tychei=l})(commonjsGlobal,n,!1)})(tychei$1);var tycheiExports=tychei$1.exports,seedrandom$1={exports:{}};const __viteBrowserExternal={},__viteBrowserExternal$1=Object.freeze(Object.defineProperty({__proto__:null,default:__viteBrowserExternal},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(__viteBrowserExternal$1);(function(n){(function(t,r,i){var s=256,o=6,l=52,f="random",u=i.pow(s,o),_=i.pow(2,l),g=_*2,a=s-1,m;function b(O,A,T){var j=[];A=A==!0?{entropy:!0}:A||{};var I=k(w(A.entropy?[O,E(r)]:O??x(),3),j),D=new v(j),$=function(){for(var N=D.g(o),M=u,W=0;N<_;)N=(N+W)*s,M*=s,W=D.g(1);for(;N>=g;)N/=2,M/=2,W>>>=1;return(N+W)/M};return $.int32=function(){return D.g(4)|0},$.quick=function(){return D.g(4)/4294967296},$.double=$,k(E(D.S),r),(A.pass||T||function(N,M,W,F){return F&&(F.S&&c(F,D),N.state=function(){return c(D,{})}),W?(i[f]=N,M):N})($,I,"global"in A?A.global:this==i,A.state)}function v(O){var A,T=O.length,j=this,I=0,D=j.i=j.j=0,$=j.S=[];for(T||(O=[T++]);I<s;)$[I]=I++;for(I=0;I<s;I++)$[I]=$[D=a&D+O[I%T]+(A=$[I])],$[D]=A;(j.g=function(N){for(var M,W=0,F=j.i,H=j.j,q=j.S;N--;)M=q[F=a&F+1],W=W*s+q[a&(q[F]=q[H=a&H+M])+(q[H]=M)];return j.i=F,j.j=H,W})(s)}function c(O,A){return A.i=O.i,A.j=O.j,A.S=O.S.slice(),A}function w(O,A){var T=[],j=typeof O,I;if(A&&j=="object")for(I in O)try{T.push(w(O[I],A-1))}catch{}return T.length?T:j=="string"?O:O+"\0"}function k(O,A){for(var T=O+"",j,I=0;I<T.length;)A[a&I]=a&(j^=A[a&I]*19)+T.charCodeAt(I++);return E(A)}function x(){try{var O;return m&&(O=m.randomBytes)?O=O(s):(O=new Uint8Array(s),(t.crypto||t.msCrypto).getRandomValues(O)),E(O)}catch{var A=t.navigator,T=A&&A.plugins;return[+new Date,t,T,t.screen,E(r)]}}function E(O){return String.fromCharCode.apply(0,O)}if(k(i.random(),r),n.exports){n.exports=b;try{m=require$$0}catch{}}else i["seed"+f]=b})(typeof self<"u"?self:commonjsGlobal,[],Math)})(seedrandom$1);var seedrandomExports=seedrandom$1.exports,alea=aleaExports,xor128=xor128Exports,xorwow=xorwowExports,xorshift7=xorshift7Exports,xor4096=xor4096Exports,tychei=tycheiExports,sr=seedrandomExports;sr.alea=alea;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;var seedrandom=sr;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real_(n){const r={input:convertToTensor(n,"input","real")};return ENGINE.runKernel(Real,r)}const real$1=op({real_});function calculateShapes(n,t,r){const i=t.shape.length,s=i>1?t.shape[i-1]:1,o=r.length;let l=1;for(let a=s;a<o;++a)l*=r[a];const f=s<1?1:s,u=sizeFromShape(t.shape)/f,_=[...computeStrides(r.slice(0,s)),1],g=sizeFromShape(r);return{sliceRank:s,numUpdates:u,sliceSize:l,strides:_,outputSize:g}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whereImpl$1(n,t){const r=[];for(let o=0;o<t.length;o++)t[o]&&r.push(o);const i=buffer(n,"int32"),s=buffer([r.length,n.length],"int32");for(let o=0;o<r.length;o++){const l=i.indexToLoc(r[o]),f=o*n.length;s.values.set(l,f)}return s.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose_(n,t,r){const i=convertToTensor(n,"x","transpose");if(t==null&&(t=i.shape.map((l,f)=>f).reverse()),assert(i.rank===t.length,()=>`Error in transpose: rank of input ${i.rank} must match length of perm ${t}.`),t.forEach(l=>{assert(l>=0&&l<i.rank,()=>`All entries in 'perm' must be between 0 and ${i.rank-1} but got ${t}`)}),i.rank<=1)return i.clone();const s={x:i},o={perm:t};return i.dtype==="complex64"?tidy(()=>{let l=real$1(i),f=imag$1(i);return l=ENGINE.runKernel(Transpose,{x:l},o),f=ENGINE.runKernel(Transpose,{x:f},o),r&&(f=neg$1(f)),complex$1(l,f)}):ENGINE.runKernel(Transpose,s,o)}const transpose$1=op({transpose_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function binaryInsert(n,t,r){const i=binarySearch(n,t,r),s=i<0?-(i+1):i;n.splice(s,0,t)}function binarySearch(n,t,r){return binarySearch_(n,t,r||defaultComparator)}function defaultComparator(n,t){return n>t?1:n<t?-1:0}function binarySearch_(n,t,r){let i=0,s=n.length,o=0,l=!1;for(;i<s;){o=i+(s-i>>>1);const f=r(t,n[o]);f>0?i=o+1:(s=o,l=!f)}return l?i:-i-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionV3Impl$1(n,t,r,i,s){return nonMaxSuppressionImpl_(n,t,r,i,s,0)}function nonMaxSuppressionV4Impl$1(n,t,r,i,s,o){return nonMaxSuppressionImpl_(n,t,r,i,s,0,!1,o,!0)}function nonMaxSuppressionV5Impl$1(n,t,r,i,s,o){return nonMaxSuppressionImpl_(n,t,r,i,s,o,!0)}function nonMaxSuppressionImpl_(n,t,r,i,s,o,l=!1,f=!1,u=!1){const _=[];for(let w=0;w<t.length;w++)t[w]>s&&_.push({score:t[w],boxIndex:w,suppressBeginIndex:0});_.sort(ascendingComparator);const g=o>0?-.5/o:0,a=[],m=[];for(;a.length<r&&_.length>0;){const w=_.pop(),{score:k,boxIndex:x,suppressBeginIndex:E}=w;if(k<s)break;let O=!1;for(let A=a.length-1;A>=E;--A){const T=intersectionOverUnion(n,x,a[A]);if(T>=i){O=!0;break}if(w.score=w.score*suppressWeight(i,g,T),w.score<=s)break}w.suppressBeginIndex=a.length,O||(w.score===k?(a.push(x),m.push(w.score)):w.score>s&&binaryInsert(_,w,ascendingComparator))}const b=a.length,v=r-b;f&&v>0&&(a.push(...new Array(v).fill(0)),m.push(...new Array(v).fill(0)));const c={selectedIndices:a};return l&&(c.selectedScores=m),u&&(c.validOutputs=b),c}function intersectionOverUnion(n,t,r){const i=n.subarray(t*4,t*4+4),s=n.subarray(r*4,r*4+4),o=Math.min(i[0],i[2]),l=Math.min(i[1],i[3]),f=Math.max(i[0],i[2]),u=Math.max(i[1],i[3]),_=Math.min(s[0],s[2]),g=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),m=Math.max(s[1],s[3]),b=(f-o)*(u-l),v=(a-_)*(m-g);if(b<=0||v<=0)return 0;const c=Math.max(o,_),w=Math.max(l,g),k=Math.min(f,a),x=Math.min(u,m),E=Math.max(k-c,0)*Math.max(x-w,0);return E/(b+v-E)}function suppressWeight(n,t,r){const i=Math.exp(t*r*r);return r<=n?i:0}function ascendingComparator(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GLOBAL_CUSTOM_OBJECT=new Map,GLOBAL_CUSTOM_NAMES=new Map;class Serializable{getClassName(){return this.constructor.className}static fromConfig(t,r){return new t(r)}}class SerializationMap{constructor(){this.classNameMap={}}static getMap(){return SerializationMap.instance==null&&(SerializationMap.instance=new SerializationMap),SerializationMap.instance}static register(t){SerializationMap.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function registerClass(n,t,r){assert(n.className!=null,()=>"Class being registered does not have the static className property defined."),assert(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),assert(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof r>"u"&&(r=n.className);const i=r,s=t+">"+i;return SerializationMap.register(n),GLOBAL_CUSTOM_OBJECT.set(s,n),GLOBAL_CUSTOM_NAMES.set(n,s),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Optimizer extends Serializable{minimize(t,r=!1,i){const{value:s,grads:o}=this.computeGradients(t,i);if(i!=null){const l=i.map(f=>({name:f.name,tensor:o[f.name]}));this.applyGradients(l)}else this.applyGradients(o);return dispose(o),r?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,r){return variableGrads(t,r)}dispose(){this.iterations_!=null&&dispose(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:scalar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Optimizer,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdadeltaOptimizer extends Optimizer{static get className(){return"Adadelta"}constructor(t,r,i=null){super(),this.learningRate=t,this.rho=r,this.epsilon=i,this.accumulatedGrads=[],this.accumulatedUpdates=[],i==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,s)=>{const o=ENGINE.registeredVariables[i],l=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${i}/accum_grad`,variable:tidy(()=>zerosLike$1(o).variable(l))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${i}/accum_var`,variable:tidy(()=>zerosLike$1(o).variable(l))});const f=Array.isArray(t)?t[s].tensor:t[i];if(f==null)return;const u=this.accumulatedGrads[s].variable,_=this.accumulatedUpdates[s].variable;tidy(()=>{const g=add$1(mul(u,this.rho),mul(square(f),1-this.rho)),a=mul(div$1(sqrt$1(add$1(_,this.epsilon)),sqrt$1(add$1(u,this.epsilon))),f),m=add$1(mul(_,this.rho),mul(square(a),1-this.rho));u.assign(g),_.assign(m);const b=add$1(mul(a,-this.learningRate),o);o.assign(b)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(dispose(this.accumulatedGrads.map(t=>t.variable)),dispose(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))}async setWeights(t){t=await this.extractIterations(t);const r=t.length/2,i=!1;this.accumulatedGrads=t.slice(0,r).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})),this.accumulatedUpdates=t.slice(r,r*2).map(s=>({originalName:s.name,variable:s.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,r){return new t(r.learningRate,r.rho,r.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdagradOptimizer extends Optimizer{static get className(){return"Adagrad"}constructor(t,r=.1){super(),this.learningRate=t,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,s)=>{const o=ENGINE.registeredVariables[i];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${i}/accumulator`,variable:tidy(()=>fill$1(o.shape,this.initialAccumulatorValue).variable(!1))});const l=Array.isArray(t)?t[s].tensor:t[i];if(l==null)return;const f=this.accumulatedGrads[s].variable;tidy(()=>{const u=add$1(f,square(l));f.assign(u);const _=add$1(mul(div$1(l,sqrt$1(add$1(u,ENGINE.backend.epsilon()))),-this.learningRate),o);o.assign(_)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&dispose(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const r=!1;this.accumulatedGrads=t.map(i=>({originalName:i.name,variable:i.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,r){return new t(r.learningRate,r.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdamOptimizer extends Optimizer{static get className(){return"Adam"}constructor(t,r,i,s=null){super(),this.learningRate=t,this.beta1=r,this.beta2=i,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tidy(()=>{this.accBeta1=scalar(r).variable(),this.accBeta2=scalar(i).variable()}),s==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(t){const r=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);tidy(()=>{const i=sub$1(1,this.accBeta1),s=sub$1(1,this.accBeta2);r.forEach((o,l)=>{const f=ENGINE.registeredVariables[o],u=!1;this.accumulatedFirstMoment[l]==null&&(this.accumulatedFirstMoment[l]={originalName:`${o}/m`,variable:tidy(()=>zerosLike$1(f).variable(u))}),this.accumulatedSecondMoment[l]==null&&(this.accumulatedSecondMoment[l]={originalName:`${o}/v`,variable:tidy(()=>zerosLike$1(f).variable(u))});const _=Array.isArray(t)?t[l].tensor:t[o];if(_==null)return;const g=this.accumulatedFirstMoment[l].variable,a=this.accumulatedSecondMoment[l].variable,m=add$1(mul(g,this.beta1),mul(_,1-this.beta1)),b=add$1(mul(a,this.beta2),mul(square(_),1-this.beta2)),v=div$1(m,i),c=div$1(b,s);g.assign(m),a.assign(b);const w=add$1(mul(div$1(v,add$1(sqrt$1(c),this.epsilon)),-this.learningRate),f);f.assign(w)}),this.accBeta1.assign(mul(this.accBeta1,this.beta1)),this.accBeta2.assign(mul(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&dispose(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&dispose(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))}async setWeights(t){t=await this.extractIterations(t),tidy(()=>{this.accBeta1.assign(pow$1(this.beta1,this.iterations_+1)),this.accBeta2.assign(pow$1(this.beta2,this.iterations_+1))});const r=t.length/2,i=!1;this.accumulatedFirstMoment=t.slice(0,r).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})),this.accumulatedSecondMoment=t.slice(r,r*2).map(s=>({originalName:s.name,variable:s.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,r){return new t(r.learningRate,r.beta1,r.beta2,r.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdamaxOptimizer extends Optimizer{static get className(){return"Adamax"}constructor(t,r,i,s=null,o=0){super(),this.learningRate=t,this.beta1=r,this.beta2=i,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tidy(()=>{this.iteration=scalar(0).variable(),this.accBeta1=scalar(r).variable()}),s==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(t){const r=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);tidy(()=>{const i=sub$1(1,this.accBeta1),s=div$1(-this.learningRate,add$1(mul(this.iteration,this.decay),1));r.forEach((o,l)=>{const f=ENGINE.registeredVariables[o],u=!1;this.accumulatedFirstMoment[l]==null&&(this.accumulatedFirstMoment[l]={originalName:`${o}/m`,variable:zerosLike$1(f).variable(u)}),this.accumulatedWeightedInfNorm[l]==null&&(this.accumulatedWeightedInfNorm[l]={originalName:`${o}/v`,variable:zerosLike$1(f).variable(u)});const _=Array.isArray(t)?t[l].tensor:t[o];if(_==null)return;const g=this.accumulatedFirstMoment[l].variable,a=this.accumulatedWeightedInfNorm[l].variable,m=add$1(mul(g,this.beta1),mul(_,1-this.beta1)),b=mul(a,this.beta2),v=abs$1(_),c=maximum$1(b,v);g.assign(m),a.assign(c);const w=add$1(mul(div$1(s,i),div$1(m,add$1(c,this.epsilon))),f);f.assign(w)}),this.iteration.assign(add$1(this.iteration,1)),this.accBeta1.assign(mul(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&dispose(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&dispose(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,r){return new t(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SGDOptimizer extends Optimizer{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,s)=>{const o=Array.isArray(t)?t[s].tensor:t[i];if(o==null)return;const l=ENGINE.registeredVariables[i];tidy(()=>{const f=add$1(mul(this.c,o),l);l.assign(f)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=keep(scalar(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,r){return new t(r.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MomentumOptimizer extends SGDOptimizer{static get className(){return"Momentum"}constructor(t,r,i=!1){super(t),this.learningRate=t,this.momentum=r,this.useNesterov=i,this.accumulations=[],this.m=scalar(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,s)=>{const o=ENGINE.registeredVariables[i];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${i}/momentum`,variable:tidy(()=>zerosLike$1(o).variable(!1))});const l=this.accumulations[s].variable,f=Array.isArray(t)?t[s].tensor:t[i];f!=null&&tidy(()=>{let u;const _=add$1(mul(this.m,l),f);this.useNesterov?u=add$1(mul(this.c,add$1(f,mul(_,this.m))),o):u=add$1(mul(this.c,_),o),l.assign(_),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&dispose(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const r=!1;this.accumulations=t.map(i=>({originalName:i.name,variable:i.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,r){return new t(r.learningRate,r.momentum,r.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RMSPropOptimizer extends Optimizer{static get className(){return"RMSProp"}constructor(t,r=.9,i=0,s=null,o=!1){if(super(),this.learningRate=t,this.decay=r,this.momentum=i,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=ENGINE.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(i=>i.name):Object.keys(t)).forEach((i,s)=>{const o=ENGINE.registeredVariables[i],l=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${i}/rms`,variable:tidy(()=>zerosLike$1(o).variable(l))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${i}/momentum`,variable:tidy(()=>zerosLike$1(o).variable(l))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${i}/mg`,variable:tidy(()=>zerosLike$1(o).variable(l))});const f=Array.isArray(t)?t[s].tensor:t[i];if(f==null)return;const u=this.accumulatedMeanSquares[s].variable,_=this.accumulatedMoments[s].variable;tidy(()=>{const g=add$1(mul(u,this.decay),mul(square(f),1-this.decay));if(this.centered){const a=this.accumulatedMeanGrads[s].variable,m=add$1(mul(a,this.decay),mul(f,1-this.decay)),b=div$1(mul(f,this.learningRate),sqrt$1(sub$1(g,add$1(square(m),this.epsilon)))),v=add$1(mul(_,this.momentum),b);u.assign(g),a.assign(m),_.assign(v);const c=sub$1(o,v);o.assign(c)}else{const a=add$1(mul(u,this.decay),mul(square(f),1-this.decay)),m=add$1(mul(_,this.momentum),div$1(mul(f,this.learningRate),sqrt$1(add$1(a,this.epsilon))));u.assign(a),_.assign(m);const b=sub$1(o,m);o.assign(b)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&dispose(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&dispose(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&dispose(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))}async setWeights(t){t=await this.extractIterations(t);const r=this.centered?t.length/3:t.length/2,i=!1;this.accumulatedMeanSquares=t.slice(0,r).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})),this.accumulatedMoments=t.slice(r,r*2).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})),this.centered&&(this.accumulatedMeanGrads=t.slice(r*2,r*3).map(s=>({originalName:s.name,variable:s.tensor.variable(i)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,r){return new t(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OPTIMIZERS=[AdadeltaOptimizer,AdagradOptimizer,AdamOptimizer,AdamaxOptimizer,MomentumOptimizer,RMSPropOptimizer,SGDOptimizer];function registerOptimizers(){for(const n of OPTIMIZERS)registerClass(n)}function prepareAndValidate(n,t){const r=n.shape.length,i=t.shape.length;if(r<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${r}.`);if(i<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${i}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[i-1]>r)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[i-1]} vs. ${r}`);if(sizeFromShape(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,o=s[s.length-1];let l=1;for(let a=0;a<s.length-1;++a)l*=s[a];const f=n.shape,u=s.slice();u.pop();let _=1;for(let a=o;a<r;++a)_*=f[a],u.push(f[a]);const g=[...computeStrides(n.shape).map(a=>a/_),1].slice(0,o);return[u,l,_,g]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NEW_AXIS=-2,SHRINK_AXIS=-1;function assertParamsValid(n,t,r){const i=n.shape.length;assert(i===t.length,()=>`Error in slice${i}D: Length of begin ${t} must match the rank of the array (${i}).`),assert(i===r.length,()=>`Error in slice${i}D: Length of size ${r} must match the rank of the array (${i}).`);for(let s=0;s<i;++s)assert(t[s]+r[s]<=n.shape[s],()=>`Error in slice${i}D: begin[${s}] + size[${s}] (${t[s]+r[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function computeOutShape$1(n,t,r){const i=[];for(let s=0;s<n.length;s++)i[s]=Math.ceil((t[s]-n[s])/r[s]);return i}function isSliceContinous(n,t,r){let i=r.length;for(let s=0;s<r.length;s++)if(r[s]>1){i=s;break}for(let s=i+1;s<r.length;s++)if(t[s]>0||r[s]!==n[s])return!1;return!0}function computeFlatOffset(n,t){let r=n.length>0?n[n.length-1]:1;for(let i=0;i<n.length-1;i++)r+=n[i]*t[i];return r}function parseSliceParams(n,t,r){let i;const s=n.shape.length;typeof t=="number"?i=[t,...new Array(s-1).fill(0)]:t.length<s?i=t.concat(new Array(s-t.length).fill(0)):i=t.slice(),i.forEach(l=>{assert(l!==-1,()=>"slice() does not support negative begin indexing.")});let o;return r==null?o=new Array(s).fill(-1):typeof r=="number"?o=[r,...new Array(s-1).fill(-1)]:r.length<s?o=r.concat(new Array(s-r.length).fill(-1)):o=r,o=o.map((l,f)=>l>=0?l:(assert(l===-1,()=>`Negative size values should be exactly -1 but got ${l} for the slice() size at index ${f}.`),n.shape[f]-i[f])),[i,o]}function sliceInfo(n,t,r,i,s,o,l,f,u){let _;if(i==null?(_=new Array(t.length),_.fill(1)):_=i,l!=null&&l&l-1)throw new Error("Multiple ellipses in slice is not allowed.");let g=!1;const a={dims:_.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:r.slice(),strides:_.slice(),beginMask:s,endMask:o,ellipsisMask:l,newAxisMask:f,shrinkAxisMask:u};for(let E=0;E<a.dims;E++)g&&1<<E&f&&a.numAddAxisAfterEllipsis++,1<<E&l&&(g=!0);g||(a.ellipsisMask|=1<<a.dims,a.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};buildDenseSpec(a,m);let b=!0,v=!0,c=!0;const w=[],k=[];for(let E=0;E<n.length;++E){if(m.strides[E]===0)throw Error(`strides[${E}] must be non-zero`);const O=!!(m.shrinkAxisMask&1<<E),A=n[E];if(A===-1){w.push(O?1:-1);continue}const T=[m.beginMask&1<<E,m.endMask&1<<E],j=[m.strides[E]>0?0:-1,m.strides[E]>0?A:A-1];if(O&&m.strides[E]<=0)throw Error("only stride 1 allowed on non-range indexing.");c=c&&m.strides[E]===1;const I=!!(m.beginMask&1<<E&&m.endMask&1<<E);if(m.beginValid&&m.endValid){if(O){const M=m.begin[E]<0?A+m.begin[E]:m.begin[E];if(m.begin[E]=M,m.end[E]=m.begin[E]+1,M<0||M>=A)throw Error(`slice index ${m.begin[E]} of dimension ${E} out of bounds.`)}else m.begin[E]=canonical(m.begin[E],0,m.strides[E],A,T,j),m.end[E]=canonical(m.end[E],1,m.strides[E],A,T,j);const N=m.strides[E]===1&&m.begin[E]===0&&m.end[E]===A;b=b&&N,v=v&&(E===0&&m.strides[E]===1||N)}else b=b&&m.strides[E]===1&&I,v=v&&(E===0&&m.strides[E]===1||I);let D,$=!1;if(m.beginValid&&m.endValid?(D=m.end[E]-m.begin[E],$=!0):O?(D=1,$=!0):I&&A>=0&&(m.strides[E]<0?D=-A:D=A,$=!0),$){let N;D===0||D<0!=m.strides[E]<0?N=0:N=Math.trunc(D/m.strides[E])+(D%m.strides[E]!==0?1:0),w.push(N)}else w.push(-1)}for(let E=0;E<m.finalShapeGatherIndices.length;++E){const O=m.finalShapeGatherIndices[E];O>=0?k.push(w[O]):O===NEW_AXIS&&k.push(1)}return{finalShapeSparse:k.filter((E,O)=>m.finalShapeGatherIndices[O]!==NEW_AXIS),finalShape:k,isIdentity:b,sliceDim0:v,isSimpleSlice:c,begin:m.begin,end:m.end,strides:m.strides}}function buildDenseSpec(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let r=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let i=0;i<n.dims;i++)if(1<<i&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-i)+1+n.numAddAxisAfterEllipsis,t.dims);for(;r<s;r++)t.begin[r]=0,t.end[r]=0,t.strides[r]=1,t.beginMask|=1<<r,t.endMask|=1<<r,t.finalShapeGatherIndices.push(r),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[r]=i}else if(1<<i&n.newAxisMask)t.finalShapeGatherIndices.push(NEW_AXIS),t.finalShapeGatherIndicesSparse.push(-1);else{if(r===t.begin.length)throw Error(`Index out of range using input dim ${r}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[r]=n.begin[i]),n.end!=null&&(t.end[r]=n.end[i]),t.strides[r]=n.strides[i],n.beginMask&1<<i&&(t.beginMask|=1<<r),n.endMask&1<<i&&(t.endMask|=1<<r),n.shrinkAxisMask&1<<i?(t.finalShapeGatherIndices.push(SHRINK_AXIS),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<r):(t.finalShapeGatherIndices.push(r),t.finalShapeGatherIndicesSparse.push(i)),t.inputShapeGatherIndicesSparse[r]=i,r++}}function canonical(n,t,r,i,s,o){if(s[t])return r>0?o[t]:o[t+1&1];{const l=n<0?i+n:n;return l<o[0]?o[0]:l>o[1]?o[1]:l}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertParamsConsistent(n,t){const r=n[0].length;n.forEach((s,o)=>{assert(s.length===r,()=>`Error in concat${r}D: rank of tensors[${o}] must be the same as the rank of the rest (${r})`)}),assert(t>=0&&t<r,()=>`Error in concat${r}D: axis must be between 0 and ${r-1}.`);const i=n[0];n.forEach((s,o)=>{for(let l=0;l<r;l++)assert(l===t||s[l]===i[l],()=>`Error in concat${r}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${i}) along the non-concatenated axis ${o}.`)})}function computeOutShape(n,t){const r=n[0].slice();for(let i=1;i<n.length;i++)r[t]+=n[i][t];return r}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var RowPartitionType$1;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(RowPartitionType$1||(RowPartitionType$1={}));function combineRaggedTensorToTensorShapes(n,t,r){let i=new Array;if(r==null&&t==null)return i;if(t==null)for(;i.length<n+r.length;)i.push(-1);else i=t.slice();if(r==null)return i;if(n+r.length!==i.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+r.length}, but shape.rank = ${i.length}`);for(let s=1;s<r.length;++s){const o=r[s],l=i[i.length-r.length+s],f=i[l];if(o>=0)if(f>=0){if(f!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${o} but shape[${s+n}] = ${f}`)}else i[l]=o}return i}function getRowPartitionTypesHelper(n){const t={FIRST_DIM_SIZE:RowPartitionType$1.FIRST_DIM_SIZE,VALUE_ROWIDS:RowPartitionType$1.VALUE_ROWIDS,ROW_LENGTHS:RowPartitionType$1.ROW_LENGTHS,ROW_SPLITS:RowPartitionType$1.ROW_SPLITS,ROW_LIMITS:RowPartitionType$1.ROW_LIMITS,ROW_STARTS:RowPartitionType$1.ROW_STARTS},r=[];for(const i of n)if(i in t)r.push(t[i]);else break;return r}function getRaggedRank(n){return n.length===0?0:n[0]===RowPartitionType$1.FIRST_DIM_SIZE?n.length-1:n.length}function validateDefaultValueShape(n,t){if(n==null||t==null)return;const r=n.length,i=t.length;if(r>=i)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${r} must be less than ragged tensor input flatValues.rank = ${i})`);for(let s=0;s<Math.min(r,i-1);++s){const o=n[s],l=t[s+1];if(o>=0&&l>=0&&o!==1&&o!==l)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${o} but ragged tensor input.flatValues.shape[${s-n.length}] = ${l}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getImageCenter(n,t,r){const i=r*(typeof n=="number"?n:n[0]),s=t*(typeof n=="number"?n:n[1]);return[i,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getReshaped(n,t,r,i=!0){let s=[];if(i)s=s.concat(t.slice(0)),s.push(n[0]/r),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=t.length;for(let l=0;l<o;++l)s=s.concat([n[l+1]/t[l],t[l]]);s=s.concat(n.slice(o+1))}return s}function getPermuted(n,t,r=!0){const i=[];if(r){i.push(t);for(let s=t+1;s<n;++s)s<=2*t?(i.push(s),i.push(s-(t+1))):i.push(s)}else{const s=[],o=[];for(let l=1;l<n;++l)l>=t*2+1||l%2===1?o.push(l):s.push(l);i.push(...s),i.push(0),i.push(...o)}return i}function getReshapedPermuted(n,t,r,i=!0){const s=[];i?s.push(n[0]/r):s.push(n[0]*r);for(let o=1;o<n.length;++o)o<=t.length?i?s.push(t[o-1]*n[o]):s.push(n[o]/t[o-1]):s.push(n[o]);return s}function getSliceBeginCoords(n,t){const r=[0];for(let i=0;i<t;++i)r.push(n[i][0]);return r}function getSliceSize(n,t,r){const i=n.slice(0,1);for(let s=0;s<r;++s)i.push(n[s+1]-t[s][0]-t[s][1]);return i}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mergeRealAndImagArrays(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const r=new Float32Array(n.length*2);for(let i=0;i<r.length;i+=2)r[i]=n[i/2],r[i+1]=t[i/2];return r}function splitRealAndImagArrays(n){const t=new Float32Array(n.length/2),r=new Float32Array(n.length/2);for(let i=0;i<n.length;i+=2)t[i/2]=n[i],r[i/2]=n[i+1];return{real:t,imag:r}}function complexWithEvenIndex(n){const t=Math.ceil(n.length/4),r=new Float32Array(t),i=new Float32Array(t);for(let s=0;s<n.length;s+=4)r[Math.floor(s/4)]=n[s],i[Math.floor(s/4)]=n[s+1];return{real:r,imag:i}}function complexWithOddIndex(n){const t=Math.floor(n.length/4),r=new Float32Array(t),i=new Float32Array(t);for(let s=2;s<n.length;s+=4)r[Math.floor(s/4)]=n[s],i[Math.floor(s/4)]=n[s+1];return{real:r,imag:i}}function getComplexWithIndex(n,t){const r=n[t*2],i=n[t*2+1];return{real:r,imag:i}}function assignToTypedArray(n,t,r,i){n[i*2]=t,n[i*2+1]=r}function exponents(n,t){const r=new Float32Array(n/2),i=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(t?2:-2)*Math.PI*(s/n);r[s]=Math.cos(o),i[s]=Math.sin(o)}return{real:r,imag:i}}function exponent(n,t,r){const i=(r?2:-2)*Math.PI*(n/t),s=Math.cos(i),o=Math.sin(i);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ARROW="->",ARROW_REGEX=/->/g,COMMA=",",ELLIPSIS="...";function decodeEinsumEquation(n,t){n=n.replace(/\s/g,"");const r=(n.length-n.replace(ARROW_REGEX,"").length)/ARROW.length;if(r<1)throw new Error("Equations without an arrow are not supported.");if(r>1)throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);const[i,s]=n.split(ARROW);assert(i.indexOf(ELLIPSIS)===-1,()=>`The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);const o=i.split(COMMA),l=o.length;if(t!==l)throw new Error(`Expected ${l} input tensors, received ${t}`);if(l>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const f=[];for(let m=0;m<s.length;++m){const b=s[m];if(!o.some(v=>v.indexOf(b)!==-1))throw new Error(`Output subscripts contain the label ${b} not present in the input subscripts.`);f.indexOf(b)===-1&&f.push(b)}for(let m=0;m<i.length;++m){const b=i[m];f.indexOf(b)===-1&&b!==COMMA&&f.push(b)}const u=new Array(o.length);for(let m=0;m<l;++m){if(new Set(o[m].split("")).size!==o[m].length)throw new Error(`Found duplicate axes in input component ${o[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let b=0;b<o[m].length;++b)u[m].push(f.indexOf(o[m][b]))}const _=f.length,g=s.length,a=[];for(let m=g;m<_;++m)a.push(m);return{allDims:f,summedDims:a,idDims:u}}function getEinsumPermutation(n,t){let r=new Array(n);r.fill(-1);for(let s=0;s<t.length;++s)r[t[s]]=s;const i=[];for(let s=0;s<n;++s)r[s]===-1&&i.push(s);return r=r.filter(s=>s!==-1),{permutationIndices:r,expandDims:i}}function checkEinsumDimSizes(n,t,r){const i=new Array(n);for(let s=0;s<r.length;++s){const o=r[s].shape;for(let l=0;l<t[s].length;++l)i[t[s][l]]===void 0?i[t[s][l]]=o[l]:assert(i[t[s][l]]===o[l],()=>`Expected dimension ${i[t[s][l]]} at axis ${l} of input shaped ${JSON.stringify(o)}, but got dimension ${o[l]}`)}}function getEinsumComputePath(n,t){const r=n,i=[];let s=0;n.length===0&&r.push(-1),s=n.length+1;for(let l=0;l<s;++l)i.push([]);const o=[];for(let l=0;l<r.length;++l){const f=r[l],u=findTermsWithDim(t,f);for(const _ of u)o.indexOf(_)===-1&&(i[l].push(_),o.push(_))}return{path:r,steps:i}}function isIdentityPermutation(n){return n.every((t,r)=>t===r)}function findTermsWithDim(n,t){const r=[];for(let i=0;i<n.length;++i)(n[i].length===0||n[i].indexOf(t)!==-1||t===-1)&&r.push(i);return r}function prepareSplitSize(n,t,r=0){let i=[];if(typeof t=="number")assert(n.shape[r]%t===0,()=>"Number of splits must evenly divide the axis."),i=new Array(t).fill(n.shape[r]/t);else{const s=t.reduce((l,f)=>(f===-1&&(l+=1),l),0);assert(s<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(o!==-1){const l=t.reduce((f,u)=>u>0?f+u:f);t[o]=n.shape[r]-l}assert(n.shape[r]===t.reduce((l,f)=>l+f),()=>"The sum of sizes must match the size of the axis dimension."),i=t}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseFillEmptyRowsIndicesDenseShapeMismatch(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function getSparseFillEmptyRowsNegativeIndexErrorMessage(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(n,t,r){return`indices(${n}, 0) is invalid: ${t} >= ${r}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function getSparseReshapeNegativeOutputDimErrorMessage(n,t){return`size ${n} must be non-negative, not ${t}`}function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function getSparseReshapeInputOutputMultipleErrorMessage(n,t){const r=sizeFromShape(n),i=sizeFromShape(t);return`Input to reshape is a SparseTensor with ${r}
  dense values, but the requested shape requires a multiple of ${i}. inputShape=${n} outputShape= ${t}`}function getSparseReshapeInputOutputMismatchErrorMessage(n,t){const r=sizeFromShape(n),i=sizeFromShape(t);return`Input to reshape is a tensor with ${r} dense values, but the requested shape has ${i}. inputShape=${n} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseSegmentReductionNegativeSegmentIdsErrorMessage(){return"segment ids must be >= 0"}function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage(){return"segment ids are not increasing"}function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,t,r){return`Bad: indices[${n}] == ${t} out of range [0, ${r})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function collectGatherOpShapeInfo(n,t,r,i){const s=t.shape.length,o=n.shape.length;if(i!==0&&(i<-s||i>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${i}`);if(i<0&&(i+=s),i>o)throw new Error(`batchDims (${i}) must be less than rank(x) (
    ${o}).`);if(r<i)throw new Error(`batchDims (${i}) must be less than or equal to axis (${r}).`);for(let a=0;a<i;++a)if(n.shape[a]!==t.shape[a])throw new Error(`x.shape[${a}]: ${n.shape[a]} should be equal to indices.shape[${a}]: ${t.shape[a]}.`);const l=n.shape[r],f=[];let u=1,_=1,g=1;for(let a=0;a<i;++a)f.push(n.shape[a]),u*=n.shape[a];for(let a=i;a<r;a++)f.push(n.shape[a]),_*=n.shape[a];for(let a=i;a<s;a++)f.push(t.shape[a]);for(let a=r+1;a<o;a++)f.push(n.shape[a]),g*=n.shape[a];return{batchSize:u,sliceSize:g,outerSize:_,dimSize:l,outputShape:f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fromUint8ToStringArray(n){try{return n.map(t=>decodeString(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function fromStringArrayToUint8(n){return n.map(t=>encodeString(t))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */registerOptimizers();/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertNotComplex(n,t){Array.isArray(n)||(n=[n]),n.forEach(r=>{r!=null&&assert(r.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const whereImpl=whereImpl$1;class MathBackendCPU extends KernelBackend{nextDataId(){return MathBackendCPU.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new DataStorage(this,engine())}write(t,r,i){this.firstUse&&(this.firstUse=!1,env().get("IS_NODE")&&warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:i,refCount:1}),s}makeTensorInfo(t,r,i){let s;if(r==="string"&&i!=null&&i.length>0&&isString(i[0])){const o=i.map(l=>encodeString(l));s=this.write(o,t,r)}else s=this.write(i,t,r);return{dataId:s,shape:t,dtype:r}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const r=this.data.get(t);r.refCount++}decRef(t){if(this.data.has(t)){const r=this.data.get(t);r.refCount--}}move(t,r,i,s,o){this.data.set(t,{values:r,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:r,complexTensorInfos:i}=this.data.get(t);if(r==="complex64"){const s=this.readSync(i.real.dataId),o=this.readSync(i.imag.dataId);return mergeRealAndImagArrays(s,o)}return convertBackendValuesAndArrayBuffer(this.data.get(t).values,r)}bufferSync(t){const r=this.readSync(t.dataId);if(t.dtype==="string")try{const i=r.map(s=>decodeString(s));return buffer(t.shape,t.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(t.shape,t.dtype,r)}makeOutput(t,r,i){return engine().makeTensorFromTensorInfo(this.makeTensorInfo(r,i,t),this)}disposeData(t,r=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!r&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:i}=this.data.get(t);i!=null&&(this.disposeData(i.real.dataId,!0),this.disposeData(i.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const r=now();return t(),{kernelMs:now()-r}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){assertNotComplex([t],"where");const r=this.readSync(t.dataId);return whereImpl(t.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}MathBackendCPU.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function simpleAbsImpl(n){const t=new Float32Array(n.length);for(let r=0;r<n.length;++r)t[r]=Math.abs(n[r]);return t}const abs=n=>{const{x:t}=n.inputs,r=n.backend;assertNotComplex(t,"abs");let i=new Float32Array(sizeFromShape(t.shape));const s=r.data.get(t.dataId).values;return i=simpleAbsImpl(s),r.makeOutput(i,t.shape,t.dtype)},absConfig={kernelName:Abs,backendName:"cpu",kernelFunc:abs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleBinaryKernelImpl(n){return(t,r,i,s,o)=>{const l=assertAndGetBroadcastShape(t,r),f=l.length,u=computeStrides(l),_=sizeFromShape(l),g=getTypedArrayFromDType(o,_),a=t.length,m=r.length,b=computeStrides(t),v=computeStrides(r),c=getBroadcastDims(t,l),w=getBroadcastDims(r,l);if(c.length+w.length===0)for(let k=0;k<g.length;++k)g[k]=n(i[k%i.length],s[k%s.length]);else for(let k=0;k<g.length;++k){const x=indexToLoc(k,f,u),E=x.slice(-a);c.forEach(j=>E[j]=0);const O=locToIndex(E,a,b),A=x.slice(-m);w.forEach(j=>A[j]=0);const T=locToIndex(A,m,v);g[k]=n(i[O],s[T])}return[g,l]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(n){const{inputs:t,backend:r}=n,{real:i,imag:s}=t,o=r.data.get(i.dataId).values,l=r.data.get(s.dataId).values,f=r.makeTensorInfo(i.shape,"complex64"),u=r.data.get(f.dataId);return u.complexTensorInfos={real:r.makeTensorInfo(i.shape,"float32",o),imag:r.makeTensorInfo(s.shape,"float32",l)},f}const complexConfig={kernelName:Complex,backendName:"cpu",kernelFunc:complex};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zeros(n,t,r="float32"){if(r==="complex64"){const s=zeros(n,t,"float32"),o=zeros(n,t,"float32");return complex({inputs:{real:s,imag:o},backend:n})}const i=makeZerosTypedArray(sizeFromShape(t),r);return n.makeTensorInfo(t,r,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity(n){const{inputs:t,backend:r}=n,{x:i}=t;return r.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const identityConfig={kernelName:Identity,backendName:"cpu",kernelFunc:identity};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(n){const{inputs:t,backend:r}=n,{input:i}=t,s=r.data.get(i.dataId).complexTensorInfos.real,o=r.data.get(s.dataId).values;return r.makeTensorInfo(s.shape,s.dtype,o)}const realConfig={kernelName:Real,backendName:"cpu",kernelFunc:real};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function castImpl(n,t,r,i){if(i==="int32"){const s=Int32Array.from(n);return[t,"int32",s]}if(i==="bool"){const s=toTypedArray([0],r),[o,l]=createSimpleBinaryKernelImpl((f,u)=>f!==u?1:0)(t,[],n,s,"bool");return[l,"bool",o]}throw new Error(`Error in Cast: failed to cast ${r} to ${i}`)}function cast(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{dtype:o}=i;if(o==="complex64"){if(s.dtype==="complex64")return identity({inputs:{x:s},backend:r});const g=zeros(r,s.shape,s.dtype),a=cast({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),m=complex({inputs:{real:a,imag:g},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(a),m}if(s.dtype==="complex64"){const g=real({inputs:{input:s},backend:r}),a=cast({inputs:{x:g},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(g),a}if(!hasEncodingLoss(s.dtype,o)){const g=identity({inputs:{x:s},backend:r});return{dataId:g.dataId,shape:g.shape,dtype:o}}const l=r.data.get(s.dataId).values,[f,u,_]=castImpl(l,s.shape,s.dtype,o);return r.makeTensorInfo(f,u,_)}const castConfig={kernelName:Cast,backendName:"cpu",kernelFunc:cast};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function binaryKernelFunc(n,t,r,i){return r==null?({inputs:s,backend:o})=>{const{a:l,b:f}=s,u=o;assertNotComplex([l,f],n);const _=u.data.get(l.dataId).values,g=u.data.get(f.dataId).values,a=l.dtype==="string"?fromUint8ToStringArray(_):_,m=l.dtype==="string"?fromUint8ToStringArray(g):g,b=i||l.dtype,[v,c]=t(l.shape,f.shape,a,m,b);return u.makeTensorInfo(c,b,v)}:({inputs:s,backend:o})=>{const{a:l,b:f}=s,u=o;if(l.dtype==="complex64"||f.dtype==="complex64"){const _=cast({inputs:{x:l},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(_.dataId),a=g.complexTensorInfos.real,m=g.complexTensorInfos.imag,b=u.data.get(a.dataId).values,v=u.data.get(m.dataId).values,c=cast({inputs:{x:f},backend:u,attrs:{dtype:"complex64"}}),w=u.data.get(c.dataId),k=w.complexTensorInfos.real,x=w.complexTensorInfos.imag,E=u.data.get(k.dataId).values,O=u.data.get(x.dataId).values,[A,T,j]=r(l.shape,f.shape,b,v,E,O),I=u.makeTensorInfo(j,"float32",A),D=u.makeTensorInfo(j,"float32",T),$=complex({inputs:{real:I,imag:D},backend:u});return u.disposeIntermediateTensorInfo(_),u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(I),u.disposeIntermediateTensorInfo(D),$}else{const _=u.data.get(l.dataId).values,g=u.data.get(f.dataId).values,a=i||l.dtype,[m,b]=t(l.shape,f.shape,_,g,a);return u.makeTensorInfo(b,a,m)}}}function createComplexBinaryKernelImpl(n){return(t,r,i,s,o,l)=>{const f=assertAndGetBroadcastShape(t,r),u=sizeFromShape(f),_=f.length,g=computeStrides(f),a=getTypedArrayFromDType("float32",u),m=getTypedArrayFromDType("float32",u),b=getBroadcastDims(t,f),v=getBroadcastDims(r,f),c=mergeRealAndImagArrays(i,s),w=mergeRealAndImagArrays(o,l),k=t.length,x=computeStrides(t),E=r.length,O=computeStrides(r);if(b.length+v.length===0)for(let A=0;A<a.length;A++){const T=A%c.length,j=A%w.length,I=n(c[T*2],c[T*2+1],w[j*2],w[j*2+1]);a[A]=I.real,m[A]=I.imag}else for(let A=0;A<a.length;A++){const T=indexToLoc(A,_,g),j=T.slice(-k);b.forEach(M=>j[M]=0);const I=locToIndex(j,k,x),D=T.slice(-E);v.forEach(M=>D[M]=0);const $=locToIndex(D,E,O),N=n(c[I*2],c[I*2+1],w[$*2],w[$*2+1]);a[A]=N.real,m[A]=N.imag}return[a,m,f]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const addImpl=createSimpleBinaryKernelImpl((n,t)=>n+t),addComplexImpl=createComplexBinaryKernelImpl((n,t,r,i)=>({real:n+r,imag:t+i})),add=binaryKernelFunc(Add,addImpl,addComplexImpl),addConfig={kernelName:Add,backendName:"cpu",kernelFunc:add};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincountImpl(n,t,r,i,s){const o=sizeFromShape(i),l=makeZerosTypedArray(s,r);for(let f=0;f<n.length;f++){const u=n[f];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(o>0?l[u]+=t[f]:l[u]+=1)}return l}function bincountReduceImpl(n,t,r,i=!1){const s=n.shape[0],o=n.shape[1],l=buffer([s,r],t.dtype);for(let f=0;f<s;f++)for(let u=0;u<o;u++){const _=n.get(f,u);if(_<0)throw new Error("Input x must be non-negative!");_>=r||(i?l.set(1,f,_):t.size>0?l.set(l.get(f,_)+t.get(f,u),f,_):l.set(l.get(f,_)+1,f,_))}return l}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bitwiseAndImpl=createSimpleBinaryKernelImpl((n,t)=>n&t),bitwiseAnd=binaryKernelFunc(BitwiseAnd,bitwiseAndImpl),bitwiseAndConfig={kernelName:BitwiseAnd,backendName:"cpu",kernelFunc:bitwiseAnd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleUnaryImpl(n){return(t,r,i)=>{const s=getArrayFromDType(r,t.length);for(let o=0;o<t.length;++o)s[o]=n(t[o],i);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unaryKernelFunc(n,t,r){const i=createSimpleUnaryImpl(t);return unaryKernelFuncFromImpl(n,i,r)}function unaryKernelFuncFromImpl(n,t,r){return({inputs:i,attrs:s,backend:o})=>{const{x:l}=i;assertNotComplex(l,n);const f=o,u=f.data.get(l.dataId).values;let _;if(l.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");_=fromUint8ToStringArray(u)}else _=u;const g=r||l.dtype,a=t(_,g,s);return f.makeTensorInfo(l.shape,g,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ceilImpl=createSimpleUnaryImpl(n=>Math.ceil(n)),ceil=unaryKernelFuncFromImpl(Ceil,ceilImpl),ceilConfig={kernelName:Ceil,backendName:"cpu",kernelFunc:ceil};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl(n,t,r,i){const s=getArrayFromDType(r,sizeFromShape(t));if(i&&r!=="string"){let o=0;n.forEach(l=>{const f=sizeFromShape(l.shape);s.set(l.vals,o),o+=f})}else{let o=0;n.forEach(l=>{const f=r==="string"?fromUint8ToStringArray(l.vals):l.vals;let u=0;for(let _=0;_<l.shape[0];++_){const g=_*t[1]+o;for(let a=0;a<l.shape[1];++a)s[g+a]=f[u++]}o+=l.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const equalImpl=createSimpleBinaryKernelImpl((n,t)=>n===t?1:0),equal=binaryKernelFunc(Equal,equalImpl,null,"bool"),equalConfig={kernelName:Equal,backendName:"cpu",kernelFunc:equal};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const expImpl=createSimpleUnaryImpl(n=>Math.exp(n)),exp=unaryKernelFuncFromImpl(Exp,expImpl,"float32"),expConfig={kernelName:Exp,backendName:"cpu",kernelFunc:exp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const expm1Impl=createSimpleUnaryImpl(n=>Math.expm1(n)),expm1=unaryKernelFuncFromImpl(Expm1,expm1Impl),expm1Config={kernelName:Expm1,backendName:"cpu",kernelFunc:expm1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const floorImpl=createSimpleUnaryImpl(n=>Math.floor(n)),floor=unaryKernelFuncFromImpl(Floor,floorImpl),floorConfig={kernelName:Floor,backendName:"cpu",kernelFunc:floor};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const floorDivImpl=createSimpleBinaryKernelImpl((n,t)=>Math.floor(n/t)),floorDiv=binaryKernelFunc(FloorDiv,floorDivImpl,null,"int32"),floorDivConfig={kernelName:FloorDiv,backendName:"cpu",kernelFunc:floorDiv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherNdImpl(n,t,r,i,s,o,l,f,u){const _=buffer([i,o],r);for(let g=0;g<i;g++){const a=[];let m=0;for(let b=0;b<s;b++){const v=n[g*s+b];m+=v*l[b],a.push(v)}if(m<0||m>=u/o)throw new Error(`Invalid indices: ${a} does not index into ${f}`);for(let b=0;b<o;b++)_.values[g*o+b]=t.get(...t.indexToLoc(m*o+b))}return _}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2Impl(n,t,r){const i=buffer(r,n.dtype);for(let s=0;s<i.size;++s){const l=i.indexToLoc(s).slice(),f=l[0],u=l[2],_=t.locToIndex([f,u]);l[2]=t.values[_];const g=n.locToIndex(l);0<=g&&g<n.values.length&&(i.values[s]=n.values[g])}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const greaterImpl=createSimpleBinaryKernelImpl((n,t)=>n>t?1:0),greater=binaryKernelFunc(Greater,greaterImpl,null,"bool"),greaterConfig={kernelName:Greater,backendName:"cpu",kernelFunc:greater};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const greaterEqualImpl=createSimpleBinaryKernelImpl((n,t)=>n>=t?1:0),greaterEqual=binaryKernelFunc(GreaterEqual,greaterEqualImpl,null,"bool"),greaterEqualConfig={kernelName:GreaterEqual,backendName:"cpu",kernelFunc:greaterEqual};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lessImpl=createSimpleBinaryKernelImpl((n,t)=>n<t?1:0),less=binaryKernelFunc(Less,lessImpl,null,"bool"),lessConfig={kernelName:Less,backendName:"cpu",kernelFunc:less};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lessEqualImpl=createSimpleBinaryKernelImpl((n,t)=>n<=t?1:0),lessEqual=binaryKernelFunc(LessEqual,lessEqualImpl,null,"bool"),lessEqualConfig={kernelName:LessEqual,backendName:"cpu",kernelFunc:lessEqual};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpaceImpl(n,t,r){const i=(t-n)/(r-1),s=makeZerosTypedArray(r,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+i;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logImpl=createSimpleUnaryImpl(n=>Math.log(n)),log=unaryKernelFuncFromImpl(Log,logImpl),logConfig={kernelName:Log,backendName:"cpu",kernelFunc:log};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxImpl(n,t,r,i){const s=getTypedArrayFromDType(i,sizeFromShape(r));for(let o=0;o<s.length;++o){const l=o*t;let f=n[l];for(let u=0;u<t;++u){const _=n[l+u];(Number.isNaN(_)||_>f)&&(f=_)}s[o]=f}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maximumImpl=createSimpleBinaryKernelImpl((n,t)=>Math.max(n,t)),maximum=binaryKernelFunc(Maximum,maximumImpl),maximumConfig={kernelName:Maximum,backendName:"cpu",kernelFunc:maximum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const minimumImpl=createSimpleBinaryKernelImpl((n,t)=>Math.min(n,t)),minimum=binaryKernelFunc(Minimum,minimumImpl),minimumConfig={kernelName:Minimum,backendName:"cpu",kernelFunc:minimum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const multiplyImpl=createSimpleBinaryKernelImpl((n,t)=>n*t),multiplyComplexImpl=createComplexBinaryKernelImpl((n,t,r,i)=>({real:n*r-t*i,imag:n*i+t*r})),multiply=binaryKernelFunc(Multiply,multiplyImpl,multiplyComplexImpl),multiplyConfig={kernelName:Multiply,backendName:"cpu",kernelFunc:multiply};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function negImpl(n,t,r){const i=createScalarValue(-1,r);return multiplyImpl([],t,i,n,r)}function neg(n){const{inputs:t,backend:r}=n,{x:i}=t;assertNotComplex(i,"neg");const s=r.data.get(i.dataId).values,[o,l]=negImpl(s,i.shape,i.dtype);return r.makeTensorInfo(l,i.dtype,o)}const negConfig={kernelName:Neg,backendName:"cpu",kernelFunc:neg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const notEqualImpl=createSimpleBinaryKernelImpl((n,t)=>n!==t?1:0),notEqual=binaryKernelFunc(NotEqual,notEqualImpl,null,"bool"),notEqualConfig={kernelName:NotEqual,backendName:"cpu",kernelFunc:notEqual};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl(n,t,r,i,s){const o=t.length,l=sizeFromShape(t),f=computeStrides(t),u=computeStrides(s),_=getTypedArrayFromDType(r,sizeFromShape(s));for(let g=0;g<l;++g){const a=indexToLoc(g,o,f),m=new Array(a.length);for(let v=0;v<m.length;v++)m[v]=a[i[v]];const b=locToIndex(m,o,u);_[b]=n[g]}return _}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose(n){const{inputs:t,attrs:r,backend:i}=n,{x:s}=t,{perm:o}=r;assertNotComplex(s,"transpose");const l=s.shape.length,f=new Array(l);for(let a=0;a<f.length;a++)f[a]=s.shape[o[a]];const u=i.data.get(s.dataId).values,_=transposeImpl(u,s.shape,s.dtype,o,f);return{dataId:i.write(_,f,s.dtype),shape:f,dtype:s.dtype}}const transposeConfig={kernelName:Transpose,backendName:"cpu",kernelFunc:transpose};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prodImpl(n,t,r,i){const[s,o]=computeOutAndReduceShapes(n,i),l=upcastType(t,"int32"),f=makeZerosTypedArray(sizeFromShape(s),l),u=sizeFromShape(o);for(let _=0;_<f.length;++_){const g=_*u;let a=1;for(let m=0;m<u;++m)a*=r[g+m];f[_]=a}return{outVals:f,outShape:s,outDtype:l}}function prod(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,keepDims:l}=i;assertNotComplex(s,"prod");const f=s.shape.length,u=parseAxisParam(o,s.shape),_=getAxesPermutation(u,f);let g=u,a=s;const m=[];_!=null&&(a=transpose({inputs:{x:s},backend:r,attrs:{perm:_}}),m.push(a),g=getInnerMostAxes(g.length,f));const b=r.data.get(a.dataId).values,{outVals:v,outShape:c,outDtype:w}=prodImpl(a.shape,a.dtype,b,g);let k=c;return l&&(k=expandShapeToKeepDim(c,u)),m.forEach(x=>r.disposeIntermediateTensorInfo(x)),r.makeTensorInfo(k,w,v)}const prodConfig={kernelName:Prod,backendName:"cpu",kernelFunc:prod};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function validateIndices(n,t,r){n.forEach((i,s)=>{if(i<0||i>=r){const o=indexToLoc(s,t.length,computeStrides(t)).join(",");throw new Error(`indices[${o}] = ${i} is not in [0, ${r})`)}})}function validateSplits(n,t){for(let r=0;r<n.length;++r){const i=n[r],s=r===n.length-1?t:n[r+1].length;if(i.length===0)throw new Error("Ragged splits may not be empty");if(i[0]<0)throw new Error("Ragged splits must be non-negative");if(i[i.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<i.length;++o)if(i[o-1]>i[o])throw new Error("Ragged splits must be sorted in ascending order")}}function makeSplits(n,t,r,i){const s=[];let o=0;const l=t.length-1+r.length,f=new Array(l).fill(null).map(()=>[0]);validateSplits(r,i);let u=1;for(let _=0;_<t.length-1;++_){u*=t[_];const g=t[_+1];for(let a=1;a<u+1;++a)f[_].push(a*g)}for(let _=0;_<n.length;++_){let g=n[_],a=n[_]+1;for(let m=0;m<r.length;++m){const b=r[m],v=m+t.length-1;if(v>=0){const c=f[v],w=c[c.length-1]-b[g];for(let k=g;k<a;++k)f[v].push(b[k+1]+w)}g=b[g],a=b[a]}a!==g&&(s.push([g,a]),o+=a-g)}return{outSplits:f,valueSlices:s,numValues:o}}function getSplits(n){const t=[];for(let r=0;r<n.length;++r){const i=n[r].length,s=getArrayFromDType("int32",i);t.push(s),n[r].forEach((o,l)=>s[l]=o)}return t}function computeFlatOuterDims(n,t){const r=n.slice(0,t);for(;r.length<t;)r.push(1);for(let i=t;i<n.length;i++)r[t-1]*=n[i];return r}function writeValueSlices(n,t,r,i,s,o){const l=computeFlatOuterDims(t,2)[1],f=computeFlatOuterDims(o,2)[1];let u=0;for(const _ of r)for(let g=_[0];g<_[1];++g){for(let a=0;a<i;++a)s[u*f+a]=n[g*l+a];++u}}function getValues(n,t,r,i,s){const o=t.slice();o[0]=s;const l=getArrayFromDType(r,sizeFromShape(o)),f=n.length,u=f===0?0:f/t[0];return writeValueSlices(n,t,i,u,l,o),[l,o]}function raggedGatherImpl(n,t,r,i,s,o,l,f){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const u=t[0][0]-1;if(validateIndices(o,l,u),i.length===0)throw new Error("params.rank must be nonzero");const _=i[0],{outSplits:g,valueSlices:a,numValues:m}=makeSplits(o,l,n,_),b=getSplits(g),v=getValues(r,i,s,a,m);return[b,v[0],v[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const INT32_MAX=2147483647;function raggedRangeImpl(n,t,r,i,s,o,l){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(l.length>1)throw new Error("deltas must be a scalar or vector");const f=t.length===0,u=s.length===0,_=l.length===0,g=[];f||g.push(t[0]),u||g.push(s[0]),_||g.push(l[0]);for(let w=1;w<g.length;++w)if(g[w]!==g[w-1])throw new Error("starts, limits, and deltas must have the same shape");const a=g.length===0?1:g[0],m=getArrayFromDType("int32",a+1);m[0]=0;for(let w=0;w<a;++w){const k=f?n[0]:n[w],x=u?i[0]:i[w],E=_?o[0]:o[w];if(E===0)throw new Error("Requires delta != 0");let O;if(E>0&&x<k||E<0&&x>k)O=0;else if(O=Math.ceil(Math.abs((x-k)/E)),O>INT32_MAX)throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);m[w+1]=m[w]+O}const b=m[a],v=getArrayFromDType(r,b);let c=0;for(let w=0;w<a;++w){const k=m[w+1]-m[w];let x=f?n[0]:n[w];const E=_?o[0]:o[w];for(let O=0;O<k;++O)v[c++]=x,x+=E}return[m,v]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var RowPartitionType=RowPartitionType$1;class RaggedTensorToTensorOp{constructor(t,r,i,s,o,l,f,u,_,g){this.shape=t,this.shapeShape=r,this.values=i,this.valuesShape=s,this.valuesDType=o,this.defaultValue=l,this.defaultValueShape=f,this.rowPartitionValues=u,this.rowPartitionValuesShapes=_,this.rowPartitionTypes=getRowPartitionTypesHelper(g),this.raggedRank=getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===RowPartitionType.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===RowPartitionType.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const r=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case RowPartitionType.VALUE_ROWIDS:return RaggedTensorToTensorOp.getMaxWidthValueRowID(r);case RowPartitionType.ROW_SPLITS:return RaggedTensorToTensorOp.getMaxWidthRowSplit(r);default:throw new Error(`Cannot handle partition type ${RowPartitionType[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const r=t.length;if(r===0||r===1)return 0;let i=0;for(let s=0;s<r-1;++s){const o=t[s+1]-t[s];o>i&&(i=o)}return i}static getMaxWidthValueRowID(t){const r=t.length;if(r===0)return 0;let i=0,s=t[0],o=0;for(let l=1;l<r;++l){const f=t[l];f!==s&&(s=f,o=Math.max(l-i,o),i=l)}return Math.max(r-i,o)}tensorShapeFromTensor(t,r,i=!0){if(r.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return makeShape(t,i)}calculateOutputSize(t){const r=this.valuesShape,i=this.defaultValueShape;validateDefaultValueShape(i,r);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),l=combineRaggedTensorToTensorShapes(this.raggedRank,s,r);l[0]<0&&(l[0]=t);for(let f=1;f<=this.raggedRank;++f)l[f]<0&&(l[f]=this.getMaxWidth(f));return l}calculateFirstParentOutputIndex(t,r,i){const s=Math.min(t,i),o=[];let l=0;for(let f=0;f<s;++f,l+=r)o.push(l);for(let f=s;f<t;++f)o.push(-1);return assert(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,r,i,s){const o=t.length,l=[];for(let f=0;f<o-1;++f){const u=t[f+1]-t[f];let _=Math.min(s,u),g=r[f];g===-1&&(_=0);for(let a=0;a<_;++a)l.push(g),g+=i;for(let a=0;a<u-_;++a)l.push(-1)}if(o>0&&l.length!==t[o-1])throw new Error("Invalid row split size.");return l}calculateOutputIndexValueRowID(t,r,i,s){const o=t.length,l=[];if(o===0)return[];let f=0,u=t[0];if(u>=r.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${r.length}`);let _=r[u];l.push(_);for(let g=1;g<o;++g){const a=t[g];if(a===u)_>=0&&(++f,f<s?_+=i:_=-1);else{if(f=0,u=a,a>=r.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${r.length}`);_=r[a]}l.push(_)}if(l.length!==t.length)throw new Error("Invalid row ids.");return l}calculateOutputIndex(t,r,i,s){const o=this.getRowPartitionTensor(t),l=this.getRowPartitionTypeByDimension(t);switch(l){case RowPartitionType.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,r,i,s);case RowPartitionType.ROW_SPLITS:if(o.length-1>r.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${r.length}`);return this.calculateOutputIndexRowSplit(o,r,i,s);default:throw new Error(`Unsupported partition type: ${RowPartitionType[l]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const r=this.rowPartitionTypes[0];switch(r){case RowPartitionType.FIRST_DIM_SIZE:return t[0];case RowPartitionType.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case RowPartitionType.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${RowPartitionType[r]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const r=this.getFirstDimensionSize(),i=this.calculateOutputSize(r),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let u=s.length-2;u>=0;--u)s[u]=s[u+1]*i[u+1];const o=makeShape(i,!1),l=getArrayFromDType(this.valuesDType,sizeFromShape(o));if(s[0]*i[0]>0){let u=this.calculateFirstParentOutputIndex(r,s[0],i[0]);for(let _=1;_<=this.raggedRank;++_)u=this.calculateOutputIndex(_-1,u,s[_],i[_]);this.setOutput(this.raggedRank,u,l,o)}return[o,l]}setOutput(t,r,i,s){if(i.length===0)return;const o=this.values,l=i;let f=s.slice();f=f.slice(t+1);const u=sizeFromShape(f),_=r.length;let g=this.defaultValue;if(g.length!==u&&g.length!==1){const v=this.defaultValueShape;tidy(()=>{const c=reshape$1(g,v);g=broadcastTo(c,f).dataSync()})}let a=0,m=0,b=0;for(let v=0;v<=_;++v){let c=v<_?r[v]:-1;if(c===b){++b;continue}if(m<b){const w=o.subarray(a*u),k=l.subarray(m*u),x=(b-m)*u;copyArray(k,w,x)}if(v>=_){const w=i.length;c=Math.floor(w/u)}if(c>b)if(this.defaultValue.length===1)l.subarray(b*u,c*u).fill(this.defaultValue[0]),b=c;else for(;c>b;){const w=l.slice(b*u);copyArray(w,g,u),++b}c<0?(a=v+1,m=b):(a=v,m=b,b=m+1)}}}function copyArray(n,t,r){for(let i=0;i<r;i++)n[i]=t[i]}function makeShape(n,t){const r=[];for(let i of n){if(i<0){if(!t)throw new Error(`Dimension ${i} must be >= 0`);if(i<-1)throw new Error(`Dimension ${i} must be >= -1`);i=-1}r.push(i)}return r}function raggedTensorToTensorImpl(n,t,r,i,s,o,l,f,u,_){return new RaggedTensorToTensorOp(n,t,r,i,s,o,l,f,u,_).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rangeImpl(n,t,r,i){const s=n===t,o=n<t&&r<0,l=t<n&&r>1;if(s||o||l)return makeZerosTypedArray(0,i);const f=Math.abs(Math.ceil((t-n)/r)),u=makeZerosTypedArray(f,i);t<n&&r===1&&(r=-1),u[0]=n;for(let _=1;_<u.length;_++)u[_]=u[_-1]+r;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rsqrtImpl=createSimpleUnaryImpl(n=>1/Math.sqrt(n)),rsqrt=unaryKernelFuncFromImpl(Rsqrt,rsqrtImpl),rsqrtConfig={kernelName:Rsqrt,backendName:"cpu",kernelFunc:rsqrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterImpl(n,t,r,i,s,o,l,f,u,_){const g=[i/s,s],a=n.values,m=t.values;if(i===0)return buffer(r,t.dtype);const b=u instanceof TensorBuffer?u:buffer(g,t.dtype);typeof u=="string"||typeof u=="number"?b.values.fill(u):typeof u=="boolean"&&b.values.fill(+u);for(let v=0;v<o;v++){const c=[];let w=0;for(let k=0;k<l;k++){const x=a[v*l+k];c.push(x),w+=x*f[k]}if(w<0||w>=i/s)throw new Error(`Invalid indices: ${c} does not index into ${r}`);for(let k=0;k<s;k++)_?b.values[w*s+k]+=m[v*s+k]:b.values[w*s+k]=t.rank===0?m[0]:m[v*s+k]}return b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sigmoid=unaryKernelFunc(Sigmoid,n=>1/(1+Math.exp(-n))),sigmoidConfig={kernelName:Sigmoid,backendName:"cpu",kernelFunc:sigmoid};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sliceImpl(n,t,r,i,s){const o=isSliceContinous(i,t,r),l=sizeFromShape(r),f=computeStrides(i);if(o){const a=computeFlatOffset(t,f);return s==="string"?n.slice(a,a+l):n.subarray(a,a+l)}const u=s==="string"?fromUint8ToStringArray(n):n,_=buffer(i,s,u),g=buffer(r,s);for(let a=0;a<g.size;++a){const m=g.indexToLoc(a),b=m.map((v,c)=>v+t[c]);g.set(_.get(...b),...m)}return s==="string"?fromStringArrayToUint8(g.values):g.values}function slice(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{begin:o,size:l}=i;assertNotComplex(s,"slice");const[f,u]=parseSliceParams(s,o,l);assertParamsValid(s,f,u);const _=r.data.get(s.dataId).values,g=sliceImpl(_,f,u,s.shape,s.dtype);return r.makeTensorInfo(u,s.dtype,g)}const sliceConfig={kernelName:Slice,backendName:"cpu",kernelFunc:slice};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseFillEmptyRowsImpl(n,t,r,i,s,o,l){const f=t[0],u=o[0],_=new Array(u),g=new Array(f),a=t[1];if(u===0){if(f!==0)throw new Error(getSparseFillEmptyRowsIndicesDenseShapeMismatch(f));const w=getArrayFromDType(r,0),k=getArrayFromDType(s,0);return[w,[0,a],k,_,g]}let m=!0,b=0;const v=new Array(u).fill(0);for(let w=0;w<f;++w){const k=n[w*a];if(k<0)throw new Error(getSparseFillEmptyRowsNegativeIndexErrorMessage(w,k));if(k>=u)throw new Error(getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(w,k,u));++v[k],m=m&&k>=b,b=k}let c=!0;for(let w=0;w<u;++w){const k=v[w]===0;_[w]=k,c=c&&!k,v[w]=Math.max(v[w],1),w>0&&(v[w]+=v[w-1])}if(c&&m){const w=n,k=i;for(let x=0;x<f;++x)g[x]=x;return[w,[f,a],k,_,g]}else{const w=v[u-1],k=getArrayFromDType(r,w*a),x=getArrayFromDType(s,w),E=new Array(u).fill(0);for(let O=0;O<f;++O){const A=n[O*a],T=E[A],j=(A===0?0:v[A-1])+T;E[A]++;for(let I=0;I<a;++I)k[j*a+I]=n[O*a+I];x[j]=i[O],g[O]=j}for(let O=0;O<u;++O)if(E[O]===0){const T=O===0?0:v[O-1];k[T*a+0]=O;for(let j=1;j<a;++j)k[T*a+j]=0;x[T]=l}return[k,[w,a],x,_,g]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseReshapeImpl(n,t,r,i,s){const o=sizeFromShape(i),l=t[0],f=s.length,u=[];let _=1,g=-1;for(let w=0;w<f;++w){const k=s[w];if(k===-1){if(g!==-1)throw new Error(getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(g,w));g=w,u.push(1)}else{if(k<0)throw new Error(getSparseReshapeNegativeOutputDimErrorMessage(w,k));_*=k,u.push(k)}}if(g!==-1){if(_<=0)throw new Error(getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const w=Math.trunc(o/_);if(_*w!==o)throw new Error(getSparseReshapeInputOutputMultipleErrorMessage(i,u));u[g]=w}if(sizeFromShape(u)!==o)throw new Error(getSparseReshapeInputOutputMismatchErrorMessage(i,u));const m=i.length,b=[];if(m>0){b[m-1]=1;for(let w=m-2;w>=0;--w)b[w]=b[w+1]*i[w+1]}const v=[];if(f>0){v[f-1]=1;for(let w=f-2;w>=0;--w)v[w]=v[w+1]*u[w+1]}const c=getArrayFromDType(r,l*f);for(let w=0;w<l;++w){let k=0;for(let x=0;x<m;++x)k+=n[w*m+x]*b[x];for(let x=0;x<f;++x)c[w*f+x]=Math.trunc(k/v[x]),k%=v[x]}return[c,[l,f],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentReductionImpl(n,t,r,i,s,o=!1,l=0){const f=i.length,u=[t[0],n.length/t[0]],_=u[1],a=f>0?s[f-1]+1:0;if(a<0)throw new Error(getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const m=t.slice();m[0]=a;const b=m.reduce((E,O)=>E*O,1),v=getArrayFromDType(r,b);if(f===0)return a>0&&v.fill(l),[v,m];if(a<=0)throw new Error(getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=0,w=1,k=0,x=s[c];for(;;){let E=0;if(w<f){if(E=s[w],x===E){++w;continue}if(x>=E)throw new Error(getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=a)throw new Error(getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,a));x>k&&v.fill(l,k*_,x*_);for(let O=c;O<w;++O){const A=i[O];if(A<0||A>=u[0])throw new Error(getSparseSegmentReductionIndicesOutOfRangeErrorMessage(O,i[O],u[0]));for(let T=0;T<_;T++)v[x*_+T]+=n[A*_+T]}if(o)for(let O=0;O<_;O++)v[x*_+O]/=w-c;if(c=w,++w,k=x+1,x=E,w>f)break}return k<a&&v.fill(l,k*_,a*_),[v,m]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sqrt=unaryKernelFunc(Sqrt,n=>Math.sqrt(n)),sqrtConfig={kernelName:Sqrt,backendName:"cpu",kernelFunc:sqrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const squaredDifferenceImpl=createSimpleBinaryKernelImpl((n,t)=>{const r=n-t;return r*r}),squaredDifference=binaryKernelFunc(SquaredDifference,squaredDifferenceImpl),squaredDifferenceConfig={kernelName:SquaredDifference,backendName:"cpu",kernelFunc:squaredDifference};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const staticRegexReplaceImpl=createSimpleUnaryImpl((n,t)=>{const{pattern:r,replaceGlobal:i,rewrite:s}=t;return n.replace(new RegExp(r,i?"g":""),s)}),staticRegexReplace=unaryKernelFuncFromImpl(StaticRegexReplace,staticRegexReplaceImpl),staticRegexReplaceConfig={kernelName:StaticRegexReplace,backendName:"cpu",kernelFunc:staticRegexReplace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSliceImpl(n,t,r,i){const s=buffer(n,t.dtype);for(let o=0;o<s.size;o++){const l=s.indexToLoc(o),f=new Array(l.length);for(let u=0;u<f.length;u++)f[u]=l[u]*r[u]+i[u];s.set(t.get(...f),...l)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class StringNGramsOp{constructor(t,r,i,s,o,l){this.separator=encodeString(t),this.nGramWidths=r,this.leftPad=encodeString(i),this.rightPad=encodeString(s),this.padWidth=o,this.preserveShort=l}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,r){const i=this.getPadWidth(r);return Math.max(0,t+2*i-r+1)}createNGrams(t,r,i,s,o,l){for(let f=0;f<o;++f){const u=this.getPadWidth(l),_=Math.max(0,u-f),g=Math.max(0,u-(o-(f+1))),a=l-(_+g),m=r+(_>0?0:f-u);let b=0;b+=_*this.leftPad.length;for(let x=0;x<a;++x)b+=t[m+x].length;b+=g*this.rightPad.length;const v=_+g+a-1;b+=v*this.separator.length,i[s+f]=new Uint8Array(b);const c=i[s+f];let w=0;const k=x=>x.forEach(E=>c[w++]=E);for(let x=0;x<_;++x)k(this.leftPad),k(this.separator);for(let x=0;x<a-1;++x)k(t[m+x]),k(this.separator);if(a>0){k(t[m+a-1]);for(let x=0;x<g;++x)k(this.separator),k(this.rightPad)}else{for(let x=0;x<g-1;++x)k(this.rightPad),k(this.separator);k(this.rightPad)}}}compute(t,r){const i=t.length,s=r.length;if(s>0){let u=r[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let _=1;_<s;++_){let g=r[_]>=u;if(g=g&&r[_]<=i,!g)throw new Error(`Invalid split value ${r[_]}, must be in [${u}, ${i}]`);u=r[_]}if(u!==i)throw new Error(`Last split value must be data size. Expected ${i}, got ${u}`)}const o=s-1,l=getArrayFromDType("int32",s);if(i===0||s===0){const u=new Array(i);for(let _=0;_<=o;++_)l[_]=0;return[u,l]}l[0]=0;for(let u=1;u<=o;++u){const _=r[u]-r[u-1];let g=0;this.nGramWidths.forEach(a=>{g+=this.getNumNGrams(_,a)}),this.preserveShort&&_>0&&g===0&&(g=1),l[u]=l[u-1]+g}const f=new Array(l[o]);for(let u=0;u<o;++u){const _=r[u];let g=l[u];if(this.nGramWidths.forEach(a=>{const m=r[u+1]-r[u],b=this.getNumNGrams(m,a);this.createNGrams(t,_,f,g,b,a),g+=b}),this.preserveShort&&g===l[u]){const a=r[u+1]-r[u];if(a===0)continue;const m=a+2*this.padWidth,b=1;this.createNGrams(t,_,f,g,b,m)}}return[f,l]}}function stringNGramsImpl(n,t,r,i,s,o,l,f){return new StringNGramsOp(r,i,s,o,l,f).compute(n,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function split(n,t,r,i){if(!n.length)return;if(t.length===0){for(let o=0;o<n.length;++o)i.push(n.subarray(o,o+1));return}if(t.length===1){const o=t[0];let l=n.indexOf(o);for(;l!==-1;){const f=n.subarray(0,l);(!r||f.length!==0)&&i.push(f),n=n.subarray(l+1),l=n.indexOf(o)}(!r||n.length!==0)&&i.push(n);return}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||t.indexOf(n[o])!==-1){const l=n.subarray(s,o);(!r||l.length!==0)&&i.push(l),s=o+1}}function stringSplitImpl(n,t,r){const i=n.length,s=[];let o=0,l=0;const f=new Array(i);for(let m=0;m<i;++m){const b=s.length;split(n[m],t,r,s);const v=s.length-b;f[m]=v,o+=v,l=Math.max(l,v)}const u=getArrayFromDType("int32",o*2),_=new Array(o),g=[i,l];let a=0;for(let m=0;m<i;++m)for(let b=0;b<f[m];++b)u[a*2]=m,u[a*2+1]=b,_[a]=s[a],++a;return[u,_,g]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringToHashBucketFastImpl(n,t){const r=getArrayFromDType("int32",n.length);for(let i=0;i<n.length;++i)r[i]=fingerPrint64(n[i]).modulo(t).getLowBitsUnsigned();return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const subImpl=createSimpleBinaryKernelImpl((n,t)=>n-t),subComplexImpl=createComplexBinaryKernelImpl((n,t,r,i)=>({real:n-r,imag:t-i})),sub=binaryKernelFunc(Sub,subImpl,subComplexImpl),subConfig={kernelName:Sub,backendName:"cpu",kernelFunc:sub};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tileImpl(n,t){const r=new Array(n.rank);for(let s=0;s<r.length;s++)r[s]=n.shape[s]*t[s];const i=buffer(r,n.dtype);for(let s=0;s<i.values.length;++s){const o=i.indexToLoc(s),l=new Array(n.rank);for(let u=0;u<l.length;u++)l[u]=o[u]%n.shape[u];const f=n.locToIndex(l);i.values[s]=n.values[f]}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const comparePair=(n,t)=>{const r=t.value-n.value;return r===0?n.index-t.index:r};function select$1(n,t,r=0,i=n.length-1){for(;i>r;){if(i-r>600){const f=i-r+1,u=t-r+1,_=Math.log(f),g=.5*Math.exp(2*_/3),a=.5*Math.sqrt(_*g*(f-g)/f)*Math.sign(u-f/2),m=Math.max(r,Math.floor(t-u*g/f+a)),b=Math.min(i,Math.floor(t+(f-u)*g/f+a));select$1(n,t,m,b)}const s=n[t];let o=r,l=i;for(swap(n,r,t),comparePair(n[i],s)>0&&swap(n,r,i);o<l;){for(swap(n,o,l),o++,l--;comparePair(n[o],s)<0;)o=o+1;for(;comparePair(n[l],s)>0;)l=l-1}comparePair(n[r],s)===0?swap(n,r,l):(l=l+1,swap(n,l,i)),l<=t&&(r=l+1),t<=l&&(i=l-1)}}function topKImpl(n,t,r,i,s){const o=t[t.length-1],[l,f]=[n.length/o,o],u=getTypedArrayFromDType(r,l*i),_=getTypedArrayFromDType("int32",l*i);for(let a=0;a<l;a++){const m=a*f,b=n.subarray(m,m+f);let v=new Array(b.length);b.forEach((x,E)=>v[E]={value:x,index:E}),i<v.length&&(select$1(v,i),v=v.slice(0,i)),s&&v.sort(comparePair);const c=a*i,w=u.subarray(c,c+i),k=_.subarray(c,c+i);for(let x=0;x<i;x++)w[x]=v[x].value,k[x]=v[x].index}const g=t.slice();return g[g.length-1]=i,[buffer(g,r,u),buffer(g,"int32",_)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uniqueImpl(n,t,r,i){const s=parseAxisParam(t,r)[0],o=[1,r[0],1];for(let v=0;v<s;v++)o[0]*=r[v];o[1]=r[s];for(let v=s+1;v<r.length;v++)o[2]*=r[v];const l=new Map,f=new Int32Array(r[s]),u=new TensorBuffer(o,i,n),_=[],g=o[0]===1&&o[2]===1;for(let v=0;v<r[s];v++){let c;if(g)c=n[v].toString();else{const k=[];for(let x=0;x<o[0];x++)for(let E=0;E<o[2];E++)k.push(u.get(x,v,E));c=k.join(",")}const w=l.get(c);if(w!=null)f[v]=w;else{const k=l.size;l.set(c,k),f[v]=k,_.push(v)}}const a=o.slice();a[1]=l.size;const m=new TensorBuffer(a,i);_.forEach((v,c)=>{for(let w=0;w<o[0];w++)for(let k=0;k<o[2];k++)m.set(u.get(w,v,k),w,c,k)});const b=r.slice();return b[s]=a[1],{outputValues:m.values,outputShape:b,indices:f}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */registerBackend("cpu",()=>new MathBackendCPU,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const elu=unaryKernelFunc(Elu,n=>n>=0?n:Math.exp(n)-1),eluConfig={kernelName:Elu,backendName:"cpu",kernelFunc:elu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function leakyRelu(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{alpha:o}=i;assertNotComplex([s],"leakyRelu");const l=sizeFromShape(s.shape),f=r.data.get(s.dataId).values,u=getTypedArrayFromDType("float32",l);for(let _=0;_<f.length;_++)u[_]=f[_]<0?o*f[_]:f[_];return r.makeTensorInfo(s.shape,"float32",u)}const leakyReluConfig={kernelName:LeakyRelu,backendName:"cpu",kernelFunc:leakyRelu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const preluImpl=createSimpleBinaryKernelImpl((n,t)=>n<0?t*n:n);function prelu(n){const{inputs:t,backend:r}=n,{x:i,alpha:s}=t;assertNotComplex([i,s],"prelu");const o=r.data.get(i.dataId).values,l=r.data.get(s.dataId).values,[f,u]=preluImpl(i.shape,s.shape,o,l,"float32");return r.makeTensorInfo(u,"float32",f)}const preluConfig={kernelName:Prelu,backendName:"cpu",kernelFunc:prelu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const relu=unaryKernelFunc(Relu,n=>Math.max(0,n)),reluConfig={kernelName:Relu,backendName:"cpu",kernelFunc:relu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const relu6=unaryKernelFunc(Relu6,n=>Math.min(Math.max(0,n),6)),relu6Config={kernelName:Relu6,backendName:"cpu",kernelFunc:relu6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function applyActivation(n,t,r,i,s){if(r==="linear")return identity({inputs:{x:t},backend:n});if(r==="relu")return relu({inputs:{x:t},backend:n});if(r==="elu")return elu({inputs:{x:t},backend:n});if(r==="relu6")return relu6({inputs:{x:t},backend:n});if(r==="prelu")return prelu({inputs:{x:t,alpha:i},backend:n});if(r==="leakyrelu")return leakyRelu({inputs:{x:t},backend:n,attrs:{alpha:s}});if(r==="sigmoid")return sigmoid({inputs:{x:t},backend:n});throw new Error(`Activation ${r} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{shape:o}=i,l=sizeFromShape(s.shape),f=inferFromImplicitShape(o,l),u=sizeFromShape(f);assert(l===u,()=>`The new shape (${f}) has ${u} elements and the old shape (${s.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`),r.incRef(s.dataId);const _=r.data.get(s.dataId);if(_.complexTensorInfos!=null){const g=_.complexTensorInfos.real,a=_.complexTensorInfos.imag;g.shape=f,a.shape=f}return{dataId:s.dataId,shape:f,dtype:s.dtype}}const reshapeConfig={kernelName:Reshape,backendName:"cpu",kernelFunc:reshape};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchMatMul(n){const{inputs:t,backend:r,attrs:i}=n,{a:s,b:o}=t,{transposeA:l,transposeB:f}=i;assertNotComplex([s,o],"matMul");const u=s.shape.length,_=o.shape.length,g=l?s.shape[u-2]:s.shape[u-1],a=f?o.shape[_-1]:o.shape[_-2],m=l?s.shape[u-1]:s.shape[u-2],b=f?o.shape[_-2]:o.shape[_-1],v=s.shape.slice(0,-2),c=o.shape.slice(0,-2),w=sizeFromShape(v),k=sizeFromShape(c),E=assertAndGetBroadcastShape(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([m,b]);assert(g===a,()=>`Error in matMul: inner shapes (${g}) and (${a}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${l} and transposeB=${f} must match.`);const O=l?[w,g,m]:[w,m,g],A=f?[k,b,a]:[k,a,b],T=reshape({inputs:{x:s},backend:r,attrs:{shape:O}}),j=reshape({inputs:{x:o},backend:r,attrs:{shape:A}}),I=l?T.shape[1]:T.shape[2],D=l?T.shape[2]:T.shape[1],$=f?j.shape[1]:j.shape[2],N=Math.max(w,k),M=r.data.get(T.dataId).values,W=r.data.get(j.dataId).values,F=computeStrides(T.shape),H=computeStrides(j.shape),[q,Y,X]=l?[F[0],1,F[1]]:[F[0],F[1],1],[J,te,ie]=f?[1,H[1],H[0]]:[H[1],1,H[0]],de=D*$,ke=buffer([N,D,$],T.dtype),we=ke.values,_e=r.blockSize;for(let Ee=0;Ee<N;Ee++){const Ae=Ee%w,je=Ee%k;for(let Oe=0;Oe<D;Oe+=_e){const Pe=Math.min(Oe+_e,D);for(let Ce=0;Ce<$;Ce+=_e){const z=Math.min(Ce+_e,$);for(let Z=0;Z<I;Z+=_e){const se=Math.min(Z+_e,I);for(let le=Oe;le<Pe;le++)for(let ue=Ce;ue<z;ue++){let pe=0;for(let be=Z;be<se;be++){const ve=M[Ae*q+le*Y+be*X],ge=W[be*J+ue*te+je*ie];pe+=ve*ge}we[Ee*de+(le*$+ue)]+=pe}}}}}return r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(j),r.makeTensorInfo(E,ke.dtype,ke.values)}const batchMatMulConfig={kernelName:BatchMatMul,backendName:"cpu",kernelFunc:batchMatMul};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fusedMatMul(n){const{inputs:t,backend:r,attrs:i}=n,{a:s,b:o,bias:l,preluActivationWeights:f}=t,{transposeA:u,transposeB:_,activation:g,leakyreluAlpha:a}=i;let m,b,v;const c=[];m=batchMatMul({inputs:{a:s,b:o},attrs:{transposeA:u,transposeB:_},backend:r}),l&&(b=add({inputs:{a:m,b:l},backend:r}),c.push(m),m=b),g&&(v=applyActivation(r,m,g,f,a),c.push(m),m=v);for(const k of c)r.disposeIntermediateTensorInfo(k);return m}const _fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"cpu",kernelFunc:_fusedMatMul};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const acos=unaryKernelFunc(Acos,n=>Math.acos(n)),acosConfig={kernelName:Acos,backendName:"cpu",kernelFunc:acos};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const acosh=unaryKernelFunc(Acosh,n=>Math.acosh(n)),acoshConfig={kernelName:Acosh,backendName:"cpu",kernelFunc:acosh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN(n){const{inputs:t,backend:r}=n,i=t;assertNotComplex(t,"addN");const s=i.map(f=>r.data.get(f.dataId).values),o=buffer(i[0].shape,i[0].dtype),l=o.values;for(let f=0;f<i.length;f++){const u=s[f];for(let _=0;_<l.length;_++)l[_]+=u[_]}return r.makeTensorInfo(o.shape,o.dtype,o.values)}const addNConfig={kernelName:AddN,backendName:"cpu",kernelFunc:addN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function all(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,keepDims:l}=i;assertNotComplex(s,"all");const f=parseAxisParam(o,s.shape);let u=f;const _=getAxesPermutation(u,s.shape.length);let g=s;_!=null&&(g=transpose({inputs:{x:s},backend:r,attrs:{perm:_}}),u=getInnerMostAxes(u.length,s.shape.length)),assertAxesAreInnerMostDims("all",u,g.shape.length);const[a,m]=computeOutAndReduceShapes(g.shape,u),b=sizeFromShape(m),v=makeZerosTypedArray(sizeFromShape(a),g.dtype),c=r.data.get(g.dataId).values;for(let k=0;k<v.length;++k){const x=k*b;let E=c[x];for(let O=0;O<b;++O){const A=c[x+O];E=E&&A}v[k]=E}_!=null&&r.disposeIntermediateTensorInfo(g);const w=r.makeTensorInfo(a,g.dtype,v);if(l){const k=expandShapeToKeepDim(a,f),x=reshape({inputs:{x:w},backend:r,attrs:{shape:k}});return r.disposeIntermediateTensorInfo(w),x}return w}const allConfig={kernelName:All,backendName:"cpu",kernelFunc:all};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function any(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,keepDims:l}=i;assertNotComplex(s,"any");const f=parseAxisParam(o,s.shape);let u=f;const _=getAxesPermutation(u,s.shape.length);let g=s;_!=null&&(g=transpose({inputs:{x:s},backend:r,attrs:{perm:_}}),u=getInnerMostAxes(u.length,s.shape.length)),assertAxesAreInnerMostDims("any",u,g.shape.length);const[a,m]=computeOutAndReduceShapes(g.shape,u),b=sizeFromShape(m),v=makeZerosTypedArray(sizeFromShape(a),g.dtype),c=r.data.get(g.dataId).values;for(let k=0;k<v.length;++k){const x=k*b;let E=c[x];for(let O=0;O<b;++O){const A=c[x+O];E=E||A}v[k]=E}_!=null&&r.disposeIntermediateTensorInfo(g);const w=r.makeTensorInfo(a,g.dtype,v);if(l){const k=expandShapeToKeepDim(a,f),x=reshape({inputs:{x:w},backend:r,attrs:{shape:k}});return r.disposeIntermediateTensorInfo(w),x}return w}const anyConfig={kernelName:Any,backendName:"cpu",kernelFunc:any};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMax(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o}=i;assertNotComplex(s,"argMax");let l=parseAxisParam(o,s.shape);const f=getAxesPermutation(l,s.shape.length);let u=s;const _=[];f!=null&&(u=transpose({inputs:{x:s},backend:r,attrs:{perm:f}}),_.push(u),l=getInnerMostAxes(l.length,u.shape.length)),l=[l[0]],assertAxesAreInnerMostDims("argMax",l,u.shape.length);const[g,a]=computeOutAndReduceShapes(u.shape,l),m=sizeFromShape(g),b=makeZerosTypedArray(m,"int32"),v=sizeFromShape(a),c=r.data.get(u.dataId).values;for(let w=0;w<b.length;++w){const k=w*v;let x=c[k],E=0;for(let O=0;O<v;++O){const A=c[k+O];A>x&&(x=A,E=O)}b[w]=E}return _.forEach(w=>r.disposeIntermediateTensorInfo(w)),r.makeTensorInfo(g,"int32",b)}const argMaxConfig={kernelName:ArgMax,backendName:"cpu",kernelFunc:argMax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMin(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o}=i;assertNotComplex(s,"argMin");let l=parseAxisParam(o,s.shape);const f=getAxesPermutation(l,s.shape.length);let u=s;const _=[];f!=null&&(u=transpose({inputs:{x:s},backend:r,attrs:{perm:f}}),_.push(u),l=getInnerMostAxes(l.length,u.shape.length)),l=[l[0]],assertAxesAreInnerMostDims("argMin",l,u.shape.length);const[g,a]=computeOutAndReduceShapes(u.shape,l),m=sizeFromShape(g),b=makeZerosTypedArray(m,"int32"),v=sizeFromShape(a),c=r.data.get(u.dataId).values;for(let w=0;w<b.length;++w){const k=w*v;let x=c[k],E=0;for(let O=0;O<v;++O){const A=c[k+O];A<x&&(x=A,E=O)}b[w]=E}return _.forEach(w=>r.disposeIntermediateTensorInfo(w)),r.makeTensorInfo(g,"int32",b)}const argMinConfig={kernelName:ArgMin,backendName:"cpu",kernelFunc:argMin};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const asin=unaryKernelFunc(Asin,n=>Math.asin(n)),asinConfig={kernelName:Asin,backendName:"cpu",kernelFunc:asin};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const asinh=unaryKernelFunc(Asinh,n=>Math.asinh(n)),asinhConfig={kernelName:Asinh,backendName:"cpu",kernelFunc:asinh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atan=unaryKernelFunc(Atan,n=>Math.atan(n)),atanConfig={kernelName:Atan,backendName:"cpu",kernelFunc:atan};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atan2Impl=createSimpleBinaryKernelImpl((n,t)=>Math.atan2(n,t)),atan2=binaryKernelFunc(Atan2,atan2Impl),atan2Config={kernelName:Atan2,backendName:"cpu",kernelFunc:atan2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atanh=unaryKernelFunc(Atanh,n=>Math.atanh(n)),atanhConfig={kernelName:Atanh,backendName:"cpu",kernelFunc:atanh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pool(n,t,r,i,s,o){const l=s.strideHeight,f=s.strideWidth,u=s.dilationHeight,_=s.dilationWidth,g=s.effectiveFilterHeight,a=s.effectiveFilterWidth,m=s.padInfo.top,b=s.padInfo.left,v=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,c=buffer(s.outShape,r),w=c.values,k=s.outShape[1]*s.outShape[2]*s.outShape[3],x=s.outShape[2]*s.outShape[3],E=s.outShape[3];for(let O=0;O<s.batchSize;++O){const A=O*k,T=O*i[0];for(let j=0;j<s.inChannels;++j)for(let I=0;I<s.outHeight;++I){const D=I*l-m,$=Math.max(0,D),N=Math.min(s.inHeight,g+D),M=A+I*x;for(let W=0;W<s.outWidth;++W){const F=W*f-b,H=Math.max(0,F),q=Math.min(s.inWidth,a+F);let Y=v,X=0,J=0;for(let ie=$;ie<N;ie+=u){const de=T+ie*i[1];for(let ke=H;ke<q;ke+=_){const we=de+ke*i[2],_e=n[we+j];o==="max"&&_e>Y?Y=_e:o==="avg"&&(X+=_e,J++)}if(isNaN(Y))break}const te=M+W*E+j;w[te]=o==="avg"?X/J:Y}}}return c}function maxPoolPositions(n,t,r,i,s=!1,o=!1){const l=buffer(i.outShape,"int32"),f=i.strideHeight,u=i.strideWidth,_=i.dilationHeight,g=i.dilationWidth,a=i.effectiveFilterHeight,m=i.effectiveFilterWidth,b=i.padInfo.top,v=i.padInfo.left,c=buffer(t,r,n);for(let w=0;w<i.batchSize;++w)for(let k=0;k<i.inChannels;++k)for(let x=0;x<i.outHeight;++x){const E=x*f-b;let O=E;for(;O<0;)O+=_;const A=Math.min(i.inHeight,a+E);for(let T=0;T<i.outWidth;++T){const j=T*u-v;let I=j;for(;I<0;)I+=g;const D=Math.min(i.inWidth,m+j);let $=Number.NEGATIVE_INFINITY,N=-1;for(let M=O;M<A;M+=_){const W=M-E;for(let F=I;F<D;F+=g){const H=F-j,q=c.get(w,M,F,k);q>$&&($=q,s?N=o?((w*i.inHeight+M)*i.inWidth+F)*i.inChannels+k:(M*i.inWidth+F)*i.inChannels+k:N=W*m+H)}}l.set(N,w,x,T,k)}}return l}function pool3d(n,t,r,i,s,o){const l=s.strideDepth,f=s.strideHeight,u=s.strideWidth,_=s.dilationDepth,g=s.dilationHeight,a=s.dilationWidth,m=s.effectiveFilterDepth,b=s.effectiveFilterHeight,v=s.effectiveFilterWidth,c=s.padInfo.front,w=s.padInfo.top,k=s.padInfo.left,x=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,E=buffer(s.outShape,r),O=E.values,A=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],T=s.outShape[2]*s.outShape[3]*s.outShape[4],j=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let D=0;D<s.batchSize;++D){const $=D*A,N=D*i[0];for(let M=0;M<s.inChannels;++M)for(let W=0;W<s.outDepth;++W){const F=W*l-c;let H=F;for(;H<0;)H+=_;const q=Math.min(s.inDepth,m+F),Y=$+W*T;for(let X=0;X<s.outHeight;++X){const J=X*f-w;let te=J;for(;te<0;)te+=g;const ie=Math.min(s.inHeight,b+J),de=Y+X*j;for(let ke=0;ke<s.outWidth;++ke){const we=ke*u-k;let _e=we;for(;_e<0;)_e+=a;const Ee=Math.min(s.inWidth,v+we),Ae=de+ke*I;let je=x,Oe=0,Pe=0;for(let z=H;z<q;z+=_){const Z=N+z*i[1];for(let se=te;se<ie;se+=g){const le=Z+se*i[2];for(let ue=_e;ue<Ee;ue+=a){const pe=le+ue*i[3],be=n[pe+M];if(o==="max"&&be>je?je=be:o==="avg"&&(Oe+=be,Pe++),isNaN(je))break}if(isNaN(je))break}if(isNaN(je))break}const Ce=Ae+M;O[Ce]=o==="avg"?Oe/Math.max(Pe,1):je}}}}return E}function maxPool3dPositions(n,t){const r=buffer(t.outShape,"int32"),i=t.strideDepth,s=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,f=t.dilationHeight,u=t.dilationWidth,_=t.effectiveFilterDepth,g=t.effectiveFilterHeight,a=t.effectiveFilterWidth,m=t.padInfo.front,b=t.padInfo.top,v=t.padInfo.left;for(let c=0;c<t.batchSize;++c)for(let w=0;w<t.inChannels;++w)for(let k=0;k<t.outDepth;++k){const x=k*i-m;let E=x;for(;E<0;)E+=l;const O=Math.min(t.inDepth,_+x);for(let A=0;A<t.outHeight;++A){const T=A*s-b;let j=T;for(;j<0;)j+=f;const I=Math.min(t.inHeight,g+T);for(let D=0;D<t.outWidth;++D){const $=D*o-v;let N=$;for(;N<0;)N+=u;const M=Math.min(t.inWidth,a+$);let W=Number.NEGATIVE_INFINITY,F=-1;for(let H=E;H<O;H+=l){const q=H-x;for(let Y=j;Y<I;Y+=f){const X=Y-T;for(let J=N;J<M;J+=u){const te=J-$,ie=n.get(c,H,Y,J,w);ie>=W&&(W=ie,F=q*g*a+X*g+te)}}}r.set(F,c,k,A,D,w)}}}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t;assertNotComplex(s,"avgPool");const{filterSize:o,strides:l,pad:f,dimRoundingMode:u}=i,_=1;assert(eitherStridesOrDilationsAreOne(l,_),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${_}'`);const g=computePool2DInfo(s.shape,o,l,_,f,u);let a;if(g.filterWidth===1&&g.filterHeight===1&&arraysEqual(g.inShape,g.outShape))a=identity({inputs:{x:s},backend:r});else{const m=r.data.get(s.dataId).values,b=computeStrides(s.shape),v=pool(m,s.shape,s.dtype,b,g,"avg");a=r.makeTensorInfo(g.outShape,s.dtype,v.values)}return a}const avgPoolConfig={kernelName:AvgPool,backendName:"cpu",kernelFunc:avgPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3D(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{filterSize:o,strides:l,pad:f,dimRoundingMode:u,dataFormat:_}=i;assertNotComplex(s,"avgPool3d");const g=computePool3DInfo(s.shape,o,l,1,f,u,_),a=r.data.get(s.dataId).values,m=pool3d(a,s.shape,s.dtype,computeStrides(s.shape),g,"avg");return r.makeTensorInfo(m.shape,"float32",m.values)}const avgPool3DConfig={kernelName:AvgPool3D,backendName:"cpu",kernelFunc:avgPool3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3DGrad(n){const{inputs:t,backend:r,attrs:i}=n,{dy:s,input:o}=t,{filterSize:l,strides:f,pad:u,dimRoundingMode:_}=i;assertNotComplex([s,o],"avgPool3DGrad");const g=computePool3DInfo(o.shape,l,f,1,u,_),a=g.strideDepth,m=g.strideHeight,b=g.strideWidth,v=g.filterDepth,c=g.filterHeight,w=g.filterWidth,k=g.dilationDepth,x=g.dilationHeight,E=g.dilationWidth,O=g.effectiveFilterDepth,A=g.effectiveFilterHeight,T=g.effectiveFilterWidth,j=O-1-g.padInfo.front,I=T-1-g.padInfo.left,D=A-1-g.padInfo.top,$=buffer(o.shape,"float32"),N=1/(v*c*w),M=r.bufferSync(s);for(let W=0;W<g.batchSize;++W)for(let F=0;F<g.inChannels;++F)for(let H=0;H<g.inDepth;++H)for(let q=0;q<g.inHeight;++q)for(let Y=0;Y<g.inWidth;++Y){const X=H-j,J=q-D,te=Y-I;let ie=0;for(let de=0;de<O;de+=k){const ke=(X+de)/a;if(!(ke<0||ke>=g.outDepth||Math.floor(ke)!==ke))for(let we=0;we<A;we+=x){const _e=(J+we)/m;if(!(_e<0||_e>=g.outHeight||Math.floor(_e)!==_e))for(let Ee=0;Ee<T;Ee+=E){const Ae=(te+Ee)/b;if(Ae<0||Ae>=g.outWidth||Math.floor(Ae)!==Ae)continue;const je=M.get(W,ke,_e,Ae,F);ie+=je}}}$.set(ie*N,W,H,q,Y,F)}return r.makeTensorInfo($.shape,$.dtype,$.values)}const avgPool3DGradConfig={kernelName:AvgPool3DGrad,backendName:"cpu",kernelFunc:avgPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPoolGrad(n){const{inputs:t,backend:r,attrs:i}=n,{dy:s,input:o}=t,l=o;assertNotComplex([s,o],"avgPoolGrad");const{filterSize:f,strides:u,pad:_}=i,g=computePool2DInfo(l.shape,f,u,1,_),a=g.strideHeight,m=g.strideWidth,b=g.filterHeight,v=g.filterWidth,c=g.dilationHeight,w=g.dilationWidth,k=g.effectiveFilterHeight,x=g.effectiveFilterWidth,E=x-1-g.padInfo.left,O=k-1-g.padInfo.top,A=buffer(l.shape,"float32"),T=1/(b*v),j=r.data.get(s.dataId).values,I=buffer(s.shape,"float32",j);for(let D=0;D<g.batchSize;++D)for(let $=0;$<g.inChannels;++$)for(let N=0;N<g.inHeight;++N)for(let M=0;M<g.inWidth;++M){const W=N-O,F=M-E;let H=0;for(let q=0;q<k;q+=c){const Y=(W+q)/a;if(!(Y<0||Y>=g.outHeight||Math.floor(Y)!==Y))for(let X=0;X<x;X+=w){const J=(F+X)/m;if(J<0||J>=g.outWidth||Math.floor(J)!==J)continue;const te=I.get(D,Y,J,$);H+=te}}A.set(H*T,D,N,M,$)}return r.makeTensorInfo(A.shape,A.dtype,A.values)}const avgPoolGradConfig={kernelName:AvgPoolGrad,backendName:"cpu",kernelFunc:avgPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchNorm(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,scale:o,offset:l,mean:f,variance:u}=t;assert(f.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),assert(l==null||f.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),assert(o==null||f.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),assertNotComplex([s,f,u,o,l],"batchNorm");let{varianceEpsilon:_}=i;_==null&&(_=.001);const g=r.data.get(s.dataId).values,a=r.data.get(f.dataId).values,m=r.data.get(u.dataId).values,b=o?r.data.get(o.dataId).values:new Float32Array([1]),v=l?r.data.get(l.dataId).values:new Float32Array([0]),c=new Float32Array(g.length),w=v.length,k=b.length,x=m.length,E=a.length;let O=0,A=0,T=0,j=0;for(let I=0;I<g.length;++I)c[I]=v[O++]+(g[I]-a[A++])*b[T++]/Math.sqrt(m[j++]+_),O>=w&&(O=0),A>=E&&(A=0),T>=k&&(T=0),j>=x&&(j=0);return r.makeTensorInfo(s.shape,s.dtype,c)}const batchNormConfig={kernelName:FusedBatchNorm,backendName:"cpu",kernelFunc:batchNorm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchToSpaceND(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{blockShape:o,crops:l}=i;assertNotComplex([s],"batchToSpaceND");const f=o.reduce((k,x)=>k*x),u=getReshaped(s.shape,o,f),_=getPermuted(u.length,o.length),g=getReshapedPermuted(s.shape,o,f),a=getSliceBeginCoords(l,o.length),m=getSliceSize(g,l,o.length),b=reshape({inputs:{x:s},backend:r,attrs:{shape:u}}),v=transpose({inputs:{x:b},backend:r,attrs:{perm:_}}),c=reshape({inputs:{x:v},backend:r,attrs:{shape:g}}),w=slice({inputs:{x:c},backend:r,attrs:{begin:a,size:m}});return r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(c),w}const batchToSpaceNDConfig={kernelName:BatchToSpaceND,backendName:"cpu",kernelFunc:batchToSpaceND};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincount(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,weights:o}=t,{size:l}=i,f=r.data.get(s.dataId).values,u=r.data.get(o.dataId).values,_=bincountImpl(f,u,o.dtype,o.shape,l);return r.makeTensorInfo([l],o.dtype,_)}const bincountConfig={kernelName:Bincount,backendName:"cpu",kernelFunc:bincount};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function broadcastArgs(n){const{inputs:t,backend:r}=n,{s0:i,s1:s}=t,o=r.data.get(i.dataId).values,l=r.data.get(s.dataId).values,f=assertAndGetBroadcastShape(Array.from(o),Array.from(l));return r.makeTensorInfo([f.length],"int32",Int32Array.from(f))}const broadcastArgsConfig={kernelName:BroadcastArgs,backendName:"cpu",kernelFunc:broadcastArgs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const clipByValue=unaryKernelFunc(ClipByValue,(n,t)=>{const r=t;return n>r.clipValueMax?r.clipValueMax:n<r.clipValueMin?r.clipValueMin:n}),clipByValueConfig={kernelName:ClipByValue,backendName:"cpu",kernelFunc:clipByValue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const complexAbs=n=>{const{x:t}=n.inputs,r=n.backend,i=new Float32Array(sizeFromShape(t.shape)),s=r.data.get(t.dataId),o=s.complexTensorInfos.real,l=s.complexTensorInfos.imag,f=r.data.get(o.dataId).values,u=r.data.get(l.dataId).values;for(let _=0;_<f.length;_++){const g=f[_],a=u[_];i[_]=Math.hypot(g,a)}return r.makeOutput(i,t.shape,"float32")},complexAbsConfig={kernelName:ComplexAbs,backendName:"cpu",kernelFunc:complexAbs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag(n){const{inputs:t,backend:r}=n,{input:i}=t,s=r.data.get(i.dataId).complexTensorInfos.imag,o=r.data.get(s.dataId).values;return r.makeTensorInfo(s.shape,s.dtype,o)}const imagConfig={kernelName:Imag,backendName:"cpu",kernelFunc:imag};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat(n){const{inputs:t,backend:r,attrs:i}=n,{axis:s}=i,o=parseAxisParam(s,t[0].shape)[0],l=t.map(c=>c.shape);assertParamsConsistent(l,o);let f=computeOutShape(t.map(c=>c.shape),o);if(sizeFromShape(f)===0)return r.makeTensorInfo(f,t[0].dtype,[]);const u=t.filter(c=>sizeFromShape(c.shape)>0);if(u.length===1)return identity({inputs:{x:u[0]},backend:r});if(u[0].dtype==="complex64"){const c=u.map(O=>real({inputs:{input:O},backend:r})),w=u.map(O=>imag({inputs:{input:O},backend:r})),k=concat({inputs:c,backend:r,attrs:{axis:o}}),x=concat({inputs:w,backend:r,attrs:{axis:o}}),E=complex({inputs:{real:k,imag:x},backend:r});return c.forEach(O=>r.disposeIntermediateTensorInfo(O)),w.forEach(O=>r.disposeIntermediateTensorInfo(O)),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(x),E}const _=u.map(c=>{const k=[-1,sizeFromShape(c.shape.slice(o))];return reshape({inputs:{x:c},backend:r,attrs:{shape:k}})}),g=_.map(c=>({vals:r.data.get(c.dataId).values,shape:c.shape}));f=computeOutShape(_.map(c=>c.shape),1);const a=_[0].shape[0]===1,m=concatImpl(g,f,t[0].dtype,a),b=computeOutShape(u.map(c=>c.shape),o),v=r.makeTensorInfo(b,t[0].dtype,m);return _.forEach(c=>r.disposeIntermediateTensorInfo(c)),v}const concatConfig={kernelName:Concat,backendName:"cpu",kernelFunc:concat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2D(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,filter:o}=t,{strides:l,pad:f,dataFormat:u,dilations:_,dimRoundingMode:g}=i;assertNotComplex([s,o],"conv2d");const a=convertConv2DDataFormat(u),m=computeConv2DInfo(s.shape,o.shape,l,_,f,g,!1,a),b=m.filterHeight,v=m.filterWidth,c=m.dilationHeight,w=m.dilationWidth,k=m.padInfo.left,x=m.padInfo.top,E=m.dataFormat==="channelsLast",O=new TensorBuffer(m.outShape,s.dtype),A=computeStrides(s.shape),T=computeStrides(o.shape),j=A[0],I=E?A[1]:A[2],D=E?A[2]:1,$=E?1:A[1],N=O.strides[0],M=E?O.strides[1]:O.strides[2],W=E?O.strides[2]:1,F=E?1:O.strides[1],H=r.data.get(s.dataId).values,q=r.data.get(o.dataId).values,Y=O.values;for(let X=0;X<m.batchSize;++X){const J=X*j,te=X*N;for(let ie=0;ie<m.outHeight;++ie){const de=te+ie*M,ke=ie*m.strideHeight-x;for(let we=0;we<b;++we){const _e=ke+we*c;if(_e<0||_e>=m.inHeight)continue;const Ee=we*T[0],Ae=J+_e*I;for(let je=0;je<m.outWidth;++je){const Oe=de+je*W,Pe=je*m.strideWidth-k;for(let Ce=0;Ce<v;++Ce){const z=Pe+Ce*w;if(z<0||z>=m.inWidth)continue;const Z=Ee+Ce*T[1],se=Ae+z*D;let le=Z;for(let ue=0;ue<m.inChannels;++ue){const pe=H[se+ue*$];for(let be=0;be<m.outChannels;++be)Y[Oe+be*F]+=pe*q[le+be];le+=m.outChannels}}}}}}return r.makeTensorInfo(O.shape,O.dtype,Y)}const conv2DConfig={kernelName:Conv2D,backendName:"cpu",kernelFunc:conv2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropFilter(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,dy:o}=t,{strides:l,pad:f,dataFormat:u,dimRoundingMode:_,filterShape:g}=i;assertNotComplex([s,o],"conv2dBackpropFilter");const a=convertConv2DDataFormat(u),m=computeConv2DInfo(s.shape,g,l,1,f,_,!1,a),{strideHeight:b,strideWidth:v,filterHeight:c,filterWidth:w}=m,k=m.dataFormat==="channelsLast",x=new TensorBuffer(m.filterShape,"float32"),E=m.padInfo.left,O=m.padInfo.top,A=r.data.get(s.dataId).values,T=r.data.get(o.dataId).values,j=new TensorBuffer(s.shape,s.dtype,A),I=new TensorBuffer(o.shape,o.dtype,T);for(let D=0;D<c;++D){const $=Math.max(0,Math.ceil((O-D)/b)),N=Math.min(m.outHeight,(m.inHeight+O-D)/b);for(let M=0;M<w;++M){const W=Math.max(0,Math.ceil((E-M)/v)),F=Math.min(m.outWidth,(m.inWidth+E-M)/v);for(let H=0;H<m.inChannels;++H)for(let q=0;q<m.outChannels;++q){let Y=0;for(let X=0;X<m.batchSize;++X)for(let J=$;J<N;++J){const te=D+J*b-O;for(let ie=W;ie<F;++ie){const de=M+ie*v-E;k?Y+=j.get(X,te,de,H)*I.get(X,J,ie,q):Y+=j.get(X,H,te,de)*I.get(X,q,J,ie)}}x.set(Y,D,M,H,q)}}}return r.makeTensorInfo(x.shape,x.dtype,x.values)}const conv2DBackpropFilterConfig={kernelName:Conv2DBackpropFilter,backendName:"cpu",kernelFunc:conv2DBackpropFilter};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropInput(n){const{inputs:t,backend:r,attrs:i}=n,{dy:s,filter:o}=t,{inputShape:l,strides:f,pad:u,dataFormat:_,dimRoundingMode:g}=i;assertNotComplex([s,o],"conv2dBackpropInput");const a=computeStrides(o.shape),m=computeStrides(s.shape);let b=convertConv2DDataFormat(_);const v=computeConv2DInfo(l,o.shape,f,1,u,g,!1,b),c=new TensorBuffer(v.inShape,"float32"),w=c.values,k=r.data.get(s.dataId).values,x=r.data.get(o.dataId).values,[E,O,A]=a,{batchSize:T,filterHeight:j,filterWidth:I,inChannels:D,inHeight:$,inWidth:N,outChannels:M,outHeight:W,outWidth:F,strideHeight:H,strideWidth:q}=v;b=v.dataFormat;const Y=j-1-v.padInfo.top,X=I-1-v.padInfo.left,J=b==="channelsLast",te=c.strides[0],ie=J?c.strides[1]:c.strides[2],de=J?c.strides[2]:1,ke=J?1:c.strides[1],we=m[0],_e=J?m[1]:m[2],Ee=J?m[2]:1,Ae=J?1:m[1];for(let je=0;je<T;++je)for(let Oe=0;Oe<D;++Oe)for(let Pe=0;Pe<$;++Pe){const Ce=Pe-Y,z=Math.max(0,Math.ceil(Ce/H)),Z=Math.min(W,(j+Ce)/H);for(let se=0;se<N;++se){const le=se-X,ue=Math.max(0,Math.ceil(le/q)),pe=Math.min(F,(I+le)/q);let be=0;for(let ge=z;ge<Z;++ge){const L=ge*H-Ce;for(let P=ue;P<pe;++P){const R=P*q-le,V=we*je+_e*ge+Ee*P,Q=E*(j-1-L)+O*(I-1-R)+A*Oe;for(let oe=0;oe<M;++oe){const ae=k[V+Ae*oe],xe=x[Q+oe];be+=ae*xe}}}const ve=te*je+ie*Pe+de*se+ke*Oe;w[ve]=be}}return r.makeTensorInfo(c.shape,c.dtype,c.values)}const conv2DBackpropInputConfig={kernelName:Conv2DBackpropInput,backendName:"cpu",kernelFunc:conv2DBackpropInput};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3D(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,filter:o}=t,{strides:l,pad:f,dilations:u}=i;assertNotComplex([s,o],"conv3d");const _=computeConv3DInfo(s.shape,o.shape,l,u,f),{filterDepth:g,filterHeight:a,filterWidth:m,dilationDepth:b,dilationHeight:v,dilationWidth:c,padInfo:w}=_,k=w.front,x=w.left,E=w.top,O=new TensorBuffer(_.outShape,s.dtype),A=r.data.get(s.dataId).values,T=r.data.get(o.dataId).values,j=O.values,I=computeStrides(s.shape),D=computeStrides(o.shape);for(let $=0;$<_.batchSize;++$){const N=$*I[0],M=$*O.strides[0];for(let W=0;W<_.outDepth;++W){const F=M+W*O.strides[1],H=W*_.strideDepth-k;for(let q=0;q<g;++q){const Y=H+q*b;if(Y<0||Y>=_.inDepth)continue;const X=q*D[0],J=N+Y*I[1];for(let te=0;te<_.outHeight;++te){const ie=F+te*O.strides[2],de=te*_.strideHeight-E;for(let ke=0;ke<a;++ke){const we=de+ke*v;if(we<0||we>=_.inHeight)continue;const _e=X+ke*D[1],Ee=J+we*I[2];for(let Ae=0;Ae<_.outWidth;++Ae){const je=ie+Ae*_.outChannels,Oe=Ae*_.strideWidth-x;for(let Pe=0;Pe<m;++Pe){const Ce=Oe+Pe*c;if(Ce<0||Ce>=_.inWidth)continue;const z=_e+Pe*D[2],Z=Ee+Ce*_.inChannels;let se=z;for(let le=0;le<_.inChannels;++le){const ue=A[Z+le];for(let pe=0;pe<_.outChannels;++pe)j[je+pe]+=ue*T[se+pe];se+=_.outChannels}}}}}}}}return r.makeTensorInfo(O.shape,O.dtype,O.values)}const conv3DConfig={kernelName:Conv3D,backendName:"cpu",kernelFunc:conv3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropFilterV2(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,dy:o}=t,{strides:l,pad:f,filterShape:u}=i;assertNotComplex([s,o],"conv3dBackpropFilterV2");const _=computeStrides(s.shape),g=computeStrides(o.shape),a=computeConv3DInfo(s.shape,u,l,1,f),m=a.strideDepth,b=a.strideHeight,v=a.strideWidth,c=a.filterDepth,w=a.filterHeight,k=a.filterWidth,x=new TensorBuffer(a.filterShape,"float32"),E=x.values,[O,A,T,j]=x.strides,I=r.data.get(o.dataId).values,[D,$,N,M]=g,W=r.data.get(s.dataId).values,[F,H,q,Y]=_,X=a.padInfo.front,J=a.padInfo.left,te=a.padInfo.top;for(let ie=0;ie<c;++ie){const de=Math.max(0,Math.ceil((X-ie)/m)),ke=Math.min(a.outDepth,(a.inDepth+X-ie)/m),we=ie*O;for(let _e=0;_e<w;++_e){const Ee=Math.max(0,Math.ceil((te-_e)/b)),Ae=Math.min(a.outHeight,(a.inHeight+te-_e)/b),je=_e*A+we;for(let Oe=0;Oe<k;++Oe){const Pe=Math.max(0,Math.ceil((J-Oe)/v)),Ce=Math.min(a.outWidth,(a.inWidth+J-Oe)/v),z=Oe*T+je;for(let Z=0;Z<a.inChannels;++Z){const se=Z*j+z;for(let le=0;le<a.outChannels;++le){let ue=0;for(let pe=0;pe<a.batchSize;++pe){const be=pe*F,ve=pe*D;for(let ge=de;ge<ke;++ge){const P=(ie+ge*m-X)*H+be,R=ge*$+ve;for(let V=Ee;V<Ae;++V){const oe=(_e+V*b-te)*q+P,ae=V*N+R;for(let xe=Pe;xe<Ce;++xe){const Be=(Oe+xe*v-J)*Y+oe,He=xe*M+ae;ue+=W[Be+Z]*I[He+le]}}}}E[se+le]=ue}}}}}return r.makeTensorInfo(x.shape,x.dtype,x.values)}const conv3DBackpropFilterV2Config={kernelName:Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:conv3DBackpropFilterV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropInputV2(n){const{inputs:t,backend:r,attrs:i}=n,{dy:s,filter:o}=t,{pad:l,strides:f,inputShape:u}=i;assertNotComplex([s],"conv3dBackpropInputV2");const _=computeStrides(s.shape),g=computeStrides(o.shape),a=computeConv3DInfo(u,o.shape,f,1,l),m=new TensorBuffer(a.inShape,"float32"),b=m.values,[v,c,w,k]=m.strides,x=r.data.get(s.dataId).values,[E,O,A,T]=_,j=r.data.get(o.dataId).values,[I,D,$,N]=g,{batchSize:M,filterDepth:W,filterHeight:F,filterWidth:H,inChannels:q,inDepth:Y,inHeight:X,inWidth:J,outChannels:te,outDepth:ie,outHeight:de,outWidth:ke,strideDepth:we,strideHeight:_e,strideWidth:Ee}=a,Ae=W-1-a.padInfo.front,je=F-1-a.padInfo.top,Oe=H-1-a.padInfo.left;for(let Pe=0;Pe<M;++Pe)for(let Ce=0;Ce<q;++Ce)for(let z=0;z<Y;++z){const Z=z-Ae,se=Math.max(0,Math.ceil(Z/we)),le=Math.min(ie,(W+Z)/we);for(let ue=0;ue<X;++ue){const pe=ue-je,be=Math.max(0,Math.ceil(pe/_e)),ve=Math.min(de,(F+pe)/_e);for(let ge=0;ge<J;++ge){const L=ge-Oe,P=Math.max(0,Math.ceil(L/Ee)),R=Math.min(ke,(H+L)/Ee);let V=0;for(let Q=se;Q<le;++Q){const oe=Q*we-Z;for(let ae=be;ae<ve;++ae){const xe=ae*_e-pe;for(let De=P;De<R;++De){const Be=De*Ee-L,He=E*Pe+O*Q+A*ae+T*De,ze=I*(W-1-oe)+D*(F-1-xe)+$*(H-1-Be)+N*Ce;for(let ot=0;ot<te;++ot){const $t=x[He+ot],nt=j[ze+ot];V+=$t*nt}}}}b[v*Pe+c*z+w*ue+k*ge+Ce]=V}}}return r.makeTensorInfo(m.shape,m.dtype,m.values)}const conv3DBackpropInputV2Config={kernelName:Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:conv3DBackpropInputV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cos=unaryKernelFunc(Cos,n=>Math.cos(n)),cosConfig={kernelName:Cos,backendName:"cpu",kernelFunc:cos};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cosh=unaryKernelFunc(Cosh,n=>Math.cosh(n)),coshConfig={kernelName:Cosh,backendName:"cpu",kernelFunc:cosh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cropAndResize(n){const{inputs:t,backend:r,attrs:i}=n,{image:s,boxes:o,boxInd:l}=t,{cropSize:f,method:u,extrapolationValue:_}=i,[g,a,m,b]=s.shape,v=o.shape[0],[c,w]=f,k=buffer([v,c,w,b],"float32"),x=r.data.get(o.dataId).values,E=r.data.get(l.dataId).values,O=r.data.get(s.dataId).values,A=computeStrides(s.shape),T=computeStrides(k.shape);for(let j=0;j<v;j++){const I=j*4,D=x[I],$=x[I+1],N=x[I+2],M=x[I+3],W=E[j];if(W>=g)continue;const F=c>1?(N-D)*(a-1)/(c-1):0,H=w>1?(M-$)*(m-1)/(w-1):0;for(let q=0;q<c;q++){const Y=c>1?D*(a-1)+q*F:.5*(D+N)*(a-1);if(Y<0||Y>a-1){for(let X=0;X<w;X++)for(let J=0;J<b;J++){const te=J+X*T[2]+q*T[1]+j*T[0];k.values[te]=_}continue}if(u==="bilinear"){const X=Math.floor(Y),J=Math.ceil(Y),te=Y-X;for(let ie=0;ie<w;ie++){const de=w>1?$*(m-1)+ie*H:.5*($+M)*(m-1);if(de<0||de>m-1){for(let Ee=0;Ee<b;Ee++){const Ae=Ee+ie*T[2]+q*T[1]+j*T[0];k.values[Ae]=_}continue}const ke=Math.floor(de),we=Math.ceil(de),_e=de-ke;for(let Ee=0;Ee<b;Ee++){let Ae=Ee+ke*A[2]+X*A[1]+W*A[0];const je=O[Ae];Ae=Ee+we*A[2]+X*A[1]+W*A[0];const Oe=O[Ae];Ae=Ee+ke*A[2]+J*A[1]+W*A[0];const Pe=O[Ae];Ae=Ee+we*A[2]+J*A[1]+W*A[0];const Ce=O[Ae],z=je+(Oe-je)*_e,Z=Pe+(Ce-Pe)*_e;Ae=Ee+ie*T[2]+q*T[1]+j*T[0],k.values[Ae]=z+(Z-z)*te}}}else for(let X=0;X<w;++X){const J=w>1?$*(m-1)+X*H:.5*($+M)*(m-1);if(J<0||J>m-1){for(let de=0;de<b;de++){const ke=de+X*T[2]+q*T[1]+j*T[0];k.values[ke]=_}continue}const te=Math.round(J),ie=Math.round(Y);for(let de=0;de<b;de++){const ke=de+te*A[2]+ie*A[1]+W*A[0],we=de+X*T[2]+q*T[1]+j*T[0];k.values[we]=O[ke]}}}}return r.makeTensorInfo(k.shape,k.dtype,k.values)}const cropAndResizeConfig={kernelName:CropAndResize,backendName:"cpu",kernelFunc:cropAndResize};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumprod(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,exclusive:l,reverse:f}=i;assertNotComplex(s,"cumprod");const u=getAxesPermutation([o],s.shape.length);let _=s;u!=null&&(_=transpose({inputs:{x:s},backend:r,attrs:{perm:u}}));const g=getInnerMostAxes(1,s.shape.length)[0];if(g!==_.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${_.shape.length-1} but got axis=${g}`);const a=upcastType(_.dtype,"int32"),m=makeOnesTypedArray(sizeFromShape(_.shape),a),b=r.data.get(_.dataId).values,v=_.shape[_.shape.length-1],c=f?(k,x)=>k+v-x-1:(k,x)=>k+x;for(let k=0;k<b.length;k+=v)for(let x=0;x<v;x++){const E=c(k,x);if(x===0)m[E]=l?1:b[E];else{const O=c(k,x-1);m[E]=l?b[O]*m[O]:b[E]*m[O]}}const w=r.makeTensorInfo(_.shape,a,m);if(u!=null){const k=getUndoAxesPermutation(u),x=transpose({inputs:{x:w},backend:r,attrs:{perm:k}});return r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(_),x}return w}const cumprodConfig={kernelName:Cumprod,backendName:"cpu",kernelFunc:cumprod};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumsum(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,exclusive:l,reverse:f}=i;assertNotComplex(s,"cumsum");const u=getAxesPermutation([o],s.shape.length);let _=s;u!=null&&(_=transpose({inputs:{x:s},backend:r,attrs:{perm:u}}));const g=getInnerMostAxes(1,s.shape.length)[0];if(g!==_.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${_.shape.length-1} but got axis=${g}`);const a=upcastType(_.dtype,"int32"),m=makeZerosTypedArray(sizeFromShape(_.shape),a),b=r.data.get(_.dataId).values,v=_.shape[_.shape.length-1],c=f?(k,x)=>k+v-x-1:(k,x)=>k+x;for(let k=0;k<b.length;k+=v)for(let x=0;x<v;x++){const E=c(k,x);if(x===0)m[E]=l?0:b[E];else{const O=c(k,x-1);m[E]=l?b[O]+m[O]:b[E]+m[O]}}const w=r.makeTensorInfo(_.shape,a,m);if(u!=null){const k=getUndoAxesPermutation(u),x=transpose({inputs:{x:w},backend:r,attrs:{perm:k}});return r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(_),x}return w}const cumsumConfig={kernelName:Cumsum,backendName:"cpu",kernelFunc:cumsum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function denseBincount(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,weights:o}=t,{size:l,binaryOutput:f}=i;if(s.shape.length===1){const u=r.data.get(s.dataId).values,_=r.data.get(o.dataId).values,g=bincountImpl(u,_,o.dtype,o.shape,l);return r.makeTensorInfo([l],o.dtype,g)}else if(s.shape.length===2){const u=r.bufferSync(s),_=r.bufferSync(o),g=bincountReduceImpl(u,_,l,f);return r.makeTensorInfo(g.shape,o.dtype,g.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const denseBincountConfig={kernelName:DenseBincount,backendName:"cpu",kernelFunc:denseBincount};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthToSpace(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{blockSize:o,dataFormat:l}=i;assert(l==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${l}`);const f=s.shape[0],u=s.shape[1],_=s.shape[2],g=s.shape[3],a=u*o,m=_*o,b=g/(o*o),v=r.data.get(s.dataId).values,c=new Float32Array(f*a*m*b);let w=0;for(let k=0;k<f;++k)for(let x=0;x<a;++x){const E=Math.floor(x/o),O=x%o;for(let A=0;A<m;++A){const T=Math.floor(A/o),j=A%o,I=(O*o+j)*b;for(let D=0;D<b;++D){const N=D+I+g*(T+_*(E+u*k));c[w++]=v[N]}}}return r.makeTensorInfo([f,a,m,b],s.dtype,c)}const depthToSpaceConfig={kernelName:DepthToSpace,backendName:"cpu",kernelFunc:depthToSpace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNative(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,filter:o}=t,{strides:l,pad:f,dilations:u,dimRoundingMode:_}=i;assertNotComplex([s,o],"depthwiseConv2DNative");const g=computeStrides(s.shape),a=computeStrides(o.shape);let m=u;m==null&&(m=[1,1]),assert(eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const b=computeConv2DInfo(s.shape,o.shape,l,m,f,_,!0),{filterHeight:v,filterWidth:c,dilationHeight:w,dilationWidth:k,padInfo:x}=b,E=x.left,O=x.top,A=b.outChannels/b.inChannels,T=new TensorBuffer(b.outShape,s.dtype),j=r.data.get(s.dataId).values,I=r.data.get(o.dataId).values,D=T.values;for(let $=0;$<b.batchSize;++$){const N=$*g[0],M=$*T.strides[0];for(let W=0;W<b.outHeight;++W){const F=M+W*T.strides[1],H=W*b.strideHeight-O;for(let q=0;q<v;++q){const Y=H+q*w;if(Y<0||Y>=b.inHeight)continue;const X=q*a[0],J=N+Y*g[1];for(let te=0;te<b.outWidth;++te){const ie=F+te*T.strides[2],de=te*b.strideWidth-E;for(let ke=0;ke<c;++ke){const we=de+ke*k;if(we<0||we>=b.inWidth)continue;const _e=X+ke*a[1],Ee=J+we*b.inChannels;let Ae=ie,je=_e;for(let Oe=0;Oe<b.inChannels;++Oe){const Pe=j[Ee+Oe];for(let Ce=0;Ce<A;++Ce)D[Ae+Ce]+=Pe*I[je+Ce];Ae+=A,je+=A}}}}}}return r.makeTensorInfo(T.shape,T.dtype,T.values)}const depthwiseConv2dNativeConfig={kernelName:DepthwiseConv2dNative,backendName:"cpu",kernelFunc:depthwiseConv2dNative};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropFilter(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,dy:o}=t,{strides:l,dilations:f,pad:u,dimRoundingMode:_,filterShape:g}=i;assertNotComplex([s,o],"depthwiseConv2dNativeBackpropFilter");const a=computeConv2DInfo(s.shape,g,l,f,u,_,!0),{strideHeight:m,strideWidth:b,filterHeight:v,filterWidth:c}=a,w=new TensorBuffer(a.filterShape,"float32"),k=a.padInfo.left,x=a.padInfo.top,E=a.outChannels/a.inChannels,O=r.data.get(s.dataId).values,A=new TensorBuffer(s.shape,s.dtype,O),T=r.data.get(o.dataId).values,j=new TensorBuffer(o.shape,o.dtype,T);for(let I=0;I<v;++I){const D=Math.max(0,Math.ceil((x-I)/m)),$=Math.min(a.outHeight,(a.inHeight+x-I)/m);for(let N=0;N<c;++N){const M=Math.max(0,Math.ceil((k-N)/b)),W=Math.min(a.outWidth,(a.inWidth+k-N)/b);for(let F=0;F<a.outChannels;++F){const H=Math.trunc(F/E),q=F%E;let Y=0;for(let X=0;X<a.batchSize;++X)for(let J=D;J<$;++J){const te=I+J*m-x;for(let ie=M;ie<W;++ie){const de=N+ie*b-k;Y+=A.get(X,te,de,H)*j.get(X,J,ie,F)}}w.set(Y,I,N,H,q)}}}return r.makeTensorInfo(w.shape,w.dtype,w.values)}const depthwiseConv2dNativeBackpropFilterConfig={kernelName:DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropFilter};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropInput(n){const{inputs:t,backend:r,attrs:i}=n,{dy:s,filter:o}=t,{strides:l,dilations:f,pad:u,dimRoundingMode:_,inputShape:g}=i;assertNotComplex([s,o],"depthwiseConv2DNativeBackpropInput");const a=computeStrides(s.shape),m=computeStrides(o.shape),b=computeConv2DInfo(g,o.shape,l,f,u,_,!0),v=new TensorBuffer(b.inShape,"float32"),c=v.values,[w,k,x]=v.strides,E=r.data.get(s.dataId).values,[O,A,T]=a,j=r.data.get(o.dataId).values,[I,D,$]=m,{batchSize:N,filterHeight:M,filterWidth:W,inChannels:F,inHeight:H,inWidth:q,outChannels:Y,outHeight:X,outWidth:J,strideHeight:te,strideWidth:ie}=b,de=M-1-b.padInfo.top,ke=W-1-b.padInfo.left,we=Y/F;for(let _e=0;_e<N;++_e)for(let Ee=0;Ee<F;++Ee)for(let Ae=0;Ae<H;++Ae){const je=Ae-de,Oe=Math.max(0,Math.ceil(je/te)),Pe=Math.min(X,(M+je)/te);for(let Ce=0;Ce<q;++Ce){const z=Ce-ke,Z=Math.max(0,Math.ceil(z/ie)),se=Math.min(J,(W+z)/ie);let le=0;for(let ue=Oe;ue<Pe;++ue){const pe=ue*te-je;for(let be=Z;be<se;++be){const ve=be*ie-z,ge=O*_e+A*ue+T*be,L=I*(M-1-pe)+D*(W-1-ve)+$*Ee;for(let P=0;P<we;++P){const R=Ee*we+P,V=E[ge+R],Q=j[L+P];le+=V*Q}}}c[w*_e+k*Ae+x*Ce+Ee]=le}}return r.makeTensorInfo(v.shape,v.dtype,v.values)}const depthwiseConv2dNativeBackpropInputConfig={kernelName:DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropInput};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function diag(n){const{inputs:t,backend:r}=n,{x:i}=t,s=sizeFromShape(i.shape),o=r.data.get(i.dataId).values,l=buffer([s,s],i.dtype),f=l.values;for(let _=0;_<o.length;_++)f[_*s+_]=o[_];const u=[...i.shape,...i.shape];return r.makeTensorInfo(u,l.dtype,l.values)}const diagConfig={kernelName:Diag,backendName:"cpu",kernelFunc:diag};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dilation2DConfig={kernelName:Dilation2D,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:r})=>{const{x:i,filter:s}=n,{strides:o,pad:l,dilations:f}=r,u=t,_=u.data.get(i.dataId).values,g=i.shape.length,a=u.data.get(s.dataId).values,m=s.shape.length,{batchSize:b,inHeight:v,inWidth:c,inChannels:w,outHeight:k,outWidth:x,padInfo:E,strideHeight:O,strideWidth:A,filterHeight:T,filterWidth:j,dilationHeight:I,dilationWidth:D,outShape:$}=computeDilation2DInfo(i.shape,s.shape,o,l,"NHWC",f),N=sizeFromShape($),M=$.length,W=getArrayFromDType(i.dtype,N);for(let H=0;H<b;++H)for(let q=0;q<k;++q){const Y=q*O-E.top;for(let X=0;X<x;++X){const J=X*A-E.left;for(let te=0;te<w;++te){let ie=Number.MIN_SAFE_INTEGER;for(let ke=0;ke<T;++ke){const we=Y+ke*I;if(we>=0&&we<v)for(let _e=0;_e<j;++_e){const Ee=J+_e*D;if(Ee>=0&&Ee<c){const Ae=locToIndex([H,we,Ee,te],g,computeStrides(i.shape)),je=locToIndex([ke,_e,te],m,computeStrides(s.shape)),Oe=_[Ae]+a[je];Oe>ie&&(ie=Oe)}}}const de=locToIndex([H,q,X,te],M,computeStrides($));W[de]=ie}}}return{dataId:u.write(toTypedArray(W,i.dtype),$,i.dtype),shape:$,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dilation2DBackpropFilterConfig={kernelName:Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:r})=>{const{x:i,filter:s,dy:o}=n,{strides:l,pad:f,dilations:u}=r,_=t,g=toNestedArray(i.shape,_.data.get(i.dataId).values),a=toNestedArray(s.shape,_.data.get(s.dataId).values),{batchSize:m,inHeight:b,inWidth:v,inChannels:c,outHeight:w,outWidth:k,padInfo:x,strideHeight:E,strideWidth:O,filterHeight:A,filterWidth:T,dilationHeight:j,dilationWidth:I,outShape:D}=computeDilation2DInfo(i.shape,s.shape,l,f,"NHWC",u);assert(o.rank===D.length,()=>`Error in ${Dilation2DBackpropFilter}, dy must have the same rank as output ${D.length}, but got ${o.rank}`);const $=toNestedArray(D,_.data.get(o.dataId).values),N=makeZerosNestedTypedArray(s.shape,s.dtype);for(let W=0;W<m;++W)for(let F=0;F<w;++F){const H=F*E-x.top;for(let q=0;q<k;++q){const Y=q*O-x.left;for(let X=0;X<c;++X){let J=Number.MIN_SAFE_INTEGER,te=0,ie=0;for(let de=0;de<A;++de){const ke=H+de*j;if(ke>=0&&ke<b)for(let we=0;we<T;++we){const _e=Y+we*I;if(_e>=0&&_e<v){const Ee=g[W][ke][_e][X]+a[de][we][X];Ee>J&&(J=Ee,te=de,ie=we)}}}N[te][ie][X]+=$[W][F][q][X]}}}return{dataId:_.write(toTypedArray(N,i.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dilation2DBackpropInputConfig={kernelName:Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:r})=>{const{x:i,filter:s,dy:o}=n,{strides:l,pad:f,dilations:u}=r,_=t,g=toNestedArray(i.shape,_.data.get(i.dataId).values),a=toNestedArray(s.shape,_.data.get(s.dataId).values),{batchSize:m,inHeight:b,inWidth:v,inChannels:c,outHeight:w,outWidth:k,padInfo:x,strideHeight:E,strideWidth:O,filterHeight:A,filterWidth:T,dilationHeight:j,dilationWidth:I,outShape:D}=computeDilation2DInfo(i.shape,s.shape,l,f,"NHWC",u);assert(o.rank===D.length,()=>`Error in ${Dilation2DBackpropInput}, dy must have the same rank as output ${D.length}, but got ${o.rank}`);const $=toNestedArray(D,_.data.get(o.dataId).values),N=makeZerosNestedTypedArray(i.shape,i.dtype);for(let W=0;W<m;++W)for(let F=0;F<w;++F){const H=F*E-x.top;for(let q=0;q<k;++q){const Y=q*O-x.left;for(let X=0;X<c;++X){let J=Number.MIN_SAFE_INTEGER,te=H<0?0:H,ie=Y<0?0:Y;for(let de=0;de<A;++de){const ke=H+de*j;if(ke>=0&&ke<b)for(let we=0;we<T;++we){const _e=Y+we*I;if(_e>=0&&_e<v){const Ee=g[W][ke][_e][X]+a[de][we][X];Ee>J&&(J=Ee,te=ke,ie=_e)}}}N[W][te][ie][X]+=$[W][F][q][X]}}}return{dataId:_.write(toTypedArray(N,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function draw(n){const{inputs:t,backend:r,attrs:i}=n,{image:s}=t,{canvas:o,options:l}=i,{contextOptions:f,imageOptions:u}=l||{},_=(u==null?void 0:u.alpha)||1,g=(f==null?void 0:f.contextType)||"2d";if(g!=="2d")throw new Error(`Context type ${f.contextType} is not supported by the CPU backend.`);const a=o.getContext(g,(f==null?void 0:f.contextAttributes)||{});if(a==null)throw new Error(`Could not get the context with ${g} type.`);const[m,b]=s.shape.slice(0,2),v=s.shape.length===2?1:s.shape[2],c=r.data.get(s.dataId).values,w=s.dtype==="float32"?255:1,k=new Uint8ClampedArray(b*m*4);for(let E=0;E<m*b;++E){const O=[0,0,0,255*_];for(let T=0;T<v;T++){const j=c[E*v+T];if(s.dtype==="float32"){if(j<0||j>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${j}.`)}else if(s.dtype==="int32"&&(j<0||j>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${j}.`);v===1?(O[0]=j*w,O[1]=j*w,O[2]=j*w):O[T]=j*w}const A=E*4;k[A+0]=Math.round(O[0]),k[A+1]=Math.round(O[1]),k[A+2]=Math.round(O[2]),k[A+3]=Math.round(O[3])}o.width=b,o.height=m;const x=new ImageData(k,b,m);return a.putImageData(x,0,0),s}const drawConfig={kernelName:Draw,backendName:"cpu",kernelFunc:draw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,keepDims:l}=i;assertNotComplex(s,"sum");let f;s.dtype==="bool"?f=cast({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):f=identity({inputs:{x:s},backend:r});const u=f.shape.length,_=parseAxisParam(o,f.shape),g=getAxesPermutation(_,u);let a=_,m=f;g!=null&&(m=transpose({inputs:{x:f},backend:r,attrs:{perm:g}}),a=getInnerMostAxes(a.length,u)),assertAxesAreInnerMostDims("sum",a,m.shape.length);const[b,v]=computeOutAndReduceShapes(m.shape,a),c=upcastType(m.dtype,"int32");let w=zeros(r,b,c);const k=sizeFromShape(v),x=r.data.get(w.dataId).values,E=r.data.get(m.dataId).values;for(let O=0;O<x.length;++O){const A=O*k;let T=0;for(let j=0;j<k;++j)T+=E[A+j];x[O]=T}if(l){const O=expandShapeToKeepDim(w.shape,_),A=w;w=reshape({inputs:{x:w},backend:r,attrs:{shape:O}}),r.disposeIntermediateTensorInfo(A)}return r.disposeIntermediateTensorInfo(f),g!=null&&r.disposeIntermediateTensorInfo(m),w}const sumConfig={kernelName:Sum,backendName:"cpu",kernelFunc:sum};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function einsum(n){const{inputs:t,backend:r,attrs:i}=n,{equation:s}=i,o=t,{allDims:l,summedDims:f,idDims:u}=decodeEinsumEquation(s,o.length);checkEinsumDimSizes(l.length,u,o);const{path:_,steps:g}=getEinsumComputePath(f,u),a=g.length;let m=null,b=l.length;const v=[];for(let c=0;c<a;++c){for(const w of g[c]){const{permutationIndices:k,expandDims:x}=getEinsumPermutation(b,u[w]);let E;isIdentityPermutation(k)?E=o[w]:(E=transpose({inputs:{x:o[w]},backend:r,attrs:{perm:k}}),v.push(E));const O=E.shape.slice();for(let A=0;A<x.length;++A)O.splice(x[A],0,1);arraysEqual(E.shape,O)||(E=reshape({inputs:{x:E},backend:r,attrs:{shape:O}}),v.push(E)),m===null?m=E:(m=multiply({inputs:{a:E,b:m},backend:r}),v.push(m))}c<a-1&&(_[c]>=0&&(m=sum({inputs:{x:m},backend:r,attrs:{axis:_[c]-(l.length-b),keepDims:!1}}),v.push(m)),b--)}for(const c of v)c!==m&&r.disposeIntermediateTensorInfo(c);return m}const einsumConfig={kernelName:Einsum,backendName:"cpu",kernelFunc:einsum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eluGrad(n){const{inputs:t,backend:r}=n,{dy:i,y:s}=t;assertNotComplex([i,s],"eluGrad");const o=new Float32Array(sizeFromShape(s.shape)),l=r.data.get(s.dataId).values,f=r.data.get(i.dataId).values;for(let u=0;u<l.length;++u){const _=l[u];_>=0?o[u]=f[u]:o[u]=f[u]*(_+1)}return r.makeTensorInfo(s.shape,"float32",o)}const eluGradConfig={kernelName:EluGrad,backendName:"cpu",kernelFunc:eluGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p=ERF_P,a1=ERF_A1,a2=ERF_A2,a3=ERF_A3,a4=ERF_A4,a5=ERF_A5,erf=unaryKernelFunc(Erf,n=>{const t=Math.sign(n),r=Math.abs(n),i=1/(1+p*r);return t*(1-((((a5*i+a4)*i+a3)*i+a2)*i+a1)*i*Math.exp(-r*r))}),erfConfig={kernelName:Erf,backendName:"cpu",kernelFunc:erf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims(n){const{inputs:t,backend:r,attrs:i}=n,{input:s}=t,{dim:o}=i,l=s.shape.length,f=s.shape.slice();let u=o;return o<0&&(assert(-(l+1)<=o,()=>`Axis must be in the interval [${-(l+1)}, ${l}]`),u=l+o+1),f.splice(u,0,1),reshape({inputs:{x:s},backend:r,attrs:{shape:f}})}const expandDimsConfig={kernelName:ExpandDims,backendName:"cpu",kernelFunc:expandDims};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const realDivImpl=createSimpleBinaryKernelImpl((n,t)=>n/t),div=binaryKernelFunc(RealDiv,realDivImpl),realDivConfig={kernelName:RealDiv,backendName:"cpu",kernelFunc:div};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftBatch(n,t,r){const i=n.shape,s=i[0],o=i[1],l=r.data.get(n.dataId),f=l.complexTensorInfos.real,u=l.complexTensorInfos.imag,_=[s,o],g=sizeFromShape(_),a=getTypedArrayFromDType("float32",g),m=getTypedArrayFromDType("float32",g);for(let w=0;w<s;w++){const k=slice({inputs:{x:f},backend:r,attrs:{begin:[w,0],size:[1,o]}}),x=slice({inputs:{x:u},backend:r,attrs:{begin:[w,0],size:[1,o]}}),E=complex({inputs:{real:k,imag:x},backend:r}),{real:O,imag:A}=fftImpl(E,t,r),T=mergeRealAndImagArrays(O,A);for(let j=0;j<o;j++){const I=getComplexWithIndex(T,j);a[w*o+j]=I.real,m[w*o+j]=I.imag}r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(E)}const b=r.makeTensorInfo(_,"float32",a),v=r.makeTensorInfo(_,"float32",m),c=complex({inputs:{real:b,imag:v},backend:r});return r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),c}function fftImpl(n,t,r){const i=sizeFromShape(n.shape),s=r.data.get(n.dataId),o=r.data.get(s.complexTensorInfos.real.dataId).values,l=r.data.get(s.complexTensorInfos.imag.dataId).values;if(isExponentOf2(i)){const f=fftRadix2(o,l,i,t,r),u=[n.shape[0],n.shape[1]];if(t){const _=r.makeTensorInfo(u,"float32",f.real),g=r.makeTensorInfo(u,"float32",f.imag),a=r.makeTensorInfo([],"float32",createScalarValue(i,"float32")),m=identity({inputs:{x:a},backend:r}),b=realDivConfig.kernelFunc({inputs:{a:_,b:a},backend:r}),v=realDivConfig.kernelFunc({inputs:{a:g,b:m},backend:r}),c=r.data.get(b.dataId).values,w=r.data.get(v.dataId).values;return r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),{real:c,imag:w}}return f}else{const f=mergeRealAndImagArrays(o,l),u=fourierTransformByMatmul(f,i,t);return splitRealAndImagArrays(u)}}function isExponentOf2(n){return(n&n-1)===0}function fftRadix2(n,t,r,i,s){if(r===1)return{real:n,imag:t};const o=mergeRealAndImagArrays(n,t),l=r/2,f=complexWithEvenIndex(o),u=f.real,_=f.imag,g=[u.length],a=s.makeTensorInfo(g,"float32",u),m=s.makeTensorInfo(g,"float32",_),b=complex({inputs:{real:a,imag:m},backend:s}),v=complexWithOddIndex(o),c=v.real,w=v.imag,k=[c.length],x=s.makeTensorInfo(k,"float32",c),E=s.makeTensorInfo(k,"float32",w),O=complex({inputs:{real:x,imag:E},backend:s}),A=fftRadix2(u,_,l,i,s),T=A.real,j=A.imag,I=[T.length],D=s.makeTensorInfo(I,"float32",T),$=s.makeTensorInfo(I,"float32",j),N=complex({inputs:{real:D,imag:$},backend:s}),M=fftRadix2(c,w,l,i,s),W=M.real,F=M.imag,H=[W.length],q=s.makeTensorInfo(H,"float32",W),Y=s.makeTensorInfo(H,"float32",F),X=complex({inputs:{real:q,imag:Y},backend:s}),J=exponents(r,i),te=[J.real.length],ie=s.makeTensorInfo(te,"float32",J.real),de=s.makeTensorInfo(te,"float32",J.imag),ke=complex({inputs:{real:ie,imag:de},backend:s}),we=multiply({inputs:{a:ke,b:X},backend:s}),_e=add({inputs:{a:N,b:we},backend:s}),Ee=sub({inputs:{a:N,b:we},backend:s}),Ae=real({inputs:{input:_e},backend:s}),je=real({inputs:{input:Ee},backend:s}),Oe=imag({inputs:{input:_e},backend:s}),Pe=imag({inputs:{input:Ee},backend:s}),Ce=concat({inputs:[Ae,je],backend:s,attrs:{axis:0}}),z=concat({inputs:[Oe,Pe],backend:s,attrs:{axis:0}}),Z=s.data.get(Ce.dataId).values,se=s.data.get(z.dataId).values;return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(ie),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(Ee),s.disposeIntermediateTensorInfo(Ae),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(je),s.disposeIntermediateTensorInfo(Pe),s.disposeIntermediateTensorInfo(Ce),s.disposeIntermediateTensorInfo(z),{real:Z,imag:se}}function fourierTransformByMatmul(n,t,r){const i=new Float32Array(t*2);for(let s=0;s<t;s++){let o=0,l=0;for(let f=0;f<t;f++){const u=exponent(s*f,t,r),_=getComplexWithIndex(n,f);o+=_.real*u.real-_.imag*u.imag,l+=_.real*u.imag+_.imag*u.real}r&&(o/=t,l/=t),assignToTypedArray(i,o,l,s)}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fft(n){const{inputs:t,backend:r}=n,{input:i}=t,s=sizeFromShape(i.shape),o=i.shape[i.shape.length-1],l=s/o,f=reshape({inputs:{x:i},backend:r,attrs:{shape:[l,o]}}),u=fftBatch(f,!1,r),_=reshape({inputs:{x:u},backend:r,attrs:{shape:i.shape}});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(u),_}const fftConfig={kernelName:FFT,backendName:"cpu",kernelFunc:fft};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(n){const{backend:t,attrs:r}=n,{shape:i,value:s,dtype:o}=r,l=o||inferDtype(s),f=getArrayFromDType(l,sizeFromShape(i));return fillValues(f,s,l),t.makeTensorInfo(i,l,f)}const fillConfig={kernelName:Fill,backendName:"cpu",kernelFunc:fill};function fillValues(n,t,r){n.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const flipLeftRightConfig={kernelName:FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:r})=>{const{image:i}=n,s=r,o=getTypedArrayFromDType(i.dtype,sizeFromShape(i.shape)),[l,f,u,_]=i.shape,g=s.data.get(i.dataId).values;for(let m=0;m<l;m++){const b=m*u*f*_;for(let v=0;v<f;v++){const c=v*(u*_);for(let w=0;w<u;w++){const k=w*_;for(let x=0;x<_;x++){const E=Math.round(u-w-1),O=b+c+k+x;let A=g[O];if(E>=0&&E<u){const T=E*_,j=b+c+T+x;A=g[j]}o[O]=A}}}}return{dataId:s.write(o,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConv2D(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,filter:o,bias:l,preluActivationWeights:f}=t,{strides:u,pad:_,dataFormat:g,dilations:a,dimRoundingMode:m,activation:b,leakyreluAlpha:v}=i;let c=conv2D({inputs:{x:s,filter:o},backend:r,attrs:{strides:u,pad:_,dataFormat:g,dilations:a,dimRoundingMode:m}});if(l){const w=c;if(g==="NCHW"&&l.shape.length===1&&l.shape[0]!==1){const k=reshape({inputs:{x:l},backend:r,attrs:{shape:[l.shape[0],1,1]}});c=add({inputs:{a:c,b:k},backend:r}),r.disposeIntermediateTensorInfo(k)}else c=add({inputs:{a:c,b:l},backend:r});r.disposeIntermediateTensorInfo(w)}if(b){const w=c;if(g==="NCHW"&&b==="prelu"&&f.shape.length===1&&f.shape[0]!==1){const k=reshape({inputs:{x:f},backend:r,attrs:{shape:[f.shape[0],1,1]}});c=applyActivation(r,c,b,k,v),r.disposeIntermediateTensorInfo(k)}else c=applyActivation(r,c,b,f,v);r.disposeIntermediateTensorInfo(w)}return c}const fusedConv2DConfig={kernelName:FusedConv2D,backendName:"cpu",kernelFunc:fusedConv2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedDepthwiseConv2D(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,filter:o,bias:l,preluActivationWeights:f}=t,{strides:u,pad:_,dataFormat:g,dilations:a,dimRoundingMode:m,activation:b,leakyreluAlpha:v}=i;let c=depthwiseConv2dNative({inputs:{x:s,filter:o},backend:r,attrs:{strides:u,pad:_,dataFormat:g,dilations:a,dimRoundingMode:m}});if(l){const w=c;c=add({inputs:{a:c,b:l},backend:r}),r.disposeIntermediateTensorInfo(w)}if(b){const w=c;c=applyActivation(r,c,b,f,v),r.disposeIntermediateTensorInfo(w)}return c}const fusedDepthwiseConv2DConfig={kernelName:FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:fusedDepthwiseConv2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherNd(n){const{inputs:t,backend:r}=n,{params:i,indices:s}=t,o=sizeFromShape(i.shape),l=s.shape,f=l[l.length-1],[u,_,g,a]=prepareAndValidate(i,s);if(_===0)return r.makeTensorInfo(u,i.dtype,[]);const m=r.data.get(s.dataId).values,b=r.bufferSync(i),v=gatherNdImpl(m,b,i.dtype,_,f,g,a,i.shape,o);return r.makeTensorInfo(u,i.dtype,v.values)}const gatherNdConfig={kernelName:GatherNd,backendName:"cpu",kernelFunc:gatherNd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,indices:o}=t,{axis:l,batchDims:f}=i;assertNotComplex([s,o],"gatherV2");const u=parseAxisParam(l,s.shape)[0],_=r.data.get(o.dataId).values,g=s.shape[u];for(let O=0;O<_.length;++O){const A=_[O];assert(A<=g-1&&A>=0,()=>`GatherV2: the index value ${A} is not in [0, ${g-1}]`)}let a=f;f==null&&(a=0);const m=sizeFromShape(o.shape),b=collectGatherOpShapeInfo(s,o,u,a),v=reshape({inputs:{x:s},backend:r,attrs:{shape:[b.batchSize,b.outerSize,b.dimSize,b.sliceSize]}}),c=reshape({inputs:{x:o},backend:r,attrs:{shape:[b.batchSize,m/b.batchSize]}}),w=[b.batchSize,b.outerSize,m/b.batchSize,b.sliceSize],k=r.bufferSync(c),x=r.bufferSync(v),E=gatherV2Impl(x,k,w);return r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(c),r.makeTensorInfo(b.outputShape,E.dtype,E.values)}const gatherV2Config={kernelName:GatherV2,backendName:"cpu",kernelFunc:gatherV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ifft(n){const{inputs:t,backend:r}=n,{input:i}=t,s=sizeFromShape(i.shape),o=i.shape[i.shape.length-1],l=s/o,f=reshape({inputs:{x:i},backend:r,attrs:{shape:[l,o]}}),u=fftBatch(f,!0,r),_=reshape({inputs:{x:u},backend:r,attrs:{shape:i.shape}});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(u),_}const ifftConfig={kernelName:IFFT,backendName:"cpu",kernelFunc:ifft};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isFinite$1=unaryKernelFunc(IsFinite,n=>Number.isFinite(n)?1:0,"bool"),isFiniteConfig={kernelName:IsFinite,backendName:"cpu",kernelFunc:isFinite$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isInf=unaryKernelFunc(IsInf,n=>Math.abs(n)===1/0?1:0,"bool"),isInfConfig={kernelName:IsInf,backendName:"cpu",kernelFunc:isInf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isNaN$1=unaryKernelFunc(IsNan,n=>Number.isNaN(n)?1:0,"bool"),isNaNConfig={kernelName:IsNan,backendName:"cpu",kernelFunc:isNaN$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpace(n){const{backend:t,attrs:r}=n,{start:i,stop:s,num:o}=r,l=linSpaceImpl(i,s,o);return t.makeTensorInfo([l.length],"float32",l)}const linSpaceConfig={kernelName:LinSpace,backendName:"cpu",kernelFunc:linSpace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const log1p=unaryKernelFunc(Log1p,n=>Math.log1p(n)),log1pConfig={kernelName:Log1p,backendName:"cpu",kernelFunc:log1p};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logicalAndImpl=createSimpleBinaryKernelImpl((n,t)=>n&&t),logicalAnd=binaryKernelFunc(LogicalAnd,logicalAndImpl,null,"bool"),logicalAndConfig={kernelName:LogicalAnd,backendName:"cpu",kernelFunc:logicalAnd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logicalNot=unaryKernelFunc(LogicalNot,n=>n?0:1,"bool"),logicalNotConfig={kernelName:LogicalNot,backendName:"cpu",kernelFunc:logicalNot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logicalOrImpl=createSimpleBinaryKernelImpl((n,t)=>n||t),logicalOr=binaryKernelFunc(LogicalOr,logicalOrImpl,null,"bool"),logicalOrConfig={kernelName:LogicalOr,backendName:"cpu",kernelFunc:logicalOr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lRN(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{depthRadius:o,bias:l,alpha:f,beta:u}=i;assertNotComplex(s,"LRN");const _=s.shape[3],g=_-1,a=r.data.get(s.dataId).values,m=sizeFromShape(s.shape),b=new Float32Array(m);function v(c){const w=c%_;let k=c-w+Math.max(0,w-o);const x=c-w+Math.min(w+o,g);let E=0;for(;k<=x;k++){const O=a[k];E+=O*O}return E}for(let c=0;c<m;c++){const w=v(c),k=a[c]*Math.pow(l+f*w,-u);b[c]=k}return r.makeTensorInfo(s.shape,s.dtype,b)}const LRNConfig={kernelName:LRN,backendName:"cpu",kernelFunc:lRN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lRNGrad(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,y:o,dy:l}=t,{depthRadius:f,bias:u,alpha:_,beta:g}=i;assertNotComplex(l,"LRNGrad");const a=sizeFromShape(l.shape),m=l.shape[3],b=r.data.get(l.dataId).values,v=r.data.get(s.dataId).values,c=r.data.get(o.dataId).values,w=new Float32Array(a),k=a;for(let x=0;x<k;x++){const E=x%m,O=x-E+Math.max(0,E-f),A=x-E+Math.min(m,E+f+1);let T=0;for(let j=O;j<A;j++)T+=Math.pow(v[j],2);T=_*T+u;for(let j=O;j<A;j++){let I=-2*_*g*v[j]*c[x]/T;x===j&&(I+=Math.pow(T,-g)),I*=b[x],w[j]+=I}}return r.makeTensorInfo(l.shape,s.dtype,w)}const LRNGradConfig={kernelName:LRNGrad,backendName:"cpu",kernelFunc:lRNGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{reductionIndices:o,keepDims:l}=i,f=r;let u=s.shape;const _=u.length,g=parseAxisParam(o,u);let a=g;const m=getAxesPermutation(a,_);let b=f.data.get(s.dataId).values;if(m!=null){const O=new Array(_);for(let A=0;A<O.length;A++)O[A]=u[m[A]];b=transposeImpl(b,u,s.dtype,m,O),a=getInnerMostAxes(a.length,_),u=O}assertNotComplex(s,"max"),assertAxesAreInnerMostDims("max",a,_);const[v,c]=computeOutAndReduceShapes(u,a),w=sizeFromShape(c),k=maxImpl(b,w,v,s.dtype),x=f.write(k,v,s.dtype);let E=v;return l&&(E=expandShapeToKeepDim(v,g)),{dataId:x,shape:E,dtype:s.dtype}}const maxConfig={kernelName:Max,backendName:"cpu",kernelFunc:max};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t;assertNotComplex(s,"maxPool");const{filterSize:o,strides:l,pad:f,dimRoundingMode:u}=i,_=1;assert(eitherStridesOrDilationsAreOne(l,_),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${_}'`);const g=computePool2DInfo(s.shape,o,l,_,f,u);let a;if(g.filterWidth===1&&g.filterHeight===1&&arraysEqual(g.inShape,g.outShape))a=identity({inputs:{x:s},backend:r});else{const m=r.data.get(s.dataId).values,b=computeStrides(s.shape),v=pool(m,s.shape,s.dtype,b,g,"max");a=r.makeTensorInfo(g.outShape,s.dtype,v.values)}return a}const maxPoolConfig={kernelName:MaxPool,backendName:"cpu",kernelFunc:maxPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3D(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{filterSize:o,strides:l,pad:f,dimRoundingMode:u,dataFormat:_}=i;assertNotComplex(s,"maxPool3d");const g=computePool3DInfo(s.shape,o,l,1,f,u,_),a=r.data.get(s.dataId).values,m=pool3d(a,s.shape,s.dtype,computeStrides(s.shape),g,"max");return r.makeTensorInfo(m.shape,"float32",m.values)}const maxPool3DConfig={kernelName:MaxPool3D,backendName:"cpu",kernelFunc:maxPool3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3DGrad(n){const{inputs:t,backend:r,attrs:i}=n,{dy:s,input:o}=t,{filterSize:l,strides:f,pad:u,dimRoundingMode:_}=i;assertNotComplex([s,o],"maxPool3DGrad");const g=computePool3DInfo(o.shape,l,f,1,u,_),a=r.bufferSync(o),m=maxPool3dPositions(a,g),b=g.strideDepth,v=g.strideHeight,c=g.strideWidth,w=g.dilationDepth,k=g.dilationHeight,x=g.dilationWidth,E=g.effectiveFilterDepth,O=g.effectiveFilterHeight,A=g.effectiveFilterWidth,T=E-1-g.padInfo.front,j=A-1-g.padInfo.left,I=O-1-g.padInfo.top,D=buffer(o.shape,"float32"),$=r.bufferSync(s);for(let N=0;N<g.batchSize;++N)for(let M=0;M<g.inChannels;++M)for(let W=0;W<g.inDepth;++W)for(let F=0;F<g.inHeight;++F)for(let H=0;H<g.inWidth;++H){const q=W-T,Y=F-I,X=H-j;let J=0;for(let te=0;te<E;te+=w){const ie=(q+te)/b;if(!(ie<0||ie>=g.outDepth||Math.floor(ie)!==ie))for(let de=0;de<O;de+=k){const ke=(Y+de)/v;if(!(ke<0||ke>=g.outHeight||Math.floor(ke)!==ke))for(let we=0;we<A;we+=x){const _e=(X+we)/c;if(_e<0||_e>=g.outWidth||Math.floor(_e)!==_e)continue;const Ee=E*O*A-1-m.get(N,ie,ke,_e,M),Ae=te*O*A+de*A+we,je=Ee===Ae?1:0;if(je===0)continue;const Oe=$.get(N,ie,ke,_e,M);J+=Oe*je}}}D.set(J,N,W,F,H,M)}return r.makeTensorInfo(D.shape,D.dtype,D.values)}const maxPool3DGradConfig={kernelName:MaxPool3DGrad,backendName:"cpu",kernelFunc:maxPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolGrad(n){const{inputs:t,backend:r,attrs:i}=n,{dy:s,input:o,output:l}=t,f=o;assertNotComplex([o,l],"maxPoolGrad");const{filterSize:u,strides:_,pad:g,dimRoundingMode:a}=i,m=computePool2DInfo(f.shape,u,_,1,g,a),b=r.data.get(f.dataId).values,v=buffer(m.outShape,f.dtype,maxPoolPositions(b,f.shape,f.dtype,m).values),c=m.strideHeight,w=m.strideWidth,k=m.dilationHeight,x=m.dilationWidth,E=m.effectiveFilterHeight,O=m.effectiveFilterWidth,A=O-1-m.padInfo.left,T=E-1-m.padInfo.top,j=buffer(f.shape,"float32"),I=r.data.get(s.dataId).values,D=buffer(s.shape,"float32",I);for(let $=0;$<m.batchSize;++$)for(let N=0;N<m.inChannels;++N)for(let M=0;M<m.inHeight;++M)for(let W=0;W<m.inWidth;++W){const F=M-T,H=W-A;let q=0;for(let Y=0;Y<E;Y+=k){const X=(F+Y)/c;if(!(X<0||X>=m.outHeight||Math.floor(X)!==X))for(let J=0;J<O;J+=x){const te=(H+J)/w;if(te<0||te>=m.outWidth||Math.floor(te)!==te)continue;const ie=E*O-1-v.get($,X,te,N),de=Y*O+J,ke=ie===de?1:0;if(ke===0)continue;const we=D.get($,X,te,N);q+=we*ke}}j.set(q,$,M,W,N)}return r.makeTensorInfo(j.shape,j.dtype,j.values)}const maxPoolGradConfig={kernelName:MaxPoolGrad,backendName:"cpu",kernelFunc:maxPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolWithArgmaxImpl(n,t,r,i,s){const o=computeStrides(t),l=pool(n,t,r,o,s,"max"),f=maxPoolPositions(n,t,r,s,!0,i);return[l.values,f.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maxPoolWithArgmaxConfig={kernelName:MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:r})=>{const{x:i}=n,{filterSize:s,strides:o,pad:l,includeBatchInIndex:f}=t,u=r;assertNotComplex(i,"MaxPoolWithArgmax");const _=u.data.get(i.dataId).values,g=computePool2DInfo(i.shape,s,o,[1,1],l),[a,m]=maxPoolWithArgmaxImpl(_,i.shape,i.dtype,f,g),b=u.write(a,g.outShape,i.dtype),v=u.write(m,g.outShape,i.dtype);return[{dataId:b,shape:g.outShape,dtype:i.dtype},{dataId:v,shape:g.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mean(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,keepDims:l}=i,f=parseAxisParam(o,s.shape),_=computeOutAndReduceShapes(s.shape,f)[1],g=sizeFromShape(_),a=[],m=r.makeTensorInfo([],"float32",new Float32Array([g]));a.push(m);const b=cast({inputs:{x:s},backend:r,attrs:{dtype:"float32"}});a.push(b);const v=div({inputs:{a:b,b:m},backend:r});a.push(v);const c=sum({inputs:{x:v},backend:r,attrs:{axis:o,keepDims:l}});return a.forEach(w=>r.disposeIntermediateTensorInfo(w)),c}const meanConfig={kernelName:Mean,backendName:"cpu",kernelFunc:mean};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function min(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{axis:o,keepDims:l}=i;assertNotComplex(s,"min");const f=parseAxisParam(o,s.shape);let u=f;const _=getAxesPermutation(u,s.shape.length);let g=s;_!=null&&(g=transpose({inputs:{x:s},backend:r,attrs:{perm:_}}),u=getInnerMostAxes(u.length,s.shape.length)),assertAxesAreInnerMostDims("min",u,g.shape.length);const[a,m]=computeOutAndReduceShapes(g.shape,u),b=sizeFromShape(m),v=makeZerosTypedArray(sizeFromShape(a),g.dtype),c=r.data.get(g.dataId).values;for(let k=0;k<v.length;++k){const x=k*b;let E=c[x];for(let O=0;O<b;++O){const A=c[x+O];(Number.isNaN(A)||A<E)&&(E=A)}v[k]=E}_!=null&&r.disposeIntermediateTensorInfo(g);const w=r.makeTensorInfo(a,g.dtype,v);if(l){const k=expandShapeToKeepDim(a,f),x=reshape({inputs:{x:w},backend:r,attrs:{shape:k}});return r.disposeIntermediateTensorInfo(w),x}return w}const minConfig={kernelName:Min,backendName:"cpu",kernelFunc:min};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mirrorPad(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{paddings:o,mode:l}=i;assertNotComplex(s,"mirrorPad");const f=o.map((E,O)=>E[0]+s.shape[O]+E[1]),u=o.map(E=>E[0]),_=o.map((E,O)=>E[0]+s.shape[O]),g=l==="reflect"?0:1,a=r.data.get(s.dataId).values,m=s.shape.length,b=computeStrides(s.shape),v=sizeFromShape(f),c=f.length,w=computeStrides(f),k=getTypedArrayFromDType(s.dtype,v);for(let E=0;E<v;E++){let O=indexToLoc(E,c,w);for(let T=0;T<c;T++)O[T]<u[T]?O[T]=u[T]*2-O[T]-g:O[T]>=_[T]&&(O[T]=(_[T]-1)*2-O[T]+g);O=O.map((T,j)=>T-u[j]);const A=locToIndex(O,m,b);k[E]=a[A]}return{dataId:r.write(k,f,s.dtype),shape:f,dtype:s.dtype}}const mirrorPadConfig={kernelName:MirrorPad,backendName:"cpu",kernelFunc:mirrorPad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const modImpl=createSimpleBinaryKernelImpl((n,t)=>{const r=n%t;return n<0&&t<0||n>=0&&t>=0?r:(r+t)%t}),mod=binaryKernelFunc(Mod,modImpl),modConfig={kernelName:Mod,backendName:"cpu",kernelFunc:mod};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax(n){const{inputs:t,backend:r,attrs:i}=n,{logits:s}=t,{dim:o}=i,l=s.shape.length;let f=o;if(f===-1&&(f=l-1),f!==l-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${l} and dim was ${f}`);const u=parseAxisParam([f],s.shape),_=max({inputs:{x:s},backend:r,attrs:{reductionIndices:u,keepDims:!1}}),g=expandShapeToKeepDim(_.shape,u),a=reshape({inputs:{x:_},backend:r,attrs:{shape:g}}),m=sub({inputs:{a:s,b:a},backend:r}),b=exp({inputs:{x:m},backend:r}),v=sum({inputs:{x:b},backend:r,attrs:{axis:u,keepDims:!1}}),c=reshape({inputs:{x:v},backend:r,attrs:{shape:g}}),w=div({inputs:{a:b,b:c},backend:r});return r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(c),w}const softmaxConfig={kernelName:Softmax,backendName:"cpu",kernelFunc:softmax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function multinomial(n){const{inputs:t,backend:r,attrs:i}=n,{logits:s}=t,{numSamples:o,seed:l,normalized:f}=i;assertNotComplex(s,"multinomial");const u=f?s:softmax({inputs:{logits:s},backend:r,attrs:{dim:-1}}),_=u.shape[0],g=u.shape[1],a=r.data.get(u.dataId).values,m=[_,o],b=makeZerosTypedArray(sizeFromShape(m),"int32");for(let v=0;v<_;++v){const c=v*g,w=new Float32Array(g-1);w[0]=a[c];for(let E=1;E<w.length;++E)w[E]=w[E-1]+a[c+E];const k=seedrandom.alea(l.toString()),x=v*o;for(let E=0;E<o;++E){const O=k();b[x+E]=w.length;for(let A=0;A<w.length;A++)if(O<w[A]){b[x+E]=A;break}}}return f||r.disposeIntermediateTensorInfo(u),r.makeTensorInfo(m,"int32",b)}const multinomialConfig={kernelName:Multinomial,backendName:"cpu",kernelFunc:multinomial};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV3Impl=nonMaxSuppressionV3Impl$1;function nonMaxSuppressionV3(n){const{inputs:t,backend:r,attrs:i}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:f,scoreThreshold:u}=i;assertNotComplex(s,"NonMaxSuppression");const _=r.data.get(s.dataId).values,g=r.data.get(o.dataId).values,{selectedIndices:a}=nonMaxSuppressionV3Impl(_,g,l,f,u);return r.makeTensorInfo([a.length],"int32",new Int32Array(a))}const nonMaxSuppressionV3Config={kernelName:NonMaxSuppressionV3,backendName:"cpu",kernelFunc:nonMaxSuppressionV3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV4Impl=nonMaxSuppressionV4Impl$1;function nonMaxSuppressionV4(n){const{inputs:t,backend:r,attrs:i}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:f,scoreThreshold:u,padToMaxOutputSize:_}=i;assertNotComplex(s,"NonMaxSuppressionPadded");const g=r.data.get(s.dataId).values,a=r.data.get(o.dataId).values,{selectedIndices:m,validOutputs:b}=nonMaxSuppressionV4Impl(g,a,l,f,u,_);return[r.makeTensorInfo([m.length],"int32",new Int32Array(m)),r.makeTensorInfo([],"int32",new Int32Array([b]))]}const nonMaxSuppressionV4Config={kernelName:NonMaxSuppressionV4,backendName:"cpu",kernelFunc:nonMaxSuppressionV4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV5Impl=nonMaxSuppressionV5Impl$1;function nonMaxSuppressionV5(n){const{inputs:t,backend:r,attrs:i}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:f,scoreThreshold:u,softNmsSigma:_}=i;assertNotComplex(s,"NonMaxSuppressionWithScore");const g=r.data.get(s.dataId).values,a=r.data.get(o.dataId).values,m=l,b=f,v=u,c=_,{selectedIndices:w,selectedScores:k}=nonMaxSuppressionV5Impl(g,a,m,b,v,c);return[r.makeTensorInfo([w.length],"int32",new Int32Array(w)),r.makeTensorInfo([k.length],"float32",new Float32Array(k))]}const nonMaxSuppressionV5Config={kernelName:NonMaxSuppressionV5,backendName:"cpu",kernelFunc:nonMaxSuppressionV5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oneHot(n){const{inputs:t,backend:r,attrs:i}=n,{indices:s}=t,{dtype:o,depth:l,onValue:f,offValue:u}=i;assertNotComplex(s,"oneHot");const _=sizeFromShape(s.shape),g=new Float32Array(_*l);g.fill(u);const a=r.data.get(s.dataId).values;for(let m=0;m<_;++m)a[m]>=0&&a[m]<l&&(g[m*l+a[m]]=f);return r.makeTensorInfo([...s.shape,l],o,g)}const oneHotConfig={kernelName:OneHot,backendName:"cpu",kernelFunc:oneHot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike(n){const{inputs:t,backend:r}=n,{x:i}=t;if(i.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(i.dtype==="complex64"){const s=real({inputs:{input:i},backend:r}),o=zerosLike({inputs:{x:s},backend:r}),l=imag({inputs:{input:i},backend:r}),f=zerosLike({inputs:{x:l},backend:r}),u=complex({inputs:{real:o,imag:f},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(f),u}else return fill({backend:r,attrs:{shape:i.shape,value:0,dtype:i.dtype}})}const zerosLikeConfig={kernelName:ZerosLike,backendName:"cpu",kernelFunc:zerosLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike(n){const{inputs:t,backend:r}=n,{x:i}=t;if(i.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(i.dtype==="complex64"){const s=real({inputs:{input:i},backend:r}),o=onesLike({inputs:{x:s},backend:r}),l=imag({inputs:{input:i},backend:r}),f=zerosLike({inputs:{x:l},backend:r}),u=complex({inputs:{real:o,imag:f},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(f),u}else return fill({backend:r,attrs:{shape:i.shape,value:1,dtype:i.dtype}})}const onesLikeConfig={kernelName:OnesLike,backendName:"cpu",kernelFunc:onesLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pack(n){const{inputs:t,backend:r,attrs:i}=n,{axis:s}=i;if(t.length===1)return expandDims({inputs:{input:t[0]},backend:r,attrs:{dim:s}});const o=t[0].shape,l=t[0].dtype;t.forEach(g=>{assertShapesMatch(o,g.shape,"All tensors passed to stack must have matching shapes"),assert(l===g.dtype,()=>"All tensors passed to stack must have matching dtypes")});const f=[],u=t.map(g=>{const a=expandDims({inputs:{input:g},backend:r,attrs:{dim:s}});return f.push(a),a}),_=concat({inputs:u,backend:r,attrs:{axis:s}});return f.forEach(g=>r.disposeIntermediateTensorInfo(g)),_}const packConfig={kernelName:Pack,backendName:"cpu",kernelFunc:pack};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function padV2(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{paddings:o,constantValue:l}=i;assertNotComplex(s,"pad");const f=o.map((x,E)=>x[0]+s.shape[E]+x[1]),u=o.map(x=>x[0]),_=r.data.get(s.dataId).values,g=sizeFromShape(s.shape),a=s.shape.length,m=computeStrides(s.shape),b=sizeFromShape(f),v=f.length,c=computeStrides(f),w=getTypedArrayFromDType(s.dtype,b);l!==0&&w.fill(l);for(let x=0;x<g;x++){const O=indexToLoc(x,a,m).map((T,j)=>T+u[j]),A=locToIndex(O,v,c);w[A]=_[x]}return{dataId:r.write(w,f,s.dtype),shape:f,dtype:s.dtype}}const padV2Config={kernelName:PadV2,backendName:"cpu",kernelFunc:padV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const powImpl=createSimpleBinaryKernelImpl((n,t)=>Math.pow(n,t)),pow=binaryKernelFunc(Pow,powImpl),powConfig={kernelName:Pow,backendName:"cpu",kernelFunc:pow};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedGather(n){const{inputs:t,backend:r,attrs:i}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:l}=t,f=s.map(w=>r.data.get(w.dataId).values),u=s.map(w=>w.shape),_=r.data.get(o.dataId).values,g=r.data.get(l.dataId).values,[a,m,b]=raggedGatherImpl(f,u,_,o.shape,o.dtype,g,l.shape),v=a.map(w=>r.makeTensorInfo([w.length],"int32",w)),c=r.makeTensorInfo(b,o.dtype,m);return v.concat([c])}const raggedGatherConfig={kernelName:RaggedGather,backendName:"cpu",kernelFunc:raggedGather};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedRange(n){const{inputs:t,backend:r}=n,{starts:i,limits:s,deltas:o}=t,l=r.data.get(i.dataId).values,f=r.data.get(s.dataId).values,u=r.data.get(o.dataId).values,[_,g]=raggedRangeImpl(l,i.shape,i.dtype,f,s.shape,u,o.shape),a=r.makeTensorInfo([_.length],"int32",_),m=r.makeTensorInfo([g.length],i.dtype,g);return[a,m]}const raggedRangeConfig={kernelName:RaggedRange,backendName:"cpu",kernelFunc:raggedRange};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedTensorToTensor(n){const{inputs:t,backend:r,attrs:i}=n,{shape:s,values:o,defaultValue:l,rowPartitionTensors:f}=t,{rowPartitionTypes:u}=i,_=r.data.get(s.dataId).values,g=r.data.get(o.dataId).values,a=r.data.get(l.dataId).values,m=f.map(w=>r.data.get(w.dataId).values),b=f.map(w=>w.shape),[v,c]=raggedTensorToTensorImpl(_,s.shape,g,o.shape,o.dtype,a,l.shape,m,b,u);return r.makeTensorInfo(v,o.dtype,c)}const raggedTensorToTensorConfig={kernelName:RaggedTensorToTensor,backendName:"cpu",kernelFunc:raggedTensorToTensor};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function range(n){const{backend:t,attrs:r}=n,{start:i,stop:s,dtype:o,step:l}=r,f=rangeImpl(i,s,l,o);return t.makeTensorInfo([f.length],o,f)}const rangeConfig={kernelName:Range,backendName:"cpu",kernelFunc:range};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const reciprocal=unaryKernelFunc(Reciprocal,n=>1/n),reciprocalConfig={kernelName:Reciprocal,backendName:"cpu",kernelFunc:reciprocal};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinear(n){const{inputs:t,backend:r,attrs:i}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:l,size:f}=i;assertNotComplex(s,"resizeBilinear");const u=computeStrides(s.shape),[_,g]=f,[a,m,b,v]=s.shape,c=r.data.get(s.dataId).values,w=new Float32Array(sizeFromShape([a,_,g,v])),k=[o&&_>1?m-1:m,o&&g>1?b-1:b],x=[o&&_>1?_-1:_,o&&g>1?g-1:g];let E=0;const O=k[0]/x[0],A=k[1]/x[1];for(let T=0;T<a;T++)for(let j=0;j<_;j++){let I;l?I=O*(j+.5)-.5:I=O*j;const D=Math.max(0,Math.floor(I)),$=I-D,N=Math.min(m-1,Math.ceil(I)),M=T*u[0]+D*u[1],W=T*u[0]+N*u[1];for(let F=0;F<g;F++){let H;l?H=A*(F+.5)-.5:H=A*F;const q=Math.max(0,Math.floor(H)),Y=H-q,X=Math.min(b-1,Math.ceil(H)),J=M+q*u[2],te=W+q*u[2],ie=M+X*u[2],de=W+X*u[2];for(let ke=0;ke<v;ke++){const we=c[J+ke],_e=c[te+ke],Ee=c[ie+ke],Ae=c[de+ke],je=we+(Ee-we)*Y,Oe=_e+(Ae-_e)*Y,Pe=je+(Oe-je)*$;w[E++]=Pe}}}return r.makeTensorInfo([a,_,g,v],"float32",w)}const resizeBilinearConfig={kernelName:ResizeBilinear,backendName:"cpu",kernelFunc:resizeBilinear};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinearGrad(n){const{inputs:t,backend:r,attrs:i}=n,{images:s,dy:o}=t,{alignCorners:l}=i;assertNotComplex([o,s],"resizeBilinearGrad");const f=computeStrides(s.shape),[u,_,g,a]=s.shape,[,m,b]=o.shape,v=new Float32Array(u*_*g*a),c=[l&&m>1?_-1:_,l&&b>1?g-1:g],w=[l&&m>1?m-1:m,l&&b>1?b-1:b],k=c[0]/w[0],x=c[1]/w[1],E=r.data.get(o.dataId).values;let O=0;for(let A=0;A<u;A++){const T=A*f[0];for(let j=0;j<m;j++){const I=j*k,D=Math.floor(I),$=Math.min(Math.ceil(I),_-1),N=T+D*f[1],M=T+$*f[1],W=I-D,F=1-W;for(let H=0;H<b;H++){const q=H*x,Y=Math.floor(q),X=Math.min(Math.ceil(q),g-1),J=q-Y,te=1-J,ie=N+Y*f[2],de=N+X*f[2],ke=M+Y*f[2],we=M+X*f[2],_e=F*te,Ee=F*J,Ae=W*te,je=W*J;for(let Oe=0;Oe<a;Oe++){const Pe=E[O++];v[ie+Oe]+=Pe*_e,v[de+Oe]+=Pe*Ee,v[ke+Oe]+=Pe*Ae,v[we+Oe]+=Pe*je}}}}return r.makeTensorInfo([u,g,_,a],"float32",v)}const resizeBilinearGradConfig={kernelName:ResizeBilinearGrad,backendName:"cpu",kernelFunc:resizeBilinearGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighbor(n){const{inputs:t,backend:r,attrs:i}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:l,size:f}=i;assertNotComplex(s,"resizeNearestNeighbor");const u=computeStrides(s.shape),[_,g]=f,[a,m,b,v]=s.shape,c=r.data.get(s.dataId).values,w=new Float32Array(a*_*g*v),k=[o&&_>1?m-1:m,o&&g>1?b-1:b],x=[o&&_>1?_-1:_,o&&g>1?g-1:g],E=k[0]/x[0],O=k[1]/x[1];let A=0;for(let T=0;T<a;T++){const j=T*u[0];for(let I=0;I<_;I++){const D=l?E*(I+.5):E*I;let $=Math.min(m-1,o?Math.round(D):Math.floor(D));l&&($=Math.max(0,$));const N=j+$*u[1];for(let M=0;M<g;M++){const W=l?O*(M+.5):O*M;let F=Math.min(b-1,o?Math.round(W):Math.floor(W));l&&(F=Math.max(0,F));const H=N+F*u[2];for(let q=0;q<v;q++){const Y=c[H+q];w[A++]=Y}}}}return r.makeTensorInfo([a,_,g,v],s.dtype,w)}const resizeNearestNeighborConfig={kernelName:ResizeNearestNeighbor,backendName:"cpu",kernelFunc:resizeNearestNeighbor};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighborGrad(n){const{inputs:t,backend:r,attrs:i}=n,{images:s,dy:o}=t,{alignCorners:l}=i;assertNotComplex([o,s],"resizeNearestNeighborGrad");const f=computeStrides(s.shape),u=computeStrides(o.shape),[_,g,a,m]=s.shape,[,b,v]=o.shape,c=new Float32Array(_*g*a*m),w=r.data.get(o.dataId).values,k=[l&&b>1?g-1:g,l&&v>1?a-1:a],x=[l&&b>1?b-1:b,l&&v>1?v-1:v],E=k[0]/x[0],O=k[1]/x[1],A=1/E,T=1/O,j=Math.ceil(A)*2+2,I=Math.ceil(T)*2+2;for(let D=0;D<_;D++){const $=D*f[0];for(let N=0;N<g;N++){const M=$+N*f[1],W=Math.floor(N*A),F=Math.floor(W-j/2);for(let H=0;H<a;H++){const q=M+H*f[2],Y=Math.floor(H*T),X=Math.floor(Y-I/2);for(let J=0;J<m;J++){let te=0;for(let ie=0;ie<j;ie++){const de=ie+F;if(de<0||de>=b)continue;const ke=$+de*u[1],we=de*E,_e=Math.min(g-1,l?Math.round(we):Math.floor(we));if(N===_e)for(let Ee=0;Ee<I;Ee++){const Ae=Ee+X;if(Ae<0||Ae>=v)continue;const je=ke+Ae*u[2],Oe=Ae*O,Pe=Math.min(a-1,l?Math.round(Oe):Math.floor(Oe));H===Pe&&(te+=w[je+J])}}c[q+J]=te}}}}return r.makeTensorInfo(s.shape,s.dtype,c)}const resizeNearestNeighborGradConfig={kernelName:ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:resizeNearestNeighborGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{dims:o}=i;assertNotComplex(s,"reverse");const l=s.shape.length,f=parseAxisParam(o,s.shape);if(l===0)return identity({inputs:{x:s},backend:r});const u=new TensorBuffer(s.shape,s.dtype),_=r.bufferSync(s);for(let g=0;g<u.size;g++){const a=u.indexToLoc(g),m=a.slice();f.forEach(b=>m[b]=s.shape[b]-1-m[b]),u.set(_.get(...m),...a)}return r.makeTensorInfo(u.shape,u.dtype,u.values)}const reverseConfig={kernelName:Reverse,backendName:"cpu",kernelFunc:reverse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rotateWithOffsetConfig={kernelName:RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:r})=>{const{image:i}=n,{radians:s,fillValue:o,center:l}=t,f=r,u=getTypedArrayFromDType(i.dtype,sizeFromShape(i.shape)),[_,g,a,m]=i.shape,[b,v]=getImageCenter(l,g,a),c=255,w=Math.sin(s),k=Math.cos(s),x=f.data.get(i.dataId).values;for(let O=0;O<_;O++){const A=O*a*g*m;for(let T=0;T<g;T++){const j=T*(a*m);for(let I=0;I<a;I++){const D=I*m;for(let $=0;$<m;$++){const N=[_,T,I,$],M=N[2],W=N[1];let F=(M-b)*k-(W-v)*w,H=(M-b)*w+(W-v)*k;F=Math.round(F+b),H=Math.round(H+v);let q=o;if(typeof o!="number"&&($===3?q=c:q=o[$]),F>=0&&F<a&&H>=0&&H<g){const X=H*(a*m),J=F*m,te=A+X+J+$;q=x[te]}const Y=A+j+D+$;u[Y]=q}}}}return{dataId:f.write(u,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const round=unaryKernelFunc(Round,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),roundConfig={kernelName:Round,backendName:"cpu",kernelFunc:round};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterNd(n){const{inputs:t,backend:r,attrs:i}=n,{indices:s,updates:o}=t,{shape:l}=i,{sliceRank:f,numUpdates:u,sliceSize:_,strides:g,outputSize:a}=calculateShapes(o,s,l),m=!0,b=r.bufferSync(s),v=r.bufferSync(o),c=scatterImpl(b,v,l,a,_,u,f,g,0,m);return r.makeTensorInfo(l,c.dtype,c.values)}const scatterNdConfig={kernelName:ScatterNd,backendName:"cpu",kernelFunc:scatterNd};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lowerBound(n,t){let r=0,i=n.length,s=0;for(;r<i;)s=Math.floor((r+i)/2),n[s]<t?r=s+1:i=s;return i}function upperBound(n,t){let r=0,i=n.length,s=0;for(;r<i;)s=Math.floor((r+i)/2),n[s]<=t?r=s+1:i=s;return i}function searchSortedImpl(n,t,r,i,s,o){const l=getArrayFromDType("int32",r*s);for(let f=0;f<r;++f){const u=n.slice(f*i,(f+1)*i),_=f*s;for(let g=0;g<s;++g)l[_+g]=o==="left"?lowerBound(u,t[g+_]):upperBound(u,t[g+_])}return l}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function searchSorted(n){const{inputs:t,backend:r,attrs:i}=n,{sortedSequence:s,values:o}=t,{side:l}=i,f=r.data.get(s.dataId).values,u=r.data.get(o.dataId).values,_=searchSortedImpl(f,u,s.shape[0],s.shape[1],o.shape[1],l);return r.makeTensorInfo(o.shape,"int32",_)}const searchSortedConfig={kernelName:SearchSorted,backendName:"cpu",kernelFunc:searchSorted};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function select(n){const{inputs:t,backend:r}=n,{condition:i,t:s,e:o}=t;assertNotComplex([i,s,o],"select");const l=i.shape.length,f=r.data.get(i.dataId).values,u=r.data.get(s.dataId).values,_=r.data.get(o.dataId).values,g=upcastType(s.dtype,o.dtype),a=makeZerosTypedArray(sizeFromShape(s.shape),g);let m=0;const b=l===0||l>1||s.shape.length===1?1:sizeFromShape(s.shape.slice(1));for(let v=0;v<f.length;v++)for(let c=0;c<b;c++)f[v]===1?a[m++]=u[v]:a[m++]=_[v];return r.makeTensorInfo(s.shape,g,a)}const selectConfig={kernelName:Select,backendName:"cpu",kernelFunc:select};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const scaleAlpha=SELU_SCALEALPHA,scale=SELU_SCALE,selu=unaryKernelFunc(Selu,n=>n>=0?scale*n:scaleAlpha*(Math.exp(n)-1)),seluConfig={kernelName:Selu,backendName:"cpu",kernelFunc:selu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sign=unaryKernelFunc(Sign,n=>n<0?-1:n>0?1:0),signConfig={kernelName:Sign,backendName:"cpu",kernelFunc:sign};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sin=unaryKernelFunc(Sin,n=>Math.sin(n)),sinConfig={kernelName:Sin,backendName:"cpu",kernelFunc:sin};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sinh=unaryKernelFunc(Sinh,n=>Math.sinh(n)),sinhConfig={kernelName:Sinh,backendName:"cpu",kernelFunc:sinh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const epsilon=11920928955078125e-23,threshold=Math.log(epsilon)+2,softplus=unaryKernelFunc(Softplus,n=>{const t=n>-threshold,r=n<threshold,i=Math.exp(n);let s;return r?s=i:t?s=n:s=Math.log(1+i),s}),softplusConfig={kernelName:Softplus,backendName:"cpu",kernelFunc:softplus};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function spaceToBatchND(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{blockShape:o,paddings:l}=i;assertNotComplex([s],"spaceToBatchND");const f=sizeFromShape(o),u=[[0,0]];u.push(...l);for(let T=1+o.length;T<s.shape.length;++T)u.push([0,0]);const _=padV2Config.kernelFunc({inputs:{x:s},backend:r,attrs:{paddings:u,constantValue:0}}),g=getReshaped(_.shape,o,f,!1),a=getPermuted(g.length,o.length,!1),m=getReshapedPermuted(_.shape,o,f,!1),c=reshape({inputs:{x:_},backend:r,attrs:{shape:g}}),x=transpose({inputs:{x:c},backend:r,attrs:{perm:a}}),A=reshape({inputs:{x},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(x),A}const spaceToBatchNDConfig={kernelName:SpaceToBatchND,backendName:"cpu",kernelFunc:spaceToBatchND};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseFillEmptyRows(n){const{inputs:t,backend:r}=n,{indices:i,values:s,denseShape:o,defaultValue:l}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${i.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(l.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${l.shape}`);const f=r.data.get(i.dataId).values,u=r.data.get(s.dataId).values,_=r.data.get(o.dataId).values,g=r.data.get(l.dataId).values[0],[a,m,b,v,c]=sparseFillEmptyRowsImpl(f,i.shape,i.dtype,u,s.dtype,_,g);return[r.makeTensorInfo(m,i.dtype,a),r.makeTensorInfo([m[0]],s.dtype,b),r.makeTensorInfo([v.length],"bool",new Uint8Array(v.map(w=>Number(w)))),r.makeTensorInfo([c.length],i.dtype,new Int32Array(c))]}const sparseFillEmptyRowsConfig={kernelName:SparseFillEmptyRows,backendName:"cpu",kernelFunc:sparseFillEmptyRows};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseReshape(n){const{inputs:t,backend:r}=n,{inputIndices:i,inputShape:s,newShape:o}=t;if(i.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${i.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const l=Array.from(r.data.get(s.dataId).values),f=r.data.get(i.dataId).values,u=Array.from(r.data.get(o.dataId).values),[_,g,a]=sparseReshapeImpl(f,i.shape,i.dtype,l,u);return[r.makeTensorInfo(g,i.dtype,_),r.makeTensorInfo([a.length],o.dtype,new Int32Array(a))]}const sparseReshapeConfig={kernelName:SparseReshape,backendName:"cpu",kernelFunc:sparseReshape};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentMean(n){const{inputs:t,backend:r}=n,{data:i,indices:s,segmentIds:o}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const l=r.data.get(i.dataId).values,f=r.data.get(s.dataId).values,u=r.data.get(o.dataId).values,[_,g]=sparseSegmentReductionImpl(l,i.shape,i.dtype,f,u,!0);return r.makeTensorInfo(g,i.dtype,_)}const sparseSegmentMeanConfig={kernelName:SparseSegmentMean,backendName:"cpu",kernelFunc:sparseSegmentMean};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentSum(n){const{inputs:t,backend:r}=n,{data:i,indices:s,segmentIds:o}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const l=r.data.get(i.dataId).values,f=r.data.get(s.dataId).values,u=r.data.get(o.dataId).values,[_,g]=sparseSegmentReductionImpl(l,i.shape,i.dtype,f,u);return r.makeTensorInfo(g,i.dtype,_)}const sparseSegmentSumConfig={kernelName:SparseSegmentSum,backendName:"cpu",kernelFunc:sparseSegmentSum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseToDense(n){const{inputs:t,backend:r,attrs:i}=n,{sparseIndices:s,sparseValues:o,defaultValue:l}=t,{outputShape:f}=i,{sliceRank:u,numUpdates:_,sliceSize:g,strides:a,outputSize:m}=calculateShapes(o,s,f),b=!1,v=r.bufferSync(s);let c;switch(o.dtype){case"bool":{const w=r.bufferSync(o),k=!!r.data.get(l.dataId).values[0];c=scatterImpl(v,w,f,m,g,_,u,a,k,b);break}case"float32":{const w=r.bufferSync(o),k=r.data.get(l.dataId).values[0];c=scatterImpl(v,w,f,m,g,_,u,a,k,b);break}case"int32":{const w=r.bufferSync(o),k=r.data.get(l.dataId).values[0];c=scatterImpl(v,w,f,m,g,_,u,a,k,b);break}case"string":{const w=r.bufferSync(o),k=decodeString(r.data.get(l.dataId).values[0]);c=scatterImpl(v,w,f,m,g,_,u,a,k,b);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return r.makeTensorInfo(f,c.dtype,c.values)}const sparseToDenseConfig={kernelName:SparseToDense,backendName:"cpu",kernelFunc:sparseToDense};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function splitV(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{numOrSizeSplits:o,axis:l}=i,f=parseAxisParam(l,s.shape)[0],u=prepareSplitSize(s,o,f),_=new Array(s.shape.length).fill(0),g=s.shape.slice();return u.map(a=>{const m=[...g];m[f]=a;const b=slice({inputs:{x:s},backend:r,attrs:{begin:_,size:m}});return _[f]+=a,b})}const splitVConfig={kernelName:SplitV,backendName:"cpu",kernelFunc:splitV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const squareConfig={kernelName:Square,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:r}=n,i=t;assertNotComplex(r,"square");const s=i.data.get(r.dataId).values,o=new Float32Array(s.length);for(let f=0;f<s.length;++f){const u=s[f];o[f]=u*u}return{dataId:i.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const step=unaryKernelFunc(Step,(n,t)=>{const r=t;return isNaN(n)?NaN:n>0?1:r.alpha}),stepConfig={kernelName:Step,backendName:"cpu",kernelFunc:step};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSlice(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{begin:o,end:l,strides:f,beginMask:u,endMask:_,ellipsisMask:g,newAxisMask:a,shrinkAxisMask:m}=i;assertNotComplex(s,"stridedSlice");const{finalShapeSparse:b,finalShape:v,isIdentity:c,sliceDim0:w,isSimpleSlice:k,begin:x,end:E,strides:O}=sliceInfo(s.shape,o,l,f,u,_,g,a,m);let A;if(c)A=reshape({inputs:{x:s},backend:r,attrs:{shape:v}});else if(w||k){assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const T=computeOutShape$1(x,E,O),j=slice({inputs:{x:s},backend:r,attrs:{begin:x,size:T}});A=reshape({inputs:{x:j},backend:r,attrs:{shape:v}}),r.disposeIntermediateTensorInfo(j)}else{const T=r.bufferSync(s),j=stridedSliceImpl(b,T,O,x);A=r.makeTensorInfo(v,j.dtype,j.values)}return A}const stridedSliceConfig={kernelName:StridedSlice,backendName:"cpu",kernelFunc:stridedSlice};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringNGrams(n){const{inputs:t,backend:r,attrs:i}=n,{separator:s,nGramWidths:o,leftPad:l,rightPad:f,padWidth:u,preserveShortSequences:_}=i,{data:g,dataSplits:a}=t,m=r.data.get(g.dataId).values,b=r.data.get(a.dataId).values,[v,c]=stringNGramsImpl(m,b,s,o,l,f,u,_);return[r.makeTensorInfo([v.length],"string",v),r.makeTensorInfo(a.shape,"int32",c)]}const stringNGramsConfig={kernelName:StringNGrams,backendName:"cpu",kernelFunc:stringNGrams};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringSplit(n){const{inputs:t,backend:r,attrs:i}=n,{skipEmpty:s}=i,{input:o,delimiter:l}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(l.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${l.shape}`);const f=r.data.get(o.dataId).values,u=r.data.get(l.dataId).values[0],[_,g,a]=stringSplitImpl(f,u,s),m=g.length;return[r.makeTensorInfo([m,2],"int32",_),r.makeTensorInfo([m],"string",g),r.makeTensorInfo([2],"int32",new Int32Array(a))]}const stringSplitConfig={kernelName:StringSplit,backendName:"cpu",kernelFunc:stringSplit};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringToHashBucketFast(n){const{inputs:t,backend:r,attrs:i}=n,{numBuckets:s}=i,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const l=r.data.get(o.dataId).values,f=stringToHashBucketFastImpl(l,s);return r.makeTensorInfo(o.shape,"int32",f)}const stringToHashBucketFastConfig={kernelName:StringToHashBucketFast,backendName:"cpu",kernelFunc:stringToHashBucketFast};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tan=unaryKernelFunc(Tan,n=>Math.tan(n)),tanConfig={kernelName:Tan,backendName:"cpu",kernelFunc:tan};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tanh=unaryKernelFunc(Tanh,n=>Math.tanh(n)),tanhConfig={kernelName:Tanh,backendName:"cpu",kernelFunc:tanh};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensorScatterUpdate(n){const{inputs:t,backend:r}=n,{tensor:i,indices:s,updates:o}=t,{sliceRank:l,numUpdates:f,sliceSize:u,strides:_,outputSize:g}=calculateShapes(o,s,i.shape),a=!1,m=r.bufferSync(s),b=r.bufferSync(o),v=r.bufferSync(i),c=scatterImpl(m,b,i.shape,g,u,f,l,_,v,a);return r.makeTensorInfo(i.shape,c.dtype,c.values)}const tensorScatterUpdateConfig={kernelName:TensorScatterUpdate,backendName:"cpu",kernelFunc:tensorScatterUpdate};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{reps:o}=i;assertNotComplex(s,"tile");const l=tileImpl(r.bufferSync(s),o);return r.makeTensorInfo(l.shape,l.dtype,l.values)}const tileConfig={kernelName:Tile,backendName:"cpu",kernelFunc:tile};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function topK(n){const{inputs:t,backend:r,attrs:i}=n,{x:s}=t,{k:o,sorted:l}=i;assertNotComplex(s,"topk");const f=r.data.get(s.dataId).values,[u,_]=topKImpl(f,s.shape,s.dtype,o,l);return[r.makeTensorInfo(u.shape,u.dtype,u.values),r.makeTensorInfo(_.shape,_.dtype,_.values)]}const topKConfig={kernelName:TopK,backendName:"cpu",kernelFunc:topK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transform(n){const{inputs:t,attrs:r,backend:i}=n,{image:s,transforms:o}=t,{interpolation:l,fillMode:f,fillValue:u,outputShape:_}=r,[g,a,m,b]=s.shape,[v,c]=_??[a,m],w=[g,v,c,b],k=computeStrides(s.shape),x=k[0],E=k[1],O=k[2],A=computeStrides(w),T=A[0],j=A[1],I=A[2],D=getTypedArrayFromDType(s.dtype,sizeFromShape(w));D.fill(u);const $=i.data.get(s.dataId).values,N=i.data.get(o.dataId).values;for(let W=0;W<g;++W){const F=o.shape[0]===1?N:N.subarray(W*8,W*8+8);for(let H=0;H<v;++H)for(let q=0;q<c;++q)for(let Y=0;Y<b;++Y){let X;const J=F[6]*q+F[7]*H+1;if(J===0)continue;const te=(F[0]*q+F[1]*H+F[2])/J,ie=(F[3]*q+F[4]*H+F[5])/J,de=mapCoord(te,m,f),ke=mapCoord(ie,a,f);switch(l){case"nearest":X=nearestInterpolation($,a,m,x,E,O,W,ke,de,Y,u);break;case"bilinear":X=bilinearInterpolation($,a,m,x,E,O,W,ke,de,Y,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${l}`)}const we=W*T+H*j+q*I+Y;D[we]=X}return i.makeTensorInfo(w,s.dtype,D)}return{dataId:i.write(D,w,s.dtype),shape:s.shape,dtype:s.dtype}}const transformConfig={kernelName:Transform,backendName:"cpu",kernelFunc:transform};function mapCoord(n,t,r){switch(r){case"reflect":return mapCoordReflect(n,t);case"wrap":return mapCoordWrap(n,t);case"nearest":return mapCoordNearest(n,t);case"constant":default:return mapCoordConstant(n)}}function mapCoordReflect(n,t){let r=n;if(r<0)if(t<=1)r=0;else{const i=2*t;r<i&&(r=i*Math.trunc(-r/i)+r),r=r<-t?r+i:-r-1}else if(r>t-1)if(t<=1)r=0;else{const i=2*t;r-=i*Math.trunc(r/i),r>=t&&(r=i-r-1)}return clamp(0,r,t-1)}function mapCoordWrap(n,t){let r=n;if(r<0)if(t<=1)r=0;else{const i=t-1;r+=t*(Math.trunc(-r/i)+1)}else if(r>t-1)if(t<=1)r=0;else{const i=t-1;r-=t*Math.trunc(r/i)}return clamp(0,r,t-1)}function mapCoordConstant(n,t){return n}function mapCoordNearest(n,t){return clamp(0,n,t-1)}function readWithFillValue(n,t,r,i,s,o,l,f,u,_,g){const a=l*i+f*s+u*o+_;return 0<=f&&f<t&&0<=u&&u<r?n[a]:g}function nearestInterpolation(n,t,r,i,s,o,l,f,u,_,g){const a=Math.round(f),m=Math.round(u);return readWithFillValue(n,t,r,i,s,o,l,a,m,_,g)}function bilinearInterpolation(n,t,r,i,s,o,l,f,u,_,g){const a=Math.floor(f),m=Math.floor(u),b=a+1,v=m+1,c=(v-u)*readWithFillValue(n,t,r,i,s,o,l,a,m,_,g)+(u-m)*readWithFillValue(n,t,r,i,s,o,l,a,v,_,g),w=(v-u)*readWithFillValue(n,t,r,i,s,o,l,b,m,_,g)+(u-m)*readWithFillValue(n,t,r,i,s,o,l,b,v,_,g);return(b-f)*c+(f-a)*w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unique(n){const{inputs:t,attrs:r,backend:i}=n,{axis:s}=r,{x:o}=t;assertNotComplex(o,"unique");const l=i.data.get(o.dataId).values,{outputValues:f,outputShape:u,indices:_}=uniqueImpl(l,s,o.shape,o.dtype);return[i.makeTensorInfo(u,o.dtype,f),i.makeTensorInfo([_.length],"int32",_)]}const uniqueConfig={kernelName:Unique,backendName:"cpu",kernelFunc:unique};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unpack(n){const{inputs:t,backend:r,attrs:i}=n,{value:s}=t;let{axis:o}=i;o<0&&(o+=s.shape.length);const l=s.shape.length,f=s.shape[o],u=new Array(l-1);let _=0;for(let b=0;b<l;b++)b!==o&&(u[_++]=s.shape[b]);const g=new Array(l).fill(0),a=s.shape.slice();a[o]=1;const m=new Array(f);for(let b=0;b<m.length;b++){g[o]=b;const v=slice({inputs:{x:s},backend:r,attrs:{begin:g,size:a}});m[b]=reshape({inputs:{x:v},backend:r,attrs:{shape:u}}),r.disposeIntermediateTensorInfo(v)}return m}const unpackConfig={kernelName:Unpack,backendName:"cpu",kernelFunc:unpack};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unsortedSegmentSum(n){const{inputs:t,backend:r,attrs:i}=n,{x:s,segmentIds:o}=t,{numSegments:l}=i;assertNotComplex(s,"unsortedSegmentSum");const f=s.shape.length,u=o.shape.length,_=[],g=[],a=f-u;let m=o;for(let v=0;v<a;++v){const c=expandDims({inputs:{input:m},backend:r,attrs:{dim:v+1}});m=c,g.push(c)}for(let v=0;v<l;++v){const c=createScalarValue(v,"int32"),w=r.makeTensorInfo([],"int32",c),k=equal({inputs:{a:w,b:m},backend:r}),x=cast({inputs:{x:k},backend:r,attrs:{dtype:"float32"}}),E=multiply({inputs:{a:x,b:s},backend:r}),O=sum({inputs:{x:E},backend:r,attrs:{axis:0,keepDims:!1}});_.push(O),g.push(w),g.push(k),g.push(x),g.push(E),g.push(O)}const b=pack({inputs:_,backend:r,attrs:{axis:0}});return g.forEach(v=>r.disposeIntermediateTensorInfo(v)),b}const unsortedSegmentSumConfig={kernelName:UnsortedSegmentSum,backendName:"cpu",kernelFunc:unsortedSegmentSum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kernelConfigs=[_fusedMatMulConfig,absConfig,acosConfig,acoshConfig,addConfig,addNConfig,allConfig,anyConfig,argMaxConfig,argMinConfig,asinConfig,asinhConfig,atanConfig,atan2Config,atanhConfig,avgPoolConfig,avgPool3DConfig,avgPool3DGradConfig,avgPoolGradConfig,batchMatMulConfig,batchNormConfig,batchToSpaceNDConfig,bincountConfig,bitwiseAndConfig,broadcastArgsConfig,castConfig,ceilConfig,clipByValueConfig,complexConfig,complexAbsConfig,concatConfig,conv2DConfig,conv2DBackpropFilterConfig,conv2DBackpropInputConfig,conv3DConfig,conv3DBackpropFilterV2Config,conv3DBackpropInputV2Config,cosConfig,coshConfig,cropAndResizeConfig,cumprodConfig,cumsumConfig,denseBincountConfig,depthToSpaceConfig,depthwiseConv2dNativeConfig,depthwiseConv2dNativeBackpropFilterConfig,depthwiseConv2dNativeBackpropInputConfig,diagConfig,dilation2DConfig,dilation2DBackpropFilterConfig,dilation2DBackpropInputConfig,drawConfig,einsumConfig,eluConfig,eluGradConfig,equalConfig,erfConfig,expConfig,expandDimsConfig,expm1Config,fftConfig,fillConfig,flipLeftRightConfig,floorConfig,floorDivConfig,fusedConv2DConfig,fusedDepthwiseConv2DConfig,gatherNdConfig,gatherV2Config,greaterConfig,greaterEqualConfig,identityConfig,ifftConfig,imagConfig,isFiniteConfig,isInfConfig,isNaNConfig,leakyReluConfig,lessConfig,lessEqualConfig,linSpaceConfig,logConfig,log1pConfig,logicalAndConfig,logicalNotConfig,logicalOrConfig,LRNConfig,LRNGradConfig,maxConfig,maximumConfig,maxPoolConfig,maxPool3DConfig,maxPool3DGradConfig,maxPoolGradConfig,maxPoolWithArgmaxConfig,meanConfig,minConfig,minimumConfig,mirrorPadConfig,modConfig,multinomialConfig,multiplyConfig,negConfig,nonMaxSuppressionV3Config,nonMaxSuppressionV4Config,nonMaxSuppressionV5Config,notEqualConfig,oneHotConfig,onesLikeConfig,packConfig,padV2Config,powConfig,preluConfig,prodConfig,raggedGatherConfig,raggedRangeConfig,raggedTensorToTensorConfig,rangeConfig,realConfig,realDivConfig,reciprocalConfig,reluConfig,relu6Config,reshapeConfig,resizeBilinearConfig,resizeBilinearGradConfig,resizeNearestNeighborConfig,resizeNearestNeighborGradConfig,reverseConfig,rotateWithOffsetConfig,roundConfig,rsqrtConfig,scatterNdConfig,searchSortedConfig,selectConfig,seluConfig,sigmoidConfig,signConfig,sinConfig,sinhConfig,sliceConfig,softmaxConfig,softplusConfig,spaceToBatchNDConfig,sparseFillEmptyRowsConfig,sparseReshapeConfig,sparseSegmentMeanConfig,sparseSegmentSumConfig,sparseToDenseConfig,splitVConfig,sqrtConfig,squareConfig,squaredDifferenceConfig,staticRegexReplaceConfig,stepConfig,stridedSliceConfig,stringNGramsConfig,stringSplitConfig,stringToHashBucketFastConfig,subConfig,sumConfig,tanConfig,tanhConfig,tensorScatterUpdateConfig,tileConfig,topKConfig,transformConfig,transposeConfig,uniqueConfig,unpackConfig,unsortedSegmentSumConfig,zerosLikeConfig];for(const n of kernelConfigs)registerKernel(n);var lodash$1={exports:{}};/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */lodash$1.exports;(function(n,t){(function(){var r,i="4.17.21",s=200,o="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",l="Expected a function",f="Invalid `variable` option passed into `_.template`",u="__lodash_hash_undefined__",_=500,g="__lodash_placeholder__",a=1,m=2,b=4,v=1,c=2,w=1,k=2,x=4,E=8,O=16,A=32,T=64,j=128,I=256,D=512,$=30,N="...",M=800,W=16,F=1,H=2,q=3,Y=1/0,X=9007199254740991,J=17976931348623157e292,te=NaN,ie=4294967295,de=ie-1,ke=ie>>>1,we=[["ary",j],["bind",w],["bindKey",k],["curry",E],["curryRight",O],["flip",D],["partial",A],["partialRight",T],["rearg",I]],_e="[object Arguments]",Ee="[object Array]",Ae="[object AsyncFunction]",je="[object Boolean]",Oe="[object Date]",Pe="[object DOMException]",Ce="[object Error]",z="[object Function]",Z="[object GeneratorFunction]",se="[object Map]",le="[object Number]",ue="[object Null]",pe="[object Object]",be="[object Promise]",ve="[object Proxy]",ge="[object RegExp]",L="[object Set]",P="[object String]",R="[object Symbol]",V="[object Undefined]",Q="[object WeakMap]",oe="[object WeakSet]",ae="[object ArrayBuffer]",xe="[object DataView]",De="[object Float32Array]",Be="[object Float64Array]",He="[object Int8Array]",ze="[object Int16Array]",ot="[object Int32Array]",$t="[object Uint8Array]",nt="[object Uint8ClampedArray]",gt="[object Uint16Array]",yn="[object Uint32Array]",Sa=/\b__p \+= '';/g,Aa=/\b(__p \+=) '' \+/g,Oa=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Ji=/&(?:amp|lt|gt|quot|#39);/g,Yi=/[&<>"']/g,Ia=RegExp(Ji.source),ja=RegExp(Yi.source),Ta=/<%-([\s\S]+?)%>/g,Da=/<%([\s\S]+?)%>/g,Xi=/<%=([\s\S]+?)%>/g,Ca=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Pa=/^\w*$/,Ra=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Br=/[\\^$.*+?()[\]{}|]/g,Ma=RegExp(Br.source),Lr=/^\s+/,$a=/\s/,Ba=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,La=/\{\n\/\* \[wrapped with (.+)\] \*/,Fa=/,? & /,Na=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Ua=/[()=,{}\[\]\/\s]/,Wa=/\\(\\)?/g,qa=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Qi=/\w*$/,Va=/^[-+]0x[0-9a-f]+$/i,Ka=/^0b[01]+$/i,Ha=/^\[object .+?Constructor\]$/,za=/^0o[0-7]+$/i,Ga=/^(?:0|[1-9]\d*)$/,Ja=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Gn=/($^)/,Ya=/['\n\r\u2028\u2029\\]/g,Jn="\\ud800-\\udfff",Xa="\\u0300-\\u036f",Qa="\\ufe20-\\ufe2f",Za="\\u20d0-\\u20ff",Zi=Xa+Qa+Za,es="\\u2700-\\u27bf",ts="a-z\\xdf-\\xf6\\xf8-\\xff",ec="\\xac\\xb1\\xd7\\xf7",tc="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",nc="\\u2000-\\u206f",rc=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",ns="A-Z\\xc0-\\xd6\\xd8-\\xde",rs="\\ufe0e\\ufe0f",is=ec+tc+nc+rc,Fr="['’]",ic="["+Jn+"]",ss="["+is+"]",Yn="["+Zi+"]",os="\\d+",sc="["+es+"]",as="["+ts+"]",cs="[^"+Jn+is+os+es+ts+ns+"]",Nr="\\ud83c[\\udffb-\\udfff]",oc="(?:"+Yn+"|"+Nr+")",ls="[^"+Jn+"]",Ur="(?:\\ud83c[\\udde6-\\uddff]){2}",Wr="[\\ud800-\\udbff][\\udc00-\\udfff]",bn="["+ns+"]",us="\\u200d",ds="(?:"+as+"|"+cs+")",ac="(?:"+bn+"|"+cs+")",fs="(?:"+Fr+"(?:d|ll|m|re|s|t|ve))?",ps="(?:"+Fr+"(?:D|LL|M|RE|S|T|VE))?",hs=oc+"?",ms="["+rs+"]?",cc="(?:"+us+"(?:"+[ls,Ur,Wr].join("|")+")"+ms+hs+")*",lc="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",uc="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",_s=ms+hs+cc,dc="(?:"+[sc,Ur,Wr].join("|")+")"+_s,fc="(?:"+[ls+Yn+"?",Yn,Ur,Wr,ic].join("|")+")",pc=RegExp(Fr,"g"),hc=RegExp(Yn,"g"),qr=RegExp(Nr+"(?="+Nr+")|"+fc+_s,"g"),mc=RegExp([bn+"?"+as+"+"+fs+"(?="+[ss,bn,"$"].join("|")+")",ac+"+"+ps+"(?="+[ss,bn+ds,"$"].join("|")+")",bn+"?"+ds+"+"+fs,bn+"+"+ps,uc,lc,os,dc].join("|"),"g"),_c=RegExp("["+us+Jn+Zi+rs+"]"),gc=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,yc=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],bc=-1,Ze={};Ze[De]=Ze[Be]=Ze[He]=Ze[ze]=Ze[ot]=Ze[$t]=Ze[nt]=Ze[gt]=Ze[yn]=!0,Ze[_e]=Ze[Ee]=Ze[ae]=Ze[je]=Ze[xe]=Ze[Oe]=Ze[Ce]=Ze[z]=Ze[se]=Ze[le]=Ze[pe]=Ze[ge]=Ze[L]=Ze[P]=Ze[Q]=!1;var Qe={};Qe[_e]=Qe[Ee]=Qe[ae]=Qe[xe]=Qe[je]=Qe[Oe]=Qe[De]=Qe[Be]=Qe[He]=Qe[ze]=Qe[ot]=Qe[se]=Qe[le]=Qe[pe]=Qe[ge]=Qe[L]=Qe[P]=Qe[R]=Qe[$t]=Qe[nt]=Qe[gt]=Qe[yn]=!0,Qe[Ce]=Qe[z]=Qe[Q]=!1;var vc={À:"A",Á:"A",Â:"A",Ã:"A",Ä:"A",Å:"A",à:"a",á:"a",â:"a",ã:"a",ä:"a",å:"a",Ç:"C",ç:"c",Ð:"D",ð:"d",È:"E",É:"E",Ê:"E",Ë:"E",è:"e",é:"e",ê:"e",ë:"e",Ì:"I",Í:"I",Î:"I",Ï:"I",ì:"i",í:"i",î:"i",ï:"i",Ñ:"N",ñ:"n",Ò:"O",Ó:"O",Ô:"O",Õ:"O",Ö:"O",Ø:"O",ò:"o",ó:"o",ô:"o",õ:"o",ö:"o",ø:"o",Ù:"U",Ú:"U",Û:"U",Ü:"U",ù:"u",ú:"u",û:"u",ü:"u",Ý:"Y",ý:"y",ÿ:"y",Æ:"Ae",æ:"ae",Þ:"Th",þ:"th",ß:"ss",Ā:"A",Ă:"A",Ą:"A",ā:"a",ă:"a",ą:"a",Ć:"C",Ĉ:"C",Ċ:"C",Č:"C",ć:"c",ĉ:"c",ċ:"c",č:"c",Ď:"D",Đ:"D",ď:"d",đ:"d",Ē:"E",Ĕ:"E",Ė:"E",Ę:"E",Ě:"E",ē:"e",ĕ:"e",ė:"e",ę:"e",ě:"e",Ĝ:"G",Ğ:"G",Ġ:"G",Ģ:"G",ĝ:"g",ğ:"g",ġ:"g",ģ:"g",Ĥ:"H",Ħ:"H",ĥ:"h",ħ:"h",Ĩ:"I",Ī:"I",Ĭ:"I",Į:"I",İ:"I",ĩ:"i",ī:"i",ĭ:"i",į:"i",ı:"i",Ĵ:"J",ĵ:"j",Ķ:"K",ķ:"k",ĸ:"k",Ĺ:"L",Ļ:"L",Ľ:"L",Ŀ:"L",Ł:"L",ĺ:"l",ļ:"l",ľ:"l",ŀ:"l",ł:"l",Ń:"N",Ņ:"N",Ň:"N",Ŋ:"N",ń:"n",ņ:"n",ň:"n",ŋ:"n",Ō:"O",Ŏ:"O",Ő:"O",ō:"o",ŏ:"o",ő:"o",Ŕ:"R",Ŗ:"R",Ř:"R",ŕ:"r",ŗ:"r",ř:"r",Ś:"S",Ŝ:"S",Ş:"S",Š:"S",ś:"s",ŝ:"s",ş:"s",š:"s",Ţ:"T",Ť:"T",Ŧ:"T",ţ:"t",ť:"t",ŧ:"t",Ũ:"U",Ū:"U",Ŭ:"U",Ů:"U",Ű:"U",Ų:"U",ũ:"u",ū:"u",ŭ:"u",ů:"u",ű:"u",ų:"u",Ŵ:"W",ŵ:"w",Ŷ:"Y",ŷ:"y",Ÿ:"Y",Ź:"Z",Ż:"Z",Ž:"Z",ź:"z",ż:"z",ž:"z",Ĳ:"IJ",ĳ:"ij",Œ:"Oe",œ:"oe",ŉ:"'n",ſ:"s"},wc={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},kc={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Ec={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},xc=parseFloat,Sc=parseInt,gs=typeof commonjsGlobal=="object"&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal,Ac=typeof self=="object"&&self&&self.Object===Object&&self,ut=gs||Ac||Function("return this")(),Vr=t&&!t.nodeType&&t,ln=Vr&&!0&&n&&!n.nodeType&&n,ys=ln&&ln.exports===Vr,Kr=ys&&gs.process,It=function(){try{var ne=ln&&ln.require&&ln.require("util").types;return ne||Kr&&Kr.binding&&Kr.binding("util")}catch{}}(),bs=It&&It.isArrayBuffer,vs=It&&It.isDate,ws=It&&It.isMap,ks=It&&It.isRegExp,Es=It&&It.isSet,xs=It&&It.isTypedArray;function kt(ne,fe,ce){switch(ce.length){case 0:return ne.call(fe);case 1:return ne.call(fe,ce[0]);case 2:return ne.call(fe,ce[0],ce[1]);case 3:return ne.call(fe,ce[0],ce[1],ce[2])}return ne.apply(fe,ce)}function Oc(ne,fe,ce,Ie){for(var Le=-1,Ge=ne==null?0:ne.length;++Le<Ge;){var at=ne[Le];fe(Ie,at,ce(at),ne)}return Ie}function jt(ne,fe){for(var ce=-1,Ie=ne==null?0:ne.length;++ce<Ie&&fe(ne[ce],ce,ne)!==!1;);return ne}function Ic(ne,fe){for(var ce=ne==null?0:ne.length;ce--&&fe(ne[ce],ce,ne)!==!1;);return ne}function Ss(ne,fe){for(var ce=-1,Ie=ne==null?0:ne.length;++ce<Ie;)if(!fe(ne[ce],ce,ne))return!1;return!0}function Zt(ne,fe){for(var ce=-1,Ie=ne==null?0:ne.length,Le=0,Ge=[];++ce<Ie;){var at=ne[ce];fe(at,ce,ne)&&(Ge[Le++]=at)}return Ge}function Xn(ne,fe){var ce=ne==null?0:ne.length;return!!ce&&vn(ne,fe,0)>-1}function Hr(ne,fe,ce){for(var Ie=-1,Le=ne==null?0:ne.length;++Ie<Le;)if(ce(fe,ne[Ie]))return!0;return!1}function et(ne,fe){for(var ce=-1,Ie=ne==null?0:ne.length,Le=Array(Ie);++ce<Ie;)Le[ce]=fe(ne[ce],ce,ne);return Le}function en(ne,fe){for(var ce=-1,Ie=fe.length,Le=ne.length;++ce<Ie;)ne[Le+ce]=fe[ce];return ne}function zr(ne,fe,ce,Ie){var Le=-1,Ge=ne==null?0:ne.length;for(Ie&&Ge&&(ce=ne[++Le]);++Le<Ge;)ce=fe(ce,ne[Le],Le,ne);return ce}function jc(ne,fe,ce,Ie){var Le=ne==null?0:ne.length;for(Ie&&Le&&(ce=ne[--Le]);Le--;)ce=fe(ce,ne[Le],Le,ne);return ce}function Gr(ne,fe){for(var ce=-1,Ie=ne==null?0:ne.length;++ce<Ie;)if(fe(ne[ce],ce,ne))return!0;return!1}var Tc=Jr("length");function Dc(ne){return ne.split("")}function Cc(ne){return ne.match(Na)||[]}function As(ne,fe,ce){var Ie;return ce(ne,function(Le,Ge,at){if(fe(Le,Ge,at))return Ie=Ge,!1}),Ie}function Qn(ne,fe,ce,Ie){for(var Le=ne.length,Ge=ce+(Ie?1:-1);Ie?Ge--:++Ge<Le;)if(fe(ne[Ge],Ge,ne))return Ge;return-1}function vn(ne,fe,ce){return fe===fe?Vc(ne,fe,ce):Qn(ne,Os,ce)}function Pc(ne,fe,ce,Ie){for(var Le=ce-1,Ge=ne.length;++Le<Ge;)if(Ie(ne[Le],fe))return Le;return-1}function Os(ne){return ne!==ne}function Is(ne,fe){var ce=ne==null?0:ne.length;return ce?Xr(ne,fe)/ce:te}function Jr(ne){return function(fe){return fe==null?r:fe[ne]}}function Yr(ne){return function(fe){return ne==null?r:ne[fe]}}function js(ne,fe,ce,Ie,Le){return Le(ne,function(Ge,at,Xe){ce=Ie?(Ie=!1,Ge):fe(ce,Ge,at,Xe)}),ce}function Rc(ne,fe){var ce=ne.length;for(ne.sort(fe);ce--;)ne[ce]=ne[ce].value;return ne}function Xr(ne,fe){for(var ce,Ie=-1,Le=ne.length;++Ie<Le;){var Ge=fe(ne[Ie]);Ge!==r&&(ce=ce===r?Ge:ce+Ge)}return ce}function Qr(ne,fe){for(var ce=-1,Ie=Array(ne);++ce<ne;)Ie[ce]=fe(ce);return Ie}function Mc(ne,fe){return et(fe,function(ce){return[ce,ne[ce]]})}function Ts(ne){return ne&&ne.slice(0,Rs(ne)+1).replace(Lr,"")}function Et(ne){return function(fe){return ne(fe)}}function Zr(ne,fe){return et(fe,function(ce){return ne[ce]})}function Pn(ne,fe){return ne.has(fe)}function Ds(ne,fe){for(var ce=-1,Ie=ne.length;++ce<Ie&&vn(fe,ne[ce],0)>-1;);return ce}function Cs(ne,fe){for(var ce=ne.length;ce--&&vn(fe,ne[ce],0)>-1;);return ce}function $c(ne,fe){for(var ce=ne.length,Ie=0;ce--;)ne[ce]===fe&&++Ie;return Ie}var Bc=Yr(vc),Lc=Yr(wc);function Fc(ne){return"\\"+Ec[ne]}function Nc(ne,fe){return ne==null?r:ne[fe]}function wn(ne){return _c.test(ne)}function Uc(ne){return gc.test(ne)}function Wc(ne){for(var fe,ce=[];!(fe=ne.next()).done;)ce.push(fe.value);return ce}function ei(ne){var fe=-1,ce=Array(ne.size);return ne.forEach(function(Ie,Le){ce[++fe]=[Le,Ie]}),ce}function Ps(ne,fe){return function(ce){return ne(fe(ce))}}function tn(ne,fe){for(var ce=-1,Ie=ne.length,Le=0,Ge=[];++ce<Ie;){var at=ne[ce];(at===fe||at===g)&&(ne[ce]=g,Ge[Le++]=ce)}return Ge}function Zn(ne){var fe=-1,ce=Array(ne.size);return ne.forEach(function(Ie){ce[++fe]=Ie}),ce}function qc(ne){var fe=-1,ce=Array(ne.size);return ne.forEach(function(Ie){ce[++fe]=[Ie,Ie]}),ce}function Vc(ne,fe,ce){for(var Ie=ce-1,Le=ne.length;++Ie<Le;)if(ne[Ie]===fe)return Ie;return-1}function Kc(ne,fe,ce){for(var Ie=ce+1;Ie--;)if(ne[Ie]===fe)return Ie;return Ie}function kn(ne){return wn(ne)?zc(ne):Tc(ne)}function Bt(ne){return wn(ne)?Gc(ne):Dc(ne)}function Rs(ne){for(var fe=ne.length;fe--&&$a.test(ne.charAt(fe)););return fe}var Hc=Yr(kc);function zc(ne){for(var fe=qr.lastIndex=0;qr.test(ne);)++fe;return fe}function Gc(ne){return ne.match(qr)||[]}function Jc(ne){return ne.match(mc)||[]}var Yc=function ne(fe){fe=fe==null?ut:En.defaults(ut.Object(),fe,En.pick(ut,yc));var ce=fe.Array,Ie=fe.Date,Le=fe.Error,Ge=fe.Function,at=fe.Math,Xe=fe.Object,ti=fe.RegExp,Xc=fe.String,Tt=fe.TypeError,er=ce.prototype,Qc=Ge.prototype,xn=Xe.prototype,tr=fe["__core-js_shared__"],nr=Qc.toString,Ye=xn.hasOwnProperty,Zc=0,Ms=function(){var d=/[^.]+$/.exec(tr&&tr.keys&&tr.keys.IE_PROTO||"");return d?"Symbol(src)_1."+d:""}(),rr=xn.toString,el=nr.call(Xe),tl=ut._,nl=ti("^"+nr.call(Ye).replace(Br,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ir=ys?fe.Buffer:r,nn=fe.Symbol,or=fe.Uint8Array,$s=ir?ir.allocUnsafe:r,ar=Ps(Xe.getPrototypeOf,Xe),Bs=Xe.create,Ls=xn.propertyIsEnumerable,cr=er.splice,Fs=nn?nn.isConcatSpreadable:r,Rn=nn?nn.iterator:r,un=nn?nn.toStringTag:r,lr=function(){try{var d=mn(Xe,"defineProperty");return d({},"",{}),d}catch{}}(),rl=fe.clearTimeout!==ut.clearTimeout&&fe.clearTimeout,il=Ie&&Ie.now!==ut.Date.now&&Ie.now,sl=fe.setTimeout!==ut.setTimeout&&fe.setTimeout,ur=at.ceil,dr=at.floor,ni=Xe.getOwnPropertySymbols,ol=ir?ir.isBuffer:r,Ns=fe.isFinite,al=er.join,cl=Ps(Xe.keys,Xe),ct=at.max,ft=at.min,ll=Ie.now,ul=fe.parseInt,Us=at.random,dl=er.reverse,ri=mn(fe,"DataView"),Mn=mn(fe,"Map"),ii=mn(fe,"Promise"),Sn=mn(fe,"Set"),$n=mn(fe,"WeakMap"),Bn=mn(Xe,"create"),fr=$n&&new $n,An={},fl=_n(ri),pl=_n(Mn),hl=_n(ii),ml=_n(Sn),_l=_n($n),pr=nn?nn.prototype:r,Ln=pr?pr.valueOf:r,Ws=pr?pr.toString:r;function U(d){if(rt(d)&&!Fe(d)&&!(d instanceof Ve)){if(d instanceof Dt)return d;if(Ye.call(d,"__wrapped__"))return Vo(d)}return new Dt(d)}var On=function(){function d(){}return function(y){if(!tt(y))return{};if(Bs)return Bs(y);d.prototype=y;var S=new d;return d.prototype=r,S}}();function hr(){}function Dt(d,y){this.__wrapped__=d,this.__actions__=[],this.__chain__=!!y,this.__index__=0,this.__values__=r}U.templateSettings={escape:Ta,evaluate:Da,interpolate:Xi,variable:"",imports:{_:U}},U.prototype=hr.prototype,U.prototype.constructor=U,Dt.prototype=On(hr.prototype),Dt.prototype.constructor=Dt;function Ve(d){this.__wrapped__=d,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=ie,this.__views__=[]}function gl(){var d=new Ve(this.__wrapped__);return d.__actions__=yt(this.__actions__),d.__dir__=this.__dir__,d.__filtered__=this.__filtered__,d.__iteratees__=yt(this.__iteratees__),d.__takeCount__=this.__takeCount__,d.__views__=yt(this.__views__),d}function yl(){if(this.__filtered__){var d=new Ve(this);d.__dir__=-1,d.__filtered__=!0}else d=this.clone(),d.__dir__*=-1;return d}function bl(){var d=this.__wrapped__.value(),y=this.__dir__,S=Fe(d),C=y<0,B=S?d.length:0,K=Du(0,B,this.__views__),G=K.start,ee=K.end,re=ee-G,he=C?ee:G-1,me=this.__iteratees__,ye=me.length,Se=0,Te=ft(re,this.__takeCount__);if(!S||!C&&B==re&&Te==re)return po(d,this.__actions__);var Me=[];e:for(;re--&&Se<Te;){he+=y;for(var Ue=-1,$e=d[he];++Ue<ye;){var qe=me[Ue],Ke=qe.iteratee,At=qe.type,_t=Ke($e);if(At==H)$e=_t;else if(!_t){if(At==F)continue e;break e}}Me[Se++]=$e}return Me}Ve.prototype=On(hr.prototype),Ve.prototype.constructor=Ve;function dn(d){var y=-1,S=d==null?0:d.length;for(this.clear();++y<S;){var C=d[y];this.set(C[0],C[1])}}function vl(){this.__data__=Bn?Bn(null):{},this.size=0}function wl(d){var y=this.has(d)&&delete this.__data__[d];return this.size-=y?1:0,y}function kl(d){var y=this.__data__;if(Bn){var S=y[d];return S===u?r:S}return Ye.call(y,d)?y[d]:r}function El(d){var y=this.__data__;return Bn?y[d]!==r:Ye.call(y,d)}function xl(d,y){var S=this.__data__;return this.size+=this.has(d)?0:1,S[d]=Bn&&y===r?u:y,this}dn.prototype.clear=vl,dn.prototype.delete=wl,dn.prototype.get=kl,dn.prototype.has=El,dn.prototype.set=xl;function Vt(d){var y=-1,S=d==null?0:d.length;for(this.clear();++y<S;){var C=d[y];this.set(C[0],C[1])}}function Sl(){this.__data__=[],this.size=0}function Al(d){var y=this.__data__,S=mr(y,d);if(S<0)return!1;var C=y.length-1;return S==C?y.pop():cr.call(y,S,1),--this.size,!0}function Ol(d){var y=this.__data__,S=mr(y,d);return S<0?r:y[S][1]}function Il(d){return mr(this.__data__,d)>-1}function jl(d,y){var S=this.__data__,C=mr(S,d);return C<0?(++this.size,S.push([d,y])):S[C][1]=y,this}Vt.prototype.clear=Sl,Vt.prototype.delete=Al,Vt.prototype.get=Ol,Vt.prototype.has=Il,Vt.prototype.set=jl;function Kt(d){var y=-1,S=d==null?0:d.length;for(this.clear();++y<S;){var C=d[y];this.set(C[0],C[1])}}function Tl(){this.size=0,this.__data__={hash:new dn,map:new(Mn||Vt),string:new dn}}function Dl(d){var y=Or(this,d).delete(d);return this.size-=y?1:0,y}function Cl(d){return Or(this,d).get(d)}function Pl(d){return Or(this,d).has(d)}function Rl(d,y){var S=Or(this,d),C=S.size;return S.set(d,y),this.size+=S.size==C?0:1,this}Kt.prototype.clear=Tl,Kt.prototype.delete=Dl,Kt.prototype.get=Cl,Kt.prototype.has=Pl,Kt.prototype.set=Rl;function fn(d){var y=-1,S=d==null?0:d.length;for(this.__data__=new Kt;++y<S;)this.add(d[y])}function Ml(d){return this.__data__.set(d,u),this}function $l(d){return this.__data__.has(d)}fn.prototype.add=fn.prototype.push=Ml,fn.prototype.has=$l;function Lt(d){var y=this.__data__=new Vt(d);this.size=y.size}function Bl(){this.__data__=new Vt,this.size=0}function Ll(d){var y=this.__data__,S=y.delete(d);return this.size=y.size,S}function Fl(d){return this.__data__.get(d)}function Nl(d){return this.__data__.has(d)}function Ul(d,y){var S=this.__data__;if(S instanceof Vt){var C=S.__data__;if(!Mn||C.length<s-1)return C.push([d,y]),this.size=++S.size,this;S=this.__data__=new Kt(C)}return S.set(d,y),this.size=S.size,this}Lt.prototype.clear=Bl,Lt.prototype.delete=Ll,Lt.prototype.get=Fl,Lt.prototype.has=Nl,Lt.prototype.set=Ul;function qs(d,y){var S=Fe(d),C=!S&&gn(d),B=!S&&!C&&cn(d),K=!S&&!C&&!B&&Dn(d),G=S||C||B||K,ee=G?Qr(d.length,Xc):[],re=ee.length;for(var he in d)(y||Ye.call(d,he))&&!(G&&(he=="length"||B&&(he=="offset"||he=="parent")||K&&(he=="buffer"||he=="byteLength"||he=="byteOffset")||Jt(he,re)))&&ee.push(he);return ee}function Vs(d){var y=d.length;return y?d[mi(0,y-1)]:r}function Wl(d,y){return Ir(yt(d),pn(y,0,d.length))}function ql(d){return Ir(yt(d))}function si(d,y,S){(S!==r&&!Ft(d[y],S)||S===r&&!(y in d))&&Ht(d,y,S)}function Fn(d,y,S){var C=d[y];(!(Ye.call(d,y)&&Ft(C,S))||S===r&&!(y in d))&&Ht(d,y,S)}function mr(d,y){for(var S=d.length;S--;)if(Ft(d[S][0],y))return S;return-1}function Vl(d,y,S,C){return rn(d,function(B,K,G){y(C,B,S(B),G)}),C}function Ks(d,y){return d&&Wt(y,lt(y),d)}function Kl(d,y){return d&&Wt(y,vt(y),d)}function Ht(d,y,S){y=="__proto__"&&lr?lr(d,y,{configurable:!0,enumerable:!0,value:S,writable:!0}):d[y]=S}function oi(d,y){for(var S=-1,C=y.length,B=ce(C),K=d==null;++S<C;)B[S]=K?r:Ni(d,y[S]);return B}function pn(d,y,S){return d===d&&(S!==r&&(d=d<=S?d:S),y!==r&&(d=d>=y?d:y)),d}function Ct(d,y,S,C,B,K){var G,ee=y&a,re=y&m,he=y&b;if(S&&(G=B?S(d,C,B,K):S(d)),G!==r)return G;if(!tt(d))return d;var me=Fe(d);if(me){if(G=Pu(d),!ee)return yt(d,G)}else{var ye=pt(d),Se=ye==z||ye==Z;if(cn(d))return _o(d,ee);if(ye==pe||ye==_e||Se&&!B){if(G=re||Se?{}:Mo(d),!ee)return re?ku(d,Kl(G,d)):wu(d,Ks(G,d))}else{if(!Qe[ye])return B?d:{};G=Ru(d,ye,ee)}}K||(K=new Lt);var Te=K.get(d);if(Te)return Te;K.set(d,G),ua(d)?d.forEach(function($e){G.add(Ct($e,y,S,$e,d,K))}):ca(d)&&d.forEach(function($e,qe){G.set(qe,Ct($e,y,S,qe,d,K))});var Me=he?re?Ai:Si:re?vt:lt,Ue=me?r:Me(d);return jt(Ue||d,function($e,qe){Ue&&(qe=$e,$e=d[qe]),Fn(G,qe,Ct($e,y,S,qe,d,K))}),G}function Hl(d){var y=lt(d);return function(S){return Hs(S,d,y)}}function Hs(d,y,S){var C=S.length;if(d==null)return!C;for(d=Xe(d);C--;){var B=S[C],K=y[B],G=d[B];if(G===r&&!(B in d)||!K(G))return!1}return!0}function zs(d,y,S){if(typeof d!="function")throw new Tt(l);return Hn(function(){d.apply(r,S)},y)}function Nn(d,y,S,C){var B=-1,K=Xn,G=!0,ee=d.length,re=[],he=y.length;if(!ee)return re;S&&(y=et(y,Et(S))),C?(K=Hr,G=!1):y.length>=s&&(K=Pn,G=!1,y=new fn(y));e:for(;++B<ee;){var me=d[B],ye=S==null?me:S(me);if(me=C||me!==0?me:0,G&&ye===ye){for(var Se=he;Se--;)if(y[Se]===ye)continue e;re.push(me)}else K(y,ye,C)||re.push(me)}return re}var rn=wo(Ut),Gs=wo(ci,!0);function zl(d,y){var S=!0;return rn(d,function(C,B,K){return S=!!y(C,B,K),S}),S}function _r(d,y,S){for(var C=-1,B=d.length;++C<B;){var K=d[C],G=y(K);if(G!=null&&(ee===r?G===G&&!St(G):S(G,ee)))var ee=G,re=K}return re}function Gl(d,y,S,C){var B=d.length;for(S=Ne(S),S<0&&(S=-S>B?0:B+S),C=C===r||C>B?B:Ne(C),C<0&&(C+=B),C=S>C?0:fa(C);S<C;)d[S++]=y;return d}function Js(d,y){var S=[];return rn(d,function(C,B,K){y(C,B,K)&&S.push(C)}),S}function dt(d,y,S,C,B){var K=-1,G=d.length;for(S||(S=$u),B||(B=[]);++K<G;){var ee=d[K];y>0&&S(ee)?y>1?dt(ee,y-1,S,C,B):en(B,ee):C||(B[B.length]=ee)}return B}var ai=ko(),Ys=ko(!0);function Ut(d,y){return d&&ai(d,y,lt)}function ci(d,y){return d&&Ys(d,y,lt)}function gr(d,y){return Zt(y,function(S){return Yt(d[S])})}function hn(d,y){y=on(y,d);for(var S=0,C=y.length;d!=null&&S<C;)d=d[qt(y[S++])];return S&&S==C?d:r}function Xs(d,y,S){var C=y(d);return Fe(d)?C:en(C,S(d))}function ht(d){return d==null?d===r?V:ue:un&&un in Xe(d)?Tu(d):qu(d)}function li(d,y){return d>y}function Jl(d,y){return d!=null&&Ye.call(d,y)}function Yl(d,y){return d!=null&&y in Xe(d)}function Xl(d,y,S){return d>=ft(y,S)&&d<ct(y,S)}function ui(d,y,S){for(var C=S?Hr:Xn,B=d[0].length,K=d.length,G=K,ee=ce(K),re=1/0,he=[];G--;){var me=d[G];G&&y&&(me=et(me,Et(y))),re=ft(me.length,re),ee[G]=!S&&(y||B>=120&&me.length>=120)?new fn(G&&me):r}me=d[0];var ye=-1,Se=ee[0];e:for(;++ye<B&&he.length<re;){var Te=me[ye],Me=y?y(Te):Te;if(Te=S||Te!==0?Te:0,!(Se?Pn(Se,Me):C(he,Me,S))){for(G=K;--G;){var Ue=ee[G];if(!(Ue?Pn(Ue,Me):C(d[G],Me,S)))continue e}Se&&Se.push(Me),he.push(Te)}}return he}function Ql(d,y,S,C){return Ut(d,function(B,K,G){y(C,S(B),K,G)}),C}function Un(d,y,S){y=on(y,d),d=Fo(d,y);var C=d==null?d:d[qt(Rt(y))];return C==null?r:kt(C,d,S)}function Qs(d){return rt(d)&&ht(d)==_e}function Zl(d){return rt(d)&&ht(d)==ae}function eu(d){return rt(d)&&ht(d)==Oe}function Wn(d,y,S,C,B){return d===y?!0:d==null||y==null||!rt(d)&&!rt(y)?d!==d&&y!==y:tu(d,y,S,C,Wn,B)}function tu(d,y,S,C,B,K){var G=Fe(d),ee=Fe(y),re=G?Ee:pt(d),he=ee?Ee:pt(y);re=re==_e?pe:re,he=he==_e?pe:he;var me=re==pe,ye=he==pe,Se=re==he;if(Se&&cn(d)){if(!cn(y))return!1;G=!0,me=!1}if(Se&&!me)return K||(K=new Lt),G||Dn(d)?Co(d,y,S,C,B,K):Iu(d,y,re,S,C,B,K);if(!(S&v)){var Te=me&&Ye.call(d,"__wrapped__"),Me=ye&&Ye.call(y,"__wrapped__");if(Te||Me){var Ue=Te?d.value():d,$e=Me?y.value():y;return K||(K=new Lt),B(Ue,$e,S,C,K)}}return Se?(K||(K=new Lt),ju(d,y,S,C,B,K)):!1}function nu(d){return rt(d)&&pt(d)==se}function di(d,y,S,C){var B=S.length,K=B,G=!C;if(d==null)return!K;for(d=Xe(d);B--;){var ee=S[B];if(G&&ee[2]?ee[1]!==d[ee[0]]:!(ee[0]in d))return!1}for(;++B<K;){ee=S[B];var re=ee[0],he=d[re],me=ee[1];if(G&&ee[2]){if(he===r&&!(re in d))return!1}else{var ye=new Lt;if(C)var Se=C(he,me,re,d,y,ye);if(!(Se===r?Wn(me,he,v|c,C,ye):Se))return!1}}return!0}function Zs(d){if(!tt(d)||Lu(d))return!1;var y=Yt(d)?nl:Ha;return y.test(_n(d))}function ru(d){return rt(d)&&ht(d)==ge}function iu(d){return rt(d)&&pt(d)==L}function su(d){return rt(d)&&Rr(d.length)&&!!Ze[ht(d)]}function eo(d){return typeof d=="function"?d:d==null?wt:typeof d=="object"?Fe(d)?ro(d[0],d[1]):no(d):Ea(d)}function fi(d){if(!Kn(d))return cl(d);var y=[];for(var S in Xe(d))Ye.call(d,S)&&S!="constructor"&&y.push(S);return y}function ou(d){if(!tt(d))return Wu(d);var y=Kn(d),S=[];for(var C in d)C=="constructor"&&(y||!Ye.call(d,C))||S.push(C);return S}function pi(d,y){return d<y}function to(d,y){var S=-1,C=bt(d)?ce(d.length):[];return rn(d,function(B,K,G){C[++S]=y(B,K,G)}),C}function no(d){var y=Ii(d);return y.length==1&&y[0][2]?Bo(y[0][0],y[0][1]):function(S){return S===d||di(S,d,y)}}function ro(d,y){return Ti(d)&&$o(y)?Bo(qt(d),y):function(S){var C=Ni(S,d);return C===r&&C===y?Ui(S,d):Wn(y,C,v|c)}}function yr(d,y,S,C,B){d!==y&&ai(y,function(K,G){if(B||(B=new Lt),tt(K))au(d,y,G,S,yr,C,B);else{var ee=C?C(Ci(d,G),K,G+"",d,y,B):r;ee===r&&(ee=K),si(d,G,ee)}},vt)}function au(d,y,S,C,B,K,G){var ee=Ci(d,S),re=Ci(y,S),he=G.get(re);if(he){si(d,S,he);return}var me=K?K(ee,re,S+"",d,y,G):r,ye=me===r;if(ye){var Se=Fe(re),Te=!Se&&cn(re),Me=!Se&&!Te&&Dn(re);me=re,Se||Te||Me?Fe(ee)?me=ee:it(ee)?me=yt(ee):Te?(ye=!1,me=_o(re,!0)):Me?(ye=!1,me=go(re,!0)):me=[]:zn(re)||gn(re)?(me=ee,gn(ee)?me=pa(ee):(!tt(ee)||Yt(ee))&&(me=Mo(re))):ye=!1}ye&&(G.set(re,me),B(me,re,C,K,G),G.delete(re)),si(d,S,me)}function io(d,y){var S=d.length;if(S)return y+=y<0?S:0,Jt(y,S)?d[y]:r}function so(d,y,S){y.length?y=et(y,function(K){return Fe(K)?function(G){return hn(G,K.length===1?K[0]:K)}:K}):y=[wt];var C=-1;y=et(y,Et(Re()));var B=to(d,function(K,G,ee){var re=et(y,function(he){return he(K)});return{criteria:re,index:++C,value:K}});return Rc(B,function(K,G){return vu(K,G,S)})}function cu(d,y){return oo(d,y,function(S,C){return Ui(d,C)})}function oo(d,y,S){for(var C=-1,B=y.length,K={};++C<B;){var G=y[C],ee=hn(d,G);S(ee,G)&&qn(K,on(G,d),ee)}return K}function lu(d){return function(y){return hn(y,d)}}function hi(d,y,S,C){var B=C?Pc:vn,K=-1,G=y.length,ee=d;for(d===y&&(y=yt(y)),S&&(ee=et(d,Et(S)));++K<G;)for(var re=0,he=y[K],me=S?S(he):he;(re=B(ee,me,re,C))>-1;)ee!==d&&cr.call(ee,re,1),cr.call(d,re,1);return d}function ao(d,y){for(var S=d?y.length:0,C=S-1;S--;){var B=y[S];if(S==C||B!==K){var K=B;Jt(B)?cr.call(d,B,1):yi(d,B)}}return d}function mi(d,y){return d+dr(Us()*(y-d+1))}function uu(d,y,S,C){for(var B=-1,K=ct(ur((y-d)/(S||1)),0),G=ce(K);K--;)G[C?K:++B]=d,d+=S;return G}function _i(d,y){var S="";if(!d||y<1||y>X)return S;do y%2&&(S+=d),y=dr(y/2),y&&(d+=d);while(y);return S}function We(d,y){return Pi(Lo(d,y,wt),d+"")}function du(d){return Vs(Cn(d))}function fu(d,y){var S=Cn(d);return Ir(S,pn(y,0,S.length))}function qn(d,y,S,C){if(!tt(d))return d;y=on(y,d);for(var B=-1,K=y.length,G=K-1,ee=d;ee!=null&&++B<K;){var re=qt(y[B]),he=S;if(re==="__proto__"||re==="constructor"||re==="prototype")return d;if(B!=G){var me=ee[re];he=C?C(me,re,ee):r,he===r&&(he=tt(me)?me:Jt(y[B+1])?[]:{})}Fn(ee,re,he),ee=ee[re]}return d}var co=fr?function(d,y){return fr.set(d,y),d}:wt,pu=lr?function(d,y){return lr(d,"toString",{configurable:!0,enumerable:!1,value:qi(y),writable:!0})}:wt;function hu(d){return Ir(Cn(d))}function Pt(d,y,S){var C=-1,B=d.length;y<0&&(y=-y>B?0:B+y),S=S>B?B:S,S<0&&(S+=B),B=y>S?0:S-y>>>0,y>>>=0;for(var K=ce(B);++C<B;)K[C]=d[C+y];return K}function mu(d,y){var S;return rn(d,function(C,B,K){return S=y(C,B,K),!S}),!!S}function br(d,y,S){var C=0,B=d==null?C:d.length;if(typeof y=="number"&&y===y&&B<=ke){for(;C<B;){var K=C+B>>>1,G=d[K];G!==null&&!St(G)&&(S?G<=y:G<y)?C=K+1:B=K}return B}return gi(d,y,wt,S)}function gi(d,y,S,C){var B=0,K=d==null?0:d.length;if(K===0)return 0;y=S(y);for(var G=y!==y,ee=y===null,re=St(y),he=y===r;B<K;){var me=dr((B+K)/2),ye=S(d[me]),Se=ye!==r,Te=ye===null,Me=ye===ye,Ue=St(ye);if(G)var $e=C||Me;else he?$e=Me&&(C||Se):ee?$e=Me&&Se&&(C||!Te):re?$e=Me&&Se&&!Te&&(C||!Ue):Te||Ue?$e=!1:$e=C?ye<=y:ye<y;$e?B=me+1:K=me}return ft(K,de)}function lo(d,y){for(var S=-1,C=d.length,B=0,K=[];++S<C;){var G=d[S],ee=y?y(G):G;if(!S||!Ft(ee,re)){var re=ee;K[B++]=G===0?0:G}}return K}function uo(d){return typeof d=="number"?d:St(d)?te:+d}function xt(d){if(typeof d=="string")return d;if(Fe(d))return et(d,xt)+"";if(St(d))return Ws?Ws.call(d):"";var y=d+"";return y=="0"&&1/d==-Y?"-0":y}function sn(d,y,S){var C=-1,B=Xn,K=d.length,G=!0,ee=[],re=ee;if(S)G=!1,B=Hr;else if(K>=s){var he=y?null:Au(d);if(he)return Zn(he);G=!1,B=Pn,re=new fn}else re=y?[]:ee;e:for(;++C<K;){var me=d[C],ye=y?y(me):me;if(me=S||me!==0?me:0,G&&ye===ye){for(var Se=re.length;Se--;)if(re[Se]===ye)continue e;y&&re.push(ye),ee.push(me)}else B(re,ye,S)||(re!==ee&&re.push(ye),ee.push(me))}return ee}function yi(d,y){return y=on(y,d),d=Fo(d,y),d==null||delete d[qt(Rt(y))]}function fo(d,y,S,C){return qn(d,y,S(hn(d,y)),C)}function vr(d,y,S,C){for(var B=d.length,K=C?B:-1;(C?K--:++K<B)&&y(d[K],K,d););return S?Pt(d,C?0:K,C?K+1:B):Pt(d,C?K+1:0,C?B:K)}function po(d,y){var S=d;return S instanceof Ve&&(S=S.value()),zr(y,function(C,B){return B.func.apply(B.thisArg,en([C],B.args))},S)}function bi(d,y,S){var C=d.length;if(C<2)return C?sn(d[0]):[];for(var B=-1,K=ce(C);++B<C;)for(var G=d[B],ee=-1;++ee<C;)ee!=B&&(K[B]=Nn(K[B]||G,d[ee],y,S));return sn(dt(K,1),y,S)}function ho(d,y,S){for(var C=-1,B=d.length,K=y.length,G={};++C<B;){var ee=C<K?y[C]:r;S(G,d[C],ee)}return G}function vi(d){return it(d)?d:[]}function wi(d){return typeof d=="function"?d:wt}function on(d,y){return Fe(d)?d:Ti(d,y)?[d]:qo(Je(d))}var _u=We;function an(d,y,S){var C=d.length;return S=S===r?C:S,!y&&S>=C?d:Pt(d,y,S)}var mo=rl||function(d){return ut.clearTimeout(d)};function _o(d,y){if(y)return d.slice();var S=d.length,C=$s?$s(S):new d.constructor(S);return d.copy(C),C}function ki(d){var y=new d.constructor(d.byteLength);return new or(y).set(new or(d)),y}function gu(d,y){var S=y?ki(d.buffer):d.buffer;return new d.constructor(S,d.byteOffset,d.byteLength)}function yu(d){var y=new d.constructor(d.source,Qi.exec(d));return y.lastIndex=d.lastIndex,y}function bu(d){return Ln?Xe(Ln.call(d)):{}}function go(d,y){var S=y?ki(d.buffer):d.buffer;return new d.constructor(S,d.byteOffset,d.length)}function yo(d,y){if(d!==y){var S=d!==r,C=d===null,B=d===d,K=St(d),G=y!==r,ee=y===null,re=y===y,he=St(y);if(!ee&&!he&&!K&&d>y||K&&G&&re&&!ee&&!he||C&&G&&re||!S&&re||!B)return 1;if(!C&&!K&&!he&&d<y||he&&S&&B&&!C&&!K||ee&&S&&B||!G&&B||!re)return-1}return 0}function vu(d,y,S){for(var C=-1,B=d.criteria,K=y.criteria,G=B.length,ee=S.length;++C<G;){var re=yo(B[C],K[C]);if(re){if(C>=ee)return re;var he=S[C];return re*(he=="desc"?-1:1)}}return d.index-y.index}function bo(d,y,S,C){for(var B=-1,K=d.length,G=S.length,ee=-1,re=y.length,he=ct(K-G,0),me=ce(re+he),ye=!C;++ee<re;)me[ee]=y[ee];for(;++B<G;)(ye||B<K)&&(me[S[B]]=d[B]);for(;he--;)me[ee++]=d[B++];return me}function vo(d,y,S,C){for(var B=-1,K=d.length,G=-1,ee=S.length,re=-1,he=y.length,me=ct(K-ee,0),ye=ce(me+he),Se=!C;++B<me;)ye[B]=d[B];for(var Te=B;++re<he;)ye[Te+re]=y[re];for(;++G<ee;)(Se||B<K)&&(ye[Te+S[G]]=d[B++]);return ye}function yt(d,y){var S=-1,C=d.length;for(y||(y=ce(C));++S<C;)y[S]=d[S];return y}function Wt(d,y,S,C){var B=!S;S||(S={});for(var K=-1,G=y.length;++K<G;){var ee=y[K],re=C?C(S[ee],d[ee],ee,S,d):r;re===r&&(re=d[ee]),B?Ht(S,ee,re):Fn(S,ee,re)}return S}function wu(d,y){return Wt(d,ji(d),y)}function ku(d,y){return Wt(d,Po(d),y)}function wr(d,y){return function(S,C){var B=Fe(S)?Oc:Vl,K=y?y():{};return B(S,d,Re(C,2),K)}}function In(d){return We(function(y,S){var C=-1,B=S.length,K=B>1?S[B-1]:r,G=B>2?S[2]:r;for(K=d.length>3&&typeof K=="function"?(B--,K):r,G&&mt(S[0],S[1],G)&&(K=B<3?r:K,B=1),y=Xe(y);++C<B;){var ee=S[C];ee&&d(y,ee,C,K)}return y})}function wo(d,y){return function(S,C){if(S==null)return S;if(!bt(S))return d(S,C);for(var B=S.length,K=y?B:-1,G=Xe(S);(y?K--:++K<B)&&C(G[K],K,G)!==!1;);return S}}function ko(d){return function(y,S,C){for(var B=-1,K=Xe(y),G=C(y),ee=G.length;ee--;){var re=G[d?ee:++B];if(S(K[re],re,K)===!1)break}return y}}function Eu(d,y,S){var C=y&w,B=Vn(d);function K(){var G=this&&this!==ut&&this instanceof K?B:d;return G.apply(C?S:this,arguments)}return K}function Eo(d){return function(y){y=Je(y);var S=wn(y)?Bt(y):r,C=S?S[0]:y.charAt(0),B=S?an(S,1).join(""):y.slice(1);return C[d]()+B}}function jn(d){return function(y){return zr(wa(va(y).replace(pc,"")),d,"")}}function Vn(d){return function(){var y=arguments;switch(y.length){case 0:return new d;case 1:return new d(y[0]);case 2:return new d(y[0],y[1]);case 3:return new d(y[0],y[1],y[2]);case 4:return new d(y[0],y[1],y[2],y[3]);case 5:return new d(y[0],y[1],y[2],y[3],y[4]);case 6:return new d(y[0],y[1],y[2],y[3],y[4],y[5]);case 7:return new d(y[0],y[1],y[2],y[3],y[4],y[5],y[6])}var S=On(d.prototype),C=d.apply(S,y);return tt(C)?C:S}}function xu(d,y,S){var C=Vn(d);function B(){for(var K=arguments.length,G=ce(K),ee=K,re=Tn(B);ee--;)G[ee]=arguments[ee];var he=K<3&&G[0]!==re&&G[K-1]!==re?[]:tn(G,re);if(K-=he.length,K<S)return Io(d,y,kr,B.placeholder,r,G,he,r,r,S-K);var me=this&&this!==ut&&this instanceof B?C:d;return kt(me,this,G)}return B}function xo(d){return function(y,S,C){var B=Xe(y);if(!bt(y)){var K=Re(S,3);y=lt(y),S=function(ee){return K(B[ee],ee,B)}}var G=d(y,S,C);return G>-1?B[K?y[G]:G]:r}}function So(d){return Gt(function(y){var S=y.length,C=S,B=Dt.prototype.thru;for(d&&y.reverse();C--;){var K=y[C];if(typeof K!="function")throw new Tt(l);if(B&&!G&&Ar(K)=="wrapper")var G=new Dt([],!0)}for(C=G?C:S;++C<S;){K=y[C];var ee=Ar(K),re=ee=="wrapper"?Oi(K):r;re&&Di(re[0])&&re[1]==(j|E|A|I)&&!re[4].length&&re[9]==1?G=G[Ar(re[0])].apply(G,re[3]):G=K.length==1&&Di(K)?G[ee]():G.thru(K)}return function(){var he=arguments,me=he[0];if(G&&he.length==1&&Fe(me))return G.plant(me).value();for(var ye=0,Se=S?y[ye].apply(this,he):me;++ye<S;)Se=y[ye].call(this,Se);return Se}})}function kr(d,y,S,C,B,K,G,ee,re,he){var me=y&j,ye=y&w,Se=y&k,Te=y&(E|O),Me=y&D,Ue=Se?r:Vn(d);function $e(){for(var qe=arguments.length,Ke=ce(qe),At=qe;At--;)Ke[At]=arguments[At];if(Te)var _t=Tn($e),Ot=$c(Ke,_t);if(C&&(Ke=bo(Ke,C,B,Te)),K&&(Ke=vo(Ke,K,G,Te)),qe-=Ot,Te&&qe<he){var st=tn(Ke,_t);return Io(d,y,kr,$e.placeholder,S,Ke,st,ee,re,he-qe)}var Nt=ye?S:this,Qt=Se?Nt[d]:d;return qe=Ke.length,ee?Ke=Vu(Ke,ee):Me&&qe>1&&Ke.reverse(),me&&re<qe&&(Ke.length=re),this&&this!==ut&&this instanceof $e&&(Qt=Ue||Vn(Qt)),Qt.apply(Nt,Ke)}return $e}function Ao(d,y){return function(S,C){return Ql(S,d,y(C),{})}}function Er(d,y){return function(S,C){var B;if(S===r&&C===r)return y;if(S!==r&&(B=S),C!==r){if(B===r)return C;typeof S=="string"||typeof C=="string"?(S=xt(S),C=xt(C)):(S=uo(S),C=uo(C)),B=d(S,C)}return B}}function Ei(d){return Gt(function(y){return y=et(y,Et(Re())),We(function(S){var C=this;return d(y,function(B){return kt(B,C,S)})})})}function xr(d,y){y=y===r?" ":xt(y);var S=y.length;if(S<2)return S?_i(y,d):y;var C=_i(y,ur(d/kn(y)));return wn(y)?an(Bt(C),0,d).join(""):C.slice(0,d)}function Su(d,y,S,C){var B=y&w,K=Vn(d);function G(){for(var ee=-1,re=arguments.length,he=-1,me=C.length,ye=ce(me+re),Se=this&&this!==ut&&this instanceof G?K:d;++he<me;)ye[he]=C[he];for(;re--;)ye[he++]=arguments[++ee];return kt(Se,B?S:this,ye)}return G}function Oo(d){return function(y,S,C){return C&&typeof C!="number"&&mt(y,S,C)&&(S=C=r),y=Xt(y),S===r?(S=y,y=0):S=Xt(S),C=C===r?y<S?1:-1:Xt(C),uu(y,S,C,d)}}function Sr(d){return function(y,S){return typeof y=="string"&&typeof S=="string"||(y=Mt(y),S=Mt(S)),d(y,S)}}function Io(d,y,S,C,B,K,G,ee,re,he){var me=y&E,ye=me?G:r,Se=me?r:G,Te=me?K:r,Me=me?r:K;y|=me?A:T,y&=~(me?T:A),y&x||(y&=~(w|k));var Ue=[d,y,B,Te,ye,Me,Se,ee,re,he],$e=S.apply(r,Ue);return Di(d)&&No($e,Ue),$e.placeholder=C,Uo($e,d,y)}function xi(d){var y=at[d];return function(S,C){if(S=Mt(S),C=C==null?0:ft(Ne(C),292),C&&Ns(S)){var B=(Je(S)+"e").split("e"),K=y(B[0]+"e"+(+B[1]+C));return B=(Je(K)+"e").split("e"),+(B[0]+"e"+(+B[1]-C))}return y(S)}}var Au=Sn&&1/Zn(new Sn([,-0]))[1]==Y?function(d){return new Sn(d)}:Hi;function jo(d){return function(y){var S=pt(y);return S==se?ei(y):S==L?qc(y):Mc(y,d(y))}}function zt(d,y,S,C,B,K,G,ee){var re=y&k;if(!re&&typeof d!="function")throw new Tt(l);var he=C?C.length:0;if(he||(y&=~(A|T),C=B=r),G=G===r?G:ct(Ne(G),0),ee=ee===r?ee:Ne(ee),he-=B?B.length:0,y&T){var me=C,ye=B;C=B=r}var Se=re?r:Oi(d),Te=[d,y,S,C,B,me,ye,K,G,ee];if(Se&&Uu(Te,Se),d=Te[0],y=Te[1],S=Te[2],C=Te[3],B=Te[4],ee=Te[9]=Te[9]===r?re?0:d.length:ct(Te[9]-he,0),!ee&&y&(E|O)&&(y&=~(E|O)),!y||y==w)var Me=Eu(d,y,S);else y==E||y==O?Me=xu(d,y,ee):(y==A||y==(w|A))&&!B.length?Me=Su(d,y,S,C):Me=kr.apply(r,Te);var Ue=Se?co:No;return Uo(Ue(Me,Te),d,y)}function To(d,y,S,C){return d===r||Ft(d,xn[S])&&!Ye.call(C,S)?y:d}function Do(d,y,S,C,B,K){return tt(d)&&tt(y)&&(K.set(y,d),yr(d,y,r,Do,K),K.delete(y)),d}function Ou(d){return zn(d)?r:d}function Co(d,y,S,C,B,K){var G=S&v,ee=d.length,re=y.length;if(ee!=re&&!(G&&re>ee))return!1;var he=K.get(d),me=K.get(y);if(he&&me)return he==y&&me==d;var ye=-1,Se=!0,Te=S&c?new fn:r;for(K.set(d,y),K.set(y,d);++ye<ee;){var Me=d[ye],Ue=y[ye];if(C)var $e=G?C(Ue,Me,ye,y,d,K):C(Me,Ue,ye,d,y,K);if($e!==r){if($e)continue;Se=!1;break}if(Te){if(!Gr(y,function(qe,Ke){if(!Pn(Te,Ke)&&(Me===qe||B(Me,qe,S,C,K)))return Te.push(Ke)})){Se=!1;break}}else if(!(Me===Ue||B(Me,Ue,S,C,K))){Se=!1;break}}return K.delete(d),K.delete(y),Se}function Iu(d,y,S,C,B,K,G){switch(S){case xe:if(d.byteLength!=y.byteLength||d.byteOffset!=y.byteOffset)return!1;d=d.buffer,y=y.buffer;case ae:return!(d.byteLength!=y.byteLength||!K(new or(d),new or(y)));case je:case Oe:case le:return Ft(+d,+y);case Ce:return d.name==y.name&&d.message==y.message;case ge:case P:return d==y+"";case se:var ee=ei;case L:var re=C&v;if(ee||(ee=Zn),d.size!=y.size&&!re)return!1;var he=G.get(d);if(he)return he==y;C|=c,G.set(d,y);var me=Co(ee(d),ee(y),C,B,K,G);return G.delete(d),me;case R:if(Ln)return Ln.call(d)==Ln.call(y)}return!1}function ju(d,y,S,C,B,K){var G=S&v,ee=Si(d),re=ee.length,he=Si(y),me=he.length;if(re!=me&&!G)return!1;for(var ye=re;ye--;){var Se=ee[ye];if(!(G?Se in y:Ye.call(y,Se)))return!1}var Te=K.get(d),Me=K.get(y);if(Te&&Me)return Te==y&&Me==d;var Ue=!0;K.set(d,y),K.set(y,d);for(var $e=G;++ye<re;){Se=ee[ye];var qe=d[Se],Ke=y[Se];if(C)var At=G?C(Ke,qe,Se,y,d,K):C(qe,Ke,Se,d,y,K);if(!(At===r?qe===Ke||B(qe,Ke,S,C,K):At)){Ue=!1;break}$e||($e=Se=="constructor")}if(Ue&&!$e){var _t=d.constructor,Ot=y.constructor;_t!=Ot&&"constructor"in d&&"constructor"in y&&!(typeof _t=="function"&&_t instanceof _t&&typeof Ot=="function"&&Ot instanceof Ot)&&(Ue=!1)}return K.delete(d),K.delete(y),Ue}function Gt(d){return Pi(Lo(d,r,zo),d+"")}function Si(d){return Xs(d,lt,ji)}function Ai(d){return Xs(d,vt,Po)}var Oi=fr?function(d){return fr.get(d)}:Hi;function Ar(d){for(var y=d.name+"",S=An[y],C=Ye.call(An,y)?S.length:0;C--;){var B=S[C],K=B.func;if(K==null||K==d)return B.name}return y}function Tn(d){var y=Ye.call(U,"placeholder")?U:d;return y.placeholder}function Re(){var d=U.iteratee||Vi;return d=d===Vi?eo:d,arguments.length?d(arguments[0],arguments[1]):d}function Or(d,y){var S=d.__data__;return Bu(y)?S[typeof y=="string"?"string":"hash"]:S.map}function Ii(d){for(var y=lt(d),S=y.length;S--;){var C=y[S],B=d[C];y[S]=[C,B,$o(B)]}return y}function mn(d,y){var S=Nc(d,y);return Zs(S)?S:r}function Tu(d){var y=Ye.call(d,un),S=d[un];try{d[un]=r;var C=!0}catch{}var B=rr.call(d);return C&&(y?d[un]=S:delete d[un]),B}var ji=ni?function(d){return d==null?[]:(d=Xe(d),Zt(ni(d),function(y){return Ls.call(d,y)}))}:zi,Po=ni?function(d){for(var y=[];d;)en(y,ji(d)),d=ar(d);return y}:zi,pt=ht;(ri&&pt(new ri(new ArrayBuffer(1)))!=xe||Mn&&pt(new Mn)!=se||ii&&pt(ii.resolve())!=be||Sn&&pt(new Sn)!=L||$n&&pt(new $n)!=Q)&&(pt=function(d){var y=ht(d),S=y==pe?d.constructor:r,C=S?_n(S):"";if(C)switch(C){case fl:return xe;case pl:return se;case hl:return be;case ml:return L;case _l:return Q}return y});function Du(d,y,S){for(var C=-1,B=S.length;++C<B;){var K=S[C],G=K.size;switch(K.type){case"drop":d+=G;break;case"dropRight":y-=G;break;case"take":y=ft(y,d+G);break;case"takeRight":d=ct(d,y-G);break}}return{start:d,end:y}}function Cu(d){var y=d.match(La);return y?y[1].split(Fa):[]}function Ro(d,y,S){y=on(y,d);for(var C=-1,B=y.length,K=!1;++C<B;){var G=qt(y[C]);if(!(K=d!=null&&S(d,G)))break;d=d[G]}return K||++C!=B?K:(B=d==null?0:d.length,!!B&&Rr(B)&&Jt(G,B)&&(Fe(d)||gn(d)))}function Pu(d){var y=d.length,S=new d.constructor(y);return y&&typeof d[0]=="string"&&Ye.call(d,"index")&&(S.index=d.index,S.input=d.input),S}function Mo(d){return typeof d.constructor=="function"&&!Kn(d)?On(ar(d)):{}}function Ru(d,y,S){var C=d.constructor;switch(y){case ae:return ki(d);case je:case Oe:return new C(+d);case xe:return gu(d,S);case De:case Be:case He:case ze:case ot:case $t:case nt:case gt:case yn:return go(d,S);case se:return new C;case le:case P:return new C(d);case ge:return yu(d);case L:return new C;case R:return bu(d)}}function Mu(d,y){var S=y.length;if(!S)return d;var C=S-1;return y[C]=(S>1?"& ":"")+y[C],y=y.join(S>2?", ":" "),d.replace(Ba,`{
/* [wrapped with `+y+`] */
`)}function $u(d){return Fe(d)||gn(d)||!!(Fs&&d&&d[Fs])}function Jt(d,y){var S=typeof d;return y=y??X,!!y&&(S=="number"||S!="symbol"&&Ga.test(d))&&d>-1&&d%1==0&&d<y}function mt(d,y,S){if(!tt(S))return!1;var C=typeof y;return(C=="number"?bt(S)&&Jt(y,S.length):C=="string"&&y in S)?Ft(S[y],d):!1}function Ti(d,y){if(Fe(d))return!1;var S=typeof d;return S=="number"||S=="symbol"||S=="boolean"||d==null||St(d)?!0:Pa.test(d)||!Ca.test(d)||y!=null&&d in Xe(y)}function Bu(d){var y=typeof d;return y=="string"||y=="number"||y=="symbol"||y=="boolean"?d!=="__proto__":d===null}function Di(d){var y=Ar(d),S=U[y];if(typeof S!="function"||!(y in Ve.prototype))return!1;if(d===S)return!0;var C=Oi(S);return!!C&&d===C[0]}function Lu(d){return!!Ms&&Ms in d}var Fu=tr?Yt:Gi;function Kn(d){var y=d&&d.constructor,S=typeof y=="function"&&y.prototype||xn;return d===S}function $o(d){return d===d&&!tt(d)}function Bo(d,y){return function(S){return S==null?!1:S[d]===y&&(y!==r||d in Xe(S))}}function Nu(d){var y=Cr(d,function(C){return S.size===_&&S.clear(),C}),S=y.cache;return y}function Uu(d,y){var S=d[1],C=y[1],B=S|C,K=B<(w|k|j),G=C==j&&S==E||C==j&&S==I&&d[7].length<=y[8]||C==(j|I)&&y[7].length<=y[8]&&S==E;if(!(K||G))return d;C&w&&(d[2]=y[2],B|=S&w?0:x);var ee=y[3];if(ee){var re=d[3];d[3]=re?bo(re,ee,y[4]):ee,d[4]=re?tn(d[3],g):y[4]}return ee=y[5],ee&&(re=d[5],d[5]=re?vo(re,ee,y[6]):ee,d[6]=re?tn(d[5],g):y[6]),ee=y[7],ee&&(d[7]=ee),C&j&&(d[8]=d[8]==null?y[8]:ft(d[8],y[8])),d[9]==null&&(d[9]=y[9]),d[0]=y[0],d[1]=B,d}function Wu(d){var y=[];if(d!=null)for(var S in Xe(d))y.push(S);return y}function qu(d){return rr.call(d)}function Lo(d,y,S){return y=ct(y===r?d.length-1:y,0),function(){for(var C=arguments,B=-1,K=ct(C.length-y,0),G=ce(K);++B<K;)G[B]=C[y+B];B=-1;for(var ee=ce(y+1);++B<y;)ee[B]=C[B];return ee[y]=S(G),kt(d,this,ee)}}function Fo(d,y){return y.length<2?d:hn(d,Pt(y,0,-1))}function Vu(d,y){for(var S=d.length,C=ft(y.length,S),B=yt(d);C--;){var K=y[C];d[C]=Jt(K,S)?B[K]:r}return d}function Ci(d,y){if(!(y==="constructor"&&typeof d[y]=="function")&&y!="__proto__")return d[y]}var No=Wo(co),Hn=sl||function(d,y){return ut.setTimeout(d,y)},Pi=Wo(pu);function Uo(d,y,S){var C=y+"";return Pi(d,Mu(C,Ku(Cu(C),S)))}function Wo(d){var y=0,S=0;return function(){var C=ll(),B=W-(C-S);if(S=C,B>0){if(++y>=M)return arguments[0]}else y=0;return d.apply(r,arguments)}}function Ir(d,y){var S=-1,C=d.length,B=C-1;for(y=y===r?C:y;++S<y;){var K=mi(S,B),G=d[K];d[K]=d[S],d[S]=G}return d.length=y,d}var qo=Nu(function(d){var y=[];return d.charCodeAt(0)===46&&y.push(""),d.replace(Ra,function(S,C,B,K){y.push(B?K.replace(Wa,"$1"):C||S)}),y});function qt(d){if(typeof d=="string"||St(d))return d;var y=d+"";return y=="0"&&1/d==-Y?"-0":y}function _n(d){if(d!=null){try{return nr.call(d)}catch{}try{return d+""}catch{}}return""}function Ku(d,y){return jt(we,function(S){var C="_."+S[0];y&S[1]&&!Xn(d,C)&&d.push(C)}),d.sort()}function Vo(d){if(d instanceof Ve)return d.clone();var y=new Dt(d.__wrapped__,d.__chain__);return y.__actions__=yt(d.__actions__),y.__index__=d.__index__,y.__values__=d.__values__,y}function Hu(d,y,S){(S?mt(d,y,S):y===r)?y=1:y=ct(Ne(y),0);var C=d==null?0:d.length;if(!C||y<1)return[];for(var B=0,K=0,G=ce(ur(C/y));B<C;)G[K++]=Pt(d,B,B+=y);return G}function zu(d){for(var y=-1,S=d==null?0:d.length,C=0,B=[];++y<S;){var K=d[y];K&&(B[C++]=K)}return B}function Gu(){var d=arguments.length;if(!d)return[];for(var y=ce(d-1),S=arguments[0],C=d;C--;)y[C-1]=arguments[C];return en(Fe(S)?yt(S):[S],dt(y,1))}var Ju=We(function(d,y){return it(d)?Nn(d,dt(y,1,it,!0)):[]}),Yu=We(function(d,y){var S=Rt(y);return it(S)&&(S=r),it(d)?Nn(d,dt(y,1,it,!0),Re(S,2)):[]}),Xu=We(function(d,y){var S=Rt(y);return it(S)&&(S=r),it(d)?Nn(d,dt(y,1,it,!0),r,S):[]});function Qu(d,y,S){var C=d==null?0:d.length;return C?(y=S||y===r?1:Ne(y),Pt(d,y<0?0:y,C)):[]}function Zu(d,y,S){var C=d==null?0:d.length;return C?(y=S||y===r?1:Ne(y),y=C-y,Pt(d,0,y<0?0:y)):[]}function ed(d,y){return d&&d.length?vr(d,Re(y,3),!0,!0):[]}function td(d,y){return d&&d.length?vr(d,Re(y,3),!0):[]}function nd(d,y,S,C){var B=d==null?0:d.length;return B?(S&&typeof S!="number"&&mt(d,y,S)&&(S=0,C=B),Gl(d,y,S,C)):[]}function Ko(d,y,S){var C=d==null?0:d.length;if(!C)return-1;var B=S==null?0:Ne(S);return B<0&&(B=ct(C+B,0)),Qn(d,Re(y,3),B)}function Ho(d,y,S){var C=d==null?0:d.length;if(!C)return-1;var B=C-1;return S!==r&&(B=Ne(S),B=S<0?ct(C+B,0):ft(B,C-1)),Qn(d,Re(y,3),B,!0)}function zo(d){var y=d==null?0:d.length;return y?dt(d,1):[]}function rd(d){var y=d==null?0:d.length;return y?dt(d,Y):[]}function id(d,y){var S=d==null?0:d.length;return S?(y=y===r?1:Ne(y),dt(d,y)):[]}function sd(d){for(var y=-1,S=d==null?0:d.length,C={};++y<S;){var B=d[y];C[B[0]]=B[1]}return C}function Go(d){return d&&d.length?d[0]:r}function od(d,y,S){var C=d==null?0:d.length;if(!C)return-1;var B=S==null?0:Ne(S);return B<0&&(B=ct(C+B,0)),vn(d,y,B)}function ad(d){var y=d==null?0:d.length;return y?Pt(d,0,-1):[]}var cd=We(function(d){var y=et(d,vi);return y.length&&y[0]===d[0]?ui(y):[]}),ld=We(function(d){var y=Rt(d),S=et(d,vi);return y===Rt(S)?y=r:S.pop(),S.length&&S[0]===d[0]?ui(S,Re(y,2)):[]}),ud=We(function(d){var y=Rt(d),S=et(d,vi);return y=typeof y=="function"?y:r,y&&S.pop(),S.length&&S[0]===d[0]?ui(S,r,y):[]});function dd(d,y){return d==null?"":al.call(d,y)}function Rt(d){var y=d==null?0:d.length;return y?d[y-1]:r}function fd(d,y,S){var C=d==null?0:d.length;if(!C)return-1;var B=C;return S!==r&&(B=Ne(S),B=B<0?ct(C+B,0):ft(B,C-1)),y===y?Kc(d,y,B):Qn(d,Os,B,!0)}function pd(d,y){return d&&d.length?io(d,Ne(y)):r}var hd=We(Jo);function Jo(d,y){return d&&d.length&&y&&y.length?hi(d,y):d}function md(d,y,S){return d&&d.length&&y&&y.length?hi(d,y,Re(S,2)):d}function _d(d,y,S){return d&&d.length&&y&&y.length?hi(d,y,r,S):d}var gd=Gt(function(d,y){var S=d==null?0:d.length,C=oi(d,y);return ao(d,et(y,function(B){return Jt(B,S)?+B:B}).sort(yo)),C});function yd(d,y){var S=[];if(!(d&&d.length))return S;var C=-1,B=[],K=d.length;for(y=Re(y,3);++C<K;){var G=d[C];y(G,C,d)&&(S.push(G),B.push(C))}return ao(d,B),S}function Ri(d){return d==null?d:dl.call(d)}function bd(d,y,S){var C=d==null?0:d.length;return C?(S&&typeof S!="number"&&mt(d,y,S)?(y=0,S=C):(y=y==null?0:Ne(y),S=S===r?C:Ne(S)),Pt(d,y,S)):[]}function vd(d,y){return br(d,y)}function wd(d,y,S){return gi(d,y,Re(S,2))}function kd(d,y){var S=d==null?0:d.length;if(S){var C=br(d,y);if(C<S&&Ft(d[C],y))return C}return-1}function Ed(d,y){return br(d,y,!0)}function xd(d,y,S){return gi(d,y,Re(S,2),!0)}function Sd(d,y){var S=d==null?0:d.length;if(S){var C=br(d,y,!0)-1;if(Ft(d[C],y))return C}return-1}function Ad(d){return d&&d.length?lo(d):[]}function Od(d,y){return d&&d.length?lo(d,Re(y,2)):[]}function Id(d){var y=d==null?0:d.length;return y?Pt(d,1,y):[]}function jd(d,y,S){return d&&d.length?(y=S||y===r?1:Ne(y),Pt(d,0,y<0?0:y)):[]}function Td(d,y,S){var C=d==null?0:d.length;return C?(y=S||y===r?1:Ne(y),y=C-y,Pt(d,y<0?0:y,C)):[]}function Dd(d,y){return d&&d.length?vr(d,Re(y,3),!1,!0):[]}function Cd(d,y){return d&&d.length?vr(d,Re(y,3)):[]}var Pd=We(function(d){return sn(dt(d,1,it,!0))}),Rd=We(function(d){var y=Rt(d);return it(y)&&(y=r),sn(dt(d,1,it,!0),Re(y,2))}),Md=We(function(d){var y=Rt(d);return y=typeof y=="function"?y:r,sn(dt(d,1,it,!0),r,y)});function $d(d){return d&&d.length?sn(d):[]}function Bd(d,y){return d&&d.length?sn(d,Re(y,2)):[]}function Ld(d,y){return y=typeof y=="function"?y:r,d&&d.length?sn(d,r,y):[]}function Mi(d){if(!(d&&d.length))return[];var y=0;return d=Zt(d,function(S){if(it(S))return y=ct(S.length,y),!0}),Qr(y,function(S){return et(d,Jr(S))})}function Yo(d,y){if(!(d&&d.length))return[];var S=Mi(d);return y==null?S:et(S,function(C){return kt(y,r,C)})}var Fd=We(function(d,y){return it(d)?Nn(d,y):[]}),Nd=We(function(d){return bi(Zt(d,it))}),Ud=We(function(d){var y=Rt(d);return it(y)&&(y=r),bi(Zt(d,it),Re(y,2))}),Wd=We(function(d){var y=Rt(d);return y=typeof y=="function"?y:r,bi(Zt(d,it),r,y)}),qd=We(Mi);function Vd(d,y){return ho(d||[],y||[],Fn)}function Kd(d,y){return ho(d||[],y||[],qn)}var Hd=We(function(d){var y=d.length,S=y>1?d[y-1]:r;return S=typeof S=="function"?(d.pop(),S):r,Yo(d,S)});function Xo(d){var y=U(d);return y.__chain__=!0,y}function zd(d,y){return y(d),d}function jr(d,y){return y(d)}var Gd=Gt(function(d){var y=d.length,S=y?d[0]:0,C=this.__wrapped__,B=function(K){return oi(K,d)};return y>1||this.__actions__.length||!(C instanceof Ve)||!Jt(S)?this.thru(B):(C=C.slice(S,+S+(y?1:0)),C.__actions__.push({func:jr,args:[B],thisArg:r}),new Dt(C,this.__chain__).thru(function(K){return y&&!K.length&&K.push(r),K}))});function Jd(){return Xo(this)}function Yd(){return new Dt(this.value(),this.__chain__)}function Xd(){this.__values__===r&&(this.__values__=da(this.value()));var d=this.__index__>=this.__values__.length,y=d?r:this.__values__[this.__index__++];return{done:d,value:y}}function Qd(){return this}function Zd(d){for(var y,S=this;S instanceof hr;){var C=Vo(S);C.__index__=0,C.__values__=r,y?B.__wrapped__=C:y=C;var B=C;S=S.__wrapped__}return B.__wrapped__=d,y}function ef(){var d=this.__wrapped__;if(d instanceof Ve){var y=d;return this.__actions__.length&&(y=new Ve(this)),y=y.reverse(),y.__actions__.push({func:jr,args:[Ri],thisArg:r}),new Dt(y,this.__chain__)}return this.thru(Ri)}function nf(){return po(this.__wrapped__,this.__actions__)}var rf=wr(function(d,y,S){Ye.call(d,S)?++d[S]:Ht(d,S,1)});function sf(d,y,S){var C=Fe(d)?Ss:zl;return S&&mt(d,y,S)&&(y=r),C(d,Re(y,3))}function of(d,y){var S=Fe(d)?Zt:Js;return S(d,Re(y,3))}var af=xo(Ko),cf=xo(Ho);function lf(d,y){return dt(Tr(d,y),1)}function uf(d,y){return dt(Tr(d,y),Y)}function df(d,y,S){return S=S===r?1:Ne(S),dt(Tr(d,y),S)}function Qo(d,y){var S=Fe(d)?jt:rn;return S(d,Re(y,3))}function Zo(d,y){var S=Fe(d)?Ic:Gs;return S(d,Re(y,3))}var ff=wr(function(d,y,S){Ye.call(d,S)?d[S].push(y):Ht(d,S,[y])});function pf(d,y,S,C){d=bt(d)?d:Cn(d),S=S&&!C?Ne(S):0;var B=d.length;return S<0&&(S=ct(B+S,0)),Mr(d)?S<=B&&d.indexOf(y,S)>-1:!!B&&vn(d,y,S)>-1}var hf=We(function(d,y,S){var C=-1,B=typeof y=="function",K=bt(d)?ce(d.length):[];return rn(d,function(G){K[++C]=B?kt(y,G,S):Un(G,y,S)}),K}),mf=wr(function(d,y,S){Ht(d,S,y)});function Tr(d,y){var S=Fe(d)?et:to;return S(d,Re(y,3))}function _f(d,y,S,C){return d==null?[]:(Fe(y)||(y=y==null?[]:[y]),S=C?r:S,Fe(S)||(S=S==null?[]:[S]),so(d,y,S))}var gf=wr(function(d,y,S){d[S?0:1].push(y)},function(){return[[],[]]});function yf(d,y,S){var C=Fe(d)?zr:js,B=arguments.length<3;return C(d,Re(y,4),S,B,rn)}function bf(d,y,S){var C=Fe(d)?jc:js,B=arguments.length<3;return C(d,Re(y,4),S,B,Gs)}function vf(d,y){var S=Fe(d)?Zt:Js;return S(d,Pr(Re(y,3)))}function wf(d){var y=Fe(d)?Vs:du;return y(d)}function kf(d,y,S){(S?mt(d,y,S):y===r)?y=1:y=Ne(y);var C=Fe(d)?Wl:fu;return C(d,y)}function Ef(d){var y=Fe(d)?ql:hu;return y(d)}function xf(d){if(d==null)return 0;if(bt(d))return Mr(d)?kn(d):d.length;var y=pt(d);return y==se||y==L?d.size:fi(d).length}function Sf(d,y,S){var C=Fe(d)?Gr:mu;return S&&mt(d,y,S)&&(y=r),C(d,Re(y,3))}var Af=We(function(d,y){if(d==null)return[];var S=y.length;return S>1&&mt(d,y[0],y[1])?y=[]:S>2&&mt(y[0],y[1],y[2])&&(y=[y[0]]),so(d,dt(y,1),[])}),Dr=il||function(){return ut.Date.now()};function Of(d,y){if(typeof y!="function")throw new Tt(l);return d=Ne(d),function(){if(--d<1)return y.apply(this,arguments)}}function ea(d,y,S){return y=S?r:y,y=d&&y==null?d.length:y,zt(d,j,r,r,r,r,y)}function ta(d,y){var S;if(typeof y!="function")throw new Tt(l);return d=Ne(d),function(){return--d>0&&(S=y.apply(this,arguments)),d<=1&&(y=r),S}}var $i=We(function(d,y,S){var C=w;if(S.length){var B=tn(S,Tn($i));C|=A}return zt(d,C,y,S,B)}),na=We(function(d,y,S){var C=w|k;if(S.length){var B=tn(S,Tn(na));C|=A}return zt(y,C,d,S,B)});function ra(d,y,S){y=S?r:y;var C=zt(d,E,r,r,r,r,r,y);return C.placeholder=ra.placeholder,C}function ia(d,y,S){y=S?r:y;var C=zt(d,O,r,r,r,r,r,y);return C.placeholder=ia.placeholder,C}function sa(d,y,S){var C,B,K,G,ee,re,he=0,me=!1,ye=!1,Se=!0;if(typeof d!="function")throw new Tt(l);y=Mt(y)||0,tt(S)&&(me=!!S.leading,ye="maxWait"in S,K=ye?ct(Mt(S.maxWait)||0,y):K,Se="trailing"in S?!!S.trailing:Se);function Te(st){var Nt=C,Qt=B;return C=B=r,he=st,G=d.apply(Qt,Nt),G}function Me(st){return he=st,ee=Hn(qe,y),me?Te(st):G}function Ue(st){var Nt=st-re,Qt=st-he,xa=y-Nt;return ye?ft(xa,K-Qt):xa}function $e(st){var Nt=st-re,Qt=st-he;return re===r||Nt>=y||Nt<0||ye&&Qt>=K}function qe(){var st=Dr();if($e(st))return Ke(st);ee=Hn(qe,Ue(st))}function Ke(st){return ee=r,Se&&C?Te(st):(C=B=r,G)}function At(){ee!==r&&mo(ee),he=0,C=re=B=ee=r}function _t(){return ee===r?G:Ke(Dr())}function Ot(){var st=Dr(),Nt=$e(st);if(C=arguments,B=this,re=st,Nt){if(ee===r)return Me(re);if(ye)return mo(ee),ee=Hn(qe,y),Te(re)}return ee===r&&(ee=Hn(qe,y)),G}return Ot.cancel=At,Ot.flush=_t,Ot}var If=We(function(d,y){return zs(d,1,y)}),jf=We(function(d,y,S){return zs(d,Mt(y)||0,S)});function Tf(d){return zt(d,D)}function Cr(d,y){if(typeof d!="function"||y!=null&&typeof y!="function")throw new Tt(l);var S=function(){var C=arguments,B=y?y.apply(this,C):C[0],K=S.cache;if(K.has(B))return K.get(B);var G=d.apply(this,C);return S.cache=K.set(B,G)||K,G};return S.cache=new(Cr.Cache||Kt),S}Cr.Cache=Kt;function Pr(d){if(typeof d!="function")throw new Tt(l);return function(){var y=arguments;switch(y.length){case 0:return!d.call(this);case 1:return!d.call(this,y[0]);case 2:return!d.call(this,y[0],y[1]);case 3:return!d.call(this,y[0],y[1],y[2])}return!d.apply(this,y)}}function Df(d){return ta(2,d)}var Cf=_u(function(d,y){y=y.length==1&&Fe(y[0])?et(y[0],Et(Re())):et(dt(y,1),Et(Re()));var S=y.length;return We(function(C){for(var B=-1,K=ft(C.length,S);++B<K;)C[B]=y[B].call(this,C[B]);return kt(d,this,C)})}),Bi=We(function(d,y){var S=tn(y,Tn(Bi));return zt(d,A,r,y,S)}),oa=We(function(d,y){var S=tn(y,Tn(oa));return zt(d,T,r,y,S)}),Pf=Gt(function(d,y){return zt(d,I,r,r,r,y)});function Rf(d,y){if(typeof d!="function")throw new Tt(l);return y=y===r?y:Ne(y),We(d,y)}function Mf(d,y){if(typeof d!="function")throw new Tt(l);return y=y==null?0:ct(Ne(y),0),We(function(S){var C=S[y],B=an(S,0,y);return C&&en(B,C),kt(d,this,B)})}function $f(d,y,S){var C=!0,B=!0;if(typeof d!="function")throw new Tt(l);return tt(S)&&(C="leading"in S?!!S.leading:C,B="trailing"in S?!!S.trailing:B),sa(d,y,{leading:C,maxWait:y,trailing:B})}function Bf(d){return ea(d,1)}function Lf(d,y){return Bi(wi(y),d)}function Ff(){if(!arguments.length)return[];var d=arguments[0];return Fe(d)?d:[d]}function Nf(d){return Ct(d,b)}function Uf(d,y){return y=typeof y=="function"?y:r,Ct(d,b,y)}function Wf(d){return Ct(d,a|b)}function qf(d,y){return y=typeof y=="function"?y:r,Ct(d,a|b,y)}function Vf(d,y){return y==null||Hs(d,y,lt(y))}function Ft(d,y){return d===y||d!==d&&y!==y}var Kf=Sr(li),Hf=Sr(function(d,y){return d>=y}),gn=Qs(function(){return arguments}())?Qs:function(d){return rt(d)&&Ye.call(d,"callee")&&!Ls.call(d,"callee")},Fe=ce.isArray,zf=bs?Et(bs):Zl;function bt(d){return d!=null&&Rr(d.length)&&!Yt(d)}function it(d){return rt(d)&&bt(d)}function Gf(d){return d===!0||d===!1||rt(d)&&ht(d)==je}var cn=ol||Gi,Jf=vs?Et(vs):eu;function Yf(d){return rt(d)&&d.nodeType===1&&!zn(d)}function Xf(d){if(d==null)return!0;if(bt(d)&&(Fe(d)||typeof d=="string"||typeof d.splice=="function"||cn(d)||Dn(d)||gn(d)))return!d.length;var y=pt(d);if(y==se||y==L)return!d.size;if(Kn(d))return!fi(d).length;for(var S in d)if(Ye.call(d,S))return!1;return!0}function Qf(d,y){return Wn(d,y)}function Zf(d,y,S){S=typeof S=="function"?S:r;var C=S?S(d,y):r;return C===r?Wn(d,y,r,S):!!C}function Li(d){if(!rt(d))return!1;var y=ht(d);return y==Ce||y==Pe||typeof d.message=="string"&&typeof d.name=="string"&&!zn(d)}function ep(d){return typeof d=="number"&&Ns(d)}function Yt(d){if(!tt(d))return!1;var y=ht(d);return y==z||y==Z||y==Ae||y==ve}function aa(d){return typeof d=="number"&&d==Ne(d)}function Rr(d){return typeof d=="number"&&d>-1&&d%1==0&&d<=X}function tt(d){var y=typeof d;return d!=null&&(y=="object"||y=="function")}function rt(d){return d!=null&&typeof d=="object"}var ca=ws?Et(ws):nu;function tp(d,y){return d===y||di(d,y,Ii(y))}function np(d,y,S){return S=typeof S=="function"?S:r,di(d,y,Ii(y),S)}function rp(d){return la(d)&&d!=+d}function ip(d){if(Fu(d))throw new Le(o);return Zs(d)}function sp(d){return d===null}function ap(d){return d==null}function la(d){return typeof d=="number"||rt(d)&&ht(d)==le}function zn(d){if(!rt(d)||ht(d)!=pe)return!1;var y=ar(d);if(y===null)return!0;var S=Ye.call(y,"constructor")&&y.constructor;return typeof S=="function"&&S instanceof S&&nr.call(S)==el}var Fi=ks?Et(ks):ru;function cp(d){return aa(d)&&d>=-X&&d<=X}var ua=Es?Et(Es):iu;function Mr(d){return typeof d=="string"||!Fe(d)&&rt(d)&&ht(d)==P}function St(d){return typeof d=="symbol"||rt(d)&&ht(d)==R}var Dn=xs?Et(xs):su;function lp(d){return d===r}function up(d){return rt(d)&&pt(d)==Q}function dp(d){return rt(d)&&ht(d)==oe}var fp=Sr(pi),pp=Sr(function(d,y){return d<=y});function da(d){if(!d)return[];if(bt(d))return Mr(d)?Bt(d):yt(d);if(Rn&&d[Rn])return Wc(d[Rn]());var y=pt(d),S=y==se?ei:y==L?Zn:Cn;return S(d)}function Xt(d){if(!d)return d===0?d:0;if(d=Mt(d),d===Y||d===-Y){var y=d<0?-1:1;return y*J}return d===d?d:0}function Ne(d){var y=Xt(d),S=y%1;return y===y?S?y-S:y:0}function fa(d){return d?pn(Ne(d),0,ie):0}function Mt(d){if(typeof d=="number")return d;if(St(d))return te;if(tt(d)){var y=typeof d.valueOf=="function"?d.valueOf():d;d=tt(y)?y+"":y}if(typeof d!="string")return d===0?d:+d;d=Ts(d);var S=Ka.test(d);return S||za.test(d)?Sc(d.slice(2),S?2:8):Va.test(d)?te:+d}function pa(d){return Wt(d,vt(d))}function hp(d){return d?pn(Ne(d),-X,X):d===0?d:0}function Je(d){return d==null?"":xt(d)}var mp=In(function(d,y){if(Kn(y)||bt(y)){Wt(y,lt(y),d);return}for(var S in y)Ye.call(y,S)&&Fn(d,S,y[S])}),ha=In(function(d,y){Wt(y,vt(y),d)}),$r=In(function(d,y,S,C){Wt(y,vt(y),d,C)}),_p=In(function(d,y,S,C){Wt(y,lt(y),d,C)}),gp=Gt(oi);function yp(d,y){var S=On(d);return y==null?S:Ks(S,y)}var bp=We(function(d,y){d=Xe(d);var S=-1,C=y.length,B=C>2?y[2]:r;for(B&&mt(y[0],y[1],B)&&(C=1);++S<C;)for(var K=y[S],G=vt(K),ee=-1,re=G.length;++ee<re;){var he=G[ee],me=d[he];(me===r||Ft(me,xn[he])&&!Ye.call(d,he))&&(d[he]=K[he])}return d}),vp=We(function(d){return d.push(r,Do),kt(ma,r,d)});function wp(d,y){return As(d,Re(y,3),Ut)}function kp(d,y){return As(d,Re(y,3),ci)}function Ep(d,y){return d==null?d:ai(d,Re(y,3),vt)}function xp(d,y){return d==null?d:Ys(d,Re(y,3),vt)}function Sp(d,y){return d&&Ut(d,Re(y,3))}function Ap(d,y){return d&&ci(d,Re(y,3))}function Op(d){return d==null?[]:gr(d,lt(d))}function Ip(d){return d==null?[]:gr(d,vt(d))}function Ni(d,y,S){var C=d==null?r:hn(d,y);return C===r?S:C}function jp(d,y){return d!=null&&Ro(d,y,Jl)}function Ui(d,y){return d!=null&&Ro(d,y,Yl)}var Tp=Ao(function(d,y,S){y!=null&&typeof y.toString!="function"&&(y=rr.call(y)),d[y]=S},qi(wt)),Dp=Ao(function(d,y,S){y!=null&&typeof y.toString!="function"&&(y=rr.call(y)),Ye.call(d,y)?d[y].push(S):d[y]=[S]},Re),Cp=We(Un);function lt(d){return bt(d)?qs(d):fi(d)}function vt(d){return bt(d)?qs(d,!0):ou(d)}function Pp(d,y){var S={};return y=Re(y,3),Ut(d,function(C,B,K){Ht(S,y(C,B,K),C)}),S}function Rp(d,y){var S={};return y=Re(y,3),Ut(d,function(C,B,K){Ht(S,B,y(C,B,K))}),S}var Mp=In(function(d,y,S){yr(d,y,S)}),ma=In(function(d,y,S,C){yr(d,y,S,C)}),$p=Gt(function(d,y){var S={};if(d==null)return S;var C=!1;y=et(y,function(K){return K=on(K,d),C||(C=K.length>1),K}),Wt(d,Ai(d),S),C&&(S=Ct(S,a|m|b,Ou));for(var B=y.length;B--;)yi(S,y[B]);return S});function Bp(d,y){return _a(d,Pr(Re(y)))}var Lp=Gt(function(d,y){return d==null?{}:cu(d,y)});function _a(d,y){if(d==null)return{};var S=et(Ai(d),function(C){return[C]});return y=Re(y),oo(d,S,function(C,B){return y(C,B[0])})}function Fp(d,y,S){y=on(y,d);var C=-1,B=y.length;for(B||(B=1,d=r);++C<B;){var K=d==null?r:d[qt(y[C])];K===r&&(C=B,K=S),d=Yt(K)?K.call(d):K}return d}function Np(d,y,S){return d==null?d:qn(d,y,S)}function Up(d,y,S,C){return C=typeof C=="function"?C:r,d==null?d:qn(d,y,S,C)}var ga=jo(lt),ya=jo(vt);function Wp(d,y,S){var C=Fe(d),B=C||cn(d)||Dn(d);if(y=Re(y,4),S==null){var K=d&&d.constructor;B?S=C?new K:[]:tt(d)?S=Yt(K)?On(ar(d)):{}:S={}}return(B?jt:Ut)(d,function(G,ee,re){return y(S,G,ee,re)}),S}function qp(d,y){return d==null?!0:yi(d,y)}function Vp(d,y,S){return d==null?d:fo(d,y,wi(S))}function Kp(d,y,S,C){return C=typeof C=="function"?C:r,d==null?d:fo(d,y,wi(S),C)}function Cn(d){return d==null?[]:Zr(d,lt(d))}function Hp(d){return d==null?[]:Zr(d,vt(d))}function zp(d,y,S){return S===r&&(S=y,y=r),S!==r&&(S=Mt(S),S=S===S?S:0),y!==r&&(y=Mt(y),y=y===y?y:0),pn(Mt(d),y,S)}function Gp(d,y,S){return y=Xt(y),S===r?(S=y,y=0):S=Xt(S),d=Mt(d),Xl(d,y,S)}function Jp(d,y,S){if(S&&typeof S!="boolean"&&mt(d,y,S)&&(y=S=r),S===r&&(typeof y=="boolean"?(S=y,y=r):typeof d=="boolean"&&(S=d,d=r)),d===r&&y===r?(d=0,y=1):(d=Xt(d),y===r?(y=d,d=0):y=Xt(y)),d>y){var C=d;d=y,y=C}if(S||d%1||y%1){var B=Us();return ft(d+B*(y-d+xc("1e-"+((B+"").length-1))),y)}return mi(d,y)}var Yp=jn(function(d,y,S){return y=y.toLowerCase(),d+(S?ba(y):y)});function ba(d){return Wi(Je(d).toLowerCase())}function va(d){return d=Je(d),d&&d.replace(Ja,Bc).replace(hc,"")}function Xp(d,y,S){d=Je(d),y=xt(y);var C=d.length;S=S===r?C:pn(Ne(S),0,C);var B=S;return S-=y.length,S>=0&&d.slice(S,B)==y}function Qp(d){return d=Je(d),d&&ja.test(d)?d.replace(Yi,Lc):d}function Zp(d){return d=Je(d),d&&Ma.test(d)?d.replace(Br,"\\$&"):d}var eh=jn(function(d,y,S){return d+(S?"-":"")+y.toLowerCase()}),th=jn(function(d,y,S){return d+(S?" ":"")+y.toLowerCase()}),nh=Eo("toLowerCase");function rh(d,y,S){d=Je(d),y=Ne(y);var C=y?kn(d):0;if(!y||C>=y)return d;var B=(y-C)/2;return xr(dr(B),S)+d+xr(ur(B),S)}function ih(d,y,S){d=Je(d),y=Ne(y);var C=y?kn(d):0;return y&&C<y?d+xr(y-C,S):d}function sh(d,y,S){d=Je(d),y=Ne(y);var C=y?kn(d):0;return y&&C<y?xr(y-C,S)+d:d}function oh(d,y,S){return S||y==null?y=0:y&&(y=+y),ul(Je(d).replace(Lr,""),y||0)}function ah(d,y,S){return(S?mt(d,y,S):y===r)?y=1:y=Ne(y),_i(Je(d),y)}function ch(){var d=arguments,y=Je(d[0]);return d.length<3?y:y.replace(d[1],d[2])}var lh=jn(function(d,y,S){return d+(S?"_":"")+y.toLowerCase()});function uh(d,y,S){return S&&typeof S!="number"&&mt(d,y,S)&&(y=S=r),S=S===r?ie:S>>>0,S?(d=Je(d),d&&(typeof y=="string"||y!=null&&!Fi(y))&&(y=xt(y),!y&&wn(d))?an(Bt(d),0,S):d.split(y,S)):[]}var dh=jn(function(d,y,S){return d+(S?" ":"")+Wi(y)});function fh(d,y,S){return d=Je(d),S=S==null?0:pn(Ne(S),0,d.length),y=xt(y),d.slice(S,S+y.length)==y}function ph(d,y,S){var C=U.templateSettings;S&&mt(d,y,S)&&(y=r),d=Je(d),y=$r({},y,C,To);var B=$r({},y.imports,C.imports,To),K=lt(B),G=Zr(B,K),ee,re,he=0,me=y.interpolate||Gn,ye="__p += '",Se=ti((y.escape||Gn).source+"|"+me.source+"|"+(me===Xi?qa:Gn).source+"|"+(y.evaluate||Gn).source+"|$","g"),Te="//# sourceURL="+(Ye.call(y,"sourceURL")?(y.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++bc+"]")+`
`;d.replace(Se,function($e,qe,Ke,At,_t,Ot){return Ke||(Ke=At),ye+=d.slice(he,Ot).replace(Ya,Fc),qe&&(ee=!0,ye+=`' +
__e(`+qe+`) +
'`),_t&&(re=!0,ye+=`';
`+_t+`;
__p += '`),Ke&&(ye+=`' +
((__t = (`+Ke+`)) == null ? '' : __t) +
'`),he=Ot+$e.length,$e}),ye+=`';
`;var Me=Ye.call(y,"variable")&&y.variable;if(!Me)ye=`with (obj) {
`+ye+`
}
`;else if(Ua.test(Me))throw new Le(f);ye=(re?ye.replace(Sa,""):ye).replace(Aa,"$1").replace(Oa,"$1;"),ye="function("+(Me||"obj")+`) {
`+(Me?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(ee?", __e = _.escape":"")+(re?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+ye+`return __p
}`;var Ue=ka(function(){return Ge(K,Te+"return "+ye).apply(r,G)});if(Ue.source=ye,Li(Ue))throw Ue;return Ue}function hh(d){return Je(d).toLowerCase()}function mh(d){return Je(d).toUpperCase()}function _h(d,y,S){if(d=Je(d),d&&(S||y===r))return Ts(d);if(!d||!(y=xt(y)))return d;var C=Bt(d),B=Bt(y),K=Ds(C,B),G=Cs(C,B)+1;return an(C,K,G).join("")}function gh(d,y,S){if(d=Je(d),d&&(S||y===r))return d.slice(0,Rs(d)+1);if(!d||!(y=xt(y)))return d;var C=Bt(d),B=Cs(C,Bt(y))+1;return an(C,0,B).join("")}function yh(d,y,S){if(d=Je(d),d&&(S||y===r))return d.replace(Lr,"");if(!d||!(y=xt(y)))return d;var C=Bt(d),B=Ds(C,Bt(y));return an(C,B).join("")}function bh(d,y){var S=$,C=N;if(tt(y)){var B="separator"in y?y.separator:B;S="length"in y?Ne(y.length):S,C="omission"in y?xt(y.omission):C}d=Je(d);var K=d.length;if(wn(d)){var G=Bt(d);K=G.length}if(S>=K)return d;var ee=S-kn(C);if(ee<1)return C;var re=G?an(G,0,ee).join(""):d.slice(0,ee);if(B===r)return re+C;if(G&&(ee+=re.length-ee),Fi(B)){if(d.slice(ee).search(B)){var he,me=re;for(B.global||(B=ti(B.source,Je(Qi.exec(B))+"g")),B.lastIndex=0;he=B.exec(me);)var ye=he.index;re=re.slice(0,ye===r?ee:ye)}}else if(d.indexOf(xt(B),ee)!=ee){var Se=re.lastIndexOf(B);Se>-1&&(re=re.slice(0,Se))}return re+C}function vh(d){return d=Je(d),d&&Ia.test(d)?d.replace(Ji,Hc):d}var wh=jn(function(d,y,S){return d+(S?" ":"")+y.toUpperCase()}),Wi=Eo("toUpperCase");function wa(d,y,S){return d=Je(d),y=S?r:y,y===r?Uc(d)?Jc(d):Cc(d):d.match(y)||[]}var ka=We(function(d,y){try{return kt(d,r,y)}catch(S){return Li(S)?S:new Le(S)}}),kh=Gt(function(d,y){return jt(y,function(S){S=qt(S),Ht(d,S,$i(d[S],d))}),d});function Eh(d){var y=d==null?0:d.length,S=Re();return d=y?et(d,function(C){if(typeof C[1]!="function")throw new Tt(l);return[S(C[0]),C[1]]}):[],We(function(C){for(var B=-1;++B<y;){var K=d[B];if(kt(K[0],this,C))return kt(K[1],this,C)}})}function xh(d){return Hl(Ct(d,a))}function qi(d){return function(){return d}}function Sh(d,y){return d==null||d!==d?y:d}var Ah=So(),Oh=So(!0);function wt(d){return d}function Vi(d){return eo(typeof d=="function"?d:Ct(d,a))}function Ih(d){return no(Ct(d,a))}function jh(d,y){return ro(d,Ct(y,a))}var Th=We(function(d,y){return function(S){return Un(S,d,y)}}),Dh=We(function(d,y){return function(S){return Un(d,S,y)}});function Ki(d,y,S){var C=lt(y),B=gr(y,C);S==null&&!(tt(y)&&(B.length||!C.length))&&(S=y,y=d,d=this,B=gr(y,lt(y)));var K=!(tt(S)&&"chain"in S)||!!S.chain,G=Yt(d);return jt(B,function(ee){var re=y[ee];d[ee]=re,G&&(d.prototype[ee]=function(){var he=this.__chain__;if(K||he){var me=d(this.__wrapped__),ye=me.__actions__=yt(this.__actions__);return ye.push({func:re,args:arguments,thisArg:d}),me.__chain__=he,me}return re.apply(d,en([this.value()],arguments))})}),d}function Ch(){return ut._===this&&(ut._=tl),this}function Hi(){}function Ph(d){return d=Ne(d),We(function(y){return io(y,d)})}var Rh=Ei(et),Mh=Ei(Ss),$h=Ei(Gr);function Ea(d){return Ti(d)?Jr(qt(d)):lu(d)}function Bh(d){return function(y){return d==null?r:hn(d,y)}}var Lh=Oo(),Fh=Oo(!0);function zi(){return[]}function Gi(){return!1}function Nh(){return{}}function Uh(){return""}function Wh(){return!0}function qh(d,y){if(d=Ne(d),d<1||d>X)return[];var S=ie,C=ft(d,ie);y=Re(y),d-=ie;for(var B=Qr(C,y);++S<d;)y(S);return B}function Vh(d){return Fe(d)?et(d,qt):St(d)?[d]:yt(qo(Je(d)))}function Kh(d){var y=++Zc;return Je(d)+y}var Hh=Er(function(d,y){return d+y},0),zh=xi("ceil"),Gh=Er(function(d,y){return d/y},1),Jh=xi("floor");function Yh(d){return d&&d.length?_r(d,wt,li):r}function Xh(d,y){return d&&d.length?_r(d,Re(y,2),li):r}function Qh(d){return Is(d,wt)}function Zh(d,y){return Is(d,Re(y,2))}function em(d){return d&&d.length?_r(d,wt,pi):r}function tm(d,y){return d&&d.length?_r(d,Re(y,2),pi):r}var nm=Er(function(d,y){return d*y},1),rm=xi("round"),im=Er(function(d,y){return d-y},0);function sm(d){return d&&d.length?Xr(d,wt):0}function om(d,y){return d&&d.length?Xr(d,Re(y,2)):0}return U.after=Of,U.ary=ea,U.assign=mp,U.assignIn=ha,U.assignInWith=$r,U.assignWith=_p,U.at=gp,U.before=ta,U.bind=$i,U.bindAll=kh,U.bindKey=na,U.castArray=Ff,U.chain=Xo,U.chunk=Hu,U.compact=zu,U.concat=Gu,U.cond=Eh,U.conforms=xh,U.constant=qi,U.countBy=rf,U.create=yp,U.curry=ra,U.curryRight=ia,U.debounce=sa,U.defaults=bp,U.defaultsDeep=vp,U.defer=If,U.delay=jf,U.difference=Ju,U.differenceBy=Yu,U.differenceWith=Xu,U.drop=Qu,U.dropRight=Zu,U.dropRightWhile=ed,U.dropWhile=td,U.fill=nd,U.filter=of,U.flatMap=lf,U.flatMapDeep=uf,U.flatMapDepth=df,U.flatten=zo,U.flattenDeep=rd,U.flattenDepth=id,U.flip=Tf,U.flow=Ah,U.flowRight=Oh,U.fromPairs=sd,U.functions=Op,U.functionsIn=Ip,U.groupBy=ff,U.initial=ad,U.intersection=cd,U.intersectionBy=ld,U.intersectionWith=ud,U.invert=Tp,U.invertBy=Dp,U.invokeMap=hf,U.iteratee=Vi,U.keyBy=mf,U.keys=lt,U.keysIn=vt,U.map=Tr,U.mapKeys=Pp,U.mapValues=Rp,U.matches=Ih,U.matchesProperty=jh,U.memoize=Cr,U.merge=Mp,U.mergeWith=ma,U.method=Th,U.methodOf=Dh,U.mixin=Ki,U.negate=Pr,U.nthArg=Ph,U.omit=$p,U.omitBy=Bp,U.once=Df,U.orderBy=_f,U.over=Rh,U.overArgs=Cf,U.overEvery=Mh,U.overSome=$h,U.partial=Bi,U.partialRight=oa,U.partition=gf,U.pick=Lp,U.pickBy=_a,U.property=Ea,U.propertyOf=Bh,U.pull=hd,U.pullAll=Jo,U.pullAllBy=md,U.pullAllWith=_d,U.pullAt=gd,U.range=Lh,U.rangeRight=Fh,U.rearg=Pf,U.reject=vf,U.remove=yd,U.rest=Rf,U.reverse=Ri,U.sampleSize=kf,U.set=Np,U.setWith=Up,U.shuffle=Ef,U.slice=bd,U.sortBy=Af,U.sortedUniq=Ad,U.sortedUniqBy=Od,U.split=uh,U.spread=Mf,U.tail=Id,U.take=jd,U.takeRight=Td,U.takeRightWhile=Dd,U.takeWhile=Cd,U.tap=zd,U.throttle=$f,U.thru=jr,U.toArray=da,U.toPairs=ga,U.toPairsIn=ya,U.toPath=Vh,U.toPlainObject=pa,U.transform=Wp,U.unary=Bf,U.union=Pd,U.unionBy=Rd,U.unionWith=Md,U.uniq=$d,U.uniqBy=Bd,U.uniqWith=Ld,U.unset=qp,U.unzip=Mi,U.unzipWith=Yo,U.update=Vp,U.updateWith=Kp,U.values=Cn,U.valuesIn=Hp,U.without=Fd,U.words=wa,U.wrap=Lf,U.xor=Nd,U.xorBy=Ud,U.xorWith=Wd,U.zip=qd,U.zipObject=Vd,U.zipObjectDeep=Kd,U.zipWith=Hd,U.entries=ga,U.entriesIn=ya,U.extend=ha,U.extendWith=$r,Ki(U,U),U.add=Hh,U.attempt=ka,U.camelCase=Yp,U.capitalize=ba,U.ceil=zh,U.clamp=zp,U.clone=Nf,U.cloneDeep=Wf,U.cloneDeepWith=qf,U.cloneWith=Uf,U.conformsTo=Vf,U.deburr=va,U.defaultTo=Sh,U.divide=Gh,U.endsWith=Xp,U.eq=Ft,U.escape=Qp,U.escapeRegExp=Zp,U.every=sf,U.find=af,U.findIndex=Ko,U.findKey=wp,U.findLast=cf,U.findLastIndex=Ho,U.findLastKey=kp,U.floor=Jh,U.forEach=Qo,U.forEachRight=Zo,U.forIn=Ep,U.forInRight=xp,U.forOwn=Sp,U.forOwnRight=Ap,U.get=Ni,U.gt=Kf,U.gte=Hf,U.has=jp,U.hasIn=Ui,U.head=Go,U.identity=wt,U.includes=pf,U.indexOf=od,U.inRange=Gp,U.invoke=Cp,U.isArguments=gn,U.isArray=Fe,U.isArrayBuffer=zf,U.isArrayLike=bt,U.isArrayLikeObject=it,U.isBoolean=Gf,U.isBuffer=cn,U.isDate=Jf,U.isElement=Yf,U.isEmpty=Xf,U.isEqual=Qf,U.isEqualWith=Zf,U.isError=Li,U.isFinite=ep,U.isFunction=Yt,U.isInteger=aa,U.isLength=Rr,U.isMap=ca,U.isMatch=tp,U.isMatchWith=np,U.isNaN=rp,U.isNative=ip,U.isNil=ap,U.isNull=sp,U.isNumber=la,U.isObject=tt,U.isObjectLike=rt,U.isPlainObject=zn,U.isRegExp=Fi,U.isSafeInteger=cp,U.isSet=ua,U.isString=Mr,U.isSymbol=St,U.isTypedArray=Dn,U.isUndefined=lp,U.isWeakMap=up,U.isWeakSet=dp,U.join=dd,U.kebabCase=eh,U.last=Rt,U.lastIndexOf=fd,U.lowerCase=th,U.lowerFirst=nh,U.lt=fp,U.lte=pp,U.max=Yh,U.maxBy=Xh,U.mean=Qh,U.meanBy=Zh,U.min=em,U.minBy=tm,U.stubArray=zi,U.stubFalse=Gi,U.stubObject=Nh,U.stubString=Uh,U.stubTrue=Wh,U.multiply=nm,U.nth=pd,U.noConflict=Ch,U.noop=Hi,U.now=Dr,U.pad=rh,U.padEnd=ih,U.padStart=sh,U.parseInt=oh,U.random=Jp,U.reduce=yf,U.reduceRight=bf,U.repeat=ah,U.replace=ch,U.result=Fp,U.round=rm,U.runInContext=ne,U.sample=wf,U.size=xf,U.snakeCase=lh,U.some=Sf,U.sortedIndex=vd,U.sortedIndexBy=wd,U.sortedIndexOf=kd,U.sortedLastIndex=Ed,U.sortedLastIndexBy=xd,U.sortedLastIndexOf=Sd,U.startCase=dh,U.startsWith=fh,U.subtract=im,U.sum=sm,U.sumBy=om,U.template=ph,U.times=qh,U.toFinite=Xt,U.toInteger=Ne,U.toLength=fa,U.toLower=hh,U.toNumber=Mt,U.toSafeInteger=hp,U.toString=Je,U.toUpper=mh,U.trim=_h,U.trimEnd=gh,U.trimStart=yh,U.truncate=bh,U.unescape=vh,U.uniqueId=Kh,U.upperCase=wh,U.upperFirst=Wi,U.each=Qo,U.eachRight=Zo,U.first=Go,Ki(U,function(){var d={};return Ut(U,function(y,S){Ye.call(U.prototype,S)||(d[S]=y)}),d}(),{chain:!1}),U.VERSION=i,jt(["bind","bindKey","curry","curryRight","partial","partialRight"],function(d){U[d].placeholder=U}),jt(["drop","take"],function(d,y){Ve.prototype[d]=function(S){S=S===r?1:ct(Ne(S),0);var C=this.__filtered__&&!y?new Ve(this):this.clone();return C.__filtered__?C.__takeCount__=ft(S,C.__takeCount__):C.__views__.push({size:ft(S,ie),type:d+(C.__dir__<0?"Right":"")}),C},Ve.prototype[d+"Right"]=function(S){return this.reverse()[d](S).reverse()}}),jt(["filter","map","takeWhile"],function(d,y){var S=y+1,C=S==F||S==q;Ve.prototype[d]=function(B){var K=this.clone();return K.__iteratees__.push({iteratee:Re(B,3),type:S}),K.__filtered__=K.__filtered__||C,K}}),jt(["head","last"],function(d,y){var S="take"+(y?"Right":"");Ve.prototype[d]=function(){return this[S](1).value()[0]}}),jt(["initial","tail"],function(d,y){var S="drop"+(y?"":"Right");Ve.prototype[d]=function(){return this.__filtered__?new Ve(this):this[S](1)}}),Ve.prototype.compact=function(){return this.filter(wt)},Ve.prototype.find=function(d){return this.filter(d).head()},Ve.prototype.findLast=function(d){return this.reverse().find(d)},Ve.prototype.invokeMap=We(function(d,y){return typeof d=="function"?new Ve(this):this.map(function(S){return Un(S,d,y)})}),Ve.prototype.reject=function(d){return this.filter(Pr(Re(d)))},Ve.prototype.slice=function(d,y){d=Ne(d);var S=this;return S.__filtered__&&(d>0||y<0)?new Ve(S):(d<0?S=S.takeRight(-d):d&&(S=S.drop(d)),y!==r&&(y=Ne(y),S=y<0?S.dropRight(-y):S.take(y-d)),S)},Ve.prototype.takeRightWhile=function(d){return this.reverse().takeWhile(d).reverse()},Ve.prototype.toArray=function(){return this.take(ie)},Ut(Ve.prototype,function(d,y){var S=/^(?:filter|find|map|reject)|While$/.test(y),C=/^(?:head|last)$/.test(y),B=U[C?"take"+(y=="last"?"Right":""):y],K=C||/^find/.test(y);B&&(U.prototype[y]=function(){var G=this.__wrapped__,ee=C?[1]:arguments,re=G instanceof Ve,he=ee[0],me=re||Fe(G),ye=function(qe){var Ke=B.apply(U,en([qe],ee));return C&&Se?Ke[0]:Ke};me&&S&&typeof he=="function"&&he.length!=1&&(re=me=!1);var Se=this.__chain__,Te=!!this.__actions__.length,Me=K&&!Se,Ue=re&&!Te;if(!K&&me){G=Ue?G:new Ve(this);var $e=d.apply(G,ee);return $e.__actions__.push({func:jr,args:[ye],thisArg:r}),new Dt($e,Se)}return Me&&Ue?d.apply(this,ee):($e=this.thru(ye),Me?C?$e.value()[0]:$e.value():$e)})}),jt(["pop","push","shift","sort","splice","unshift"],function(d){var y=er[d],S=/^(?:push|sort|unshift)$/.test(d)?"tap":"thru",C=/^(?:pop|shift)$/.test(d);U.prototype[d]=function(){var B=arguments;if(C&&!this.__chain__){var K=this.value();return y.apply(Fe(K)?K:[],B)}return this[S](function(G){return y.apply(Fe(G)?G:[],B)})}}),Ut(Ve.prototype,function(d,y){var S=U[y];if(S){var C=S.name+"";Ye.call(An,C)||(An[C]=[]),An[C].push({name:y,func:S})}}),An[kr(r,k).name]=[{name:"wrapper",func:r}],Ve.prototype.clone=gl,Ve.prototype.reverse=yl,Ve.prototype.value=bl,U.prototype.at=Gd,U.prototype.chain=Jd,U.prototype.commit=Yd,U.prototype.next=Xd,U.prototype.plant=Zd,U.prototype.reverse=ef,U.prototype.toJSON=U.prototype.valueOf=U.prototype.value=nf,U.prototype.first=U.prototype.head,Rn&&(U.prototype[Rn]=Qd),U},En=Yc();ln?((ln.exports=En)._=En,Vr._=En):ut._=En}).call(commonjsGlobal)})(lodash$1,lodash$1.exports);var lodashExports=lodash$1.exports;const lodash=getDefaultExportFromCjs(lodashExports);function inferImgAxes(n,t="bcz"){if(n.length===2)return"yx";if(n.length<=5){let r=n.indexOf(Math.min(...n)),i=n.slice();i.splice(r,1);let s=inferImgAxes(i,t.slice(1));const o=t[0];return insertCharAtPosition(s,o,r)}else throw new Error(`Image shape [${n.join(", ")}] is not supported.`)}function inferImgAxesViaSpec(n,t,r=!1){let i;if(r)if(n.length===2)i="yx";else if(n.length===3)i="yxc";else if(n.length===4)t.includes("z")?i="zyxc":i="cyxb";else throw new Error(`Image shape [${n.join(", ")}] is not supported.`);else{let s="bcz";t.includes("c")?t.includes("z")?t.includes("b")||(s="cz"):s="bc":s="bz",i=inferImgAxes(n,s)}return i}function insertCharAtPosition(n,t,r){return n.substring(0,r)+t+n.substring(r)}function getConstructor(n){let t;if(n=="uint8")t=Uint8Array;else if(n=="int8")t=Int8Array;else if(n=="uint16")t=Uint16Array;else if(n=="int16")t=Int16Array;else if(n=="uint32")t=Uint32Array;else if(n=="int32")t=Int32Array;else if(n=="float32")t=Float32Array;else if(n=="float64")t=Float64Array;else if(n=="bool")t=Uint8Array;else throw new Error("Unsupported dtype: "+n);return t}function reverseEndianness(n,t){let r=new Uint8Array(n);for(let i=0;i<r.length;i+=t)for(let s=i,o=i+t-1;s<o;s++,o--)[r[s],r[o]]=[r[o],r[s]];return n}function imjoyToTfjs(n){let t=new ArrayBuffer(n._rvalue.length);new Uint8Array(t).set(n._rvalue);const i=getConstructor(n._rdtype);let s=new i(t);if(n._rdtype==="bool")for(let l=0;l<s.length;l++)s[l]===1&&(s[l]=255);const o=tensor(Array.from(s),n._rshape);return o._rdtype=n._rdtype,o}function tfjsToImJoy(n,t=!1){const r=n.dataSync(),i=getConstructor(n._rdtype);let s=new i(r.length);for(let f=0;f<r.length;f++)s[f]=r[f];t&&(s=new i(reverseEndianness(s.buffer,i.BYTES_PER_ELEMENT)));const o=new Uint8Array(s.buffer);return{_rtype:"ndarray",_rdtype:n._rdtype,_rshape:n.shape,_rvalue:o}}function pick(n,t){const r=[];for(let l=0;l<n.shape.length;l++)t[l]===null?r.push(0):r.push(t[l]);const i=[];for(let l=0;l<n.shape.length;l++)t[l]===null?i.push(n.shape[l]):i.push(1);const s=slice$1(n,r,i),o=[];for(let l=0;l<n.shape.length;l++)t[l]===null&&o.push(n.shape[l]);return reshape$1(s,o)}function mapAxes(n,t,r){if(t.length!==n.shape.length)throw new Error(`Number of axes ${t.length} and dimension of input ${n.shape.length} don't match`);const i=[];t.split("").forEach((f,u)=>{const _=n.shape[u];if(r.includes(f))i.push(null);else{let g=0;"zyx".includes(f)&&(g=Math.floor(_/2)),i.push(g)}});let s=t.split("").filter((f,u)=>i[u]===null),o=pick(n,i);r.split("").forEach(f=>{t.includes(f)||(o=reshape$1(o,o.shape.concat([1])),s.push(f))});const l=[];for(let f=0;f<r.length;f++){const u=r[f],_=s.indexOf(u);l.push(_)}return o=transpose$1(o,l),o._rdtype=n._rdtype,o}const splitBy=(n,t,r)=>{const i=r.indexOf(t),s=n.shape[i],o=[];for(let l=0;l<s;l++){const f=[];for(let _=0;_<n.shape.length;_++)_===i?f.push(l):f.push(null);const u=pick(n,f);o.push(u)}return o};function splitForShow(n,t){if(!t.includes("x")||!t.includes("y"))throw new Error("Unsupported axes: "+t);const r=t.includes("c"),i=n.shape[t.indexOf("c")],s=t.includes("z"),o=n.shape[t.indexOf("z")];let l=[];if(t.length===2)l.push(n);else if(t.length===3)r?i===3?n._rdtype==="uint8"?l.push(mapAxes(n,t,"yxc")):l.push(mapAxes(n,t,"cyx")):i===1?l.push(mapAxes(n,t,"yx")):l.push(mapAxes(n,t,"cyx")):s?l.push(mapAxes(n,t,"zyx")):l=splitBy(n,"b",t);else if(t.length===4)r&&s?i==3?l.push(mapAxes(n,t,"zyxc")):i==1?l.push(mapAxes(n,t,"zyx")):o==1?l.push(mapAxes(n,t,"cyx")):splitBy(n,"c",t).map(f=>{const u=t.replace("c","");l=l.concat(splitForShow(f,u))}):splitBy(n,"b",t).map(f=>{const u=t.replace("b","");l=l.concat(splitForShow(f,u))});else if(t.length===5)splitBy(n,"b",t).map(f=>{const u=t.replace("b","");l=l.concat(splitForShow(f,u))});else throw new Error("Unsupported axes: "+t);return l}function processForShow(n,t){const r=t.includes("x")&&t.includes("y");let i;return r?i=splitForShow(n,t):t.length>2&&t.includes("b")?i=splitBy(n,"b",t):i=[n],i.map(s=>(s._rdtype=n._rdtype,tfjsToImJoy(s)))}function getNpyDtype(n){const t=new DataView(n.slice(8,10)).getUint8(0),r=new TextDecoder("utf-8").decode(new Uint8Array(n.slice(10,10+t)));return JSON.parse(r.toLowerCase().replace(/'/g,'"').replace("(","[").replace(/,*\),*/g,"]")).descr}async function getNpyEndianness(n){const t=await fetch(n,{headers:{Range:"bytes=0-999"}});if(!t.ok)return console.error(t),null;const r=await t.arrayBuffer();return getNpyDtype(r)[0]}class ImgPadder{constructor(t,r,i,s=0){this.fixedPaddedShape=t,this.padMin=r,this.padStep=i,this.padValue=s}getPaddedShape(t){let r=[];if(this.fixedPaddedShape)r=this.fixedPaddedShape;else{const i=this.padMin,s=this.padStep;for(let o=0;o<t.length;o++)if(s[o]===0)r.push(t[o]);else{const l=Math.max(0,Math.ceil((t[o]-i[o])/s[o])*s[o]);r.push(l+i[o])}}return r}pad(t,r="center"){const i=this.getPaddedShape(t.shape),s=[];for(let l=0;l<t.shape.length;l++){if(i[l]<t.shape[l])throw new Error(`Invalid shape: ${t.shape} for ${this.inputSpec.shape}`);const f=i[l]-t.shape[l];if(r==="center")s.push([Math.floor(f/2),Math.ceil(f/2)]);else if(r==="begin")s.push([0,f]);else if(r==="end")s.push([f,0]);else throw new Error(`Invalid position: ${r}`)}const o=pad(t,s,this.padValue);return o._rdtype=t._rdtype,[o,s]}crop(t,r,i=void 0){let s;return i?s=slice$1(t,r.map((o,l)=>o[0]+i[l]),t.shape.map((o,l)=>o-r[l][0]-r[l][1]-i[l]*2)):s=slice$1(t,r.map(o=>o[0]),t.shape.map((o,l)=>o-r[l][0]-r[l][1])),s._rdtype=t._rdtype,s}}class ImgTile{constructor(t,r,i){this.starts=t,this.ends=r,this.indexes=i,this.shape=r.map((s,o)=>s-this.starts[o]),this.data=null}slice(t){this.data=slice$1(t,this.starts,this.shape),this.data._rdtype=t._rdtype}merge(t,r){const i=this.starts.slice(),s=this.ends.slice();s[r]=t.ends[r];const o=this.ends[r]-t.starts[r];if(o<0)throw new Error("Cannot merge tiles with negative overlap.");let l;if(this.data===null||t.data===null)l=null;else{if(o===0)l=concat$1([this.data,t.data],r);else{const u=this.data.shape.slice();u[r]-=Math.ceil(o/2);const _=u.map(()=>0),g=slice$1(this.data,_,u),a=t.data.shape.slice();a[r]-=Math.floor(o/2);const m=a.map(()=>0);m[r]+=Math.floor(o/2);const b=slice$1(t.data,m,a);l=concat$1([g,b],r)}l._rdtype=this.data._rdtype}const f=new ImgTile(i,s,this.indexes);return f.data=l,f}mergeMean(t){const r=this.starts.slice(),i=this.ends.slice(),s=add$1(this.data,t.data).div(2);s._rdtype=this.data._rdtype;const o=new ImgTile(r,i,this.indexes);return o.data=s,o}}const cartesian=(...n)=>n.reduce((t,r)=>t.flatMap(i=>r.map(s=>[i,s].flat())));class ImgTiler{constructor(t,r,i=void 0){this.imgShape=t,this.tileShape=r,i===void 0&&(i=r.map(()=>0)),this.overlap=i}getNTiles(){const t=this.overlap,r=this.tileShape,i=this.imgShape;return r.map((o,l)=>Math.ceil(i[l]/(o-t[l])))}getTiles(){const t=this.overlap,r=this.tileShape,i=this.imgShape,s=this.getNTiles(),o=cartesian(...s.map(_=>Array.from(Array(_).keys()))),l=o.map(_=>_.map((g,a)=>g*(r[a]-t[a]))),f=l.map(_=>_.map((g,a)=>Math.min(g+r[a],i[a])));return l.map((_,g)=>new ImgTile(_,f[g],o[g]))}}class TileMerger{constructor(t){this.imgShape=t}mergeTiles(t){for(let i=0;i<this.imgShape.length;i++){const s=[],o=f=>{const u=[];return f.indexes.map((_,g)=>{g!==i&&u.push(_)}),u.join("-")},l=lodash.groupBy(t,o);for(let f in l){const u=l[f];if(u.sort((_,g)=>_.indexes[i]-g.indexes[i]),u.length>1){let _=u[0];for(let g=1;g<u.length;g++)_=_.merge(u[g],i);s.push(_)}else s.push(u[0])}t=s}return t[0]}}class MeanTileMerger extends TileMerger{constructor(t){super(t)}mergeTiles(t){const r=t[0];for(let i=1;i<t.length;i++)r.mergeMean(t[i]);return r}}const _export_sfc=(n,t)=>{const r=n.__vccOpts||n;for(const[i,s]of t)r[i]=s;return r},_sfc_main$6={props:{summary:String}};function _sfc_render$5(n,t,r,i,s,o){return openBlock(),createElementBlock("details",null,[renderSlot(n.$slots,"default",{},void 0,!0),createBaseVNode("summary",null,toDisplayString(r.summary),1)])}const HideContainer=_export_sfc(_sfc_main$6,[["render",_sfc_render$5],["__scopeId","data-v-1a1edfed"]]),_sfc_main$5={props:{open:Boolean}},_hoisted_1$e={class:"overlay-container"},_hoisted_2$a={key:0,class:"overlay"};function _sfc_render$4(n,t,r,i,s,o){return openBlock(),createElementBlock("div",_hoisted_1$e,[r.open?(openBlock(),createElementBlock("div",_hoisted_2$a)):createCommentVNode("",!0),renderSlot(n.$slots,"default",{},void 0,!0)])}const OverlayContainer=_export_sfc(_sfc_main$5,[["render",_sfc_render$4],["__scopeId","data-v-82e95675"]]),_sfc_main$4={props:{tritonConfig:Object,inputMinShape:Object,inputMaxShape:Object,tileSizes:Object,tileOverlaps:Object,serverUrl:String},data:function(){const n=this.serverUrl,t=[n];return n==="https://hypha.bioimage.io"?t.push("https://ai.imjoy.io"):n==="https://ai.imjoy.io"?t.push("https://hypha.bioimage.io"):(t.push("https://hypha.bioimage.io"),t.push("https://ai.imjoy.io")),{serverURL:t[0],serverUrlList:t}},watch:{serverUrl(){console.log(this.serverUrl),this.serverURL=this.serverUrl}},methods:{updateServerUrl(){this.$emit("server-url-changed",this.serverURL)}}},_withScopeId$1=n=>(pushScopeId("data-v-cbf370ec"),n=n(),popScopeId(),n),_hoisted_1$d={class:"server-setting"},_hoisted_2$9=_withScopeId$1(()=>createBaseVNode("h3",null,"Settings for server",-1)),_hoisted_3$5=_withScopeId$1(()=>createBaseVNode("label",{class:"field-label"},"Server URL",-1)),_hoisted_4$4={class:"field-row"},_hoisted_5$4={key:0,class:"tiling-setting"},_hoisted_6$4=_withScopeId$1(()=>createBaseVNode("h3",null,"Settings for image tiling",-1)),_hoisted_7$2={class:"field-row"},_hoisted_8$1={class:"field-column"},_hoisted_9$1={key:0},_hoisted_10$1=_withScopeId$1(()=>createBaseVNode("label",{class:"field-label"},"Tile size(XY)",-1)),_hoisted_11$1={key:1},_hoisted_12=_withScopeId$1(()=>createBaseVNode("label",{class:"field-label"},"Tile size(Z)",-1)),_hoisted_13={class:"field-column"},_hoisted_14={key:0},_hoisted_15=_withScopeId$1(()=>createBaseVNode("label",{class:"field-label"},"Tile overlap(XY)",-1)),_hoisted_16={key:1},_hoisted_17=_withScopeId$1(()=>createBaseVNode("label",{class:"field-label"},"Tile overlap(Z)",-1));function _sfc_render$3(n,t,r,i,s,o){const l=resolveComponent("InputText"),f=resolveComponent("Button"),u=resolveComponent("InputNumber");return openBlock(),createElementBlock("div",null,[createBaseVNode("div",_hoisted_1$d,[_hoisted_2$9,_hoisted_3$5,createBaseVNode("div",_hoisted_4$4,[createVNode(l,{id:"server-select",modelValue:n.serverURL,"onUpdate:modelValue":t[0]||(t[0]=_=>n.serverURL=_)},null,8,["modelValue"]),createVNode(f,{onClick:this.updateServerUrl},{default:withCtx(()=>[createTextVNode("Update")]),_:1},8,["onClick"])])]),r.tritonConfig?(openBlock(),createElementBlock("div",_hoisted_5$4,[_hoisted_6$4,createBaseVNode("div",_hoisted_7$2,[createBaseVNode("div",_hoisted_8$1,["x"in r.inputMinShape&&"y"in r.inputMinShape?(openBlock(),createElementBlock("div",_hoisted_9$1,[_hoisted_10$1,createVNode(u,{modelValue:r.tileSizes.x,"onUpdate:modelValue":t[1]||(t[1]=_=>r.tileSizes.x=_),showButtons:"",min:r.inputMinShape.x,max:r.inputMaxShape.x},null,8,["modelValue","min","max"])])):createCommentVNode("",!0),"z"in r.inputMinShape?(openBlock(),createElementBlock("div",_hoisted_11$1,[_hoisted_12,createVNode(u,{modelValue:r.tileSizes.z,"onUpdate:modelValue":t[2]||(t[2]=_=>r.tileSizes.z=_),showButtons:"",min:r.inputMinShape.z,max:r.inputMaxShape.z},null,8,["modelValue","min","max"])])):createCommentVNode("",!0)]),createBaseVNode("div",_hoisted_13,["x"in r.inputMinShape&&"y"in r.inputMinShape?(openBlock(),createElementBlock("div",_hoisted_14,[_hoisted_15,createVNode(u,{modelValue:r.tileOverlaps.x,"onUpdate:modelValue":t[3]||(t[3]=_=>r.tileOverlaps.x=_),showButtons:"",min:0,max:r.inputMaxShape.x},null,8,["modelValue","max"])])):createCommentVNode("",!0),"z"in r.inputMinShape?(openBlock(),createElementBlock("div",_hoisted_16,[_hoisted_17,createVNode(u,{modelValue:r.tileOverlaps.z,"onUpdate:modelValue":t[4]||(t[4]=_=>r.tileOverlaps.z=_),showButtons:"",min:0,max:r.inputMaxShape.z},null,8,["modelValue","max"])])):createCommentVNode("",!0)])])])):createCommentVNode("",!0)])}const AdvanceSetting=_export_sfc(_sfc_main$4,[["render",_sfc_render$3],["__scopeId","data-v-cbf370ec"]]),_sfc_main$3={},_hoisted_1$c={class:"loading-animation"};function _sfc_render$2(n,t){return openBlock(),createElementBlock("div",_hoisted_1$c)}const LoadingAnimation=_export_sfc(_sfc_main$3,[["render",_sfc_render$2],["__scopeId","data-v-91fefc2d"]]),_sfc_main$2={data(){return{currentModel:null,modelList:[]}},mounted(){this.fetchModels()},watch:{currentModel(){this.$emit("model-selected",this.currentModel)}},methods:{async fetchAvailableModels(){return(await(await fetch("https://raw.githubusercontent.com/bioimage-io/bioengine-model-runner/gh-pages/manifest.bioengine.json")).json()).collection.map(s=>s.id)},async fetchCollections(){return(await(await fetch("https://bioimage-io.github.io/collection-bioimage-io/rdf.json")).json()).collection},async fetchModels(){const n=await this.fetchAvailableModels(),r=(await this.fetchCollections()).filter(i=>n.includes(i.id));this.modelList=r,this.currentModel=r[0]}}},_hoisted_1$b={key:0},_hoisted_2$8={key:1},_hoisted_3$4=["title"];function _sfc_render$1(n,t,r,i,s,o){const l=resolveComponent("Dropdown");return openBlock(),createElementBlock("div",null,[createVNode(l,{modelValue:s.currentModel,"onUpdate:modelValue":t[0]||(t[0]=f=>s.currentModel=f),options:s.modelList,"option-label":"name"},{value:withCtx(f=>[f.value?(openBlock(),createElementBlock("div",_hoisted_1$b,[createBaseVNode("div",null,toDisplayString(f.value.nickname_icon)+" "+toDisplayString(f.value.name),1)])):(openBlock(),createElementBlock("span",_hoisted_2$8,toDisplayString(f.placeholder),1))]),option:withCtx(f=>[createBaseVNode("div",null,[createBaseVNode("div",{title:f.option.description},toDisplayString(f.option.nickname_icon)+" "+toDisplayString(f.option.name),9,_hoisted_3$4)])]),_:1},8,["modelValue","options"])])}const ModelSelect=_export_sfc(_sfc_main$2,[["render",_sfc_render$1]]),scriptRel="modulepreload",assetsURL=function(n){return"/"+n},seen={},__vitePreload=function(t,r,i){let s=Promise.resolve();if(r&&r.length>0){const o=document.getElementsByTagName("link");s=Promise.all(r.map(l=>{if(l=assetsURL(l),l in seen)return;seen[l]=!0;const f=l.endsWith(".css"),u=f?'[rel="stylesheet"]':"";if(!!i)for(let a=o.length-1;a>=0;a--){const m=o[a];if(m.href===l&&(!f||m.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${l}"]${u}`))return;const g=document.createElement("link");if(g.rel=f?"stylesheet":scriptRel,f||(g.as="script",g.crossOrigin=""),g.href=l,document.head.appendChild(g),f)return new Promise((a,m)=>{g.addEventListener("load",a),g.addEventListener("error",()=>m(new Error(`Unable to preload CSS for ${l}`)))})}))}return s.then(()=>t()).catch(o=>{const l=new Event("vite:preloadError",{cancelable:!0});if(l.payload=o,window.dispatchEvent(l),!l.defaultPrevented)throw o})};var imjoyRpc$1={exports:{}};(function(module,exports){(function(t,r){module.exports=r()})(window,function(){return function(n){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i,l:!1,exports:{}};return n[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=n,r.c=t,r.d=function(i,s,o){r.o(i,s)||Object.defineProperty(i,s,{enumerable:!0,get:o})},r.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},r.t=function(i,s){if(s&1&&(i=r(i)),s&8||s&4&&typeof i=="object"&&i&&i.__esModule)return i;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:i}),s&2&&typeof i!="string")for(var l in i)r.d(o,l,(function(f){return i[f]}).bind(null,l));return o},r.n=function(i){var s=i&&i.__esModule?function(){return i.default}:function(){return i};return r.d(s,"a",s),s},r.o=function(i,s){return Object.prototype.hasOwnProperty.call(i,s)},r.p="",r(r.s="./src/main.js")}({"./node_modules/worker-loader/dist/workers/InlineWorker.js":function(n,t,r){var i=window.URL||window.webkitURL;n.exports=function(s,o){try{try{var l;try{var f=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder;l=new f,l.append(s),l=l.getBlob()}catch{l=new Blob([s])}return new Worker(i.createObjectURL(l))}catch{return new Worker("data:application/javascript,"+encodeURIComponent(s))}}catch{if(!o)throw Error("Inline worker is not supported");return new Worker(o)}}},"./package.json":function(n){n.exports=JSON.parse('{"name":"imjoy-rpc","version":"0.5.46","description":"Remote procedure calls for ImJoy.","module":"index.js","types":"index.d.ts","scripts":{"build":"rm -rf dist && npm run build-umd","build-umd":"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map ","watch":"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map","publish-npm":"npm install && npm run build && npm publish","serve":"webpack-dev-server","stats":"webpack --profile --json > stats.json","stats-prod":"webpack --profile --json --mode production > stats-prod.json","analyze":"webpack-bundle-analyzer -p 9999 stats.json","analyze-prod":"webpack-bundle-analyzer -p 9999 stats-prod.json","clean":"rimraf dist/*","deploy":"npm run build && node deploy-site.js","format":"prettier --write \\"{src,tests}/**/**\\"","check-format":"prettier --check \\"{src,tests}/**/**\\"","test":"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js","test-watch":"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug"},"repository":{"type":"git","url":"git+https://github.com/imjoy-team/imjoy-rpc.git"},"keywords":["imjoy","rpc"],"author":"imjoy-team <imjoy.team@gmail.com>","license":"MIT","bugs":{"url":"https://github.com/imjoy-team/imjoy-rpc/issues"},"homepage":"https://github.com/imjoy-team/imjoy-rpc","dependencies":{"@msgpack/msgpack":"^2.7.1","socket.io-client":"^4.6.2"},"devDependencies":{"@babel/core":"^7.16.12","@babel/plugin-syntax-dynamic-import":"^7.8.3","@babel/polyfill":"^7.12.1","@babel/preset-env":"^7.16.11","@types/requirejs":"^2.1.34","babel-core":"^6.26.0","babel-eslint":"^10.1.0","babel-loader":"^8.2.3","babel-runtime":"^6.26.0","chai":"^4.3.6","clean-webpack-plugin":"^0.1.19","copy-webpack-plugin":"^5.1.2","eslint":"^6.8.0","eslint-config-prettier":"^4.2.0","eslint-loader":"^4.0.2","file-loader":"^0.11.2","fs-extra":"^0.30.0","gh-pages":"^2.0.1","html-loader":"^0.5.5","html-webpack-plugin":"^3.2.0","json-loader":"^0.5.4","karma":"^6.3.12","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^1.3.0","karma-mocha":"^2.0.1","karma-sourcemap-loader":"^0.3.8","karma-spec-reporter":"0.0.32","karma-webpack":"^4.0.2","lerna":"^6.0.3","lodash.debounce":"^4.0.8","mocha":"^10.1.0","postcss":"^7.0.36","prettier":"^1.6.1","rimraf":"^2.6.2","schema-utils":"^0.4.3","style-loader":"^0.18.1","ts-loader":"^9.4.3","url-loader":"^0.5.9","webpack":"^4.46.0","webpack-bundle-analyzer":"^4.7.0","webpack-cli":"^3.3.12","webpack-dev-server":"^3.11.3","webpack-merge":"^4.1.1","workbox-webpack-plugin":"^4.3.1","worker-loader":"^2.0.0","write-file-webpack-plugin":"^4.5.1"},"eslintConfig":{"globals":{"document":true,"window":true}}}')},"./src/main.js":function(n,t,r){r.r(t),r.d(t,"waitForInitialization",function(){return m}),r.d(t,"setupRPC",function(){return b});var i=r("./src/plugin.webworker.js"),s=r.n(i),o=r("./src/pluginIframe.js"),l=r("./src/utils.js");r.d(t,"loadRequirements",function(){return l.loadRequirements});var f=r("./src/rpc.js");r.d(t,"RPC",function(){return f.RPC}),r.d(t,"API_VERSION",function(){return f.API_VERSION});var u=r("./package.json");r.d(t,"VERSION",function(){return u.version});function _(){try{return window.self!==window.top}catch{return!0}}function g(){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope}function a(v){if(!v.allow_execution)throw new Error("web-worker plugin can only work with allow_execution=true");let c=null;v.broadcastChannel&&(c=new BroadcastChannel(v.broadcastChannel));const w=new s.a,k=setTimeout(function(){w.terminate(),console.warn("Plugin failed to start as a web-worker, running in an iframe instead."),Object(o.default)(v)},2e3),x=Object(l.randId)();w.addEventListener("message",function(E){let O;const A=E.data;if(A.type==="worker-ready"){w.postMessage({type:"connectRPC",config:v}),clearTimeout(k);return}else A.type==="initialized"?(A.config=Object.assign({},v,A.config),A.origin=globalThis.location.origin,A.peer_id=x):A.type==="imjoy_remote_api_ready"?globalThis.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:null})):A.type==="cacheRequirements"&&typeof cache_requirements=="function"?cache_requirements(A.requirements):A.type==="disconnect"?w.terminate():A.__transferables__&&(O=A.__transferables__,delete A.__transferables__);c?c.postMessage(A):parent.postMessage(A,v.target_origin||"*",O)}),(c||window).addEventListener("message",function(E){if(E.type==="message"&&(c||v.target_origin==="*"||E.origin===v.target_origin)){let O;const A=E.data;A.__transferables__&&(O=A.__transferables__,delete A.__transferables__),A.peer_id===x?w.postMessage(A,O):v.debug&&console.log(`connection peer id mismatch ${A.peer_id} !== ${x}`)}})}function m(v){g()&&(globalThis.parent=self),v=v||{},v.enable_service_worker&&(Object(l.setupServiceWorker)(v.base_url,v.target_origin,v.cache_requirements),v.enable_service_worker=!1),v.cache_requirements&&delete v.cache_requirements;const c=v.target_origin||"*";if(v.credential_required&&typeof v.verify_credential!="function")throw new Error("Please also provide the `verify_credential` function with `credential_required`.");if(v.credential_required&&c==="*")throw new Error("`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.");const w=()=>{globalThis.removeEventListener("message",x)},k=Object(l.randId)(),x=E=>{if(E.type==="message"&&(!E.origin||c==="*"||E.origin===c))if(E.data.type==="initialize"){w(),E.data.peer_id!==k&&console.warn(`${E.data.config&&E.data.config.name}: connection peer id mismatch ${E.data.peer_id} !== ${k}`);const O=E.data.config;c!=="*"&&(O.target_origin=c),v.credential_required?v.verify_credential(O.credential).then(A=>{if(A&&A.auth&&!A.error)O.auth=A.auth,b(O).then(()=>{console.log("ImJoy RPC loaded successfully!")});else throw new Error("Failed to verify the credentail:"+(A&&A.error))}):b(O).then(()=>{console.log("ImJoy RPC loaded successfully!")})}else throw new Error(`unrecognized message: ${E.data}`)};globalThis.addEventListener("message",x),g()?parent.postMessage({type:"imjoyRPCReady",config:v,peer_id:k}):parent.postMessage({type:"imjoyRPCReady",config:v,peer_id:k},"*")}function b(v){return v=v||{},v.name=v.name||Object(l.randId)(),v=Object(l.normalizeConfig)(v),v.enable_service_worker&&Object(l.setupServiceWorker)(v.base_url,v.target_origin,v.cache_requirements),v.cache_requirements&&delete v.cache_requirements,new Promise((c,w)=>{const k=x=>{const E=x.detail;v.expose_api_globally&&(globalThis.api=E),c(E),globalThis.removeEventListener("imjoy_remote_api_ready",k)};if(_()){if(v.type==="web-worker")try{a(v)}catch{Object(o.default)(v)}else if(["rpc-window","rpc-worker","iframe","window"].includes(v.type))Object(o.default)(v);else{console.error("Unsupported plugin type: "+v.type),w("Unsupported plugin type: "+v.type);return}globalThis.addEventListener("imjoy_remote_api_ready",k)}else g()?Object(o.default)(v):w(new Error("imjoy-rpc should only run inside an iframe or a webworker."))})}},"./src/plugin.webworker.js":function(n,t,r){n.exports=function(){return r("./node_modules/worker-loader/dist/workers/InlineWorker.js")(`/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/plugin.webworker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\\
  !*** ./src/plugin.webworker.js ***!
  \\*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the routines loaded by the plugin Worker under web-browser.
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */




// make sure this runs inside a webworker
if (
  typeof WorkerGlobalScope === "undefined" ||
  !self ||
  !(self instanceof WorkerGlobalScope)
) {
  throw new Error("This script can only loaded in a webworker");
}

async function executeEsModule(content) {
  const dataUri =
    "data:text/javascript;charset=utf-8," + encodeURIComponent(content);
  await import(/* webpackIgnore: true */ dataUri);
}

/**
 * Connection object provided to the RPC constructor,
 * plugin site implementation for the web-based environment.
 * Global will be then cleared to prevent exposure into the
 * Worker, so we put this local connection object into a closure
 */
class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
  }
  connect() {
    self.addEventListener("message", e => {
      this._fire(e.data.type, e.data);
    });
    this.emit({
      type: "initialized",
      config: this.config
    });
  }
  disconnect() {
    this._fire("beforeDisconnect");
    self.close();
    this._fire("disconnected");
  }
  emit(data) {
    let transferables = undefined;
    if (data.__transferables__) {
      transferables = data.__transferables__;
      delete data.__transferables__;
    }
    self.postMessage(data, transferables);
  }
  async execute(code) {
    if (code.type === "requirements") {
      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirementsInWebworker"])(code.requirements);
    } else if (code.type === "script") {
      try {
        if (code.attrs.type === "module") {
          await executeEsModule(code.content);
        } else {
          eval(code.content);
        }
      } catch (e) {
        console.error(e.message, e.stack);
        throw e;
      }
    } else {
      throw "unsupported code type.";
    }
    if (code.type === "requirements") {
      self.postMessage({
        type: "cacheRequirements",
        requirements: code.requirements
      });
    }
  }
}
const config = {
  type: "web-worker",
  dedicated_thread: true,
  allow_execution: true,
  lang: "javascript",
  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"]
};
const conn = new Connection(config);
conn.on("connectRPC", data => {
  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(conn, Object.assign(data.config, config));
});
conn.connect();
self.postMessage({
  type: "worker-ready"
});


/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\\
  !*** ./src/pluginCore.js ***!
  \\***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectRPC", function() { return connectRPC; });
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/**
 * Core plugin script loaded into the plugin process/thread.
 *
 * Initializes the plugin-site API global methods.
 */

function connectRPC(connection, config) {
  config = config || {};
  const codecs = {};
  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__["RPC"](connection, config, codecs);
  rpc.on("getInterface", function () {
    launchConnected();
  });
  rpc.on("remoteReady", function () {
    const api = rpc.getRemote() || {};

    api.registerCodec = function (config) {
      if (!config["name"] || !config["encoder"] && !config["decoder"]) {
        throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");
      } else {
        if (config.type) {
          for (let k of Object.keys(codecs)) {
            if (codecs[k].type === config.type || k === config.name) {
              delete codecs[k];
              console.warn("Remove duplicated codec: " + k);
            }
          }
        }

        codecs[config["name"]] = config;
      }
    };

    api.init = function (config) {
      // register a minimal plugin api
      rpc.setInterface({
        setup() {}

      }, config);
    };

    api.disposeObject = function (obj) {
      rpc.disposeObject(obj);
    };

    api.export = function (_interface, config) {
      rpc.setInterface(_interface, config);
    };

    api.onLoad = function (handler) {
      handler = checkHandler(handler);

      if (connected) {
        handler();
      } else {
        connectedHandlers.push(handler);
      }
    };

    api.dispose = function (_interface) {
      rpc.disconnect();
    };

    api._rpc = rpc;

    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
      self.api = api;
      self.postMessage({
        type: "imjoy_remote_api_ready"
      });
      self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    } else if (typeof window) {
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    }
  });
  let connected = false;
  const connectedHandlers = [];

  const launchConnected = function () {
    if (!connected) {
      connected = true;
      let handler;

      while (handler = connectedHandlers.pop()) {
        handler();
      }
    }
  };

  const checkHandler = function (handler) {
    const type = typeof handler;

    if (type !== "function") {
      const msg = "A function may only be subsribed to the event, " + type + " was provided instead";
      throw new Error(msg);
    }

    return handler;
  };

  return rpc;
}

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\\
  !*** ./src/rpc.js ***!
  \\********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return API_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return RPC; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the RPC object used both by the application
 * site, and by each plugin
 */

const API_VERSION = "0.2.3";
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;

function _appendBuffer(buffer1, buffer2) {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
}

function indexObject(obj, is) {
  if (!is) throw new Error("undefined index");
  if (typeof is === "string") return indexObject(obj, is.split("."));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));
}
/**
 * RPC object represents a single site in the
 * communication protocol between the application and the plugin
 *
 * @param {Object} connection a special object allowing to send
 * and receive messages from the opposite site (basically it
 * should only provide send() and onMessage() methods)
 */


class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(connection, config, codecs) {
    super(config && config.debug);
    this._connection = connection;
    this.config = config || {};
    this._codecs = codecs || {};
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._remote_set = false; // make sure there is an execute function

    const name = this.config.name;

    this._connection.execute = this._connection.execute || function () {
      throw new Error(\`connection.execute not implemented (in "\${name}")\`);
    };

    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();

    this._method_refs.onReady(() => {
      this._fire("remoteIdle");
    });

    this._method_refs.onBusy(() => {
      this._fire("remoteBusy");
    });

    this._setupMessageHanlders();
  }

  init() {
    this._connection.emit({
      type: "initialized",
      config: this.config,
      peer_id: this._connection.peer_id
    });
  }

  setConfig(config) {
    if (config) for (const k of Object.keys(config)) {
      this.config[k] = config[k];
    }
  }
  /**
   * Set a handler to be called when received a responce from the
   * remote site reporting that the previously provided interface
   * has been successfully set as remote for that site
   *
   * @param {Function} handler
   */


  getRemoteCallStack() {
    return this._method_refs.getStack();
  }
  /**
   * @returns {Object} set of remote interface methods
   */


  getRemote() {
    return this._remote_interface;
  }
  /**
   * Sets the interface of this site making it available to the
   * remote site by sending a message with a set of methods names
   *
   * @param {Object} _interface to set
   */


  setInterface(_interface, config) {
    config = config || {};
    this.config.name = config.name || this.config.name;
    this.config.description = config.description || this.config.description;

    if (this.config.forwarding_functions) {
      for (let func_name of this.config.forwarding_functions) {
        const _remote = this._remote_interface;

        if (_remote[func_name]) {
          if (_interface.constructor === Object) {
            if (!_interface[func_name]) {
              _interface[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          } else if (_interface.constructor.constructor === Function) {
            if (!_interface.constructor.prototype[func_name]) {
              _interface.constructor.prototype[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          }
        }
      }
    }

    this._local_api = _interface;
    if (!this._remote_set) this._fire("interfaceAvailable");else this.sendInterface();
    return new Promise(resolve => {
      this.once("interfaceSetAsRemote", resolve);
    });
  }
  /**
   * Sends the actual interface to the remote site upon it was
   * updated or by a special request of the remote site
   */


  sendInterface() {
    if (!this._local_api) {
      throw new Error("interface is not set.");
    }

    this._encode(this._local_api, true).then(api => {
      this._connection.emit({
        type: "setInterface",
        api: api
      });
    });
  }

  _disposeObject(objectId) {
    if (this._object_store[objectId]) {
      delete this._object_store[objectId];
    } else {
      throw new Error(\`Object (id=\${objectId}) not found.\`);
    }
  }

  disposeObject(obj) {
    return new Promise((resolve, reject) => {
      if (this._object_weakmap.has(obj)) {
        const objectId = this._object_weakmap.get(obj);

        this._connection.once("disposed", data => {
          if (data.error) reject(new Error(data.error));else resolve();
        });

        this._connection.emit({
          type: "disposeObject",
          object_id: objectId
        });
      } else {
        throw new Error("Invalid object");
      }
    });
  }
  /**
   * Handles a message from the remote site
   */


  _setupMessageHanlders() {
    this._connection.on("init", this.init);

    this._connection.on("execute", data => {
      Promise.resolve(this._connection.execute(data.code)).then(() => {
        this._connection.emit({
          type: "executed"
        });
      }).catch(e => {
        console.error(e);

        this._connection.emit({
          type: "executed",
          error: String(e)
        });
      });
    });

    this._connection.on("method", async data => {
      let resolve, reject, method, method_this, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        const _interface = this._object_store[data.object_id];
        method = indexObject(_interface, data.name);

        if (data.name.includes(".")) {
          const tmp = data.name.split(".");
          const intf_index = tmp.slice(0, tmp.length - 1).join(".");
          method_this = indexObject(_interface, intf_index);
        } else {
          method_this = _interface;
        }

        args = await this._unwrap(data.args, true);

        if (data.promise) {
          result = method.apply(method_this, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method.apply(method_this, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("callback", async data => {
      let resolve, reject, method, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        if (data.promise) {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          result = method.apply(null, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          method.apply(null, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("disposeObject", data => {
      try {
        this._disposeObject(data.object_id);

        this._connection.emit({
          type: "disposed"
        });
      } catch (e) {
        console.error(e);

        this._connection.emit({
          type: "disposed",
          error: String(e)
        });
      }
    });

    this._connection.on("setInterface", data => {
      this._setRemoteInterface(data.api);
    });

    this._connection.on("getInterface", () => {
      this._fire("getInterface");

      if (this._local_api) {
        this.sendInterface();
      } else {
        this.once("interfaceAvailable", () => {
          this.sendInterface();
        });
      }
    });

    this._connection.on("interfaceSetAsRemote", () => {
      this._remote_set = true;

      this._fire("interfaceSetAsRemote");
    });

    this._connection.on("disconnect", () => {
      this._fire("beforeDisconnect");

      this._connection.disconnect();

      this._fire("disconnected");
    });
  }
  /**
   * Sends a requests to the remote site asking it to provide its
   * current interface
   */


  requestRemote() {
    this._connection.emit({
      type: "getInterface"
    });
  }

  _ndarray(typedArray, shape, dtype) {
    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(typedArray);

    if (dtype && dtype !== _dtype) {
      throw "dtype doesn't match the type of the array: " + _dtype + " != " + dtype;
    }

    shape = shape || [typedArray.length];
    return {
      _rtype: "ndarray",
      _rvalue: typedArray.buffer,
      _rshape: shape,
      _rdtype: _dtype
    };
  }
  /**
   * Sets the new remote interface provided by the other site
   *
   * @param {Array} names list of function names
   */


  _setRemoteInterface(api) {
    this._decode(api).then(intf => {
      // update existing interface instead of recreating it
      // this will preserve the object reference
      if (this._remote_interface) {
        // clear the interface
        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces


        Object.assign(this._remote_interface, intf);
      } else this._remote_interface = intf;

      this._fire("remoteReady");

      this._reportRemoteSet();
    });
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * method. When the generated function is called, it will send the
   * corresponding message to the remote site asking it to execute
   * the particular method of its interface
   *
   * @param {String} name of the remote method
   *
   * @returns {Function} wrapped remote method
   */


  _genRemoteMethod(targetId, name, objectId) {
    const me = this;

    const remoteMethod = function () {
      return new Promise(async (resolve, reject) => {
        let id = null;

        try {
          id = me._method_refs.put(objectId ? objectId + "/" + name : name);

          const wrapped_resolve = function () {
            if (id !== null) me._method_refs.fetch(id);
            return resolve.apply(this, arguments);
          };

          const wrapped_reject = function () {
            if (id !== null) me._method_refs.fetch(id);
            return reject.apply(this, arguments);
          };

          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together

          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;
          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;
          let args = Array.prototype.slice.call(arguments);
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;

          if (name === "register" || name === "registerService" || name === "register_service" || name === "export" || name === "on") {
            args = await me._wrap(args, true);
          } else {
            args = await me._wrap(args);
          }

          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;

          me._connection.emit({
            type: "method",
            target_id: targetId,
            name: name,
            object_id: objectId,
            args: args,
            promise: encodedPromise,
            with_kwargs: withKwargs
          }, transferables);
        } catch (e) {
          if (id) me._method_refs.fetch(id);
          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);
        }
      });
    };

    remoteMethod.__remote_method = true;
    return remoteMethod;
  }
  /**
   * Sends a responce reporting that interface just provided by the
   * remote site was successfully set by this site as remote
   */


  _reportRemoteSet() {
    this._connection.emit({
      type: "interfaceSetAsRemote"
    });
  }
  /**
   * Prepares the provided set of remote method arguments for
   * sending to the remote site, replaces all the callbacks with
   * identifiers
   *
   * @param {Array} args to wrap
   *
   * @returns {Array} wrapped arguments
   */


  async _encode(aObject, asInterface, objectId) {
    const aType = typeof aObject;

    if (aType === "number" || aType === "string" || aType === "boolean" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {
      return aObject;
    }

    let bObject;

    if (typeof aObject === "function") {
      if (asInterface) {
        if (!objectId) throw new Error("objectId is not specified.");
        bObject = {
          _rtype: "interface",
          _rtarget_id: this._connection.peer_id,
          _rintf: objectId,
          _rvalue: asInterface
        };

        this._method_weakmap.set(aObject, bObject);
      } else if (this._method_weakmap.has(aObject)) {
        bObject = this._method_weakmap.get(aObject);
      } else {
        const cid = this._store.put(aObject);

        bObject = {
          _rtype: "callback",
          _rtarget_id: this._connection.peer_id,
          _rname: aObject.constructor && aObject.constructor.name || cid,
          _rvalue: cid
        };
      }

      return bObject;
    } // skip if already encoded


    if (aObject.constructor instanceof Object && aObject._rtype) {
      // make sure the interface functions are encoded
      if (aObject._rintf) {
        const temp = aObject._rtype;
        delete aObject._rtype;
        bObject = await this._encode(aObject, asInterface, objectId);
        bObject._rtype = temp;
      } else {
        bObject = aObject;
      }

      return bObject;
    }

    const transferables = [];
    const _transfer = aObject._transfer;
    const isarray = Array.isArray(aObject);

    for (let tp of Object.keys(this._codecs)) {
      const codec = this._codecs[tp];

      if (codec.encoder && aObject instanceof codec.type) {
        // TODO: what if multiple encoders found
        let encodedObj = await Promise.resolve(codec.encoder(aObject));
        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object

        if (encodedObj && encodedObj._rintf) {
          const temp = encodedObj._rtype;
          delete encodedObj._rtype;
          encodedObj = await this._encode(encodedObj, asInterface, objectId);
          encodedObj._rtype = temp;
        }

        bObject = encodedObj;
        return bObject;
      }
    }

    if (
    /*global tf*/
    typeof tf !== "undefined" && tf.Tensor && aObject instanceof tf.Tensor) {
      const v_buffer = aObject.dataSync();

      if (aObject._transfer || _transfer) {
        transferables.push(v_buffer.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: v_buffer.buffer,
        _rshape: aObject.shape,
        _rdtype: aObject.dtype
      };
    } else if (
    /*global nj*/
    typeof nj !== "undefined" && nj.NdArray && aObject instanceof nj.NdArray) {
      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject.selection.data);

      if (aObject._transfer || _transfer) {
        transferables.push(aObject.selection.data.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: aObject.selection.data.buffer,
        _rshape: aObject.shape,
        _rdtype: dtype
      };
    } else if (aObject instanceof Error) {
      console.error(aObject);
      bObject = {
        _rtype: "error",
        _rvalue: aObject.toString()
      };
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } // send objects supported by structure clone algorithm
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== "undefined" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== "undefined" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== "undefined" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== "undefined" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== "undefined" && aObject instanceof FileSystemWritableFileStream) {
      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rname: aObject.name,
        _rmime: aObject.type,
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } else if (aObject instanceof Blob) {
      bObject = {
        _rtype: "blob",
        _rvalue: aObject
      };
    } else if (aObject instanceof ArrayBufferView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject);
      bObject = {
        _rtype: "typedarray",
        _rvalue: aObject.buffer,
        _rdtype: dtype
      };
    } else if (aObject instanceof DataView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "memoryview",
        _rvalue: aObject.buffer
      };
    } else if (aObject instanceof Set) {
      bObject = {
        _rtype: "set",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject instanceof Map) {
      bObject = {
        _rtype: "orderedmap",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {
      bObject = isarray ? [] : {};
      let keys; // an object/array

      if (aObject.constructor === Object || Array.isArray(aObject)) {
        keys = Object.keys(aObject);
      } // a class
      else if (aObject.constructor === Function) {
        throw new Error("Please instantiate the class before exportting it.");
      } // instance of a class
      else if (aObject.constructor.constructor === Function) {
        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object
        // always encode class instance as interface

        asInterface = true;
      } else {
        throw Error("Unsupported interface type");
      }

      let hasFunction = false; // encode interfaces

      if (aObject._rintf || asInterface) {
        if (!objectId) {
          if (typeof aObject._rintf === "string" && aObject._rintf.length > 0) {
            objectId = aObject._rintf; // enable custom object id
          } else {
            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
          } // Note: object with the same id will be overwritten


          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);
          this._object_store[objectId] = aObject;
        }

        for (let k of keys) {
          if (k === "constructor") continue;

          if (k.startsWith("_")) {
            continue;
          }

          bObject[k] = await this._encode(aObject[k], typeof asInterface === "string" ? asInterface + "." + k : k, objectId);

          if (typeof aObject[k] === "function") {
            hasFunction = true;
          }
        } // object id for dispose the object remotely


        if (hasFunction) bObject._rintf = objectId; // remove interface when closed

        if (aObject.on && typeof aObject.on === "function") {
          aObject.on("close", () => {
            delete this._object_store[objectId];
          });
        }
      } else {
        for (let k of keys) {
          if (["hasOwnProperty", "constructor"].includes(k)) continue;
          bObject[k] = await this._encode(aObject[k]);
        }
      } // for example, browserFS object

    } else if (typeof aObject === "object") {
      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));
      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();

      for (let k of keys) {
        if (["hasOwnProperty", "constructor"].includes(k)) continue; // encode as interface

        bObject[k] = await this._encode(aObject[k], k, bObject);
      } // object id, used for dispose the object


      bObject._rintf = objectId;
    } else {
      throw "imjoy-rpc: Unsupported data type:" + aObject;
    }

    if (transferables.length > 0) {
      bObject.__transferables__ = transferables;
    }

    if (!bObject) {
      throw new Error("Failed to encode object");
    }

    return bObject;
  }

  async _decode(aObject, withPromise) {
    if (!aObject) {
      return aObject;
    }

    let bObject;

    if (aObject["_rtype"]) {
      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          aObject = await this._decode(aObject, withPromise);
          aObject._rtype = temp;
        }

        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));
      } else if (aObject._rtype === "callback") {
        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);
      } else if (aObject._rtype === "interface") {
        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);
      } else if (aObject._rtype === "ndarray") {
        /*global nj tf*/
        //create build array/tensor if used in the plugin
        if (typeof nj !== "undefined" && nj.array) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);
        } else if (typeof tf !== "undefined" && tf.Tensor) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);
        } else {
          //keep it as regular if transfered to the main app
          bObject = aObject;
        }
      } else if (aObject._rtype === "error") {
        bObject = new Error(aObject._rvalue);
      } else if (aObject._rtype === "file") {
        if (aObject._rvalue instanceof File) {
          bObject = aObject._rvalue; //patch _path

          bObject._path = aObject._rpath;
        } else {
          bObject = new File([aObject._rvalue], aObject._rname, {
            type: aObject._rmime
          });
          bObject._path = aObject._rpath;
        }
      } else if (aObject._rtype === "typedarray") {
        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
        if (!arraytype) throw new Error("unsupported dtype: " + aObject._rdtype);
        bObject = new arraytype(aObject._rvalue);
      } else if (aObject._rtype === "memoryview") {
        bObject = new DataView(aObject._rvalue);
      } else if (aObject._rtype === "blob") {
        if (aObject._rvalue instanceof Blob) {
          bObject = aObject._rvalue;
        } else {
          bObject = new Blob([aObject._rvalue], {
            type: aObject._rmime
          });
        }
      } else if (aObject._rtype === "orderedmap") {
        bObject = new Map(await this._decode(aObject._rvalue, withPromise));
      } else if (aObject._rtype === "set") {
        bObject = new Set(await this._decode(aObject._rvalue, withPromise));
      } else {
        // make sure all the interface functions are decoded
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          bObject = await this._decode(aObject, withPromise);
          bObject._rtype = temp;
        } else bObject = aObject;
      }
    } else if (aObject.constructor === Object || Array.isArray(aObject)) {
      const isarray = Array.isArray(aObject);
      bObject = isarray ? [] : {};

      for (let k of Object.keys(aObject)) {
        if (isarray || aObject.hasOwnProperty(k)) {
          const v = aObject[k];
          bObject[k] = await this._decode(v, withPromise);
        }
      }
    } else {
      bObject = aObject;
    }

    if (bObject === undefined) {
      throw new Error("Failed to decode object");
    } // store the object id for dispose


    if (aObject._rintf) {
      this._object_weakmap.set(bObject, aObject._rintf);
    }

    return bObject;
  }

  async _wrap(args, asInterface) {
    return await this._encode(args, asInterface);
  }
  /**
   * Unwraps the set of arguments delivered from the remote site,
   * replaces all callback identifiers with a function which will
   * initiate sending that callback identifier back to other site
   *
   * @param {Object} args to unwrap
   *
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Array} unwrapped args
   */


  async _unwrap(args, withPromise) {
    return await this._decode(args, withPromise);
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * callback. When the generated function is called, it will send
   * the corresponding message to the remote site asking it to
   * execute the particular callback previously saved during a call
   * by the remote site a method from the interface of this site
   *
   * @param {Number} id of the remote callback to execute
   * @param {Number} argNum argument index of the callback
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Function} wrapped remote callback
   */


  _genRemoteCallback(targetId, cid, withPromise) {
    const me = this;
    let remoteCallback;

    if (withPromise) {
      remoteCallback = function () {
        return new Promise(async (resolve, reject) => {
          const args = await me._wrap(Array.prototype.slice.call(arguments));
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;
          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;
          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together

          resolve.__promise_pair = encodedPromise[1]._rvalue;
          reject.__promise_pair = encodedPromise[0]._rvalue;

          try {
            me._connection.emit({
              type: "callback",
              target_id: targetId,
              id: cid,
              args: args,
              promise: encodedPromise,
              with_kwargs: withKwargs
            }, transferables);
          } catch (e) {
            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);
          }
        });
      };

      return remoteCallback;
    } else {
      remoteCallback = async function () {
        const args = await me._wrap(Array.prototype.slice.call(arguments));
        const argLength = args.length; // if the last argument is an object, mark it as kwargs

        const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
        if (withKwargs) delete args[argLength - 1]._rkwargs;
        const transferables = args.__transferables__;
        if (transferables) delete args.__transferables__;
        return me._connection.emit({
          type: "callback",
          target_id: targetId,
          id: cid,
          args: args,
          with_kwargs: withKwargs
        }, transferables);
      };

      return remoteCallback;
    }
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
    this._remote_interface = null;
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();
  }
  /**
   * Sends the notification message and breaks the connection
   */


  disconnect() {
    this._connection.emit({
      type: "disconnect"
    });

    this.reset();
    setTimeout(() => {
      this._connection.disconnect();
    }, 2000);
  }

}
/**
 * ReferenceStore is a special object which stores other objects
 * and provides the references (number) instead. This reference
 * may then be sent over a json-based communication channel (IPC
 * to another Node.js process or a message to the Worker). Other
 * site may then provide the reference in the responce message
 * implying the given object should be activated.
 *
 * Primary usage for the ReferenceStore is a storage for the
 * callbacks, which therefore makes it possible to initiate a
 * callback execution by the opposite site (which normally cannot
 * directly execute functions over the communication channel).
 *
 * Each stored object can only be fetched once and is not
 * available for the second time. Each stored object must be
 * fetched, since otherwise it will remain stored forever and
 * consume memory.
 *
 * Stored object indeces are simply the numbers, which are however
 * released along with the objects, and are later reused again (in
 * order to postpone the overflow, which should not likely happen,
 * but anyway).
 */

class ReferenceStore {
  constructor() {
    this._store = {}; // stored object

    this._indices = [0]; // smallest available indices

    this._readyHandler = function () {};

    this._busyHandler = function () {};

    this._readyHandler();
  }
  /**
   * call handler when the store is empty
   *
   * @param {FUNCTION} id of a handler
   */


  onReady(readyHandler) {
    this._readyHandler = readyHandler || function () {};
  }
  /**
   * call handler when the store is not empty
   *
   * @param {FUNCTION} id of a handler
   */


  onBusy(busyHandler) {
    this._busyHandler = busyHandler || function () {};
  }
  /**
   * get the length of the store
   *
   */


  getStack() {
    return Object.keys(this._store).length;
  }
  /**
   * @function _genId() generates the new reference id
   *
   * @returns {Number} smallest available id and reserves it
   */


  _genId() {
    let id;

    if (this._indices.length === 1) {
      id = this._indices[0]++;
    } else {
      id = this._indices.shift();
    }

    return id;
  }
  /**
   * Releases the given reference id so that it will be available by
   * another object stored
   *
   * @param {Number} id to release
   */


  _releaseId(id) {
    for (let i = 0; i < this._indices.length; i++) {
      if (id < this._indices[i]) {
        this._indices.splice(i, 0, id);

        break;
      }
    } // cleaning-up the sequence tail


    for (let i = this._indices.length - 1; i >= 0; i--) {
      if (this._indices[i] - 1 === this._indices[i - 1]) {
        this._indices.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Stores the given object and returns the refernce id instead
   *
   * @param {Object} obj to store
   *
   * @returns {Number} reference id of the stored object
   */


  put(obj) {
    if (this._busyHandler && Object.keys(this._store).length === 0) {
      this._busyHandler();
    }

    const id = this._genId();

    this._store[id] = obj;
    return id;
  }
  /**
   * Retrieves previously stored object and releases its reference
   *
   * @param {Number} id of an object to retrieve
   */


  fetch(id) {
    const obj = this._store[id];

    if (obj && !obj.__remote_method) {
      delete this._store[id];

      this._releaseId(id);

      if (this._readyHandler && Object.keys(this._store).length === 0) {
        this._readyHandler();
      }
    }

    if (obj && obj.__promise_pair) {
      this.fetch(obj.__promise_pair);
    }

    return obj;
  }

}

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\\
  !*** ./src/utils.js ***!
  \\**********************/
/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dtypeToTypedArray", function() { return dtypeToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWindow", function() { return loadRequirementsInWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWebworker", function() { return loadRequirementsInWebworker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return loadRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeConfig", function() { return normalizeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtypeMapping", function() { return typedArrayToDtypeMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtype", function() { return typedArrayToDtype; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheRequirements", function() { return cacheRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupServiceWorker", function() { return setupServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlJoin", function() { return urlJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
function randId() {
  return Math.random().toString(36).substr(2, 10) + new Date().getTime();
}
const dtypeToTypedArray = {
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  float32: Float32Array,
  float64: Float64Array,
  array: Array
};
async function loadRequirementsInWindow(requirements) {
  function _importScript(url) {
    //url is URL of external file, implementationCode is the code
    //to be called from the file, location is the location to
    //insert the <script> element
    return new Promise((resolve, reject) => {
      var scriptTag = document.createElement("script");
      scriptTag.src = url;
      scriptTag.type = "text/javascript";
      scriptTag.onload = resolve;

      scriptTag.onreadystatechange = function () {
        if (this.readyState === "loaded" || this.readyState === "complete") {
          resolve();
        }
      };

      scriptTag.onerror = reject;
      document.head.appendChild(scriptTag);
    });
  } // support importScripts outside web worker


  async function importScripts() {
    var args = Array.prototype.slice.call(arguments),
        len = args.length,
        i = 0;

    for (; i < len; i++) {
      await _importScript(args[i]);
    }
  }

  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      var link_node;
      requirements = typeof requirements === "string" ? [requirements] : requirements;

      if (Array.isArray(requirements)) {
        for (var i = 0; i < requirements.length; i++) {
          if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
            if (requirements[i].startsWith("css:")) {
              requirements[i] = requirements[i].slice(4);
            }

            link_node = document.createElement("link");
            link_node.rel = "stylesheet";
            link_node.href = requirements[i];
            document.head.appendChild(link_node);
          } else if (requirements[i].toLowerCase().endsWith(".mjs") || requirements[i].startsWith("mjs:")) {
            // import esmodule
            if (requirements[i].startsWith("mjs:")) {
              requirements[i] = requirements[i].slice(4);
            }

            await import(
            /* webpackIgnore: true */
            requirements[i]);
          } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
            if (requirements[i].startsWith("js:")) {
              requirements[i] = requirements[i].slice(3);
            }

            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("http")) {
            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("cache:")) {//ignore cache
          } else {
            console.log("Unprocessed requirements url: " + requirements[i]);
          }
        }
      } else {
        throw "unsupported requirements definition";
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
async function loadRequirementsInWebworker(requirements) {
  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      if (!Array.isArray(requirements)) {
        requirements = [requirements];
      }

      for (var i = 0; i < requirements.length; i++) {
        if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
          throw "unable to import css in a webworker";
        } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
          if (requirements[i].startsWith("js:")) {
            requirements[i] = requirements[i].slice(3);
          }

          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("http")) {
          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("cache:")) {//ignore cache
        } else {
          console.log("Unprocessed requirements url: " + requirements[i]);
        }
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
function loadRequirements(requirements) {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return loadRequirementsInWebworker(requirements);
  } else {
    return loadRequirementsInWindow(requirements);
  }
}
function normalizeConfig(config) {
  config.version = config.version || "0.1.0";
  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;
  config.type = config.type || "rpc-window";
  config.id = config.id || randId();
  config.target_origin = config.target_origin || "*";
  config.allow_execution = config.allow_execution || false; // remove functions

  config = Object.keys(config).reduce((p, c) => {
    if (typeof config[c] !== "function") p[c] = config[c];
    return p;
  }, {});
  return config;
}
const typedArrayToDtypeMapping = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};
const typedArrayToDtypeKeys = [];

for (const arrType of Object.keys(typedArrayToDtypeMapping)) {
  typedArrayToDtypeKeys.push(eval(arrType));
}

function typedArrayToDtype(obj) {
  let dtype = typedArrayToDtypeMapping[obj.constructor.name];

  if (!dtype) {
    const pt = Object.getPrototypeOf(obj);

    for (const arrType of typedArrayToDtypeKeys) {
      if (pt instanceof arrType) {
        dtype = typedArrayToDtypeMapping[arrType.name];
        break;
      }
    }
  }

  return dtype;
}

function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}

async function cacheRequirements(requirements) {
  requirements = requirements || [];

  if (!Array.isArray(requirements)) {
    requirements = [requirements];
  }

  for (let req of requirements) {
    //remove prefix
    if (req.startsWith("js:")) req = req.slice(3);
    if (req.startsWith("css:")) req = req.slice(4);
    if (req.startsWith("cache:")) req = req.slice(6);
    if (!req.startsWith("http")) continue;
    await cacheUrlInServiceWorker(req).catch(e => {
      console.error(e);
    });
  }
}
function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {
  // register service worker for offline access
  if ("serviceWorker" in navigator) {
    baseUrl = baseUrl || "/";
    navigator.serviceWorker.register(baseUrl + "plugin-service-worker.js").then(function (registration) {
      // Registration was successful
      console.log("ServiceWorker registration successful with scope: ", registration.scope);
    }, function (err) {
      // registration failed :(
      console.log("ServiceWorker registration failed: ", err);
    });
    targetOrigin = targetOrigin || "*";
    cacheCallback = cacheCallback || cacheRequirements;

    if (cacheCallback && typeof cacheCallback !== "function") {
      throw new Error("config.cache_requirements must be a function");
    }

    window.addEventListener("message", function (e) {
      if (targetOrigin === "*" || e.origin === targetOrigin) {
        const m = e.data;

        if (m.type === "cacheRequirements") {
          cacheCallback(m.requirements);
        }
      }
    });
  }
} //#Source https://bit.ly/2neWfJ2

function urlJoin(...args) {
  return args.join("/").replace(/[\\/]+/g, "/").replace(/^(.+):\\//, "$1://").replace(/^file:/, "file:/").replace(/\\/(\\?|&|#[^!])/g, "$1").replace(/\\?/g, "&").replace("&", "?");
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}

/***/ })

/******/ });
//# sourceMappingURL=plugin.webworker.js.map`,null)}},"./src/pluginCore.js":function(n,t,r){r.r(t),r.d(t,"connectRPC",function(){return s});var i=r("./src/rpc.js");function s(o,l){l=l||{};const f={},u=new i.RPC(o,l,f);u.on("getInterface",function(){a()}),u.on("remoteReady",function(){const b=u.getRemote()||{};b.registerCodec=function(v){if(!v.name||!v.encoder&&!v.decoder)throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");if(v.type)for(let c of Object.keys(f))(f[c].type===v.type||c===v.name)&&(delete f[c],console.warn("Remove duplicated codec: "+c));f[v.name]=v},b.init=function(v){u.setInterface({setup(){}},v)},b.disposeObject=function(v){u.disposeObject(v)},b.export=function(v,c){u.setInterface(v,c)},b.onLoad=function(v){v=m(v),_?v():g.push(v)},b.dispose=function(v){u.disconnect()},b._rpc=u,typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?(self.api=b,self.postMessage({type:"imjoy_remote_api_ready"}),self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:b}))):window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:b}))});let _=!1;const g=[],a=function(){if(!_){_=!0;let b;for(;b=g.pop();)b()}},m=function(b){const v=typeof b;if(v!=="function"){const c="A function may only be subsribed to the event, "+v+" was provided instead";throw new Error(c)}return b};return u}},"./src/pluginIframe.js":function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"Connection",function(){return Connection}),__webpack_require__.d(__webpack_exports__,"default",function(){return setupIframe});var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./src/pluginCore.js"),_rpc_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./src/rpc.js"),_utils_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./src/utils.js");function _htmlToElement(n){var t=document.createElement("template");return n=n.trim(),t.innerHTML=n,t.content.firstChild}const _inWebWorker=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope;async function executeEsModule(n){const t="data:text/javascript;charset=utf-8,"+encodeURIComponent(n);await __vitePreload(()=>import(t),__vite__mapDeps([]))}class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.MessageEmitter{constructor(n){super(n&&n.debug),this.config=n||{},this.peer_id=Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__.randId)()}connect(){this.config.target_origin=this.config.target_origin||"*",this.config.broadcastChannel?this.broadcastChannel=new BroadcastChannel(this.config.broadcastChannel):this.broadcastChannel=null,this.broadcastChannel?this.broadcastChannel.addEventListener("message",this):globalThis.addEventListener("message",this),this.emit({type:"initialized",config:this.config,origin:globalThis.location.origin,peer_id:this.peer_id}),this._fire("connected")}handleEvent(n){n.type==="message"&&(this.broadcastChannel||this.config.target_origin==="*"||!n.origin||n.origin===this.config.target_origin)&&(n.data.peer_id===this.peer_id?this._fire(n.data.type,n.data):this.config.debug&&console.log(`connection peer id mismatch ${n.data.peer_id} !== ${this.peer_id}`))}disconnect(){this._fire("beforeDisconnect"),globalThis.removeEventListener("message",this),this._fire("disconnected")}emit(n){let t;this.broadcastChannel?this.broadcastChannel.postMessage(n):n.__transferables__?(t=n.__transferables__,delete n.__transferables__):_inWebWorker?self.postMessage(n,t):parent.postMessage(n,this.config.target_origin,t)}async execute(code){try{if(code.type==="requirements")await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__.loadRequirementsInWindow)(code.requirements);else if(code.type==="script")if(code.src){var script_node=document.createElement("script");script_node.setAttribute("type",code.attrs.type),script_node.setAttribute("src",code.src),document.head.appendChild(script_node)}else if(code.content&&code.attrs.lang==="javascript")code.attrs.type==="module"?await executeEsModule(code.content):eval(code.content);else{var node=document.createElement("script");for(let n in code.attrs)node.setAttribute(n,code.attrs[n]);node.appendChild(document.createTextNode(code.content)),document.body.appendChild(node)}else if(code.type==="style"){const n=document.createElement("style");code.src&&(n.src=code.src),n.innerHTML=code.content,document.head.appendChild(n)}else if(code.type==="link"){const n=document.createElement("link");code.rel&&(n.rel=code.rel),code.href&&(n.href=code.href),code.attrs&&code.attrs.type&&(n.type=code.attrs.type),document.head.appendChild(n)}else if(code.type==="html")document.body.appendChild(_htmlToElement(code.content));else throw"unsupported code type.";_inWebWorker?self.postMessage({type:"executed"}):parent.postMessage({type:"executed"},this.config.target_origin)}catch(n){console.error("failed to execute scripts: ",code,n),_inWebWorker?self.postMessage({type:"executed",error:n.stack||String(n)}):parent.postMessage({type:"executed",error:n.stack||String(n)},this.config.target_origin)}}}function setupIframe(n){n=n||{},n.dedicated_thread=!1,n.lang="javascript",n.api_version=_rpc_js__WEBPACK_IMPORTED_MODULE_1__.API_VERSION;const t=new Connection(n);Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__.connectRPC)(t,n),t.connect()}},"./src/rpc.js":function(n,t,r){r.r(t),r.d(t,"API_VERSION",function(){return s}),r.d(t,"RPC",function(){return u});var i=r("./src/utils.js");const s="0.2.3",o=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor;function l(g,a){const m=new Uint8Array(g.byteLength+a.byteLength);return m.set(new Uint8Array(g),0),m.set(new Uint8Array(a),g.byteLength),m.buffer}function f(g,a){if(!a)throw new Error("undefined index");return typeof a=="string"?f(g,a.split(".")):a.length===0?g:f(g[a[0]],a.slice(1))}class u extends i.MessageEmitter{constructor(a,m,b){super(m&&m.debug),this._connection=a,this.config=m||{},this._codecs=b||{},this._object_store={},this._method_weakmap=new WeakMap,this._object_weakmap=new WeakMap,this._local_api=null,this._remote_set=!1;const v=this.config.name;this._connection.execute=this._connection.execute||function(){throw new Error(`connection.execute not implemented (in "${v}")`)},this._store=new _,this._method_refs=new _,this._method_refs.onReady(()=>{this._fire("remoteIdle")}),this._method_refs.onBusy(()=>{this._fire("remoteBusy")}),this._setupMessageHanlders()}init(){this._connection.emit({type:"initialized",config:this.config,peer_id:this._connection.peer_id})}setConfig(a){if(a)for(const m of Object.keys(a))this.config[m]=a[m]}getRemoteCallStack(){return this._method_refs.getStack()}getRemote(){return this._remote_interface}setInterface(a,m){if(m=m||{},this.config.name=m.name||this.config.name,this.config.description=m.description||this.config.description,this.config.forwarding_functions)for(let b of this.config.forwarding_functions){const v=this._remote_interface;v[b]&&(a.constructor===Object?a[b]||(a[b]=(...c)=>{v[b](...c)}):a.constructor.constructor===Function&&(a.constructor.prototype[b]||(a.constructor.prototype[b]=(...c)=>{v[b](...c)})))}return this._local_api=a,this._remote_set?this.sendInterface():this._fire("interfaceAvailable"),new Promise(b=>{this.once("interfaceSetAsRemote",b)})}sendInterface(){if(!this._local_api)throw new Error("interface is not set.");this._encode(this._local_api,!0).then(a=>{this._connection.emit({type:"setInterface",api:a})})}_disposeObject(a){if(this._object_store[a])delete this._object_store[a];else throw new Error(`Object (id=${a}) not found.`)}disposeObject(a){return new Promise((m,b)=>{if(this._object_weakmap.has(a)){const v=this._object_weakmap.get(a);this._connection.once("disposed",c=>{c.error?b(new Error(c.error)):m()}),this._connection.emit({type:"disposeObject",object_id:v})}else throw new Error("Invalid object")})}_setupMessageHanlders(){this._connection.on("init",this.init),this._connection.on("execute",a=>{Promise.resolve(this._connection.execute(a.code)).then(()=>{this._connection.emit({type:"executed"})}).catch(m=>{console.error(m),this._connection.emit({type:"executed",error:String(m)})})}),this._connection.on("method",async a=>{let m,b,v,c,w,k;try{a.promise&&([m,b]=await this._unwrap(a.promise,!1));const x=this._object_store[a.object_id];if(v=f(x,a.name),a.name.includes(".")){const E=a.name.split("."),O=E.slice(0,E.length-1).join(".");c=f(x,O)}else c=x;w=await this._unwrap(a.args,!0),a.promise?(k=v.apply(c,w),k instanceof Promise||v.constructor&&v.constructor.name==="AsyncFunction"?k.then(m).catch(b):m(k)):v.apply(c,w)}catch(x){console.error(this.config.name,x),b&&b(x)}}),this._connection.on("callback",async a=>{let m,b,v,c,w;try{if(a.promise&&([m,b]=await this._unwrap(a.promise,!1)),a.promise){if(v=this._store.fetch(a.id),c=await this._unwrap(a.args,!0),!v)throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");w=v.apply(null,c),w instanceof Promise||v.constructor&&v.constructor.name==="AsyncFunction"?w.then(m).catch(b):m(w)}else{if(v=this._store.fetch(a.id),c=await this._unwrap(a.args,!0),!v)throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");v.apply(null,c)}}catch(k){console.error(this.config.name,k),b&&b(k)}}),this._connection.on("disposeObject",a=>{try{this._disposeObject(a.object_id),this._connection.emit({type:"disposed"})}catch(m){console.error(m),this._connection.emit({type:"disposed",error:String(m)})}}),this._connection.on("setInterface",a=>{this._setRemoteInterface(a.api)}),this._connection.on("getInterface",()=>{this._fire("getInterface"),this._local_api?this.sendInterface():this.once("interfaceAvailable",()=>{this.sendInterface()})}),this._connection.on("interfaceSetAsRemote",()=>{this._remote_set=!0,this._fire("interfaceSetAsRemote")}),this._connection.on("disconnect",()=>{this._fire("beforeDisconnect"),this._connection.disconnect(),this._fire("disconnected")})}requestRemote(){this._connection.emit({type:"getInterface"})}_ndarray(a,m,b){const v=Object(i.typedArrayToDtype)(a);if(b&&b!==v)throw"dtype doesn't match the type of the array: "+v+" != "+b;return m=m||[a.length],{_rtype:"ndarray",_rvalue:a.buffer,_rshape:m,_rdtype:v}}_setRemoteInterface(a){this._decode(a).then(m=>{if(this._remote_interface){for(let b in this._remote_interface)delete this._remote_interface[b];Object.assign(this._remote_interface,m)}else this._remote_interface=m;this._fire("remoteReady"),this._reportRemoteSet()})}_genRemoteMethod(a,m,b){const v=this,c=function(){return new Promise(async(w,k)=>{let x=null;try{x=v._method_refs.put(b?b+"/"+m:m);const E=function(){return x!==null&&v._method_refs.fetch(x),w.apply(this,arguments)},O=function(){return x!==null&&v._method_refs.fetch(x),k.apply(this,arguments)},A=await v._wrap([E,O]);E.__promise_pair=A[1]._rvalue,O.__promise_pair=A[0]._rvalue;let T=Array.prototype.slice.call(arguments);const j=T.length,I=j>0&&typeof T[j-1]=="object"&&T[j-1]!==null&&T[j-1]._rkwargs;I&&delete T[j-1]._rkwargs,m==="register"||m==="registerService"||m==="register_service"||m==="export"||m==="on"?T=await v._wrap(T,!0):T=await v._wrap(T);const D=T.__transferables__;D&&delete T.__transferables__,v._connection.emit({type:"method",target_id:a,name:m,object_id:b,args:T,promise:A,with_kwargs:I},D)}catch(E){x&&v._method_refs.fetch(x),k(`Failed to exectue remote method (interface: ${b||v.id}, method: ${m}), error: ${E}`)}})};return c.__remote_method=!0,c}_reportRemoteSet(){this._connection.emit({type:"interfaceSetAsRemote"})}async _encode(a,m,b){const v=typeof a;if(v==="number"||v==="string"||v==="boolean"||a===null||a===void 0||a instanceof ArrayBuffer)return a;let c;if(typeof a=="function"){if(m){if(!b)throw new Error("objectId is not specified.");c={_rtype:"interface",_rtarget_id:this._connection.peer_id,_rintf:b,_rvalue:m},this._method_weakmap.set(a,c)}else if(this._method_weakmap.has(a))c=this._method_weakmap.get(a);else{const E=this._store.put(a);c={_rtype:"callback",_rtarget_id:this._connection.peer_id,_rname:a.constructor&&a.constructor.name||E,_rvalue:E}}return c}if(a.constructor instanceof Object&&a._rtype){if(a._rintf){const E=a._rtype;delete a._rtype,c=await this._encode(a,m,b),c._rtype=E}else c=a;return c}const w=[],k=a._transfer,x=Array.isArray(a);for(let E of Object.keys(this._codecs)){const O=this._codecs[E];if(O.encoder&&a instanceof O.type){let A=await Promise.resolve(O.encoder(a));if(A&&!A._rtype&&(A._rtype=O.name),A&&A._rintf){const T=A._rtype;delete A._rtype,A=await this._encode(A,m,b),A._rtype=T}return c=A,c}}if(typeof tf<"u"&&tf.Tensor&&a instanceof tf.Tensor){const E=a.dataSync();(a._transfer||k)&&(w.push(E.buffer),delete a._transfer),c={_rtype:"ndarray",_rvalue:E.buffer,_rshape:a.shape,_rdtype:a.dtype}}else if(typeof nj<"u"&&nj.NdArray&&a instanceof nj.NdArray){const E=Object(i.typedArrayToDtype)(a.selection.data);(a._transfer||k)&&(w.push(a.selection.data.buffer),delete a._transfer),c={_rtype:"ndarray",_rvalue:a.selection.data.buffer,_rshape:a.shape,_rdtype:E}}else if(a instanceof Error)console.error(a),c={_rtype:"error",_rvalue:a.toString()};else if(typeof File<"u"&&a instanceof File)c={_rtype:"file",_rvalue:a,_rpath:a._path||a.webkitRelativePath};else if(a!==Object(a)||a instanceof Boolean||a instanceof String||a instanceof Date||a instanceof RegExp||a instanceof ImageData||typeof FileList<"u"&&a instanceof FileList||typeof FileSystemDirectoryHandle<"u"&&a instanceof FileSystemDirectoryHandle||typeof FileSystemFileHandle<"u"&&a instanceof FileSystemFileHandle||typeof FileSystemHandle<"u"&&a instanceof FileSystemHandle||typeof FileSystemWritableFileStream<"u"&&a instanceof FileSystemWritableFileStream)c=a;else if(typeof File<"u"&&a instanceof File)c={_rtype:"file",_rname:a.name,_rmime:a.type,_rvalue:a,_rpath:a._path||a.webkitRelativePath};else if(a instanceof Blob)c={_rtype:"blob",_rvalue:a};else if(a instanceof o){(a._transfer||k)&&(w.push(a.buffer),delete a._transfer);const E=Object(i.typedArrayToDtype)(a);c={_rtype:"typedarray",_rvalue:a.buffer,_rdtype:E}}else if(a instanceof DataView)(a._transfer||k)&&(w.push(a.buffer),delete a._transfer),c={_rtype:"memoryview",_rvalue:a.buffer};else if(a instanceof Set)c={_rtype:"set",_rvalue:await this._encode(Array.from(a),m)};else if(a instanceof Map)c={_rtype:"orderedmap",_rvalue:await this._encode(Array.from(a),m)};else if(a.constructor instanceof Object||Array.isArray(a)){c=x?[]:{};let E;if(a.constructor===Object||Array.isArray(a))E=Object.keys(a);else{if(a.constructor===Function)throw new Error("Please instantiate the class before exportting it.");if(a.constructor.constructor===Function)E=Object.getOwnPropertyNames(Object.getPrototypeOf(a)).concat(Object.keys(a)),m=!0;else throw Error("Unsupported interface type")}let O=!1;if(a._rintf||m){b||(typeof a._rintf=="string"&&a._rintf.length>0?b=a._rintf:b=Object(i.randId)(),this._object_store[b]&&console.warn(`Overwritting interface object with the same id: ${b}`),this._object_store[b]=a);for(let A of E)A!=="constructor"&&(A.startsWith("_")||(c[A]=await this._encode(a[A],typeof m=="string"?m+"."+A:A,b),typeof a[A]=="function"&&(O=!0)));O&&(c._rintf=b),a.on&&typeof a.on=="function"&&a.on("close",()=>{delete this._object_store[b]})}else for(let A of E)["hasOwnProperty","constructor"].includes(A)||(c[A]=await this._encode(a[A]))}else if(typeof a=="object"){const E=Object.getOwnPropertyNames(Object.getPrototypeOf(a)).concat(Object.keys(a)),O=Object(i.randId)();for(let A of E)["hasOwnProperty","constructor"].includes(A)||(c[A]=await this._encode(a[A],A,c));c._rintf=O}else throw"imjoy-rpc: Unsupported data type:"+a;if(w.length>0&&(c.__transferables__=w),!c)throw new Error("Failed to encode object");return c}async _decode(a,m){if(!a)return a;let b;if(a._rtype)if(this._codecs[a._rtype]&&this._codecs[a._rtype].decoder){if(a._rintf){const v=a._rtype;delete a._rtype,a=await this._decode(a,m),a._rtype=v}b=await Promise.resolve(this._codecs[a._rtype].decoder(a))}else if(a._rtype==="callback")b=this._genRemoteCallback(a._rtarget_id,a._rvalue,m);else if(a._rtype==="interface")b=this._genRemoteMethod(a._rtarget_id,a._rvalue,a._rintf);else if(a._rtype==="ndarray")if(typeof nj<"u"&&nj.array)Array.isArray(a._rvalue)&&(a._rvalue=a._rvalue.reduce(l)),b=nj.array(new Uint8(a._rvalue),a._rdtype).reshape(a._rshape);else if(typeof tf<"u"&&tf.Tensor){Array.isArray(a._rvalue)&&(a._rvalue=a._rvalue.reduce(l));const v=i.dtypeToTypedArray[a._rdtype];b=tf.tensor(new v(a._rvalue),a._rshape,a._rdtype)}else b=a;else if(a._rtype==="error")b=new Error(a._rvalue);else if(a._rtype==="file")a._rvalue instanceof File?(b=a._rvalue,b._path=a._rpath):(b=new File([a._rvalue],a._rname,{type:a._rmime}),b._path=a._rpath);else if(a._rtype==="typedarray"){const v=i.dtypeToTypedArray[a._rdtype];if(!v)throw new Error("unsupported dtype: "+a._rdtype);b=new v(a._rvalue)}else if(a._rtype==="memoryview")b=new DataView(a._rvalue);else if(a._rtype==="blob")a._rvalue instanceof Blob?b=a._rvalue:b=new Blob([a._rvalue],{type:a._rmime});else if(a._rtype==="orderedmap")b=new Map(await this._decode(a._rvalue,m));else if(a._rtype==="set")b=new Set(await this._decode(a._rvalue,m));else if(a._rintf){const v=a._rtype;delete a._rtype,b=await this._decode(a,m),b._rtype=v}else b=a;else if(a.constructor===Object||Array.isArray(a)){const v=Array.isArray(a);b=v?[]:{};for(let c of Object.keys(a))if(v||a.hasOwnProperty(c)){const w=a[c];b[c]=await this._decode(w,m)}}else b=a;if(b===void 0)throw new Error("Failed to decode object");return a._rintf&&this._object_weakmap.set(b,a._rintf),b}async _wrap(a,m){return await this._encode(a,m)}async _unwrap(a,m){return await this._decode(a,m)}_genRemoteCallback(a,m,b){const v=this;let c;return b?(c=function(){return new Promise(async(w,k)=>{const x=await v._wrap(Array.prototype.slice.call(arguments)),E=x.length,O=E>0&&typeof x[E-1]=="object"&&x[E-1]!==null&&x[E-1]._rkwargs;O&&delete x[E-1]._rkwargs;const A=x.__transferables__;A&&delete x.__transferables__;const T=await v._wrap([w,k]);w.__promise_pair=T[1]._rvalue,k.__promise_pair=T[0]._rvalue;try{v._connection.emit({type:"callback",target_id:a,id:m,args:x,promise:T,with_kwargs:O},A)}catch{k(`Failed to exectue remote callback ( id: ${m}).`)}})},c):(c=async function(){const w=await v._wrap(Array.prototype.slice.call(arguments)),k=w.length,x=k>0&&typeof w[k-1]=="object"&&w[k-1]!==null&&w[k-1]._rkwargs;x&&delete w[k-1]._rkwargs;const E=w.__transferables__;return E&&delete w.__transferables__,v._connection.emit({type:"callback",target_id:a,id:m,args:w,with_kwargs:x},E)},c)}reset(){this._event_handlers={},this._once_handlers={},this._remote_interface=null,this._object_store={},this._method_weakmap=new WeakMap,this._object_weakmap=new WeakMap,this._local_api=null,this._store=new _,this._method_refs=new _}disconnect(){this._connection.emit({type:"disconnect"}),this.reset(),setTimeout(()=>{this._connection.disconnect()},2e3)}}class _{constructor(){this._store={},this._indices=[0],this._readyHandler=function(){},this._busyHandler=function(){},this._readyHandler()}onReady(a){this._readyHandler=a||function(){}}onBusy(a){this._busyHandler=a||function(){}}getStack(){return Object.keys(this._store).length}_genId(){let a;return this._indices.length===1?a=this._indices[0]++:a=this._indices.shift(),a}_releaseId(a){for(let m=0;m<this._indices.length;m++)if(a<this._indices[m]){this._indices.splice(m,0,a);break}for(let m=this._indices.length-1;m>=0&&this._indices[m]-1===this._indices[m-1];m--)this._indices.pop()}put(a){this._busyHandler&&Object.keys(this._store).length===0&&this._busyHandler();const m=this._genId();return this._store[m]=a,m}fetch(a){const m=this._store[a];return m&&!m.__remote_method&&(delete this._store[a],this._releaseId(a),this._readyHandler&&Object.keys(this._store).length===0&&this._readyHandler()),m&&m.__promise_pair&&this.fetch(m.__promise_pair),m}}},"./src/utils.js":function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"randId",function(){return randId}),__webpack_require__.d(__webpack_exports__,"dtypeToTypedArray",function(){return dtypeToTypedArray}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWindow",function(){return loadRequirementsInWindow}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWebworker",function(){return loadRequirementsInWebworker}),__webpack_require__.d(__webpack_exports__,"loadRequirements",function(){return loadRequirements}),__webpack_require__.d(__webpack_exports__,"normalizeConfig",function(){return normalizeConfig}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtypeMapping",function(){return typedArrayToDtypeMapping}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtype",function(){return typedArrayToDtype}),__webpack_require__.d(__webpack_exports__,"cacheRequirements",function(){return cacheRequirements}),__webpack_require__.d(__webpack_exports__,"setupServiceWorker",function(){return setupServiceWorker}),__webpack_require__.d(__webpack_exports__,"urlJoin",function(){return urlJoin}),__webpack_require__.d(__webpack_exports__,"MessageEmitter",function(){return MessageEmitter});function randId(){return Math.random().toString(36).substr(2,10)+new Date().getTime()}const dtypeToTypedArray={int8:Int8Array,int16:Int16Array,int32:Int32Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,float32:Float32Array,float64:Float64Array,array:Array};async function loadRequirementsInWindow(n){function t(o){return new Promise((l,f)=>{var u=document.createElement("script");u.src=o,u.type="text/javascript",u.onload=l,u.onreadystatechange=function(){(this.readyState==="loaded"||this.readyState==="complete")&&l()},u.onerror=f,document.head.appendChild(u)})}async function r(){for(var o=Array.prototype.slice.call(arguments),l=o.length,f=0;f<l;f++)await t(o[f])}if(n&&(Array.isArray(n)||typeof n=="string"))try{var i;if(n=typeof n=="string"?[n]:n,Array.isArray(n))for(var s=0;s<n.length;s++)n[s].toLowerCase().endsWith(".css")||n[s].startsWith("css:")?(n[s].startsWith("css:")&&(n[s]=n[s].slice(4)),i=document.createElement("link"),i.rel="stylesheet",i.href=n[s],document.head.appendChild(i)):n[s].toLowerCase().endsWith(".mjs")||n[s].startsWith("mjs:")?(n[s].startsWith("mjs:")&&(n[s]=n[s].slice(4)),await __vitePreload(()=>import(n[s]),__vite__mapDeps([]))):n[s].toLowerCase().endsWith(".js")||n[s].startsWith("js:")?(n[s].startsWith("js:")&&(n[s]=n[s].slice(3)),await r(n[s])):n[s].startsWith("http")?await r(n[s]):n[s].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[s]);else throw"unsupported requirements definition"}catch{throw"failed to import required scripts: "+n.toString()}}async function loadRequirementsInWebworker(n){if(n&&(Array.isArray(n)||typeof n=="string"))try{Array.isArray(n)||(n=[n]);for(var t=0;t<n.length;t++){if(n[t].toLowerCase().endsWith(".css")||n[t].startsWith("css:"))throw"unable to import css in a webworker";n[t].toLowerCase().endsWith(".js")||n[t].startsWith("js:")?(n[t].startsWith("js:")&&(n[t]=n[t].slice(3)),importScripts(n[t])):n[t].startsWith("http")?importScripts(n[t]):n[t].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[t])}}catch{throw"failed to import required scripts: "+n.toString()}}function loadRequirements(n){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?loadRequirementsInWebworker(n):loadRequirementsInWindow(n)}function normalizeConfig(n){return n.version=n.version||"0.1.0",n.description=n.description||`[TODO: add description for ${n.name} ]`,n.type=n.type||"rpc-window",n.id=n.id||randId(),n.target_origin=n.target_origin||"*",n.allow_execution=n.allow_execution||!1,n=Object.keys(n).reduce((t,r)=>(typeof n[r]!="function"&&(t[r]=n[r]),t),{}),n}const typedArrayToDtypeMapping={Int8Array:"int8",Int16Array:"int16",Int32Array:"int32",Uint8Array:"uint8",Uint16Array:"uint16",Uint32Array:"uint32",Float32Array:"float32",Float64Array:"float64",Array:"array"},typedArrayToDtypeKeys=[];for(const arrType of Object.keys(typedArrayToDtypeMapping))typedArrayToDtypeKeys.push(eval(arrType));function typedArrayToDtype(n){let t=typedArrayToDtypeMapping[n.constructor.name];if(!t){const r=Object.getPrototypeOf(n);for(const i of typedArrayToDtypeKeys)if(r instanceof i){t=typedArrayToDtypeMapping[i.name];break}}return t}function cacheUrlInServiceWorker(n){return new Promise(function(t,r){const i={command:"add",url:n};if(!navigator.serviceWorker||!navigator.serviceWorker.register){r("Service worker is not supported.");return}const s=new MessageChannel;s.port1.onmessage=function(o){o.data&&o.data.error?r(o.data.error):t(o.data&&o.data.result)},navigator.serviceWorker&&navigator.serviceWorker.controller?navigator.serviceWorker.controller.postMessage(i,[s.port2]):r("Service worker controller is not available")})}async function cacheRequirements(n){n=n||[],Array.isArray(n)||(n=[n]);for(let t of n)t.startsWith("js:")&&(t=t.slice(3)),t.startsWith("css:")&&(t=t.slice(4)),t.startsWith("cache:")&&(t=t.slice(6)),t.startsWith("http")&&await cacheUrlInServiceWorker(t).catch(r=>{console.error(r)})}function setupServiceWorker(n,t,r){if("serviceWorker"in navigator){if(n=n||"/",navigator.serviceWorker.register(n+"plugin-service-worker.js").then(function(i){console.log("ServiceWorker registration successful with scope: ",i.scope)},function(i){console.log("ServiceWorker registration failed: ",i)}),t=t||"*",r=r||cacheRequirements,r&&typeof r!="function")throw new Error("config.cache_requirements must be a function");window.addEventListener("message",function(i){if(t==="*"||i.origin===t){const s=i.data;s.type==="cacheRequirements"&&r(s.requirements)}})}}function urlJoin(...n){return n.join("/").replace(/[\/]+/g,"/").replace(/^(.+):\//,"$1://").replace(/^file:/,"file:/").replace(/\/(\?|&|#[^!])/g,"$1").replace(/\?/g,"&").replace("&","?")}class MessageEmitter{constructor(t){this._event_handlers={},this._once_handlers={},this._debug=t}emit(){throw new Error("emit is not implemented")}on(t,r){this._event_handlers[t]||(this._event_handlers[t]=[]),this._event_handlers[t].push(r)}once(t,r){r.___event_run_once=!0,this.on(t,r)}off(t,r){if(!t&&!r)this._event_handlers={};else if(t&&!r)this._event_handlers[t]&&(this._event_handlers[t]=[]);else if(this._event_handlers[t]){const i=this._event_handlers[t].indexOf(r);i>=0&&this._event_handlers[t].splice(i,1)}}_fire(t,r){if(this._event_handlers[t])for(var i=this._event_handlers[t].length;i--;){const s=this._event_handlers[t][i];try{s(r)}catch(o){console.error(o)}finally{s.___event_run_once&&this._event_handlers[t].splice(i,1)}}else this._debug&&console.warn("unhandled event",t,r)}}}})})})(imjoyRpc$1);var imjoyRpcExports=imjoyRpc$1.exports,imjoyRpcSocketio={exports:{}};(function(module,exports){(function(t,r){module.exports=r()})(window,function(){return function(n){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i,l:!1,exports:{}};return n[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=n,r.c=t,r.d=function(i,s,o){r.o(i,s)||Object.defineProperty(i,s,{enumerable:!0,get:o})},r.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},r.t=function(i,s){if(s&1&&(i=r(i)),s&8||s&4&&typeof i=="object"&&i&&i.__esModule)return i;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:i}),s&2&&typeof i!="string")for(var l in i)r.d(o,l,(function(f){return i[f]}).bind(null,l));return o},r.n=function(i){var s=i&&i.__esModule?function(){return i.default}:function(){return i};return r.d(s,"a",s),s},r.o=function(i,s){return Object.prototype.hasOwnProperty.call(i,s)},r.p="",r(r.s="./src/socketIOMain.js")}({"./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js":function(n,t,r){r.r(t),r.d(t,"decode",function(){return f}),r.d(t,"encode",function(){return l});for(var i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=typeof Uint8Array>"u"?[]:new Uint8Array(256),o=0;o<i.length;o++)s[i.charCodeAt(o)]=o;var l=function(u){var _=new Uint8Array(u),g,a=_.length,m="";for(g=0;g<a;g+=3)m+=i[_[g]>>2],m+=i[(_[g]&3)<<4|_[g+1]>>4],m+=i[(_[g+1]&15)<<2|_[g+2]>>6],m+=i[_[g+2]&63];return a%3===2?m=m.substring(0,m.length-1)+"=":a%3===1&&(m=m.substring(0,m.length-2)+"=="),m},f=function(u){var _=u.length*.75,g=u.length,a,m=0,b,v,c,w;u[u.length-1]==="="&&(_--,u[u.length-2]==="="&&_--);var k=new ArrayBuffer(_),x=new Uint8Array(k);for(a=0;a<g;a+=4)b=s[u.charCodeAt(a)],v=s[u.charCodeAt(a+1)],c=s[u.charCodeAt(a+2)],w=s[u.charCodeAt(a+3)],x[m++]=b<<2|v>>4,x[m++]=(v&15)<<4|c>>2,x[m++]=(c&3)<<6|w&63;return k}},"./node_modules/@socket.io/component-emitter/index.mjs":function(n,t,r){r.r(t),r.d(t,"Emitter",function(){return i});function i(o){if(o)return s(o)}function s(o){for(var l in i.prototype)o[l]=i.prototype[l];return o}i.prototype.on=i.prototype.addEventListener=function(o,l){return this._callbacks=this._callbacks||{},(this._callbacks["$"+o]=this._callbacks["$"+o]||[]).push(l),this},i.prototype.once=function(o,l){function f(){this.off(o,f),l.apply(this,arguments)}return f.fn=l,this.on(o,f),this},i.prototype.off=i.prototype.removeListener=i.prototype.removeAllListeners=i.prototype.removeEventListener=function(o,l){if(this._callbacks=this._callbacks||{},arguments.length==0)return this._callbacks={},this;var f=this._callbacks["$"+o];if(!f)return this;if(arguments.length==1)return delete this._callbacks["$"+o],this;for(var u,_=0;_<f.length;_++)if(u=f[_],u===l||u.fn===l){f.splice(_,1);break}return f.length===0&&delete this._callbacks["$"+o],this},i.prototype.emit=function(o){this._callbacks=this._callbacks||{};for(var l=new Array(arguments.length-1),f=this._callbacks["$"+o],u=1;u<arguments.length;u++)l[u-1]=arguments[u];if(f){f=f.slice(0);for(var u=0,_=f.length;u<_;++u)f[u].apply(this,l)}return this},i.prototype.emitReserved=i.prototype.emit,i.prototype.listeners=function(o){return this._callbacks=this._callbacks||{},this._callbacks["$"+o]||[]},i.prototype.hasListeners=function(o){return!!this.listeners(o).length}},"./node_modules/base64-js/index.js":function(n,t,r){t.byteLength=g,t.toByteArray=m,t.fromByteArray=c;for(var i=[],s=[],o=typeof Uint8Array<"u"?Uint8Array:Array,l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",f=0,u=l.length;f<u;++f)i[f]=l[f],s[l.charCodeAt(f)]=f;s[45]=62,s[95]=63;function _(w){var k=w.length;if(k%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var x=w.indexOf("=");x===-1&&(x=k);var E=x===k?0:4-x%4;return[x,E]}function g(w){var k=_(w),x=k[0],E=k[1];return(x+E)*3/4-E}function a(w,k,x){return(k+x)*3/4-x}function m(w){var k,x=_(w),E=x[0],O=x[1],A=new o(a(w,E,O)),T=0,j=O>0?E-4:E,I;for(I=0;I<j;I+=4)k=s[w.charCodeAt(I)]<<18|s[w.charCodeAt(I+1)]<<12|s[w.charCodeAt(I+2)]<<6|s[w.charCodeAt(I+3)],A[T++]=k>>16&255,A[T++]=k>>8&255,A[T++]=k&255;return O===2&&(k=s[w.charCodeAt(I)]<<2|s[w.charCodeAt(I+1)]>>4,A[T++]=k&255),O===1&&(k=s[w.charCodeAt(I)]<<10|s[w.charCodeAt(I+1)]<<4|s[w.charCodeAt(I+2)]>>2,A[T++]=k>>8&255,A[T++]=k&255),A}function b(w){return i[w>>18&63]+i[w>>12&63]+i[w>>6&63]+i[w&63]}function v(w,k,x){for(var E,O=[],A=k;A<x;A+=3)E=(w[A]<<16&16711680)+(w[A+1]<<8&65280)+(w[A+2]&255),O.push(b(E));return O.join("")}function c(w){for(var k,x=w.length,E=x%3,O=[],A=16383,T=0,j=x-E;T<j;T+=A)O.push(v(w,T,T+A>j?j:T+A));return E===1?(k=w[x-1],O.push(i[k>>2]+i[k<<4&63]+"==")):E===2&&(k=(w[x-2]<<8)+w[x-1],O.push(i[k>>10]+i[k>>4&63]+i[k<<2&63]+"=")),O.join("")}},"./node_modules/buffer/index.js":function(n,t,r){(function(i){/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <http://feross.org>
* @license  MIT
*/var s=r("./node_modules/base64-js/index.js"),o=r("./node_modules/ieee754/index.js"),l=r("./node_modules/isarray/index.js");t.Buffer=g,t.SlowBuffer=O,t.INSPECT_MAX_BYTES=50,g.TYPED_ARRAY_SUPPORT=i.TYPED_ARRAY_SUPPORT!==void 0?i.TYPED_ARRAY_SUPPORT:f(),t.kMaxLength=u();function f(){try{var L=new Uint8Array(1);return L.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},L.foo()===42&&typeof L.subarray=="function"&&L.subarray(1,1).byteLength===0}catch{return!1}}function u(){return g.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function _(L,P){if(u()<P)throw new RangeError("Invalid typed array length");return g.TYPED_ARRAY_SUPPORT?(L=new Uint8Array(P),L.__proto__=g.prototype):(L===null&&(L=new g(P)),L.length=P),L}function g(L,P,R){if(!g.TYPED_ARRAY_SUPPORT&&!(this instanceof g))return new g(L,P,R);if(typeof L=="number"){if(typeof P=="string")throw new Error("If encoding is specified then the first argument must be a string");return v(this,L)}return a(this,L,P,R)}g.poolSize=8192,g._augment=function(L){return L.__proto__=g.prototype,L};function a(L,P,R,V){if(typeof P=="number")throw new TypeError('"value" argument must not be a number');return typeof ArrayBuffer<"u"&&P instanceof ArrayBuffer?k(L,P,R,V):typeof P=="string"?c(L,P,R):x(L,P)}g.from=function(L,P,R){return a(null,L,P,R)},g.TYPED_ARRAY_SUPPORT&&(g.prototype.__proto__=Uint8Array.prototype,g.__proto__=Uint8Array,typeof Symbol<"u"&&Symbol.species&&g[Symbol.species]===g&&Object.defineProperty(g,Symbol.species,{value:null,configurable:!0}));function m(L){if(typeof L!="number")throw new TypeError('"size" argument must be a number');if(L<0)throw new RangeError('"size" argument must not be negative')}function b(L,P,R,V){return m(P),P<=0?_(L,P):R!==void 0?typeof V=="string"?_(L,P).fill(R,V):_(L,P).fill(R):_(L,P)}g.alloc=function(L,P,R){return b(null,L,P,R)};function v(L,P){if(m(P),L=_(L,P<0?0:E(P)|0),!g.TYPED_ARRAY_SUPPORT)for(var R=0;R<P;++R)L[R]=0;return L}g.allocUnsafe=function(L){return v(null,L)},g.allocUnsafeSlow=function(L){return v(null,L)};function c(L,P,R){if((typeof R!="string"||R==="")&&(R="utf8"),!g.isEncoding(R))throw new TypeError('"encoding" must be a valid string encoding');var V=A(P,R)|0;L=_(L,V);var Q=L.write(P,R);return Q!==V&&(L=L.slice(0,Q)),L}function w(L,P){var R=P.length<0?0:E(P.length)|0;L=_(L,R);for(var V=0;V<R;V+=1)L[V]=P[V]&255;return L}function k(L,P,R,V){if(P.byteLength,R<0||P.byteLength<R)throw new RangeError("'offset' is out of bounds");if(P.byteLength<R+(V||0))throw new RangeError("'length' is out of bounds");return R===void 0&&V===void 0?P=new Uint8Array(P):V===void 0?P=new Uint8Array(P,R):P=new Uint8Array(P,R,V),g.TYPED_ARRAY_SUPPORT?(L=P,L.__proto__=g.prototype):L=w(L,P),L}function x(L,P){if(g.isBuffer(P)){var R=E(P.length)|0;return L=_(L,R),L.length===0||P.copy(L,0,0,R),L}if(P){if(typeof ArrayBuffer<"u"&&P.buffer instanceof ArrayBuffer||"length"in P)return typeof P.length!="number"||ge(P.length)?_(L,0):w(L,P);if(P.type==="Buffer"&&l(P.data))return w(L,P.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function E(L){if(L>=u())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+u().toString(16)+" bytes");return L|0}function O(L){return+L!=L&&(L=0),g.alloc(+L)}g.isBuffer=function(P){return!!(P!=null&&P._isBuffer)},g.compare=function(P,R){if(!g.isBuffer(P)||!g.isBuffer(R))throw new TypeError("Arguments must be Buffers");if(P===R)return 0;for(var V=P.length,Q=R.length,oe=0,ae=Math.min(V,Q);oe<ae;++oe)if(P[oe]!==R[oe]){V=P[oe],Q=R[oe];break}return V<Q?-1:Q<V?1:0},g.isEncoding=function(P){switch(String(P).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},g.concat=function(P,R){if(!l(P))throw new TypeError('"list" argument must be an Array of Buffers');if(P.length===0)return g.alloc(0);var V;if(R===void 0)for(R=0,V=0;V<P.length;++V)R+=P[V].length;var Q=g.allocUnsafe(R),oe=0;for(V=0;V<P.length;++V){var ae=P[V];if(!g.isBuffer(ae))throw new TypeError('"list" argument must be an Array of Buffers');ae.copy(Q,oe),oe+=ae.length}return Q};function A(L,P){if(g.isBuffer(L))return L.length;if(typeof ArrayBuffer<"u"&&typeof ArrayBuffer.isView=="function"&&(ArrayBuffer.isView(L)||L instanceof ArrayBuffer))return L.byteLength;typeof L!="string"&&(L=""+L);var R=L.length;if(R===0)return 0;for(var V=!1;;)switch(P){case"ascii":case"latin1":case"binary":return R;case"utf8":case"utf-8":case void 0:return le(L).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return R*2;case"hex":return R>>>1;case"base64":return be(L).length;default:if(V)return le(L).length;P=(""+P).toLowerCase(),V=!0}}g.byteLength=A;function T(L,P,R){var V=!1;if((P===void 0||P<0)&&(P=0),P>this.length||((R===void 0||R>this.length)&&(R=this.length),R<=0)||(R>>>=0,P>>>=0,R<=P))return"";for(L||(L="utf8");;)switch(L){case"hex":return de(this,P,R);case"utf8":case"utf-8":return Y(this,P,R);case"ascii":return te(this,P,R);case"latin1":case"binary":return ie(this,P,R);case"base64":return q(this,P,R);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ke(this,P,R);default:if(V)throw new TypeError("Unknown encoding: "+L);L=(L+"").toLowerCase(),V=!0}}g.prototype._isBuffer=!0;function j(L,P,R){var V=L[P];L[P]=L[R],L[R]=V}g.prototype.swap16=function(){var P=this.length;if(P%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var R=0;R<P;R+=2)j(this,R,R+1);return this},g.prototype.swap32=function(){var P=this.length;if(P%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var R=0;R<P;R+=4)j(this,R,R+3),j(this,R+1,R+2);return this},g.prototype.swap64=function(){var P=this.length;if(P%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var R=0;R<P;R+=8)j(this,R,R+7),j(this,R+1,R+6),j(this,R+2,R+5),j(this,R+3,R+4);return this},g.prototype.toString=function(){var P=this.length|0;return P===0?"":arguments.length===0?Y(this,0,P):T.apply(this,arguments)},g.prototype.equals=function(P){if(!g.isBuffer(P))throw new TypeError("Argument must be a Buffer");return this===P?!0:g.compare(this,P)===0},g.prototype.inspect=function(){var P="",R=t.INSPECT_MAX_BYTES;return this.length>0&&(P=this.toString("hex",0,R).match(/.{2}/g).join(" "),this.length>R&&(P+=" ... ")),"<Buffer "+P+">"},g.prototype.compare=function(P,R,V,Q,oe){if(!g.isBuffer(P))throw new TypeError("Argument must be a Buffer");if(R===void 0&&(R=0),V===void 0&&(V=P?P.length:0),Q===void 0&&(Q=0),oe===void 0&&(oe=this.length),R<0||V>P.length||Q<0||oe>this.length)throw new RangeError("out of range index");if(Q>=oe&&R>=V)return 0;if(Q>=oe)return-1;if(R>=V)return 1;if(R>>>=0,V>>>=0,Q>>>=0,oe>>>=0,this===P)return 0;for(var ae=oe-Q,xe=V-R,De=Math.min(ae,xe),Be=this.slice(Q,oe),He=P.slice(R,V),ze=0;ze<De;++ze)if(Be[ze]!==He[ze]){ae=Be[ze],xe=He[ze];break}return ae<xe?-1:xe<ae?1:0};function I(L,P,R,V,Q){if(L.length===0)return-1;if(typeof R=="string"?(V=R,R=0):R>2147483647?R=2147483647:R<-2147483648&&(R=-2147483648),R=+R,isNaN(R)&&(R=Q?0:L.length-1),R<0&&(R=L.length+R),R>=L.length){if(Q)return-1;R=L.length-1}else if(R<0)if(Q)R=0;else return-1;if(typeof P=="string"&&(P=g.from(P,V)),g.isBuffer(P))return P.length===0?-1:D(L,P,R,V,Q);if(typeof P=="number")return P=P&255,g.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf=="function"?Q?Uint8Array.prototype.indexOf.call(L,P,R):Uint8Array.prototype.lastIndexOf.call(L,P,R):D(L,[P],R,V,Q);throw new TypeError("val must be string, number or Buffer")}function D(L,P,R,V,Q){var oe=1,ae=L.length,xe=P.length;if(V!==void 0&&(V=String(V).toLowerCase(),V==="ucs2"||V==="ucs-2"||V==="utf16le"||V==="utf-16le")){if(L.length<2||P.length<2)return-1;oe=2,ae/=2,xe/=2,R/=2}function De($t,nt){return oe===1?$t[nt]:$t.readUInt16BE(nt*oe)}var Be;if(Q){var He=-1;for(Be=R;Be<ae;Be++)if(De(L,Be)===De(P,He===-1?0:Be-He)){if(He===-1&&(He=Be),Be-He+1===xe)return He*oe}else He!==-1&&(Be-=Be-He),He=-1}else for(R+xe>ae&&(R=ae-xe),Be=R;Be>=0;Be--){for(var ze=!0,ot=0;ot<xe;ot++)if(De(L,Be+ot)!==De(P,ot)){ze=!1;break}if(ze)return Be}return-1}g.prototype.includes=function(P,R,V){return this.indexOf(P,R,V)!==-1},g.prototype.indexOf=function(P,R,V){return I(this,P,R,V,!0)},g.prototype.lastIndexOf=function(P,R,V){return I(this,P,R,V,!1)};function $(L,P,R,V){R=Number(R)||0;var Q=L.length-R;V?(V=Number(V),V>Q&&(V=Q)):V=Q;var oe=P.length;if(oe%2!==0)throw new TypeError("Invalid hex string");V>oe/2&&(V=oe/2);for(var ae=0;ae<V;++ae){var xe=parseInt(P.substr(ae*2,2),16);if(isNaN(xe))return ae;L[R+ae]=xe}return ae}function N(L,P,R,V){return ve(le(P,L.length-R),L,R,V)}function M(L,P,R,V){return ve(ue(P),L,R,V)}function W(L,P,R,V){return M(L,P,R,V)}function F(L,P,R,V){return ve(be(P),L,R,V)}function H(L,P,R,V){return ve(pe(P,L.length-R),L,R,V)}g.prototype.write=function(P,R,V,Q){if(R===void 0)Q="utf8",V=this.length,R=0;else if(V===void 0&&typeof R=="string")Q=R,V=this.length,R=0;else if(isFinite(R))R=R|0,isFinite(V)?(V=V|0,Q===void 0&&(Q="utf8")):(Q=V,V=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");var oe=this.length-R;if((V===void 0||V>oe)&&(V=oe),P.length>0&&(V<0||R<0)||R>this.length)throw new RangeError("Attempt to write outside buffer bounds");Q||(Q="utf8");for(var ae=!1;;)switch(Q){case"hex":return $(this,P,R,V);case"utf8":case"utf-8":return N(this,P,R,V);case"ascii":return M(this,P,R,V);case"latin1":case"binary":return W(this,P,R,V);case"base64":return F(this,P,R,V);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return H(this,P,R,V);default:if(ae)throw new TypeError("Unknown encoding: "+Q);Q=(""+Q).toLowerCase(),ae=!0}},g.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function q(L,P,R){return P===0&&R===L.length?s.fromByteArray(L):s.fromByteArray(L.slice(P,R))}function Y(L,P,R){R=Math.min(L.length,R);for(var V=[],Q=P;Q<R;){var oe=L[Q],ae=null,xe=oe>239?4:oe>223?3:oe>191?2:1;if(Q+xe<=R){var De,Be,He,ze;switch(xe){case 1:oe<128&&(ae=oe);break;case 2:De=L[Q+1],(De&192)===128&&(ze=(oe&31)<<6|De&63,ze>127&&(ae=ze));break;case 3:De=L[Q+1],Be=L[Q+2],(De&192)===128&&(Be&192)===128&&(ze=(oe&15)<<12|(De&63)<<6|Be&63,ze>2047&&(ze<55296||ze>57343)&&(ae=ze));break;case 4:De=L[Q+1],Be=L[Q+2],He=L[Q+3],(De&192)===128&&(Be&192)===128&&(He&192)===128&&(ze=(oe&15)<<18|(De&63)<<12|(Be&63)<<6|He&63,ze>65535&&ze<1114112&&(ae=ze))}}ae===null?(ae=65533,xe=1):ae>65535&&(ae-=65536,V.push(ae>>>10&1023|55296),ae=56320|ae&1023),V.push(ae),Q+=xe}return J(V)}var X=4096;function J(L){var P=L.length;if(P<=X)return String.fromCharCode.apply(String,L);for(var R="",V=0;V<P;)R+=String.fromCharCode.apply(String,L.slice(V,V+=X));return R}function te(L,P,R){var V="";R=Math.min(L.length,R);for(var Q=P;Q<R;++Q)V+=String.fromCharCode(L[Q]&127);return V}function ie(L,P,R){var V="";R=Math.min(L.length,R);for(var Q=P;Q<R;++Q)V+=String.fromCharCode(L[Q]);return V}function de(L,P,R){var V=L.length;(!P||P<0)&&(P=0),(!R||R<0||R>V)&&(R=V);for(var Q="",oe=P;oe<R;++oe)Q+=se(L[oe]);return Q}function ke(L,P,R){for(var V=L.slice(P,R),Q="",oe=0;oe<V.length;oe+=2)Q+=String.fromCharCode(V[oe]+V[oe+1]*256);return Q}g.prototype.slice=function(P,R){var V=this.length;P=~~P,R=R===void 0?V:~~R,P<0?(P+=V,P<0&&(P=0)):P>V&&(P=V),R<0?(R+=V,R<0&&(R=0)):R>V&&(R=V),R<P&&(R=P);var Q;if(g.TYPED_ARRAY_SUPPORT)Q=this.subarray(P,R),Q.__proto__=g.prototype;else{var oe=R-P;Q=new g(oe,void 0);for(var ae=0;ae<oe;++ae)Q[ae]=this[ae+P]}return Q};function we(L,P,R){if(L%1!==0||L<0)throw new RangeError("offset is not uint");if(L+P>R)throw new RangeError("Trying to access beyond buffer length")}g.prototype.readUIntLE=function(P,R,V){P=P|0,R=R|0,V||we(P,R,this.length);for(var Q=this[P],oe=1,ae=0;++ae<R&&(oe*=256);)Q+=this[P+ae]*oe;return Q},g.prototype.readUIntBE=function(P,R,V){P=P|0,R=R|0,V||we(P,R,this.length);for(var Q=this[P+--R],oe=1;R>0&&(oe*=256);)Q+=this[P+--R]*oe;return Q},g.prototype.readUInt8=function(P,R){return R||we(P,1,this.length),this[P]},g.prototype.readUInt16LE=function(P,R){return R||we(P,2,this.length),this[P]|this[P+1]<<8},g.prototype.readUInt16BE=function(P,R){return R||we(P,2,this.length),this[P]<<8|this[P+1]},g.prototype.readUInt32LE=function(P,R){return R||we(P,4,this.length),(this[P]|this[P+1]<<8|this[P+2]<<16)+this[P+3]*16777216},g.prototype.readUInt32BE=function(P,R){return R||we(P,4,this.length),this[P]*16777216+(this[P+1]<<16|this[P+2]<<8|this[P+3])},g.prototype.readIntLE=function(P,R,V){P=P|0,R=R|0,V||we(P,R,this.length);for(var Q=this[P],oe=1,ae=0;++ae<R&&(oe*=256);)Q+=this[P+ae]*oe;return oe*=128,Q>=oe&&(Q-=Math.pow(2,8*R)),Q},g.prototype.readIntBE=function(P,R,V){P=P|0,R=R|0,V||we(P,R,this.length);for(var Q=R,oe=1,ae=this[P+--Q];Q>0&&(oe*=256);)ae+=this[P+--Q]*oe;return oe*=128,ae>=oe&&(ae-=Math.pow(2,8*R)),ae},g.prototype.readInt8=function(P,R){return R||we(P,1,this.length),this[P]&128?(255-this[P]+1)*-1:this[P]},g.prototype.readInt16LE=function(P,R){R||we(P,2,this.length);var V=this[P]|this[P+1]<<8;return V&32768?V|4294901760:V},g.prototype.readInt16BE=function(P,R){R||we(P,2,this.length);var V=this[P+1]|this[P]<<8;return V&32768?V|4294901760:V},g.prototype.readInt32LE=function(P,R){return R||we(P,4,this.length),this[P]|this[P+1]<<8|this[P+2]<<16|this[P+3]<<24},g.prototype.readInt32BE=function(P,R){return R||we(P,4,this.length),this[P]<<24|this[P+1]<<16|this[P+2]<<8|this[P+3]},g.prototype.readFloatLE=function(P,R){return R||we(P,4,this.length),o.read(this,P,!0,23,4)},g.prototype.readFloatBE=function(P,R){return R||we(P,4,this.length),o.read(this,P,!1,23,4)},g.prototype.readDoubleLE=function(P,R){return R||we(P,8,this.length),o.read(this,P,!0,52,8)},g.prototype.readDoubleBE=function(P,R){return R||we(P,8,this.length),o.read(this,P,!1,52,8)};function _e(L,P,R,V,Q,oe){if(!g.isBuffer(L))throw new TypeError('"buffer" argument must be a Buffer instance');if(P>Q||P<oe)throw new RangeError('"value" argument is out of bounds');if(R+V>L.length)throw new RangeError("Index out of range")}g.prototype.writeUIntLE=function(P,R,V,Q){if(P=+P,R=R|0,V=V|0,!Q){var oe=Math.pow(2,8*V)-1;_e(this,P,R,V,oe,0)}var ae=1,xe=0;for(this[R]=P&255;++xe<V&&(ae*=256);)this[R+xe]=P/ae&255;return R+V},g.prototype.writeUIntBE=function(P,R,V,Q){if(P=+P,R=R|0,V=V|0,!Q){var oe=Math.pow(2,8*V)-1;_e(this,P,R,V,oe,0)}var ae=V-1,xe=1;for(this[R+ae]=P&255;--ae>=0&&(xe*=256);)this[R+ae]=P/xe&255;return R+V},g.prototype.writeUInt8=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,1,255,0),g.TYPED_ARRAY_SUPPORT||(P=Math.floor(P)),this[R]=P&255,R+1};function Ee(L,P,R,V){P<0&&(P=65535+P+1);for(var Q=0,oe=Math.min(L.length-R,2);Q<oe;++Q)L[R+Q]=(P&255<<8*(V?Q:1-Q))>>>(V?Q:1-Q)*8}g.prototype.writeUInt16LE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,2,65535,0),g.TYPED_ARRAY_SUPPORT?(this[R]=P&255,this[R+1]=P>>>8):Ee(this,P,R,!0),R+2},g.prototype.writeUInt16BE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,2,65535,0),g.TYPED_ARRAY_SUPPORT?(this[R]=P>>>8,this[R+1]=P&255):Ee(this,P,R,!1),R+2};function Ae(L,P,R,V){P<0&&(P=4294967295+P+1);for(var Q=0,oe=Math.min(L.length-R,4);Q<oe;++Q)L[R+Q]=P>>>(V?Q:3-Q)*8&255}g.prototype.writeUInt32LE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,4,4294967295,0),g.TYPED_ARRAY_SUPPORT?(this[R+3]=P>>>24,this[R+2]=P>>>16,this[R+1]=P>>>8,this[R]=P&255):Ae(this,P,R,!0),R+4},g.prototype.writeUInt32BE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,4,4294967295,0),g.TYPED_ARRAY_SUPPORT?(this[R]=P>>>24,this[R+1]=P>>>16,this[R+2]=P>>>8,this[R+3]=P&255):Ae(this,P,R,!1),R+4},g.prototype.writeIntLE=function(P,R,V,Q){if(P=+P,R=R|0,!Q){var oe=Math.pow(2,8*V-1);_e(this,P,R,V,oe-1,-oe)}var ae=0,xe=1,De=0;for(this[R]=P&255;++ae<V&&(xe*=256);)P<0&&De===0&&this[R+ae-1]!==0&&(De=1),this[R+ae]=(P/xe>>0)-De&255;return R+V},g.prototype.writeIntBE=function(P,R,V,Q){if(P=+P,R=R|0,!Q){var oe=Math.pow(2,8*V-1);_e(this,P,R,V,oe-1,-oe)}var ae=V-1,xe=1,De=0;for(this[R+ae]=P&255;--ae>=0&&(xe*=256);)P<0&&De===0&&this[R+ae+1]!==0&&(De=1),this[R+ae]=(P/xe>>0)-De&255;return R+V},g.prototype.writeInt8=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,1,127,-128),g.TYPED_ARRAY_SUPPORT||(P=Math.floor(P)),P<0&&(P=255+P+1),this[R]=P&255,R+1},g.prototype.writeInt16LE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,2,32767,-32768),g.TYPED_ARRAY_SUPPORT?(this[R]=P&255,this[R+1]=P>>>8):Ee(this,P,R,!0),R+2},g.prototype.writeInt16BE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,2,32767,-32768),g.TYPED_ARRAY_SUPPORT?(this[R]=P>>>8,this[R+1]=P&255):Ee(this,P,R,!1),R+2},g.prototype.writeInt32LE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,4,2147483647,-2147483648),g.TYPED_ARRAY_SUPPORT?(this[R]=P&255,this[R+1]=P>>>8,this[R+2]=P>>>16,this[R+3]=P>>>24):Ae(this,P,R,!0),R+4},g.prototype.writeInt32BE=function(P,R,V){return P=+P,R=R|0,V||_e(this,P,R,4,2147483647,-2147483648),P<0&&(P=4294967295+P+1),g.TYPED_ARRAY_SUPPORT?(this[R]=P>>>24,this[R+1]=P>>>16,this[R+2]=P>>>8,this[R+3]=P&255):Ae(this,P,R,!1),R+4};function je(L,P,R,V,Q,oe){if(R+V>L.length)throw new RangeError("Index out of range");if(R<0)throw new RangeError("Index out of range")}function Oe(L,P,R,V,Q){return Q||je(L,P,R,4),o.write(L,P,R,V,23,4),R+4}g.prototype.writeFloatLE=function(P,R,V){return Oe(this,P,R,!0,V)},g.prototype.writeFloatBE=function(P,R,V){return Oe(this,P,R,!1,V)};function Pe(L,P,R,V,Q){return Q||je(L,P,R,8),o.write(L,P,R,V,52,8),R+8}g.prototype.writeDoubleLE=function(P,R,V){return Pe(this,P,R,!0,V)},g.prototype.writeDoubleBE=function(P,R,V){return Pe(this,P,R,!1,V)},g.prototype.copy=function(P,R,V,Q){if(V||(V=0),!Q&&Q!==0&&(Q=this.length),R>=P.length&&(R=P.length),R||(R=0),Q>0&&Q<V&&(Q=V),Q===V||P.length===0||this.length===0)return 0;if(R<0)throw new RangeError("targetStart out of bounds");if(V<0||V>=this.length)throw new RangeError("sourceStart out of bounds");if(Q<0)throw new RangeError("sourceEnd out of bounds");Q>this.length&&(Q=this.length),P.length-R<Q-V&&(Q=P.length-R+V);var oe=Q-V,ae;if(this===P&&V<R&&R<Q)for(ae=oe-1;ae>=0;--ae)P[ae+R]=this[ae+V];else if(oe<1e3||!g.TYPED_ARRAY_SUPPORT)for(ae=0;ae<oe;++ae)P[ae+R]=this[ae+V];else Uint8Array.prototype.set.call(P,this.subarray(V,V+oe),R);return oe},g.prototype.fill=function(P,R,V,Q){if(typeof P=="string"){if(typeof R=="string"?(Q=R,R=0,V=this.length):typeof V=="string"&&(Q=V,V=this.length),P.length===1){var oe=P.charCodeAt(0);oe<256&&(P=oe)}if(Q!==void 0&&typeof Q!="string")throw new TypeError("encoding must be a string");if(typeof Q=="string"&&!g.isEncoding(Q))throw new TypeError("Unknown encoding: "+Q)}else typeof P=="number"&&(P=P&255);if(R<0||this.length<R||this.length<V)throw new RangeError("Out of range index");if(V<=R)return this;R=R>>>0,V=V===void 0?this.length:V>>>0,P||(P=0);var ae;if(typeof P=="number")for(ae=R;ae<V;++ae)this[ae]=P;else{var xe=g.isBuffer(P)?P:le(new g(P,Q).toString()),De=xe.length;for(ae=0;ae<V-R;++ae)this[ae+R]=xe[ae%De]}return this};var Ce=/[^+\/0-9A-Za-z-_]/g;function z(L){if(L=Z(L).replace(Ce,""),L.length<2)return"";for(;L.length%4!==0;)L=L+"=";return L}function Z(L){return L.trim?L.trim():L.replace(/^\s+|\s+$/g,"")}function se(L){return L<16?"0"+L.toString(16):L.toString(16)}function le(L,P){P=P||1/0;for(var R,V=L.length,Q=null,oe=[],ae=0;ae<V;++ae){if(R=L.charCodeAt(ae),R>55295&&R<57344){if(!Q){if(R>56319){(P-=3)>-1&&oe.push(239,191,189);continue}else if(ae+1===V){(P-=3)>-1&&oe.push(239,191,189);continue}Q=R;continue}if(R<56320){(P-=3)>-1&&oe.push(239,191,189),Q=R;continue}R=(Q-55296<<10|R-56320)+65536}else Q&&(P-=3)>-1&&oe.push(239,191,189);if(Q=null,R<128){if((P-=1)<0)break;oe.push(R)}else if(R<2048){if((P-=2)<0)break;oe.push(R>>6|192,R&63|128)}else if(R<65536){if((P-=3)<0)break;oe.push(R>>12|224,R>>6&63|128,R&63|128)}else if(R<1114112){if((P-=4)<0)break;oe.push(R>>18|240,R>>12&63|128,R>>6&63|128,R&63|128)}else throw new Error("Invalid code point")}return oe}function ue(L){for(var P=[],R=0;R<L.length;++R)P.push(L.charCodeAt(R)&255);return P}function pe(L,P){for(var R,V,Q,oe=[],ae=0;ae<L.length&&!((P-=2)<0);++ae)R=L.charCodeAt(ae),V=R>>8,Q=R%256,oe.push(Q),oe.push(V);return oe}function be(L){return s.toByteArray(z(L))}function ve(L,P,R,V){for(var Q=0;Q<V&&!(Q+R>=P.length||Q>=L.length);++Q)P[Q+R]=L[Q];return Q}function ge(L){return L!==L}}).call(this,r("./node_modules/webpack/buildin/global.js"))},"./node_modules/engine.io-client/build/esm/contrib/has-cors.js":function(n,t,r){r.r(t),r.d(t,"hasCORS",function(){return s});let i=!1;try{i=typeof XMLHttpRequest<"u"&&"withCredentials"in new XMLHttpRequest}catch{}const s=i},"./node_modules/engine.io-client/build/esm/contrib/parseqs.js":function(n,t,r){r.r(t),r.d(t,"encode",function(){return i}),r.d(t,"decode",function(){return s});function i(o){let l="";for(let f in o)o.hasOwnProperty(f)&&(l.length&&(l+="&"),l+=encodeURIComponent(f)+"="+encodeURIComponent(o[f]));return l}function s(o){let l={},f=o.split("&");for(let u=0,_=f.length;u<_;u++){let g=f[u].split("=");l[decodeURIComponent(g[0])]=decodeURIComponent(g[1])}return l}},"./node_modules/engine.io-client/build/esm/contrib/parseuri.js":function(n,t,r){r.r(t),r.d(t,"parse",function(){return o});const i=/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,s=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];function o(u){const _=u,g=u.indexOf("["),a=u.indexOf("]");g!=-1&&a!=-1&&(u=u.substring(0,g)+u.substring(g,a).replace(/:/g,";")+u.substring(a,u.length));let m=i.exec(u||""),b={},v=14;for(;v--;)b[s[v]]=m[v]||"";return g!=-1&&a!=-1&&(b.source=_,b.host=b.host.substring(1,b.host.length-1).replace(/;/g,":"),b.authority=b.authority.replace("[","").replace("]","").replace(/;/g,":"),b.ipv6uri=!0),b.pathNames=l(b,b.path),b.queryKey=f(b,b.query),b}function l(u,_){const g=/\/{2,9}/g,a=_.replace(g,"/").split("/");return(_.slice(0,1)=="/"||_.length===0)&&a.splice(0,1),_.slice(-1)=="/"&&a.splice(a.length-1,1),a}function f(u,_){const g={};return _.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,function(a,m,b){m&&(g[m]=b)}),g}},"./node_modules/engine.io-client/build/esm/contrib/yeast.js":function(n,t,r){r.r(t),r.d(t,"encode",function(){return _}),r.d(t,"decode",function(){return g}),r.d(t,"yeast",function(){return a});const i="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),s=64,o={};let l=0,f=0,u;function _(m){let b="";do b=i[m%s]+b,m=Math.floor(m/s);while(m>0);return b}function g(m){let b=0;for(f=0;f<m.length;f++)b=b*s+o[m.charAt(f)];return b}function a(){const m=_(+new Date);return m!==u?(l=0,u=m):m+"."+_(l++)}for(;f<s;f++)o[i[f]]=f},"./node_modules/engine.io-client/build/esm/globalThis.browser.js":function(n,t,r){r.r(t),r.d(t,"globalThisShim",function(){return i});const i=typeof self<"u"?self:typeof window<"u"?window:Function("return this")()},"./node_modules/engine.io-client/build/esm/index.js":function(n,t,r){r.r(t),r.d(t,"protocol",function(){return _});var i=r("./node_modules/engine.io-client/build/esm/socket.js");r.d(t,"Socket",function(){return i.Socket});var s=r("./node_modules/engine.io-client/build/esm/transport.js");r.d(t,"Transport",function(){return s.Transport});var o=r("./node_modules/engine.io-client/build/esm/transports/index.js");r.d(t,"transports",function(){return o.transports});var l=r("./node_modules/engine.io-client/build/esm/util.js");r.d(t,"installTimerFunctions",function(){return l.installTimerFunctions});var f=r("./node_modules/engine.io-client/build/esm/contrib/parseuri.js");r.d(t,"parse",function(){return f.parse});var u=r("./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js");r.d(t,"nextTick",function(){return u.nextTick});const _=i.Socket.protocol},"./node_modules/engine.io-client/build/esm/socket.js":function(n,t,r){r.r(t),r.d(t,"Socket",function(){return _});var i=r("./node_modules/engine.io-client/build/esm/transports/index.js"),s=r("./node_modules/engine.io-client/build/esm/util.js"),o=r("./node_modules/engine.io-client/build/esm/contrib/parseqs.js"),l=r("./node_modules/engine.io-client/build/esm/contrib/parseuri.js"),f=r("./node_modules/@socket.io/component-emitter/index.mjs"),u=r("./node_modules/engine.io-parser/build/esm/index.js");class _ extends f.Emitter{constructor(a,m={}){super(),this.writeBuffer=[],a&&typeof a=="object"&&(m=a,a=null),a?(a=Object(l.parse)(a),m.hostname=a.host,m.secure=a.protocol==="https"||a.protocol==="wss",m.port=a.port,a.query&&(m.query=a.query)):m.host&&(m.hostname=Object(l.parse)(m.host).host),Object(s.installTimerFunctions)(this,m),this.secure=m.secure!=null?m.secure:typeof location<"u"&&location.protocol==="https:",m.hostname&&!m.port&&(m.port=this.secure?"443":"80"),this.hostname=m.hostname||(typeof location<"u"?location.hostname:"localhost"),this.port=m.port||(typeof location<"u"&&location.port?location.port:this.secure?"443":"80"),this.transports=m.transports||["polling","websocket"],this.writeBuffer=[],this.prevBufferLen=0,this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,addTrailingSlash:!0,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!0},m),this.opts.path=this.opts.path.replace(/\/$/,"")+(this.opts.addTrailingSlash?"/":""),typeof this.opts.query=="string"&&(this.opts.query=Object(o.decode)(this.opts.query)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingTimeoutTimer=null,typeof addEventListener=="function"&&(this.opts.closeOnBeforeunload&&(this.beforeunloadEventListener=()=>{this.transport&&(this.transport.removeAllListeners(),this.transport.close())},addEventListener("beforeunload",this.beforeunloadEventListener,!1)),this.hostname!=="localhost"&&(this.offlineEventListener=()=>{this.onClose("transport close",{description:"network connection lost"})},addEventListener("offline",this.offlineEventListener,!1))),this.open()}createTransport(a){const m=Object.assign({},this.opts.query);m.EIO=u.protocol,m.transport=a,this.id&&(m.sid=this.id);const b=Object.assign({},this.opts.transportOptions[a],this.opts,{query:m,socket:this,hostname:this.hostname,secure:this.secure,port:this.port});return new i.transports[a](b)}open(){let a;if(this.opts.rememberUpgrade&&_.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)a="websocket";else if(this.transports.length===0){this.setTimeoutFn(()=>{this.emitReserved("error","No transports available")},0);return}else a=this.transports[0];this.readyState="opening";try{a=this.createTransport(a)}catch{this.transports.shift(),this.open();return}a.open(),this.setTransport(a)}setTransport(a){this.transport&&this.transport.removeAllListeners(),this.transport=a,a.on("drain",this.onDrain.bind(this)).on("packet",this.onPacket.bind(this)).on("error",this.onError.bind(this)).on("close",m=>this.onClose("transport close",m))}probe(a){let m=this.createTransport(a),b=!1;_.priorWebsocketSuccess=!1;const v=()=>{b||(m.send([{type:"ping",data:"probe"}]),m.once("packet",A=>{if(!b)if(A.type==="pong"&&A.data==="probe"){if(this.upgrading=!0,this.emitReserved("upgrading",m),!m)return;_.priorWebsocketSuccess=m.name==="websocket",this.transport.pause(()=>{b||this.readyState!=="closed"&&(O(),this.setTransport(m),m.send([{type:"upgrade"}]),this.emitReserved("upgrade",m),m=null,this.upgrading=!1,this.flush())})}else{const T=new Error("probe error");T.transport=m.name,this.emitReserved("upgradeError",T)}}))};function c(){b||(b=!0,O(),m.close(),m=null)}const w=A=>{const T=new Error("probe error: "+A);T.transport=m.name,c(),this.emitReserved("upgradeError",T)};function k(){w("transport closed")}function x(){w("socket closed")}function E(A){m&&A.name!==m.name&&c()}const O=()=>{m.removeListener("open",v),m.removeListener("error",w),m.removeListener("close",k),this.off("close",x),this.off("upgrading",E)};m.once("open",v),m.once("error",w),m.once("close",k),this.once("close",x),this.once("upgrading",E),m.open()}onOpen(){if(this.readyState="open",_.priorWebsocketSuccess=this.transport.name==="websocket",this.emitReserved("open"),this.flush(),this.readyState==="open"&&this.opts.upgrade){let a=0;const m=this.upgrades.length;for(;a<m;a++)this.probe(this.upgrades[a])}}onPacket(a){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing")switch(this.emitReserved("packet",a),this.emitReserved("heartbeat"),a.type){case"open":this.onHandshake(JSON.parse(a.data));break;case"ping":this.resetPingTimeout(),this.sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong");break;case"error":const m=new Error("server error");m.code=a.data,this.onError(m);break;case"message":this.emitReserved("data",a.data),this.emitReserved("message",a.data);break}}onHandshake(a){this.emitReserved("handshake",a),this.id=a.sid,this.transport.query.sid=a.sid,this.upgrades=this.filterUpgrades(a.upgrades),this.pingInterval=a.pingInterval,this.pingTimeout=a.pingTimeout,this.maxPayload=a.maxPayload,this.onOpen(),this.readyState!=="closed"&&this.resetPingTimeout()}resetPingTimeout(){this.clearTimeoutFn(this.pingTimeoutTimer),this.pingTimeoutTimer=this.setTimeoutFn(()=>{this.onClose("ping timeout")},this.pingInterval+this.pingTimeout),this.opts.autoUnref&&this.pingTimeoutTimer.unref()}onDrain(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,this.writeBuffer.length===0?this.emitReserved("drain"):this.flush()}flush(){if(this.readyState!=="closed"&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){const a=this.getWritablePackets();this.transport.send(a),this.prevBufferLen=a.length,this.emitReserved("flush")}}getWritablePackets(){if(!(this.maxPayload&&this.transport.name==="polling"&&this.writeBuffer.length>1))return this.writeBuffer;let m=1;for(let b=0;b<this.writeBuffer.length;b++){const v=this.writeBuffer[b].data;if(v&&(m+=Object(s.byteLength)(v)),b>0&&m>this.maxPayload)return this.writeBuffer.slice(0,b);m+=2}return this.writeBuffer}write(a,m,b){return this.sendPacket("message",a,m,b),this}send(a,m,b){return this.sendPacket("message",a,m,b),this}sendPacket(a,m,b,v){if(typeof m=="function"&&(v=m,m=void 0),typeof b=="function"&&(v=b,b=null),this.readyState==="closing"||this.readyState==="closed")return;b=b||{},b.compress=b.compress!==!1;const c={type:a,data:m,options:b};this.emitReserved("packetCreate",c),this.writeBuffer.push(c),v&&this.once("flush",v),this.flush()}close(){const a=()=>{this.onClose("forced close"),this.transport.close()},m=()=>{this.off("upgrade",m),this.off("upgradeError",m),a()},b=()=>{this.once("upgrade",m),this.once("upgradeError",m)};return(this.readyState==="opening"||this.readyState==="open")&&(this.readyState="closing",this.writeBuffer.length?this.once("drain",()=>{this.upgrading?b():a()}):this.upgrading?b():a()),this}onError(a){_.priorWebsocketSuccess=!1,this.emitReserved("error",a),this.onClose("transport error",a)}onClose(a,m){(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing")&&(this.clearTimeoutFn(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),typeof removeEventListener=="function"&&(removeEventListener("beforeunload",this.beforeunloadEventListener,!1),removeEventListener("offline",this.offlineEventListener,!1)),this.readyState="closed",this.id=null,this.emitReserved("close",a,m),this.writeBuffer=[],this.prevBufferLen=0)}filterUpgrades(a){const m=[];let b=0;const v=a.length;for(;b<v;b++)~this.transports.indexOf(a[b])&&m.push(a[b]);return m}}_.protocol=u.protocol},"./node_modules/engine.io-client/build/esm/transport.js":function(n,t,r){r.r(t),r.d(t,"Transport",function(){return f});var i=r("./node_modules/engine.io-parser/build/esm/index.js"),s=r("./node_modules/@socket.io/component-emitter/index.mjs"),o=r("./node_modules/engine.io-client/build/esm/util.js");class l extends Error{constructor(_,g,a){super(_),this.description=g,this.context=a,this.type="TransportError"}}class f extends s.Emitter{constructor(_){super(),this.writable=!1,Object(o.installTimerFunctions)(this,_),this.opts=_,this.query=_.query,this.socket=_.socket}onError(_,g,a){return super.emitReserved("error",new l(_,g,a)),this}open(){return this.readyState="opening",this.doOpen(),this}close(){return(this.readyState==="opening"||this.readyState==="open")&&(this.doClose(),this.onClose()),this}send(_){this.readyState==="open"&&this.write(_)}onOpen(){this.readyState="open",this.writable=!0,super.emitReserved("open")}onData(_){const g=Object(i.decodePacket)(_,this.socket.binaryType);this.onPacket(g)}onPacket(_){super.emitReserved("packet",_)}onClose(_){this.readyState="closed",super.emitReserved("close",_)}pause(_){}}},"./node_modules/engine.io-client/build/esm/transports/index.js":function(n,t,r){r.r(t),r.d(t,"transports",function(){return o});var i=r("./node_modules/engine.io-client/build/esm/transports/polling.js"),s=r("./node_modules/engine.io-client/build/esm/transports/websocket.js");const o={websocket:s.WS,polling:i.Polling}},"./node_modules/engine.io-client/build/esm/transports/polling.js":function(n,t,r){r.r(t),r.d(t,"Polling",function(){return b}),r.d(t,"Request",function(){return v});var i=r("./node_modules/engine.io-client/build/esm/transport.js"),s=r("./node_modules/engine.io-client/build/esm/contrib/yeast.js"),o=r("./node_modules/engine.io-client/build/esm/contrib/parseqs.js"),l=r("./node_modules/engine.io-parser/build/esm/index.js"),f=r("./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js"),u=r("./node_modules/@socket.io/component-emitter/index.mjs"),_=r("./node_modules/engine.io-client/build/esm/util.js"),g=r("./node_modules/engine.io-client/build/esm/globalThis.browser.js");function a(){}const m=function(){return new f.XHR({xdomain:!1}).responseType!=null}();class b extends i.Transport{constructor(k){if(super(k),this.polling=!1,typeof location<"u"){const E=location.protocol==="https:";let O=location.port;O||(O=E?"443":"80"),this.xd=typeof location<"u"&&k.hostname!==location.hostname||O!==k.port,this.xs=k.secure!==E}const x=k&&k.forceBase64;this.supportsBinary=m&&!x}get name(){return"polling"}doOpen(){this.poll()}pause(k){this.readyState="pausing";const x=()=>{this.readyState="paused",k()};if(this.polling||!this.writable){let E=0;this.polling&&(E++,this.once("pollComplete",function(){--E||x()})),this.writable||(E++,this.once("drain",function(){--E||x()}))}else x()}poll(){this.polling=!0,this.doPoll(),this.emitReserved("poll")}onData(k){const x=E=>{if(this.readyState==="opening"&&E.type==="open"&&this.onOpen(),E.type==="close")return this.onClose({description:"transport closed by the server"}),!1;this.onPacket(E)};Object(l.decodePayload)(k,this.socket.binaryType).forEach(x),this.readyState!=="closed"&&(this.polling=!1,this.emitReserved("pollComplete"),this.readyState==="open"&&this.poll())}doClose(){const k=()=>{this.write([{type:"close"}])};this.readyState==="open"?k():this.once("open",k)}write(k){this.writable=!1,Object(l.encodePayload)(k,x=>{this.doWrite(x,()=>{this.writable=!0,this.emitReserved("drain")})})}uri(){let k=this.query||{};const x=this.opts.secure?"https":"http";let E="";this.opts.timestampRequests!==!1&&(k[this.opts.timestampParam]=Object(s.yeast)()),!this.supportsBinary&&!k.sid&&(k.b64=1),this.opts.port&&(x==="https"&&Number(this.opts.port)!==443||x==="http"&&Number(this.opts.port)!==80)&&(E=":"+this.opts.port);const O=Object(o.encode)(k),A=this.opts.hostname.indexOf(":")!==-1;return x+"://"+(A?"["+this.opts.hostname+"]":this.opts.hostname)+E+this.opts.path+(O.length?"?"+O:"")}request(k={}){return Object.assign(k,{xd:this.xd,xs:this.xs},this.opts),new v(this.uri(),k)}doWrite(k,x){const E=this.request({method:"POST",data:k});E.on("success",x),E.on("error",(O,A)=>{this.onError("xhr post error",O,A)})}doPoll(){const k=this.request();k.on("data",this.onData.bind(this)),k.on("error",(x,E)=>{this.onError("xhr poll error",x,E)}),this.pollXhr=k}}class v extends u.Emitter{constructor(k,x){super(),Object(_.installTimerFunctions)(this,x),this.opts=x,this.method=x.method||"GET",this.uri=k,this.async=x.async!==!1,this.data=x.data!==void 0?x.data:null,this.create()}create(){const k=Object(_.pick)(this.opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");k.xdomain=!!this.opts.xd,k.xscheme=!!this.opts.xs;const x=this.xhr=new f.XHR(k);try{x.open(this.method,this.uri,this.async);try{if(this.opts.extraHeaders){x.setDisableHeaderCheck&&x.setDisableHeaderCheck(!0);for(let E in this.opts.extraHeaders)this.opts.extraHeaders.hasOwnProperty(E)&&x.setRequestHeader(E,this.opts.extraHeaders[E])}}catch{}if(this.method==="POST")try{x.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch{}try{x.setRequestHeader("Accept","*/*")}catch{}"withCredentials"in x&&(x.withCredentials=this.opts.withCredentials),this.opts.requestTimeout&&(x.timeout=this.opts.requestTimeout),x.onreadystatechange=()=>{x.readyState===4&&(x.status===200||x.status===1223?this.onLoad():this.setTimeoutFn(()=>{this.onError(typeof x.status=="number"?x.status:0)},0))},x.send(this.data)}catch(E){this.setTimeoutFn(()=>{this.onError(E)},0);return}typeof document<"u"&&(this.index=v.requestsCount++,v.requests[this.index]=this)}onError(k){this.emitReserved("error",k,this.xhr),this.cleanup(!0)}cleanup(k){if(!(typeof this.xhr>"u"||this.xhr===null)){if(this.xhr.onreadystatechange=a,k)try{this.xhr.abort()}catch{}typeof document<"u"&&delete v.requests[this.index],this.xhr=null}}onLoad(){const k=this.xhr.responseText;k!==null&&(this.emitReserved("data",k),this.emitReserved("success"),this.cleanup())}abort(){this.cleanup()}}if(v.requestsCount=0,v.requests={},typeof document<"u"){if(typeof attachEvent=="function")attachEvent("onunload",c);else if(typeof addEventListener=="function"){const w="onpagehide"in g.globalThisShim?"pagehide":"unload";addEventListener(w,c,!1)}}function c(){for(let w in v.requests)v.requests.hasOwnProperty(w)&&v.requests[w].abort()}},"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js":function(n,t,r){r.r(t),r.d(t,"nextTick",function(){return s}),r.d(t,"WebSocket",function(){return o}),r.d(t,"usingBrowserWebSocket",function(){return l}),r.d(t,"defaultBinaryType",function(){return f});var i=r("./node_modules/engine.io-client/build/esm/globalThis.browser.js");const s=typeof Promise=="function"&&typeof Promise.resolve=="function"?_=>Promise.resolve().then(_):(_,g)=>g(_,0),o=i.globalThisShim.WebSocket||i.globalThisShim.MozWebSocket,l=!0,f="arraybuffer"},"./node_modules/engine.io-client/build/esm/transports/websocket.js":function(n,t,r){r.r(t),(function(i){r.d(t,"WS",function(){return a});var s=r("./node_modules/engine.io-client/build/esm/transport.js"),o=r("./node_modules/engine.io-client/build/esm/contrib/parseqs.js"),l=r("./node_modules/engine.io-client/build/esm/contrib/yeast.js"),f=r("./node_modules/engine.io-client/build/esm/util.js"),u=r("./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js"),_=r("./node_modules/engine.io-parser/build/esm/index.js");const g=typeof navigator<"u"&&typeof navigator.product=="string"&&navigator.product.toLowerCase()==="reactnative";class a extends s.Transport{constructor(b){super(b),this.supportsBinary=!b.forceBase64}get name(){return"websocket"}doOpen(){if(!this.check())return;const b=this.uri(),v=this.opts.protocols,c=g?{}:Object(f.pick)(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(c.headers=this.opts.extraHeaders);try{this.ws=u.usingBrowserWebSocket&&!g?v?new u.WebSocket(b,v):new u.WebSocket(b):new u.WebSocket(b,v,c)}catch(w){return this.emitReserved("error",w)}this.ws.binaryType=this.socket.binaryType||u.defaultBinaryType,this.addEventListeners()}addEventListeners(){this.ws.onopen=()=>{this.opts.autoUnref&&this.ws._socket.unref(),this.onOpen()},this.ws.onclose=b=>this.onClose({description:"websocket connection closed",context:b}),this.ws.onmessage=b=>this.onData(b.data),this.ws.onerror=b=>this.onError("websocket error",b)}write(b){this.writable=!1;for(let v=0;v<b.length;v++){const c=b[v],w=v===b.length-1;Object(_.encodePacket)(c,this.supportsBinary,k=>{const x={};u.usingBrowserWebSocket||(c.options&&(x.compress=c.options.compress),this.opts.perMessageDeflate&&(typeof k=="string"?i.byteLength(k):k.length)<this.opts.perMessageDeflate.threshold&&(x.compress=!1));try{u.usingBrowserWebSocket?this.ws.send(k):this.ws.send(k,x)}catch{}w&&Object(u.nextTick)(()=>{this.writable=!0,this.emitReserved("drain")},this.setTimeoutFn)})}}doClose(){typeof this.ws<"u"&&(this.ws.close(),this.ws=null)}uri(){let b=this.query||{};const v=this.opts.secure?"wss":"ws";let c="";this.opts.port&&(v==="wss"&&Number(this.opts.port)!==443||v==="ws"&&Number(this.opts.port)!==80)&&(c=":"+this.opts.port),this.opts.timestampRequests&&(b[this.opts.timestampParam]=Object(l.yeast)()),this.supportsBinary||(b.b64=1);const w=Object(o.encode)(b),k=this.opts.hostname.indexOf(":")!==-1;return v+"://"+(k?"["+this.opts.hostname+"]":this.opts.hostname)+c+this.opts.path+(w.length?"?"+w:"")}check(){return!!u.WebSocket}}}).call(this,r("./node_modules/buffer/index.js").Buffer)},"./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js":function(n,t,r){r.r(t),r.d(t,"XHR",function(){return o});var i=r("./node_modules/engine.io-client/build/esm/contrib/has-cors.js"),s=r("./node_modules/engine.io-client/build/esm/globalThis.browser.js");function o(l){const f=l.xdomain;try{if(typeof XMLHttpRequest<"u"&&(!f||i.hasCORS))return new XMLHttpRequest}catch{}if(!f)try{return new s.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")}catch{}}},"./node_modules/engine.io-client/build/esm/util.js":function(n,t,r){r.r(t),r.d(t,"pick",function(){return s}),r.d(t,"installTimerFunctions",function(){return f}),r.d(t,"byteLength",function(){return _});var i=r("./node_modules/engine.io-client/build/esm/globalThis.browser.js");function s(a,...m){return m.reduce((b,v)=>(a.hasOwnProperty(v)&&(b[v]=a[v]),b),{})}const o=i.globalThisShim.setTimeout,l=i.globalThisShim.clearTimeout;function f(a,m){m.useNativeTimers?(a.setTimeoutFn=o.bind(i.globalThisShim),a.clearTimeoutFn=l.bind(i.globalThisShim)):(a.setTimeoutFn=i.globalThisShim.setTimeout.bind(i.globalThisShim),a.clearTimeoutFn=i.globalThisShim.clearTimeout.bind(i.globalThisShim))}const u=1.33;function _(a){return typeof a=="string"?g(a):Math.ceil((a.byteLength||a.size)*u)}function g(a){let m=0,b=0;for(let v=0,c=a.length;v<c;v++)m=a.charCodeAt(v),m<128?b+=1:m<2048?b+=2:m<55296||m>=57344?b+=3:(v++,b+=4);return b}},"./node_modules/engine.io-parser/build/esm/commons.js":function(n,t,r){r.r(t),r.d(t,"PACKET_TYPES",function(){return i}),r.d(t,"PACKET_TYPES_REVERSE",function(){return s}),r.d(t,"ERROR_PACKET",function(){return o});const i=Object.create(null);i.open="0",i.close="1",i.ping="2",i.pong="3",i.message="4",i.upgrade="5",i.noop="6";const s=Object.create(null);Object.keys(i).forEach(l=>{s[i[l]]=l});const o={type:"error",data:"parser error"}},"./node_modules/engine.io-parser/build/esm/decodePacket.browser.js":function(n,t,r){r.r(t);var i=r("./node_modules/engine.io-parser/build/esm/commons.js"),s=r("./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js");const o=typeof ArrayBuffer=="function",l=(_,g)=>{if(typeof _!="string")return{type:"message",data:u(_,g)};const a=_.charAt(0);return a==="b"?{type:"message",data:f(_.substring(1),g)}:i.PACKET_TYPES_REVERSE[a]?_.length>1?{type:i.PACKET_TYPES_REVERSE[a],data:_.substring(1)}:{type:i.PACKET_TYPES_REVERSE[a]}:i.ERROR_PACKET},f=(_,g)=>{if(o){const a=Object(s.decode)(_);return u(a,g)}else return{base64:!0,data:_}},u=(_,g)=>{switch(g){case"blob":return _ instanceof ArrayBuffer?new Blob([_]):_;case"arraybuffer":default:return _}};t.default=l},"./node_modules/engine.io-parser/build/esm/encodePacket.browser.js":function(n,t,r){r.r(t);var i=r("./node_modules/engine.io-parser/build/esm/commons.js");const s=typeof Blob=="function"||typeof Blob<"u"&&Object.prototype.toString.call(Blob)==="[object BlobConstructor]",o=typeof ArrayBuffer=="function",l=_=>typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(_):_&&_.buffer instanceof ArrayBuffer,f=({type:_,data:g},a,m)=>s&&g instanceof Blob?a?m(g):u(g,m):o&&(g instanceof ArrayBuffer||l(g))?a?m(g):u(new Blob([g]),m):m(i.PACKET_TYPES[_]+(g||"")),u=(_,g)=>{const a=new FileReader;return a.onload=function(){const m=a.result.split(",")[1];g("b"+m)},a.readAsDataURL(_)};t.default=f},"./node_modules/engine.io-parser/build/esm/index.js":function(n,t,r){r.r(t),r.d(t,"protocol",function(){return u}),r.d(t,"encodePayload",function(){return l}),r.d(t,"decodePayload",function(){return f});var i=r("./node_modules/engine.io-parser/build/esm/encodePacket.browser.js");r.d(t,"encodePacket",function(){return i.default});var s=r("./node_modules/engine.io-parser/build/esm/decodePacket.browser.js");r.d(t,"decodePacket",function(){return s.default});const o="",l=(_,g)=>{const a=_.length,m=new Array(a);let b=0;_.forEach((v,c)=>{Object(i.default)(v,!1,w=>{m[c]=w,++b===a&&g(m.join(o))})})},f=(_,g)=>{const a=_.split(o),m=[];for(let b=0;b<a.length;b++){const v=Object(s.default)(a[b],g);if(m.push(v),v.type==="error")break}return m},u=4},"./node_modules/ieee754/index.js":function(n,t){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */t.read=function(r,i,s,o,l){var f,u,_=l*8-o-1,g=(1<<_)-1,a=g>>1,m=-7,b=s?l-1:0,v=s?-1:1,c=r[i+b];for(b+=v,f=c&(1<<-m)-1,c>>=-m,m+=_;m>0;f=f*256+r[i+b],b+=v,m-=8);for(u=f&(1<<-m)-1,f>>=-m,m+=o;m>0;u=u*256+r[i+b],b+=v,m-=8);if(f===0)f=1-a;else{if(f===g)return u?NaN:(c?-1:1)*(1/0);u=u+Math.pow(2,o),f=f-a}return(c?-1:1)*u*Math.pow(2,f-o)},t.write=function(r,i,s,o,l,f){var u,_,g,a=f*8-l-1,m=(1<<a)-1,b=m>>1,v=l===23?Math.pow(2,-24)-Math.pow(2,-77):0,c=o?0:f-1,w=o?1:-1,k=i<0||i===0&&1/i<0?1:0;for(i=Math.abs(i),isNaN(i)||i===1/0?(_=isNaN(i)?1:0,u=m):(u=Math.floor(Math.log(i)/Math.LN2),i*(g=Math.pow(2,-u))<1&&(u--,g*=2),u+b>=1?i+=v/g:i+=v*Math.pow(2,1-b),i*g>=2&&(u++,g/=2),u+b>=m?(_=0,u=m):u+b>=1?(_=(i*g-1)*Math.pow(2,l),u=u+b):(_=i*Math.pow(2,b-1)*Math.pow(2,l),u=0));l>=8;r[s+c]=_&255,c+=w,_/=256,l-=8);for(u=u<<l|_,a+=l;a>0;r[s+c]=u&255,c+=w,u/=256,a-=8);r[s+c-w]|=k*128}},"./node_modules/isarray/index.js":function(n,t){var r={}.toString;n.exports=Array.isArray||function(i){return r.call(i)=="[object Array]"}},"./node_modules/socket.io-client/build/esm/contrib/backo2.js":function(n,t,r){r.r(t),r.d(t,"Backoff",function(){return i});function i(s){s=s||{},this.ms=s.min||100,this.max=s.max||1e4,this.factor=s.factor||2,this.jitter=s.jitter>0&&s.jitter<=1?s.jitter:0,this.attempts=0}i.prototype.duration=function(){var s=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var o=Math.random(),l=Math.floor(o*this.jitter*s);s=Math.floor(o*10)&1?s+l:s-l}return Math.min(s,this.max)|0},i.prototype.reset=function(){this.attempts=0},i.prototype.setMin=function(s){this.ms=s},i.prototype.setMax=function(s){this.max=s},i.prototype.setJitter=function(s){this.jitter=s}},"./node_modules/socket.io-client/build/esm/index.js":function(n,t,r){r.r(t),r.d(t,"io",function(){return u}),r.d(t,"connect",function(){return u}),r.d(t,"default",function(){return u});var i=r("./node_modules/socket.io-client/build/esm/url.js"),s=r("./node_modules/socket.io-client/build/esm/manager.js");r.d(t,"Manager",function(){return s.Manager});var o=r("./node_modules/socket.io-client/build/esm/socket.js");r.d(t,"Socket",function(){return o.Socket});var l=r("./node_modules/socket.io-parser/build/esm/index.js");r.d(t,"protocol",function(){return l.protocol});const f={};function u(_,g){typeof _=="object"&&(g=_,_=void 0),g=g||{};const a=Object(i.url)(_,g.path||"/socket.io"),m=a.source,b=a.id,v=a.path,c=f[b]&&v in f[b].nsps,w=g.forceNew||g["force new connection"]||g.multiplex===!1||c;let k;return w?k=new s.Manager(m,g):(f[b]||(f[b]=new s.Manager(m,g)),k=f[b]),a.query&&!g.query&&(g.query=a.queryKey),k.socket(a.path,g)}Object.assign(u,{Manager:s.Manager,Socket:o.Socket,io:u,connect:u})},"./node_modules/socket.io-client/build/esm/manager.js":function(n,t,r){r.r(t),r.d(t,"Manager",function(){return _});var i=r("./node_modules/engine.io-client/build/esm/index.js"),s=r("./node_modules/socket.io-client/build/esm/socket.js"),o=r("./node_modules/socket.io-parser/build/esm/index.js"),l=r("./node_modules/socket.io-client/build/esm/on.js"),f=r("./node_modules/socket.io-client/build/esm/contrib/backo2.js"),u=r("./node_modules/@socket.io/component-emitter/index.mjs");class _ extends u.Emitter{constructor(a,m){var b;super(),this.nsps={},this.subs=[],a&&typeof a=="object"&&(m=a,a=void 0),m=m||{},m.path=m.path||"/socket.io",this.opts=m,Object(i.installTimerFunctions)(this,m),this.reconnection(m.reconnection!==!1),this.reconnectionAttempts(m.reconnectionAttempts||1/0),this.reconnectionDelay(m.reconnectionDelay||1e3),this.reconnectionDelayMax(m.reconnectionDelayMax||5e3),this.randomizationFactor((b=m.randomizationFactor)!==null&&b!==void 0?b:.5),this.backoff=new f.Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(m.timeout==null?2e4:m.timeout),this._readyState="closed",this.uri=a;const v=m.parser||o;this.encoder=new v.Encoder,this.decoder=new v.Decoder,this._autoConnect=m.autoConnect!==!1,this._autoConnect&&this.open()}reconnection(a){return arguments.length?(this._reconnection=!!a,this):this._reconnection}reconnectionAttempts(a){return a===void 0?this._reconnectionAttempts:(this._reconnectionAttempts=a,this)}reconnectionDelay(a){var m;return a===void 0?this._reconnectionDelay:(this._reconnectionDelay=a,(m=this.backoff)===null||m===void 0||m.setMin(a),this)}randomizationFactor(a){var m;return a===void 0?this._randomizationFactor:(this._randomizationFactor=a,(m=this.backoff)===null||m===void 0||m.setJitter(a),this)}reconnectionDelayMax(a){var m;return a===void 0?this._reconnectionDelayMax:(this._reconnectionDelayMax=a,(m=this.backoff)===null||m===void 0||m.setMax(a),this)}timeout(a){return arguments.length?(this._timeout=a,this):this._timeout}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&this.backoff.attempts===0&&this.reconnect()}open(a){if(~this._readyState.indexOf("open"))return this;this.engine=new i.Socket(this.uri,this.opts);const m=this.engine,b=this;this._readyState="opening",this.skipReconnect=!1;const v=Object(l.on)(m,"open",function(){b.onopen(),a&&a()}),c=Object(l.on)(m,"error",w=>{b.cleanup(),b._readyState="closed",this.emitReserved("error",w),a?a(w):b.maybeReconnectOnOpen()});if(this._timeout!==!1){const w=this._timeout;w===0&&v();const k=this.setTimeoutFn(()=>{v(),m.close(),m.emit("error",new Error("timeout"))},w);this.opts.autoUnref&&k.unref(),this.subs.push(function(){clearTimeout(k)})}return this.subs.push(v),this.subs.push(c),this}connect(a){return this.open(a)}onopen(){this.cleanup(),this._readyState="open",this.emitReserved("open");const a=this.engine;this.subs.push(Object(l.on)(a,"ping",this.onping.bind(this)),Object(l.on)(a,"data",this.ondata.bind(this)),Object(l.on)(a,"error",this.onerror.bind(this)),Object(l.on)(a,"close",this.onclose.bind(this)),Object(l.on)(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(a){try{this.decoder.add(a)}catch(m){this.onclose("parse error",m)}}ondecoded(a){Object(i.nextTick)(()=>{this.emitReserved("packet",a)},this.setTimeoutFn)}onerror(a){this.emitReserved("error",a)}socket(a,m){let b=this.nsps[a];return b?this._autoConnect&&!b.active&&b.connect():(b=new s.Socket(this,a,m),this.nsps[a]=b),b}_destroy(a){const m=Object.keys(this.nsps);for(const b of m)if(this.nsps[b].active)return;this._close()}_packet(a){const m=this.encoder.encode(a);for(let b=0;b<m.length;b++)this.engine.write(m[b],a.options)}cleanup(){this.subs.forEach(a=>a()),this.subs.length=0,this.decoder.destroy()}_close(){this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close"),this.engine&&this.engine.close()}disconnect(){return this._close()}onclose(a,m){this.cleanup(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",a,m),this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const a=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const m=this.backoff.duration();this._reconnecting=!0;const b=this.setTimeoutFn(()=>{a.skipReconnect||(this.emitReserved("reconnect_attempt",a.backoff.attempts),!a.skipReconnect&&a.open(v=>{v?(a._reconnecting=!1,a.reconnect(),this.emitReserved("reconnect_error",v)):a.onreconnect()}))},m);this.opts.autoUnref&&b.unref(),this.subs.push(function(){clearTimeout(b)})}}onreconnect(){const a=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",a)}}},"./node_modules/socket.io-client/build/esm/on.js":function(n,t,r){r.r(t),r.d(t,"on",function(){return i});function i(s,o,l){return s.on(o,l),function(){s.off(o,l)}}},"./node_modules/socket.io-client/build/esm/socket.js":function(n,t,r){r.r(t),r.d(t,"Socket",function(){return f});var i=r("./node_modules/socket.io-parser/build/esm/index.js"),s=r("./node_modules/socket.io-client/build/esm/on.js"),o=r("./node_modules/@socket.io/component-emitter/index.mjs");const l=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class f extends o.Emitter{constructor(_,g,a){super(),this.connected=!1,this.recovered=!1,this.receiveBuffer=[],this.sendBuffer=[],this._queue=[],this._queueSeq=0,this.ids=0,this.acks={},this.flags={},this.io=_,this.nsp=g,a&&a.auth&&(this.auth=a.auth),this._opts=Object.assign({},a),this.io._autoConnect&&this.open()}get disconnected(){return!this.connected}subEvents(){if(this.subs)return;const _=this.io;this.subs=[Object(s.on)(_,"open",this.onopen.bind(this)),Object(s.on)(_,"packet",this.onpacket.bind(this)),Object(s.on)(_,"error",this.onerror.bind(this)),Object(s.on)(_,"close",this.onclose.bind(this))]}get active(){return!!this.subs}connect(){return this.connected?this:(this.subEvents(),this.io._reconnecting||this.io.open(),this.io._readyState==="open"&&this.onopen(),this)}open(){return this.connect()}send(..._){return _.unshift("message"),this.emit.apply(this,_),this}emit(_,...g){if(l.hasOwnProperty(_))throw new Error('"'+_.toString()+'" is a reserved event name');if(g.unshift(_),this._opts.retries&&!this.flags.fromQueue&&!this.flags.volatile)return this._addToQueue(g),this;const a={type:i.PacketType.EVENT,data:g};if(a.options={},a.options.compress=this.flags.compress!==!1,typeof g[g.length-1]=="function"){const v=this.ids++,c=g.pop();this._registerAckCallback(v,c),a.id=v}const m=this.io.engine&&this.io.engine.transport&&this.io.engine.transport.writable;return this.flags.volatile&&(!m||!this.connected)||(this.connected?(this.notifyOutgoingListeners(a),this.packet(a)):this.sendBuffer.push(a)),this.flags={},this}_registerAckCallback(_,g){var a;const m=(a=this.flags.timeout)!==null&&a!==void 0?a:this._opts.ackTimeout;if(m===void 0){this.acks[_]=g;return}const b=this.io.setTimeoutFn(()=>{delete this.acks[_];for(let v=0;v<this.sendBuffer.length;v++)this.sendBuffer[v].id===_&&this.sendBuffer.splice(v,1);g.call(this,new Error("operation has timed out"))},m);this.acks[_]=(...v)=>{this.io.clearTimeoutFn(b),g.apply(this,[null,...v])}}emitWithAck(_,...g){const a=this.flags.timeout!==void 0||this._opts.ackTimeout!==void 0;return new Promise((m,b)=>{g.push((v,c)=>a?v?b(v):m(c):m(v)),this.emit(_,...g)})}_addToQueue(_){let g;typeof _[_.length-1]=="function"&&(g=_.pop());const a={id:this._queueSeq++,tryCount:0,pending:!1,args:_,flags:Object.assign({fromQueue:!0},this.flags)};_.push((m,...b)=>a!==this._queue[0]?void 0:(m!==null?a.tryCount>this._opts.retries&&(this._queue.shift(),g&&g(m)):(this._queue.shift(),g&&g(null,...b)),a.pending=!1,this._drainQueue())),this._queue.push(a),this._drainQueue()}_drainQueue(_=!1){if(!this.connected||this._queue.length===0)return;const g=this._queue[0];g.pending&&!_||(g.pending=!0,g.tryCount++,this.flags=g.flags,this.emit.apply(this,g.args))}packet(_){_.nsp=this.nsp,this.io._packet(_)}onopen(){typeof this.auth=="function"?this.auth(_=>{this._sendConnectPacket(_)}):this._sendConnectPacket(this.auth)}_sendConnectPacket(_){this.packet({type:i.PacketType.CONNECT,data:this._pid?Object.assign({pid:this._pid,offset:this._lastOffset},_):_})}onerror(_){this.connected||this.emitReserved("connect_error",_)}onclose(_,g){this.connected=!1,delete this.id,this.emitReserved("disconnect",_,g)}onpacket(_){if(_.nsp===this.nsp)switch(_.type){case i.PacketType.CONNECT:_.data&&_.data.sid?this.onconnect(_.data.sid,_.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case i.PacketType.EVENT:case i.PacketType.BINARY_EVENT:this.onevent(_);break;case i.PacketType.ACK:case i.PacketType.BINARY_ACK:this.onack(_);break;case i.PacketType.DISCONNECT:this.ondisconnect();break;case i.PacketType.CONNECT_ERROR:this.destroy();const a=new Error(_.data.message);a.data=_.data.data,this.emitReserved("connect_error",a);break}}onevent(_){const g=_.data||[];_.id!=null&&g.push(this.ack(_.id)),this.connected?this.emitEvent(g):this.receiveBuffer.push(Object.freeze(g))}emitEvent(_){if(this._anyListeners&&this._anyListeners.length){const g=this._anyListeners.slice();for(const a of g)a.apply(this,_)}super.emit.apply(this,_),this._pid&&_.length&&typeof _[_.length-1]=="string"&&(this._lastOffset=_[_.length-1])}ack(_){const g=this;let a=!1;return function(...m){a||(a=!0,g.packet({type:i.PacketType.ACK,id:_,data:m}))}}onack(_){const g=this.acks[_.id];typeof g=="function"&&(g.apply(this,_.data),delete this.acks[_.id])}onconnect(_,g){this.id=_,this.recovered=g&&this._pid===g,this._pid=g,this.connected=!0,this.emitBuffered(),this.emitReserved("connect"),this._drainQueue(!0)}emitBuffered(){this.receiveBuffer.forEach(_=>this.emitEvent(_)),this.receiveBuffer=[],this.sendBuffer.forEach(_=>{this.notifyOutgoingListeners(_),this.packet(_)}),this.sendBuffer=[]}ondisconnect(){this.destroy(),this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach(_=>_()),this.subs=void 0),this.io._destroy(this)}disconnect(){return this.connected&&this.packet({type:i.PacketType.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}close(){return this.disconnect()}compress(_){return this.flags.compress=_,this}get volatile(){return this.flags.volatile=!0,this}timeout(_){return this.flags.timeout=_,this}onAny(_){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(_),this}prependAny(_){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(_),this}offAny(_){if(!this._anyListeners)return this;if(_){const g=this._anyListeners;for(let a=0;a<g.length;a++)if(_===g[a])return g.splice(a,1),this}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}onAnyOutgoing(_){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(_),this}prependAnyOutgoing(_){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(_),this}offAnyOutgoing(_){if(!this._anyOutgoingListeners)return this;if(_){const g=this._anyOutgoingListeners;for(let a=0;a<g.length;a++)if(_===g[a])return g.splice(a,1),this}else this._anyOutgoingListeners=[];return this}listenersAnyOutgoing(){return this._anyOutgoingListeners||[]}notifyOutgoingListeners(_){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){const g=this._anyOutgoingListeners.slice();for(const a of g)a.apply(this,_.data)}}}},"./node_modules/socket.io-client/build/esm/url.js":function(n,t,r){r.r(t),r.d(t,"url",function(){return s});var i=r("./node_modules/engine.io-client/build/esm/index.js");function s(o,l="",f){let u=o;f=f||typeof location<"u"&&location,o==null&&(o=f.protocol+"//"+f.host),typeof o=="string"&&(o.charAt(0)==="/"&&(o.charAt(1)==="/"?o=f.protocol+o:o=f.host+o),/^(https?|wss?):\/\//.test(o)||(typeof f<"u"?o=f.protocol+"//"+o:o="https://"+o),u=Object(i.parse)(o)),u.port||(/^(http|ws)$/.test(u.protocol)?u.port="80":/^(http|ws)s$/.test(u.protocol)&&(u.port="443")),u.path=u.path||"/";const g=u.host.indexOf(":")!==-1?"["+u.host+"]":u.host;return u.id=u.protocol+"://"+g+":"+u.port+l,u.href=u.protocol+"://"+g+(f&&f.port===u.port?"":":"+u.port),u}},"./node_modules/socket.io-parser/build/esm/binary.js":function(n,t,r){r.r(t),r.d(t,"deconstructPacket",function(){return s}),r.d(t,"reconstructPacket",function(){return l});var i=r("./node_modules/socket.io-parser/build/esm/is-binary.js");function s(u){const _=[],g=u.data,a=u;return a.data=o(g,_),a.attachments=_.length,{packet:a,buffers:_}}function o(u,_){if(!u)return u;if(Object(i.isBinary)(u)){const g={_placeholder:!0,num:_.length};return _.push(u),g}else if(Array.isArray(u)){const g=new Array(u.length);for(let a=0;a<u.length;a++)g[a]=o(u[a],_);return g}else if(typeof u=="object"&&!(u instanceof Date)){const g={};for(const a in u)Object.prototype.hasOwnProperty.call(u,a)&&(g[a]=o(u[a],_));return g}return u}function l(u,_){return u.data=f(u.data,_),delete u.attachments,u}function f(u,_){if(!u)return u;if(u&&u._placeholder===!0){if(typeof u.num=="number"&&u.num>=0&&u.num<_.length)return _[u.num];throw new Error("illegal attachments")}else if(Array.isArray(u))for(let g=0;g<u.length;g++)u[g]=f(u[g],_);else if(typeof u=="object")for(const g in u)Object.prototype.hasOwnProperty.call(u,g)&&(u[g]=f(u[g],_));return u}},"./node_modules/socket.io-parser/build/esm/index.js":function(n,t,r){r.r(t),r.d(t,"protocol",function(){return f}),r.d(t,"PacketType",function(){return u}),r.d(t,"Encoder",function(){return _}),r.d(t,"Decoder",function(){return a});var i=r("./node_modules/@socket.io/component-emitter/index.mjs"),s=r("./node_modules/socket.io-parser/build/esm/binary.js"),o=r("./node_modules/socket.io-parser/build/esm/is-binary.js");const l=["connect","connect_error","disconnect","disconnecting","newListener","removeListener"],f=5;var u;(function(b){b[b.CONNECT=0]="CONNECT",b[b.DISCONNECT=1]="DISCONNECT",b[b.EVENT=2]="EVENT",b[b.ACK=3]="ACK",b[b.CONNECT_ERROR=4]="CONNECT_ERROR",b[b.BINARY_EVENT=5]="BINARY_EVENT",b[b.BINARY_ACK=6]="BINARY_ACK"})(u||(u={}));class _{constructor(v){this.replacer=v}encode(v){return(v.type===u.EVENT||v.type===u.ACK)&&Object(o.hasBinary)(v)?this.encodeAsBinary({type:v.type===u.EVENT?u.BINARY_EVENT:u.BINARY_ACK,nsp:v.nsp,data:v.data,id:v.id}):[this.encodeAsString(v)]}encodeAsString(v){let c=""+v.type;return(v.type===u.BINARY_EVENT||v.type===u.BINARY_ACK)&&(c+=v.attachments+"-"),v.nsp&&v.nsp!=="/"&&(c+=v.nsp+","),v.id!=null&&(c+=v.id),v.data!=null&&(c+=JSON.stringify(v.data,this.replacer)),c}encodeAsBinary(v){const c=Object(s.deconstructPacket)(v),w=this.encodeAsString(c.packet),k=c.buffers;return k.unshift(w),k}}function g(b){return Object.prototype.toString.call(b)==="[object Object]"}class a extends i.Emitter{constructor(v){super(),this.reviver=v}add(v){let c;if(typeof v=="string"){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");c=this.decodeString(v);const w=c.type===u.BINARY_EVENT;w||c.type===u.BINARY_ACK?(c.type=w?u.EVENT:u.ACK,this.reconstructor=new m(c),c.attachments===0&&super.emitReserved("decoded",c)):super.emitReserved("decoded",c)}else if(Object(o.isBinary)(v)||v.base64)if(this.reconstructor)c=this.reconstructor.takeBinaryData(v),c&&(this.reconstructor=null,super.emitReserved("decoded",c));else throw new Error("got binary data when not reconstructing a packet");else throw new Error("Unknown type: "+v)}decodeString(v){let c=0;const w={type:Number(v.charAt(0))};if(u[w.type]===void 0)throw new Error("unknown packet type "+w.type);if(w.type===u.BINARY_EVENT||w.type===u.BINARY_ACK){const x=c+1;for(;v.charAt(++c)!=="-"&&c!=v.length;);const E=v.substring(x,c);if(E!=Number(E)||v.charAt(c)!=="-")throw new Error("Illegal attachments");w.attachments=Number(E)}if(v.charAt(c+1)==="/"){const x=c+1;for(;++c&&!(v.charAt(c)===","||c===v.length););w.nsp=v.substring(x,c)}else w.nsp="/";const k=v.charAt(c+1);if(k!==""&&Number(k)==k){const x=c+1;for(;++c;){const E=v.charAt(c);if(E==null||Number(E)!=E){--c;break}if(c===v.length)break}w.id=Number(v.substring(x,c+1))}if(v.charAt(++c)){const x=this.tryParse(v.substr(c));if(a.isPayloadValid(w.type,x))w.data=x;else throw new Error("invalid payload")}return w}tryParse(v){try{return JSON.parse(v,this.reviver)}catch{return!1}}static isPayloadValid(v,c){switch(v){case u.CONNECT:return g(c);case u.DISCONNECT:return c===void 0;case u.CONNECT_ERROR:return typeof c=="string"||g(c);case u.EVENT:case u.BINARY_EVENT:return Array.isArray(c)&&(typeof c[0]=="number"||typeof c[0]=="string"&&l.indexOf(c[0])===-1);case u.ACK:case u.BINARY_ACK:return Array.isArray(c)}}destroy(){this.reconstructor&&(this.reconstructor.finishedReconstruction(),this.reconstructor=null)}}class m{constructor(v){this.packet=v,this.buffers=[],this.reconPack=v}takeBinaryData(v){if(this.buffers.push(v),this.buffers.length===this.reconPack.attachments){const c=Object(s.reconstructPacket)(this.reconPack,this.buffers);return this.finishedReconstruction(),c}return null}finishedReconstruction(){this.reconPack=null,this.buffers=[]}}},"./node_modules/socket.io-parser/build/esm/is-binary.js":function(n,t,r){r.r(t),r.d(t,"isBinary",function(){return u}),r.d(t,"hasBinary",function(){return _});const i=typeof ArrayBuffer=="function",s=g=>typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(g):g.buffer instanceof ArrayBuffer,o=Object.prototype.toString,l=typeof Blob=="function"||typeof Blob<"u"&&o.call(Blob)==="[object BlobConstructor]",f=typeof File=="function"||typeof File<"u"&&o.call(File)==="[object FileConstructor]";function u(g){return i&&(g instanceof ArrayBuffer||s(g))||l&&g instanceof Blob||f&&g instanceof File}function _(g,a){if(!g||typeof g!="object")return!1;if(Array.isArray(g)){for(let m=0,b=g.length;m<b;m++)if(_(g[m]))return!0;return!1}if(u(g))return!0;if(g.toJSON&&typeof g.toJSON=="function"&&arguments.length===1)return _(g.toJSON(),!0);for(const m in g)if(Object.prototype.hasOwnProperty.call(g,m)&&_(g[m]))return!0;return!1}},"./node_modules/webpack/buildin/global.js":function(n,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch{typeof window=="object"&&(r=window)}n.exports=r},"./node_modules/worker-loader/dist/workers/InlineWorker.js":function(n,t,r){var i=window.URL||window.webkitURL;n.exports=function(s,o){try{try{var l;try{var f=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder;l=new f,l.append(s),l=l.getBlob()}catch{l=new Blob([s])}return new Worker(i.createObjectURL(l))}catch{return new Worker("data:application/javascript,"+encodeURIComponent(s))}}catch{if(!o)throw Error("Inline worker is not supported");return new Worker(o)}}},"./package.json":function(n){n.exports=JSON.parse('{"name":"imjoy-rpc","version":"0.5.46","description":"Remote procedure calls for ImJoy.","module":"index.js","types":"index.d.ts","scripts":{"build":"rm -rf dist && npm run build-umd","build-umd":"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map ","watch":"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map","publish-npm":"npm install && npm run build && npm publish","serve":"webpack-dev-server","stats":"webpack --profile --json > stats.json","stats-prod":"webpack --profile --json --mode production > stats-prod.json","analyze":"webpack-bundle-analyzer -p 9999 stats.json","analyze-prod":"webpack-bundle-analyzer -p 9999 stats-prod.json","clean":"rimraf dist/*","deploy":"npm run build && node deploy-site.js","format":"prettier --write \\"{src,tests}/**/**\\"","check-format":"prettier --check \\"{src,tests}/**/**\\"","test":"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js","test-watch":"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug"},"repository":{"type":"git","url":"git+https://github.com/imjoy-team/imjoy-rpc.git"},"keywords":["imjoy","rpc"],"author":"imjoy-team <imjoy.team@gmail.com>","license":"MIT","bugs":{"url":"https://github.com/imjoy-team/imjoy-rpc/issues"},"homepage":"https://github.com/imjoy-team/imjoy-rpc","dependencies":{"@msgpack/msgpack":"^2.7.1","socket.io-client":"^4.6.2"},"devDependencies":{"@babel/core":"^7.16.12","@babel/plugin-syntax-dynamic-import":"^7.8.3","@babel/polyfill":"^7.12.1","@babel/preset-env":"^7.16.11","@types/requirejs":"^2.1.34","babel-core":"^6.26.0","babel-eslint":"^10.1.0","babel-loader":"^8.2.3","babel-runtime":"^6.26.0","chai":"^4.3.6","clean-webpack-plugin":"^0.1.19","copy-webpack-plugin":"^5.1.2","eslint":"^6.8.0","eslint-config-prettier":"^4.2.0","eslint-loader":"^4.0.2","file-loader":"^0.11.2","fs-extra":"^0.30.0","gh-pages":"^2.0.1","html-loader":"^0.5.5","html-webpack-plugin":"^3.2.0","json-loader":"^0.5.4","karma":"^6.3.12","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^1.3.0","karma-mocha":"^2.0.1","karma-sourcemap-loader":"^0.3.8","karma-spec-reporter":"0.0.32","karma-webpack":"^4.0.2","lerna":"^6.0.3","lodash.debounce":"^4.0.8","mocha":"^10.1.0","postcss":"^7.0.36","prettier":"^1.6.1","rimraf":"^2.6.2","schema-utils":"^0.4.3","style-loader":"^0.18.1","ts-loader":"^9.4.3","url-loader":"^0.5.9","webpack":"^4.46.0","webpack-bundle-analyzer":"^4.7.0","webpack-cli":"^3.3.12","webpack-dev-server":"^3.11.3","webpack-merge":"^4.1.1","workbox-webpack-plugin":"^4.3.1","worker-loader":"^2.0.0","write-file-webpack-plugin":"^4.5.1"},"eslintConfig":{"globals":{"document":true,"window":true}}}')},"./src/main.js":function(n,t,r){r.r(t),r.d(t,"waitForInitialization",function(){return m}),r.d(t,"setupRPC",function(){return b});var i=r("./src/plugin.webworker.js"),s=r.n(i),o=r("./src/pluginIframe.js"),l=r("./src/utils.js");r.d(t,"loadRequirements",function(){return l.loadRequirements});var f=r("./src/rpc.js");r.d(t,"RPC",function(){return f.RPC}),r.d(t,"API_VERSION",function(){return f.API_VERSION});var u=r("./package.json");r.d(t,"VERSION",function(){return u.version});function _(){try{return window.self!==window.top}catch{return!0}}function g(){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope}function a(v){if(!v.allow_execution)throw new Error("web-worker plugin can only work with allow_execution=true");let c=null;v.broadcastChannel&&(c=new BroadcastChannel(v.broadcastChannel));const w=new s.a,k=setTimeout(function(){w.terminate(),console.warn("Plugin failed to start as a web-worker, running in an iframe instead."),Object(o.default)(v)},2e3),x=Object(l.randId)();w.addEventListener("message",function(E){let O;const A=E.data;if(A.type==="worker-ready"){w.postMessage({type:"connectRPC",config:v}),clearTimeout(k);return}else A.type==="initialized"?(A.config=Object.assign({},v,A.config),A.origin=globalThis.location.origin,A.peer_id=x):A.type==="imjoy_remote_api_ready"?globalThis.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:null})):A.type==="cacheRequirements"&&typeof cache_requirements=="function"?cache_requirements(A.requirements):A.type==="disconnect"?w.terminate():A.__transferables__&&(O=A.__transferables__,delete A.__transferables__);c?c.postMessage(A):parent.postMessage(A,v.target_origin||"*",O)}),(c||window).addEventListener("message",function(E){if(E.type==="message"&&(c||v.target_origin==="*"||E.origin===v.target_origin)){let O;const A=E.data;A.__transferables__&&(O=A.__transferables__,delete A.__transferables__),A.peer_id===x?w.postMessage(A,O):v.debug&&console.log(`connection peer id mismatch ${A.peer_id} !== ${x}`)}})}function m(v){g()&&(globalThis.parent=self),v=v||{},v.enable_service_worker&&(Object(l.setupServiceWorker)(v.base_url,v.target_origin,v.cache_requirements),v.enable_service_worker=!1),v.cache_requirements&&delete v.cache_requirements;const c=v.target_origin||"*";if(v.credential_required&&typeof v.verify_credential!="function")throw new Error("Please also provide the `verify_credential` function with `credential_required`.");if(v.credential_required&&c==="*")throw new Error("`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.");const w=()=>{globalThis.removeEventListener("message",x)},k=Object(l.randId)(),x=E=>{if(E.type==="message"&&(!E.origin||c==="*"||E.origin===c))if(E.data.type==="initialize"){w(),E.data.peer_id!==k&&console.warn(`${E.data.config&&E.data.config.name}: connection peer id mismatch ${E.data.peer_id} !== ${k}`);const O=E.data.config;c!=="*"&&(O.target_origin=c),v.credential_required?v.verify_credential(O.credential).then(A=>{if(A&&A.auth&&!A.error)O.auth=A.auth,b(O).then(()=>{console.log("ImJoy RPC loaded successfully!")});else throw new Error("Failed to verify the credentail:"+(A&&A.error))}):b(O).then(()=>{console.log("ImJoy RPC loaded successfully!")})}else throw new Error(`unrecognized message: ${E.data}`)};globalThis.addEventListener("message",x),g()?parent.postMessage({type:"imjoyRPCReady",config:v,peer_id:k}):parent.postMessage({type:"imjoyRPCReady",config:v,peer_id:k},"*")}function b(v){return v=v||{},v.name=v.name||Object(l.randId)(),v=Object(l.normalizeConfig)(v),v.enable_service_worker&&Object(l.setupServiceWorker)(v.base_url,v.target_origin,v.cache_requirements),v.cache_requirements&&delete v.cache_requirements,new Promise((c,w)=>{const k=x=>{const E=x.detail;v.expose_api_globally&&(globalThis.api=E),c(E),globalThis.removeEventListener("imjoy_remote_api_ready",k)};if(_()){if(v.type==="web-worker")try{a(v)}catch{Object(o.default)(v)}else if(["rpc-window","rpc-worker","iframe","window"].includes(v.type))Object(o.default)(v);else{console.error("Unsupported plugin type: "+v.type),w("Unsupported plugin type: "+v.type);return}globalThis.addEventListener("imjoy_remote_api_ready",k)}else g()?Object(o.default)(v):w(new Error("imjoy-rpc should only run inside an iframe or a webworker."))})}},"./src/plugin.webworker.js":function(n,t,r){n.exports=function(){return r("./node_modules/worker-loader/dist/workers/InlineWorker.js")(`/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/plugin.webworker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\\
  !*** ./src/plugin.webworker.js ***!
  \\*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the routines loaded by the plugin Worker under web-browser.
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */




// make sure this runs inside a webworker
if (
  typeof WorkerGlobalScope === "undefined" ||
  !self ||
  !(self instanceof WorkerGlobalScope)
) {
  throw new Error("This script can only loaded in a webworker");
}

async function executeEsModule(content) {
  const dataUri =
    "data:text/javascript;charset=utf-8," + encodeURIComponent(content);
  await import(/* webpackIgnore: true */ dataUri);
}

/**
 * Connection object provided to the RPC constructor,
 * plugin site implementation for the web-based environment.
 * Global will be then cleared to prevent exposure into the
 * Worker, so we put this local connection object into a closure
 */
class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
  }
  connect() {
    self.addEventListener("message", e => {
      this._fire(e.data.type, e.data);
    });
    this.emit({
      type: "initialized",
      config: this.config
    });
  }
  disconnect() {
    this._fire("beforeDisconnect");
    self.close();
    this._fire("disconnected");
  }
  emit(data) {
    let transferables = undefined;
    if (data.__transferables__) {
      transferables = data.__transferables__;
      delete data.__transferables__;
    }
    self.postMessage(data, transferables);
  }
  async execute(code) {
    if (code.type === "requirements") {
      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirementsInWebworker"])(code.requirements);
    } else if (code.type === "script") {
      try {
        if (code.attrs.type === "module") {
          await executeEsModule(code.content);
        } else {
          eval(code.content);
        }
      } catch (e) {
        console.error(e.message, e.stack);
        throw e;
      }
    } else {
      throw "unsupported code type.";
    }
    if (code.type === "requirements") {
      self.postMessage({
        type: "cacheRequirements",
        requirements: code.requirements
      });
    }
  }
}
const config = {
  type: "web-worker",
  dedicated_thread: true,
  allow_execution: true,
  lang: "javascript",
  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"]
};
const conn = new Connection(config);
conn.on("connectRPC", data => {
  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(conn, Object.assign(data.config, config));
});
conn.connect();
self.postMessage({
  type: "worker-ready"
});


/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\\
  !*** ./src/pluginCore.js ***!
  \\***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectRPC", function() { return connectRPC; });
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/**
 * Core plugin script loaded into the plugin process/thread.
 *
 * Initializes the plugin-site API global methods.
 */

function connectRPC(connection, config) {
  config = config || {};
  const codecs = {};
  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__["RPC"](connection, config, codecs);
  rpc.on("getInterface", function () {
    launchConnected();
  });
  rpc.on("remoteReady", function () {
    const api = rpc.getRemote() || {};

    api.registerCodec = function (config) {
      if (!config["name"] || !config["encoder"] && !config["decoder"]) {
        throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");
      } else {
        if (config.type) {
          for (let k of Object.keys(codecs)) {
            if (codecs[k].type === config.type || k === config.name) {
              delete codecs[k];
              console.warn("Remove duplicated codec: " + k);
            }
          }
        }

        codecs[config["name"]] = config;
      }
    };

    api.init = function (config) {
      // register a minimal plugin api
      rpc.setInterface({
        setup() {}

      }, config);
    };

    api.disposeObject = function (obj) {
      rpc.disposeObject(obj);
    };

    api.export = function (_interface, config) {
      rpc.setInterface(_interface, config);
    };

    api.onLoad = function (handler) {
      handler = checkHandler(handler);

      if (connected) {
        handler();
      } else {
        connectedHandlers.push(handler);
      }
    };

    api.dispose = function (_interface) {
      rpc.disconnect();
    };

    api._rpc = rpc;

    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
      self.api = api;
      self.postMessage({
        type: "imjoy_remote_api_ready"
      });
      self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    } else if (typeof window) {
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    }
  });
  let connected = false;
  const connectedHandlers = [];

  const launchConnected = function () {
    if (!connected) {
      connected = true;
      let handler;

      while (handler = connectedHandlers.pop()) {
        handler();
      }
    }
  };

  const checkHandler = function (handler) {
    const type = typeof handler;

    if (type !== "function") {
      const msg = "A function may only be subsribed to the event, " + type + " was provided instead";
      throw new Error(msg);
    }

    return handler;
  };

  return rpc;
}

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\\
  !*** ./src/rpc.js ***!
  \\********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return API_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return RPC; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the RPC object used both by the application
 * site, and by each plugin
 */

const API_VERSION = "0.2.3";
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;

function _appendBuffer(buffer1, buffer2) {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
}

function indexObject(obj, is) {
  if (!is) throw new Error("undefined index");
  if (typeof is === "string") return indexObject(obj, is.split("."));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));
}
/**
 * RPC object represents a single site in the
 * communication protocol between the application and the plugin
 *
 * @param {Object} connection a special object allowing to send
 * and receive messages from the opposite site (basically it
 * should only provide send() and onMessage() methods)
 */


class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(connection, config, codecs) {
    super(config && config.debug);
    this._connection = connection;
    this.config = config || {};
    this._codecs = codecs || {};
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._remote_set = false; // make sure there is an execute function

    const name = this.config.name;

    this._connection.execute = this._connection.execute || function () {
      throw new Error(\`connection.execute not implemented (in "\${name}")\`);
    };

    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();

    this._method_refs.onReady(() => {
      this._fire("remoteIdle");
    });

    this._method_refs.onBusy(() => {
      this._fire("remoteBusy");
    });

    this._setupMessageHanlders();
  }

  init() {
    this._connection.emit({
      type: "initialized",
      config: this.config,
      peer_id: this._connection.peer_id
    });
  }

  setConfig(config) {
    if (config) for (const k of Object.keys(config)) {
      this.config[k] = config[k];
    }
  }
  /**
   * Set a handler to be called when received a responce from the
   * remote site reporting that the previously provided interface
   * has been successfully set as remote for that site
   *
   * @param {Function} handler
   */


  getRemoteCallStack() {
    return this._method_refs.getStack();
  }
  /**
   * @returns {Object} set of remote interface methods
   */


  getRemote() {
    return this._remote_interface;
  }
  /**
   * Sets the interface of this site making it available to the
   * remote site by sending a message with a set of methods names
   *
   * @param {Object} _interface to set
   */


  setInterface(_interface, config) {
    config = config || {};
    this.config.name = config.name || this.config.name;
    this.config.description = config.description || this.config.description;

    if (this.config.forwarding_functions) {
      for (let func_name of this.config.forwarding_functions) {
        const _remote = this._remote_interface;

        if (_remote[func_name]) {
          if (_interface.constructor === Object) {
            if (!_interface[func_name]) {
              _interface[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          } else if (_interface.constructor.constructor === Function) {
            if (!_interface.constructor.prototype[func_name]) {
              _interface.constructor.prototype[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          }
        }
      }
    }

    this._local_api = _interface;
    if (!this._remote_set) this._fire("interfaceAvailable");else this.sendInterface();
    return new Promise(resolve => {
      this.once("interfaceSetAsRemote", resolve);
    });
  }
  /**
   * Sends the actual interface to the remote site upon it was
   * updated or by a special request of the remote site
   */


  sendInterface() {
    if (!this._local_api) {
      throw new Error("interface is not set.");
    }

    this._encode(this._local_api, true).then(api => {
      this._connection.emit({
        type: "setInterface",
        api: api
      });
    });
  }

  _disposeObject(objectId) {
    if (this._object_store[objectId]) {
      delete this._object_store[objectId];
    } else {
      throw new Error(\`Object (id=\${objectId}) not found.\`);
    }
  }

  disposeObject(obj) {
    return new Promise((resolve, reject) => {
      if (this._object_weakmap.has(obj)) {
        const objectId = this._object_weakmap.get(obj);

        this._connection.once("disposed", data => {
          if (data.error) reject(new Error(data.error));else resolve();
        });

        this._connection.emit({
          type: "disposeObject",
          object_id: objectId
        });
      } else {
        throw new Error("Invalid object");
      }
    });
  }
  /**
   * Handles a message from the remote site
   */


  _setupMessageHanlders() {
    this._connection.on("init", this.init);

    this._connection.on("execute", data => {
      Promise.resolve(this._connection.execute(data.code)).then(() => {
        this._connection.emit({
          type: "executed"
        });
      }).catch(e => {
        console.error(e);

        this._connection.emit({
          type: "executed",
          error: String(e)
        });
      });
    });

    this._connection.on("method", async data => {
      let resolve, reject, method, method_this, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        const _interface = this._object_store[data.object_id];
        method = indexObject(_interface, data.name);

        if (data.name.includes(".")) {
          const tmp = data.name.split(".");
          const intf_index = tmp.slice(0, tmp.length - 1).join(".");
          method_this = indexObject(_interface, intf_index);
        } else {
          method_this = _interface;
        }

        args = await this._unwrap(data.args, true);

        if (data.promise) {
          result = method.apply(method_this, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method.apply(method_this, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("callback", async data => {
      let resolve, reject, method, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        if (data.promise) {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          result = method.apply(null, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          method.apply(null, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("disposeObject", data => {
      try {
        this._disposeObject(data.object_id);

        this._connection.emit({
          type: "disposed"
        });
      } catch (e) {
        console.error(e);

        this._connection.emit({
          type: "disposed",
          error: String(e)
        });
      }
    });

    this._connection.on("setInterface", data => {
      this._setRemoteInterface(data.api);
    });

    this._connection.on("getInterface", () => {
      this._fire("getInterface");

      if (this._local_api) {
        this.sendInterface();
      } else {
        this.once("interfaceAvailable", () => {
          this.sendInterface();
        });
      }
    });

    this._connection.on("interfaceSetAsRemote", () => {
      this._remote_set = true;

      this._fire("interfaceSetAsRemote");
    });

    this._connection.on("disconnect", () => {
      this._fire("beforeDisconnect");

      this._connection.disconnect();

      this._fire("disconnected");
    });
  }
  /**
   * Sends a requests to the remote site asking it to provide its
   * current interface
   */


  requestRemote() {
    this._connection.emit({
      type: "getInterface"
    });
  }

  _ndarray(typedArray, shape, dtype) {
    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(typedArray);

    if (dtype && dtype !== _dtype) {
      throw "dtype doesn't match the type of the array: " + _dtype + " != " + dtype;
    }

    shape = shape || [typedArray.length];
    return {
      _rtype: "ndarray",
      _rvalue: typedArray.buffer,
      _rshape: shape,
      _rdtype: _dtype
    };
  }
  /**
   * Sets the new remote interface provided by the other site
   *
   * @param {Array} names list of function names
   */


  _setRemoteInterface(api) {
    this._decode(api).then(intf => {
      // update existing interface instead of recreating it
      // this will preserve the object reference
      if (this._remote_interface) {
        // clear the interface
        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces


        Object.assign(this._remote_interface, intf);
      } else this._remote_interface = intf;

      this._fire("remoteReady");

      this._reportRemoteSet();
    });
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * method. When the generated function is called, it will send the
   * corresponding message to the remote site asking it to execute
   * the particular method of its interface
   *
   * @param {String} name of the remote method
   *
   * @returns {Function} wrapped remote method
   */


  _genRemoteMethod(targetId, name, objectId) {
    const me = this;

    const remoteMethod = function () {
      return new Promise(async (resolve, reject) => {
        let id = null;

        try {
          id = me._method_refs.put(objectId ? objectId + "/" + name : name);

          const wrapped_resolve = function () {
            if (id !== null) me._method_refs.fetch(id);
            return resolve.apply(this, arguments);
          };

          const wrapped_reject = function () {
            if (id !== null) me._method_refs.fetch(id);
            return reject.apply(this, arguments);
          };

          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together

          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;
          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;
          let args = Array.prototype.slice.call(arguments);
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;

          if (name === "register" || name === "registerService" || name === "register_service" || name === "export" || name === "on") {
            args = await me._wrap(args, true);
          } else {
            args = await me._wrap(args);
          }

          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;

          me._connection.emit({
            type: "method",
            target_id: targetId,
            name: name,
            object_id: objectId,
            args: args,
            promise: encodedPromise,
            with_kwargs: withKwargs
          }, transferables);
        } catch (e) {
          if (id) me._method_refs.fetch(id);
          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);
        }
      });
    };

    remoteMethod.__remote_method = true;
    return remoteMethod;
  }
  /**
   * Sends a responce reporting that interface just provided by the
   * remote site was successfully set by this site as remote
   */


  _reportRemoteSet() {
    this._connection.emit({
      type: "interfaceSetAsRemote"
    });
  }
  /**
   * Prepares the provided set of remote method arguments for
   * sending to the remote site, replaces all the callbacks with
   * identifiers
   *
   * @param {Array} args to wrap
   *
   * @returns {Array} wrapped arguments
   */


  async _encode(aObject, asInterface, objectId) {
    const aType = typeof aObject;

    if (aType === "number" || aType === "string" || aType === "boolean" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {
      return aObject;
    }

    let bObject;

    if (typeof aObject === "function") {
      if (asInterface) {
        if (!objectId) throw new Error("objectId is not specified.");
        bObject = {
          _rtype: "interface",
          _rtarget_id: this._connection.peer_id,
          _rintf: objectId,
          _rvalue: asInterface
        };

        this._method_weakmap.set(aObject, bObject);
      } else if (this._method_weakmap.has(aObject)) {
        bObject = this._method_weakmap.get(aObject);
      } else {
        const cid = this._store.put(aObject);

        bObject = {
          _rtype: "callback",
          _rtarget_id: this._connection.peer_id,
          _rname: aObject.constructor && aObject.constructor.name || cid,
          _rvalue: cid
        };
      }

      return bObject;
    } // skip if already encoded


    if (aObject.constructor instanceof Object && aObject._rtype) {
      // make sure the interface functions are encoded
      if (aObject._rintf) {
        const temp = aObject._rtype;
        delete aObject._rtype;
        bObject = await this._encode(aObject, asInterface, objectId);
        bObject._rtype = temp;
      } else {
        bObject = aObject;
      }

      return bObject;
    }

    const transferables = [];
    const _transfer = aObject._transfer;
    const isarray = Array.isArray(aObject);

    for (let tp of Object.keys(this._codecs)) {
      const codec = this._codecs[tp];

      if (codec.encoder && aObject instanceof codec.type) {
        // TODO: what if multiple encoders found
        let encodedObj = await Promise.resolve(codec.encoder(aObject));
        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object

        if (encodedObj && encodedObj._rintf) {
          const temp = encodedObj._rtype;
          delete encodedObj._rtype;
          encodedObj = await this._encode(encodedObj, asInterface, objectId);
          encodedObj._rtype = temp;
        }

        bObject = encodedObj;
        return bObject;
      }
    }

    if (
    /*global tf*/
    typeof tf !== "undefined" && tf.Tensor && aObject instanceof tf.Tensor) {
      const v_buffer = aObject.dataSync();

      if (aObject._transfer || _transfer) {
        transferables.push(v_buffer.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: v_buffer.buffer,
        _rshape: aObject.shape,
        _rdtype: aObject.dtype
      };
    } else if (
    /*global nj*/
    typeof nj !== "undefined" && nj.NdArray && aObject instanceof nj.NdArray) {
      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject.selection.data);

      if (aObject._transfer || _transfer) {
        transferables.push(aObject.selection.data.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: aObject.selection.data.buffer,
        _rshape: aObject.shape,
        _rdtype: dtype
      };
    } else if (aObject instanceof Error) {
      console.error(aObject);
      bObject = {
        _rtype: "error",
        _rvalue: aObject.toString()
      };
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } // send objects supported by structure clone algorithm
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== "undefined" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== "undefined" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== "undefined" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== "undefined" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== "undefined" && aObject instanceof FileSystemWritableFileStream) {
      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rname: aObject.name,
        _rmime: aObject.type,
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } else if (aObject instanceof Blob) {
      bObject = {
        _rtype: "blob",
        _rvalue: aObject
      };
    } else if (aObject instanceof ArrayBufferView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject);
      bObject = {
        _rtype: "typedarray",
        _rvalue: aObject.buffer,
        _rdtype: dtype
      };
    } else if (aObject instanceof DataView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "memoryview",
        _rvalue: aObject.buffer
      };
    } else if (aObject instanceof Set) {
      bObject = {
        _rtype: "set",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject instanceof Map) {
      bObject = {
        _rtype: "orderedmap",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {
      bObject = isarray ? [] : {};
      let keys; // an object/array

      if (aObject.constructor === Object || Array.isArray(aObject)) {
        keys = Object.keys(aObject);
      } // a class
      else if (aObject.constructor === Function) {
        throw new Error("Please instantiate the class before exportting it.");
      } // instance of a class
      else if (aObject.constructor.constructor === Function) {
        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object
        // always encode class instance as interface

        asInterface = true;
      } else {
        throw Error("Unsupported interface type");
      }

      let hasFunction = false; // encode interfaces

      if (aObject._rintf || asInterface) {
        if (!objectId) {
          if (typeof aObject._rintf === "string" && aObject._rintf.length > 0) {
            objectId = aObject._rintf; // enable custom object id
          } else {
            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
          } // Note: object with the same id will be overwritten


          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);
          this._object_store[objectId] = aObject;
        }

        for (let k of keys) {
          if (k === "constructor") continue;

          if (k.startsWith("_")) {
            continue;
          }

          bObject[k] = await this._encode(aObject[k], typeof asInterface === "string" ? asInterface + "." + k : k, objectId);

          if (typeof aObject[k] === "function") {
            hasFunction = true;
          }
        } // object id for dispose the object remotely


        if (hasFunction) bObject._rintf = objectId; // remove interface when closed

        if (aObject.on && typeof aObject.on === "function") {
          aObject.on("close", () => {
            delete this._object_store[objectId];
          });
        }
      } else {
        for (let k of keys) {
          if (["hasOwnProperty", "constructor"].includes(k)) continue;
          bObject[k] = await this._encode(aObject[k]);
        }
      } // for example, browserFS object

    } else if (typeof aObject === "object") {
      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));
      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();

      for (let k of keys) {
        if (["hasOwnProperty", "constructor"].includes(k)) continue; // encode as interface

        bObject[k] = await this._encode(aObject[k], k, bObject);
      } // object id, used for dispose the object


      bObject._rintf = objectId;
    } else {
      throw "imjoy-rpc: Unsupported data type:" + aObject;
    }

    if (transferables.length > 0) {
      bObject.__transferables__ = transferables;
    }

    if (!bObject) {
      throw new Error("Failed to encode object");
    }

    return bObject;
  }

  async _decode(aObject, withPromise) {
    if (!aObject) {
      return aObject;
    }

    let bObject;

    if (aObject["_rtype"]) {
      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          aObject = await this._decode(aObject, withPromise);
          aObject._rtype = temp;
        }

        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));
      } else if (aObject._rtype === "callback") {
        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);
      } else if (aObject._rtype === "interface") {
        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);
      } else if (aObject._rtype === "ndarray") {
        /*global nj tf*/
        //create build array/tensor if used in the plugin
        if (typeof nj !== "undefined" && nj.array) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);
        } else if (typeof tf !== "undefined" && tf.Tensor) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);
        } else {
          //keep it as regular if transfered to the main app
          bObject = aObject;
        }
      } else if (aObject._rtype === "error") {
        bObject = new Error(aObject._rvalue);
      } else if (aObject._rtype === "file") {
        if (aObject._rvalue instanceof File) {
          bObject = aObject._rvalue; //patch _path

          bObject._path = aObject._rpath;
        } else {
          bObject = new File([aObject._rvalue], aObject._rname, {
            type: aObject._rmime
          });
          bObject._path = aObject._rpath;
        }
      } else if (aObject._rtype === "typedarray") {
        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
        if (!arraytype) throw new Error("unsupported dtype: " + aObject._rdtype);
        bObject = new arraytype(aObject._rvalue);
      } else if (aObject._rtype === "memoryview") {
        bObject = new DataView(aObject._rvalue);
      } else if (aObject._rtype === "blob") {
        if (aObject._rvalue instanceof Blob) {
          bObject = aObject._rvalue;
        } else {
          bObject = new Blob([aObject._rvalue], {
            type: aObject._rmime
          });
        }
      } else if (aObject._rtype === "orderedmap") {
        bObject = new Map(await this._decode(aObject._rvalue, withPromise));
      } else if (aObject._rtype === "set") {
        bObject = new Set(await this._decode(aObject._rvalue, withPromise));
      } else {
        // make sure all the interface functions are decoded
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          bObject = await this._decode(aObject, withPromise);
          bObject._rtype = temp;
        } else bObject = aObject;
      }
    } else if (aObject.constructor === Object || Array.isArray(aObject)) {
      const isarray = Array.isArray(aObject);
      bObject = isarray ? [] : {};

      for (let k of Object.keys(aObject)) {
        if (isarray || aObject.hasOwnProperty(k)) {
          const v = aObject[k];
          bObject[k] = await this._decode(v, withPromise);
        }
      }
    } else {
      bObject = aObject;
    }

    if (bObject === undefined) {
      throw new Error("Failed to decode object");
    } // store the object id for dispose


    if (aObject._rintf) {
      this._object_weakmap.set(bObject, aObject._rintf);
    }

    return bObject;
  }

  async _wrap(args, asInterface) {
    return await this._encode(args, asInterface);
  }
  /**
   * Unwraps the set of arguments delivered from the remote site,
   * replaces all callback identifiers with a function which will
   * initiate sending that callback identifier back to other site
   *
   * @param {Object} args to unwrap
   *
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Array} unwrapped args
   */


  async _unwrap(args, withPromise) {
    return await this._decode(args, withPromise);
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * callback. When the generated function is called, it will send
   * the corresponding message to the remote site asking it to
   * execute the particular callback previously saved during a call
   * by the remote site a method from the interface of this site
   *
   * @param {Number} id of the remote callback to execute
   * @param {Number} argNum argument index of the callback
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Function} wrapped remote callback
   */


  _genRemoteCallback(targetId, cid, withPromise) {
    const me = this;
    let remoteCallback;

    if (withPromise) {
      remoteCallback = function () {
        return new Promise(async (resolve, reject) => {
          const args = await me._wrap(Array.prototype.slice.call(arguments));
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;
          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;
          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together

          resolve.__promise_pair = encodedPromise[1]._rvalue;
          reject.__promise_pair = encodedPromise[0]._rvalue;

          try {
            me._connection.emit({
              type: "callback",
              target_id: targetId,
              id: cid,
              args: args,
              promise: encodedPromise,
              with_kwargs: withKwargs
            }, transferables);
          } catch (e) {
            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);
          }
        });
      };

      return remoteCallback;
    } else {
      remoteCallback = async function () {
        const args = await me._wrap(Array.prototype.slice.call(arguments));
        const argLength = args.length; // if the last argument is an object, mark it as kwargs

        const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
        if (withKwargs) delete args[argLength - 1]._rkwargs;
        const transferables = args.__transferables__;
        if (transferables) delete args.__transferables__;
        return me._connection.emit({
          type: "callback",
          target_id: targetId,
          id: cid,
          args: args,
          with_kwargs: withKwargs
        }, transferables);
      };

      return remoteCallback;
    }
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
    this._remote_interface = null;
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();
  }
  /**
   * Sends the notification message and breaks the connection
   */


  disconnect() {
    this._connection.emit({
      type: "disconnect"
    });

    this.reset();
    setTimeout(() => {
      this._connection.disconnect();
    }, 2000);
  }

}
/**
 * ReferenceStore is a special object which stores other objects
 * and provides the references (number) instead. This reference
 * may then be sent over a json-based communication channel (IPC
 * to another Node.js process or a message to the Worker). Other
 * site may then provide the reference in the responce message
 * implying the given object should be activated.
 *
 * Primary usage for the ReferenceStore is a storage for the
 * callbacks, which therefore makes it possible to initiate a
 * callback execution by the opposite site (which normally cannot
 * directly execute functions over the communication channel).
 *
 * Each stored object can only be fetched once and is not
 * available for the second time. Each stored object must be
 * fetched, since otherwise it will remain stored forever and
 * consume memory.
 *
 * Stored object indeces are simply the numbers, which are however
 * released along with the objects, and are later reused again (in
 * order to postpone the overflow, which should not likely happen,
 * but anyway).
 */

class ReferenceStore {
  constructor() {
    this._store = {}; // stored object

    this._indices = [0]; // smallest available indices

    this._readyHandler = function () {};

    this._busyHandler = function () {};

    this._readyHandler();
  }
  /**
   * call handler when the store is empty
   *
   * @param {FUNCTION} id of a handler
   */


  onReady(readyHandler) {
    this._readyHandler = readyHandler || function () {};
  }
  /**
   * call handler when the store is not empty
   *
   * @param {FUNCTION} id of a handler
   */


  onBusy(busyHandler) {
    this._busyHandler = busyHandler || function () {};
  }
  /**
   * get the length of the store
   *
   */


  getStack() {
    return Object.keys(this._store).length;
  }
  /**
   * @function _genId() generates the new reference id
   *
   * @returns {Number} smallest available id and reserves it
   */


  _genId() {
    let id;

    if (this._indices.length === 1) {
      id = this._indices[0]++;
    } else {
      id = this._indices.shift();
    }

    return id;
  }
  /**
   * Releases the given reference id so that it will be available by
   * another object stored
   *
   * @param {Number} id to release
   */


  _releaseId(id) {
    for (let i = 0; i < this._indices.length; i++) {
      if (id < this._indices[i]) {
        this._indices.splice(i, 0, id);

        break;
      }
    } // cleaning-up the sequence tail


    for (let i = this._indices.length - 1; i >= 0; i--) {
      if (this._indices[i] - 1 === this._indices[i - 1]) {
        this._indices.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Stores the given object and returns the refernce id instead
   *
   * @param {Object} obj to store
   *
   * @returns {Number} reference id of the stored object
   */


  put(obj) {
    if (this._busyHandler && Object.keys(this._store).length === 0) {
      this._busyHandler();
    }

    const id = this._genId();

    this._store[id] = obj;
    return id;
  }
  /**
   * Retrieves previously stored object and releases its reference
   *
   * @param {Number} id of an object to retrieve
   */


  fetch(id) {
    const obj = this._store[id];

    if (obj && !obj.__remote_method) {
      delete this._store[id];

      this._releaseId(id);

      if (this._readyHandler && Object.keys(this._store).length === 0) {
        this._readyHandler();
      }
    }

    if (obj && obj.__promise_pair) {
      this.fetch(obj.__promise_pair);
    }

    return obj;
  }

}

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\\
  !*** ./src/utils.js ***!
  \\**********************/
/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dtypeToTypedArray", function() { return dtypeToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWindow", function() { return loadRequirementsInWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWebworker", function() { return loadRequirementsInWebworker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return loadRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeConfig", function() { return normalizeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtypeMapping", function() { return typedArrayToDtypeMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtype", function() { return typedArrayToDtype; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheRequirements", function() { return cacheRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupServiceWorker", function() { return setupServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlJoin", function() { return urlJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
function randId() {
  return Math.random().toString(36).substr(2, 10) + new Date().getTime();
}
const dtypeToTypedArray = {
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  float32: Float32Array,
  float64: Float64Array,
  array: Array
};
async function loadRequirementsInWindow(requirements) {
  function _importScript(url) {
    //url is URL of external file, implementationCode is the code
    //to be called from the file, location is the location to
    //insert the <script> element
    return new Promise((resolve, reject) => {
      var scriptTag = document.createElement("script");
      scriptTag.src = url;
      scriptTag.type = "text/javascript";
      scriptTag.onload = resolve;

      scriptTag.onreadystatechange = function () {
        if (this.readyState === "loaded" || this.readyState === "complete") {
          resolve();
        }
      };

      scriptTag.onerror = reject;
      document.head.appendChild(scriptTag);
    });
  } // support importScripts outside web worker


  async function importScripts() {
    var args = Array.prototype.slice.call(arguments),
        len = args.length,
        i = 0;

    for (; i < len; i++) {
      await _importScript(args[i]);
    }
  }

  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      var link_node;
      requirements = typeof requirements === "string" ? [requirements] : requirements;

      if (Array.isArray(requirements)) {
        for (var i = 0; i < requirements.length; i++) {
          if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
            if (requirements[i].startsWith("css:")) {
              requirements[i] = requirements[i].slice(4);
            }

            link_node = document.createElement("link");
            link_node.rel = "stylesheet";
            link_node.href = requirements[i];
            document.head.appendChild(link_node);
          } else if (requirements[i].toLowerCase().endsWith(".mjs") || requirements[i].startsWith("mjs:")) {
            // import esmodule
            if (requirements[i].startsWith("mjs:")) {
              requirements[i] = requirements[i].slice(4);
            }

            await import(
            /* webpackIgnore: true */
            requirements[i]);
          } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
            if (requirements[i].startsWith("js:")) {
              requirements[i] = requirements[i].slice(3);
            }

            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("http")) {
            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("cache:")) {//ignore cache
          } else {
            console.log("Unprocessed requirements url: " + requirements[i]);
          }
        }
      } else {
        throw "unsupported requirements definition";
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
async function loadRequirementsInWebworker(requirements) {
  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      if (!Array.isArray(requirements)) {
        requirements = [requirements];
      }

      for (var i = 0; i < requirements.length; i++) {
        if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
          throw "unable to import css in a webworker";
        } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
          if (requirements[i].startsWith("js:")) {
            requirements[i] = requirements[i].slice(3);
          }

          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("http")) {
          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("cache:")) {//ignore cache
        } else {
          console.log("Unprocessed requirements url: " + requirements[i]);
        }
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
function loadRequirements(requirements) {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return loadRequirementsInWebworker(requirements);
  } else {
    return loadRequirementsInWindow(requirements);
  }
}
function normalizeConfig(config) {
  config.version = config.version || "0.1.0";
  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;
  config.type = config.type || "rpc-window";
  config.id = config.id || randId();
  config.target_origin = config.target_origin || "*";
  config.allow_execution = config.allow_execution || false; // remove functions

  config = Object.keys(config).reduce((p, c) => {
    if (typeof config[c] !== "function") p[c] = config[c];
    return p;
  }, {});
  return config;
}
const typedArrayToDtypeMapping = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};
const typedArrayToDtypeKeys = [];

for (const arrType of Object.keys(typedArrayToDtypeMapping)) {
  typedArrayToDtypeKeys.push(eval(arrType));
}

function typedArrayToDtype(obj) {
  let dtype = typedArrayToDtypeMapping[obj.constructor.name];

  if (!dtype) {
    const pt = Object.getPrototypeOf(obj);

    for (const arrType of typedArrayToDtypeKeys) {
      if (pt instanceof arrType) {
        dtype = typedArrayToDtypeMapping[arrType.name];
        break;
      }
    }
  }

  return dtype;
}

function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}

async function cacheRequirements(requirements) {
  requirements = requirements || [];

  if (!Array.isArray(requirements)) {
    requirements = [requirements];
  }

  for (let req of requirements) {
    //remove prefix
    if (req.startsWith("js:")) req = req.slice(3);
    if (req.startsWith("css:")) req = req.slice(4);
    if (req.startsWith("cache:")) req = req.slice(6);
    if (!req.startsWith("http")) continue;
    await cacheUrlInServiceWorker(req).catch(e => {
      console.error(e);
    });
  }
}
function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {
  // register service worker for offline access
  if ("serviceWorker" in navigator) {
    baseUrl = baseUrl || "/";
    navigator.serviceWorker.register(baseUrl + "plugin-service-worker.js").then(function (registration) {
      // Registration was successful
      console.log("ServiceWorker registration successful with scope: ", registration.scope);
    }, function (err) {
      // registration failed :(
      console.log("ServiceWorker registration failed: ", err);
    });
    targetOrigin = targetOrigin || "*";
    cacheCallback = cacheCallback || cacheRequirements;

    if (cacheCallback && typeof cacheCallback !== "function") {
      throw new Error("config.cache_requirements must be a function");
    }

    window.addEventListener("message", function (e) {
      if (targetOrigin === "*" || e.origin === targetOrigin) {
        const m = e.data;

        if (m.type === "cacheRequirements") {
          cacheCallback(m.requirements);
        }
      }
    });
  }
} //#Source https://bit.ly/2neWfJ2

function urlJoin(...args) {
  return args.join("/").replace(/[\\/]+/g, "/").replace(/^(.+):\\//, "$1://").replace(/^file:/, "file:/").replace(/\\/(\\?|&|#[^!])/g, "$1").replace(/\\?/g, "&").replace("&", "?");
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}

/***/ })

/******/ });
//# sourceMappingURL=plugin.webworker.js.map`,null)}},"./src/pluginCore.js":function(n,t,r){r.r(t),r.d(t,"connectRPC",function(){return s});var i=r("./src/rpc.js");function s(o,l){l=l||{};const f={},u=new i.RPC(o,l,f);u.on("getInterface",function(){a()}),u.on("remoteReady",function(){const b=u.getRemote()||{};b.registerCodec=function(v){if(!v.name||!v.encoder&&!v.decoder)throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");if(v.type)for(let c of Object.keys(f))(f[c].type===v.type||c===v.name)&&(delete f[c],console.warn("Remove duplicated codec: "+c));f[v.name]=v},b.init=function(v){u.setInterface({setup(){}},v)},b.disposeObject=function(v){u.disposeObject(v)},b.export=function(v,c){u.setInterface(v,c)},b.onLoad=function(v){v=m(v),_?v():g.push(v)},b.dispose=function(v){u.disconnect()},b._rpc=u,typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?(self.api=b,self.postMessage({type:"imjoy_remote_api_ready"}),self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:b}))):window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready",{detail:b}))});let _=!1;const g=[],a=function(){if(!_){_=!0;let b;for(;b=g.pop();)b()}},m=function(b){const v=typeof b;if(v!=="function"){const c="A function may only be subsribed to the event, "+v+" was provided instead";throw new Error(c)}return b};return u}},"./src/pluginIframe.js":function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"Connection",function(){return Connection}),__webpack_require__.d(__webpack_exports__,"default",function(){return setupIframe});var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./src/pluginCore.js"),_rpc_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./src/rpc.js"),_utils_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./src/utils.js");function _htmlToElement(n){var t=document.createElement("template");return n=n.trim(),t.innerHTML=n,t.content.firstChild}const _inWebWorker=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope;async function executeEsModule(n){const t="data:text/javascript;charset=utf-8,"+encodeURIComponent(n);await __vitePreload(()=>import(t),__vite__mapDeps([]))}class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.MessageEmitter{constructor(n){super(n&&n.debug),this.config=n||{},this.peer_id=Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__.randId)()}connect(){this.config.target_origin=this.config.target_origin||"*",this.config.broadcastChannel?this.broadcastChannel=new BroadcastChannel(this.config.broadcastChannel):this.broadcastChannel=null,this.broadcastChannel?this.broadcastChannel.addEventListener("message",this):globalThis.addEventListener("message",this),this.emit({type:"initialized",config:this.config,origin:globalThis.location.origin,peer_id:this.peer_id}),this._fire("connected")}handleEvent(n){n.type==="message"&&(this.broadcastChannel||this.config.target_origin==="*"||!n.origin||n.origin===this.config.target_origin)&&(n.data.peer_id===this.peer_id?this._fire(n.data.type,n.data):this.config.debug&&console.log(`connection peer id mismatch ${n.data.peer_id} !== ${this.peer_id}`))}disconnect(){this._fire("beforeDisconnect"),globalThis.removeEventListener("message",this),this._fire("disconnected")}emit(n){let t;this.broadcastChannel?this.broadcastChannel.postMessage(n):n.__transferables__?(t=n.__transferables__,delete n.__transferables__):_inWebWorker?self.postMessage(n,t):parent.postMessage(n,this.config.target_origin,t)}async execute(code){try{if(code.type==="requirements")await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__.loadRequirementsInWindow)(code.requirements);else if(code.type==="script")if(code.src){var script_node=document.createElement("script");script_node.setAttribute("type",code.attrs.type),script_node.setAttribute("src",code.src),document.head.appendChild(script_node)}else if(code.content&&code.attrs.lang==="javascript")code.attrs.type==="module"?await executeEsModule(code.content):eval(code.content);else{var node=document.createElement("script");for(let n in code.attrs)node.setAttribute(n,code.attrs[n]);node.appendChild(document.createTextNode(code.content)),document.body.appendChild(node)}else if(code.type==="style"){const n=document.createElement("style");code.src&&(n.src=code.src),n.innerHTML=code.content,document.head.appendChild(n)}else if(code.type==="link"){const n=document.createElement("link");code.rel&&(n.rel=code.rel),code.href&&(n.href=code.href),code.attrs&&code.attrs.type&&(n.type=code.attrs.type),document.head.appendChild(n)}else if(code.type==="html")document.body.appendChild(_htmlToElement(code.content));else throw"unsupported code type.";_inWebWorker?self.postMessage({type:"executed"}):parent.postMessage({type:"executed"},this.config.target_origin)}catch(n){console.error("failed to execute scripts: ",code,n),_inWebWorker?self.postMessage({type:"executed",error:n.stack||String(n)}):parent.postMessage({type:"executed",error:n.stack||String(n)},this.config.target_origin)}}}function setupIframe(n){n=n||{},n.dedicated_thread=!1,n.lang="javascript",n.api_version=_rpc_js__WEBPACK_IMPORTED_MODULE_1__.API_VERSION;const t=new Connection(n);Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__.connectRPC)(t,n),t.connect()}},"./src/rpc.js":function(n,t,r){r.r(t),r.d(t,"API_VERSION",function(){return s}),r.d(t,"RPC",function(){return u});var i=r("./src/utils.js");const s="0.2.3",o=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor;function l(g,a){const m=new Uint8Array(g.byteLength+a.byteLength);return m.set(new Uint8Array(g),0),m.set(new Uint8Array(a),g.byteLength),m.buffer}function f(g,a){if(!a)throw new Error("undefined index");return typeof a=="string"?f(g,a.split(".")):a.length===0?g:f(g[a[0]],a.slice(1))}class u extends i.MessageEmitter{constructor(a,m,b){super(m&&m.debug),this._connection=a,this.config=m||{},this._codecs=b||{},this._object_store={},this._method_weakmap=new WeakMap,this._object_weakmap=new WeakMap,this._local_api=null,this._remote_set=!1;const v=this.config.name;this._connection.execute=this._connection.execute||function(){throw new Error(`connection.execute not implemented (in "${v}")`)},this._store=new _,this._method_refs=new _,this._method_refs.onReady(()=>{this._fire("remoteIdle")}),this._method_refs.onBusy(()=>{this._fire("remoteBusy")}),this._setupMessageHanlders()}init(){this._connection.emit({type:"initialized",config:this.config,peer_id:this._connection.peer_id})}setConfig(a){if(a)for(const m of Object.keys(a))this.config[m]=a[m]}getRemoteCallStack(){return this._method_refs.getStack()}getRemote(){return this._remote_interface}setInterface(a,m){if(m=m||{},this.config.name=m.name||this.config.name,this.config.description=m.description||this.config.description,this.config.forwarding_functions)for(let b of this.config.forwarding_functions){const v=this._remote_interface;v[b]&&(a.constructor===Object?a[b]||(a[b]=(...c)=>{v[b](...c)}):a.constructor.constructor===Function&&(a.constructor.prototype[b]||(a.constructor.prototype[b]=(...c)=>{v[b](...c)})))}return this._local_api=a,this._remote_set?this.sendInterface():this._fire("interfaceAvailable"),new Promise(b=>{this.once("interfaceSetAsRemote",b)})}sendInterface(){if(!this._local_api)throw new Error("interface is not set.");this._encode(this._local_api,!0).then(a=>{this._connection.emit({type:"setInterface",api:a})})}_disposeObject(a){if(this._object_store[a])delete this._object_store[a];else throw new Error(`Object (id=${a}) not found.`)}disposeObject(a){return new Promise((m,b)=>{if(this._object_weakmap.has(a)){const v=this._object_weakmap.get(a);this._connection.once("disposed",c=>{c.error?b(new Error(c.error)):m()}),this._connection.emit({type:"disposeObject",object_id:v})}else throw new Error("Invalid object")})}_setupMessageHanlders(){this._connection.on("init",this.init),this._connection.on("execute",a=>{Promise.resolve(this._connection.execute(a.code)).then(()=>{this._connection.emit({type:"executed"})}).catch(m=>{console.error(m),this._connection.emit({type:"executed",error:String(m)})})}),this._connection.on("method",async a=>{let m,b,v,c,w,k;try{a.promise&&([m,b]=await this._unwrap(a.promise,!1));const x=this._object_store[a.object_id];if(v=f(x,a.name),a.name.includes(".")){const E=a.name.split("."),O=E.slice(0,E.length-1).join(".");c=f(x,O)}else c=x;w=await this._unwrap(a.args,!0),a.promise?(k=v.apply(c,w),k instanceof Promise||v.constructor&&v.constructor.name==="AsyncFunction"?k.then(m).catch(b):m(k)):v.apply(c,w)}catch(x){console.error(this.config.name,x),b&&b(x)}}),this._connection.on("callback",async a=>{let m,b,v,c,w;try{if(a.promise&&([m,b]=await this._unwrap(a.promise,!1)),a.promise){if(v=this._store.fetch(a.id),c=await this._unwrap(a.args,!0),!v)throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");w=v.apply(null,c),w instanceof Promise||v.constructor&&v.constructor.name==="AsyncFunction"?w.then(m).catch(b):m(w)}else{if(v=this._store.fetch(a.id),c=await this._unwrap(a.args,!0),!v)throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");v.apply(null,c)}}catch(k){console.error(this.config.name,k),b&&b(k)}}),this._connection.on("disposeObject",a=>{try{this._disposeObject(a.object_id),this._connection.emit({type:"disposed"})}catch(m){console.error(m),this._connection.emit({type:"disposed",error:String(m)})}}),this._connection.on("setInterface",a=>{this._setRemoteInterface(a.api)}),this._connection.on("getInterface",()=>{this._fire("getInterface"),this._local_api?this.sendInterface():this.once("interfaceAvailable",()=>{this.sendInterface()})}),this._connection.on("interfaceSetAsRemote",()=>{this._remote_set=!0,this._fire("interfaceSetAsRemote")}),this._connection.on("disconnect",()=>{this._fire("beforeDisconnect"),this._connection.disconnect(),this._fire("disconnected")})}requestRemote(){this._connection.emit({type:"getInterface"})}_ndarray(a,m,b){const v=Object(i.typedArrayToDtype)(a);if(b&&b!==v)throw"dtype doesn't match the type of the array: "+v+" != "+b;return m=m||[a.length],{_rtype:"ndarray",_rvalue:a.buffer,_rshape:m,_rdtype:v}}_setRemoteInterface(a){this._decode(a).then(m=>{if(this._remote_interface){for(let b in this._remote_interface)delete this._remote_interface[b];Object.assign(this._remote_interface,m)}else this._remote_interface=m;this._fire("remoteReady"),this._reportRemoteSet()})}_genRemoteMethod(a,m,b){const v=this,c=function(){return new Promise(async(w,k)=>{let x=null;try{x=v._method_refs.put(b?b+"/"+m:m);const E=function(){return x!==null&&v._method_refs.fetch(x),w.apply(this,arguments)},O=function(){return x!==null&&v._method_refs.fetch(x),k.apply(this,arguments)},A=await v._wrap([E,O]);E.__promise_pair=A[1]._rvalue,O.__promise_pair=A[0]._rvalue;let T=Array.prototype.slice.call(arguments);const j=T.length,I=j>0&&typeof T[j-1]=="object"&&T[j-1]!==null&&T[j-1]._rkwargs;I&&delete T[j-1]._rkwargs,m==="register"||m==="registerService"||m==="register_service"||m==="export"||m==="on"?T=await v._wrap(T,!0):T=await v._wrap(T);const D=T.__transferables__;D&&delete T.__transferables__,v._connection.emit({type:"method",target_id:a,name:m,object_id:b,args:T,promise:A,with_kwargs:I},D)}catch(E){x&&v._method_refs.fetch(x),k(`Failed to exectue remote method (interface: ${b||v.id}, method: ${m}), error: ${E}`)}})};return c.__remote_method=!0,c}_reportRemoteSet(){this._connection.emit({type:"interfaceSetAsRemote"})}async _encode(a,m,b){const v=typeof a;if(v==="number"||v==="string"||v==="boolean"||a===null||a===void 0||a instanceof ArrayBuffer)return a;let c;if(typeof a=="function"){if(m){if(!b)throw new Error("objectId is not specified.");c={_rtype:"interface",_rtarget_id:this._connection.peer_id,_rintf:b,_rvalue:m},this._method_weakmap.set(a,c)}else if(this._method_weakmap.has(a))c=this._method_weakmap.get(a);else{const E=this._store.put(a);c={_rtype:"callback",_rtarget_id:this._connection.peer_id,_rname:a.constructor&&a.constructor.name||E,_rvalue:E}}return c}if(a.constructor instanceof Object&&a._rtype){if(a._rintf){const E=a._rtype;delete a._rtype,c=await this._encode(a,m,b),c._rtype=E}else c=a;return c}const w=[],k=a._transfer,x=Array.isArray(a);for(let E of Object.keys(this._codecs)){const O=this._codecs[E];if(O.encoder&&a instanceof O.type){let A=await Promise.resolve(O.encoder(a));if(A&&!A._rtype&&(A._rtype=O.name),A&&A._rintf){const T=A._rtype;delete A._rtype,A=await this._encode(A,m,b),A._rtype=T}return c=A,c}}if(typeof tf<"u"&&tf.Tensor&&a instanceof tf.Tensor){const E=a.dataSync();(a._transfer||k)&&(w.push(E.buffer),delete a._transfer),c={_rtype:"ndarray",_rvalue:E.buffer,_rshape:a.shape,_rdtype:a.dtype}}else if(typeof nj<"u"&&nj.NdArray&&a instanceof nj.NdArray){const E=Object(i.typedArrayToDtype)(a.selection.data);(a._transfer||k)&&(w.push(a.selection.data.buffer),delete a._transfer),c={_rtype:"ndarray",_rvalue:a.selection.data.buffer,_rshape:a.shape,_rdtype:E}}else if(a instanceof Error)console.error(a),c={_rtype:"error",_rvalue:a.toString()};else if(typeof File<"u"&&a instanceof File)c={_rtype:"file",_rvalue:a,_rpath:a._path||a.webkitRelativePath};else if(a!==Object(a)||a instanceof Boolean||a instanceof String||a instanceof Date||a instanceof RegExp||a instanceof ImageData||typeof FileList<"u"&&a instanceof FileList||typeof FileSystemDirectoryHandle<"u"&&a instanceof FileSystemDirectoryHandle||typeof FileSystemFileHandle<"u"&&a instanceof FileSystemFileHandle||typeof FileSystemHandle<"u"&&a instanceof FileSystemHandle||typeof FileSystemWritableFileStream<"u"&&a instanceof FileSystemWritableFileStream)c=a;else if(typeof File<"u"&&a instanceof File)c={_rtype:"file",_rname:a.name,_rmime:a.type,_rvalue:a,_rpath:a._path||a.webkitRelativePath};else if(a instanceof Blob)c={_rtype:"blob",_rvalue:a};else if(a instanceof o){(a._transfer||k)&&(w.push(a.buffer),delete a._transfer);const E=Object(i.typedArrayToDtype)(a);c={_rtype:"typedarray",_rvalue:a.buffer,_rdtype:E}}else if(a instanceof DataView)(a._transfer||k)&&(w.push(a.buffer),delete a._transfer),c={_rtype:"memoryview",_rvalue:a.buffer};else if(a instanceof Set)c={_rtype:"set",_rvalue:await this._encode(Array.from(a),m)};else if(a instanceof Map)c={_rtype:"orderedmap",_rvalue:await this._encode(Array.from(a),m)};else if(a.constructor instanceof Object||Array.isArray(a)){c=x?[]:{};let E;if(a.constructor===Object||Array.isArray(a))E=Object.keys(a);else{if(a.constructor===Function)throw new Error("Please instantiate the class before exportting it.");if(a.constructor.constructor===Function)E=Object.getOwnPropertyNames(Object.getPrototypeOf(a)).concat(Object.keys(a)),m=!0;else throw Error("Unsupported interface type")}let O=!1;if(a._rintf||m){b||(typeof a._rintf=="string"&&a._rintf.length>0?b=a._rintf:b=Object(i.randId)(),this._object_store[b]&&console.warn(`Overwritting interface object with the same id: ${b}`),this._object_store[b]=a);for(let A of E)A!=="constructor"&&(A.startsWith("_")||(c[A]=await this._encode(a[A],typeof m=="string"?m+"."+A:A,b),typeof a[A]=="function"&&(O=!0)));O&&(c._rintf=b),a.on&&typeof a.on=="function"&&a.on("close",()=>{delete this._object_store[b]})}else for(let A of E)["hasOwnProperty","constructor"].includes(A)||(c[A]=await this._encode(a[A]))}else if(typeof a=="object"){const E=Object.getOwnPropertyNames(Object.getPrototypeOf(a)).concat(Object.keys(a)),O=Object(i.randId)();for(let A of E)["hasOwnProperty","constructor"].includes(A)||(c[A]=await this._encode(a[A],A,c));c._rintf=O}else throw"imjoy-rpc: Unsupported data type:"+a;if(w.length>0&&(c.__transferables__=w),!c)throw new Error("Failed to encode object");return c}async _decode(a,m){if(!a)return a;let b;if(a._rtype)if(this._codecs[a._rtype]&&this._codecs[a._rtype].decoder){if(a._rintf){const v=a._rtype;delete a._rtype,a=await this._decode(a,m),a._rtype=v}b=await Promise.resolve(this._codecs[a._rtype].decoder(a))}else if(a._rtype==="callback")b=this._genRemoteCallback(a._rtarget_id,a._rvalue,m);else if(a._rtype==="interface")b=this._genRemoteMethod(a._rtarget_id,a._rvalue,a._rintf);else if(a._rtype==="ndarray")if(typeof nj<"u"&&nj.array)Array.isArray(a._rvalue)&&(a._rvalue=a._rvalue.reduce(l)),b=nj.array(new Uint8(a._rvalue),a._rdtype).reshape(a._rshape);else if(typeof tf<"u"&&tf.Tensor){Array.isArray(a._rvalue)&&(a._rvalue=a._rvalue.reduce(l));const v=i.dtypeToTypedArray[a._rdtype];b=tf.tensor(new v(a._rvalue),a._rshape,a._rdtype)}else b=a;else if(a._rtype==="error")b=new Error(a._rvalue);else if(a._rtype==="file")a._rvalue instanceof File?(b=a._rvalue,b._path=a._rpath):(b=new File([a._rvalue],a._rname,{type:a._rmime}),b._path=a._rpath);else if(a._rtype==="typedarray"){const v=i.dtypeToTypedArray[a._rdtype];if(!v)throw new Error("unsupported dtype: "+a._rdtype);b=new v(a._rvalue)}else if(a._rtype==="memoryview")b=new DataView(a._rvalue);else if(a._rtype==="blob")a._rvalue instanceof Blob?b=a._rvalue:b=new Blob([a._rvalue],{type:a._rmime});else if(a._rtype==="orderedmap")b=new Map(await this._decode(a._rvalue,m));else if(a._rtype==="set")b=new Set(await this._decode(a._rvalue,m));else if(a._rintf){const v=a._rtype;delete a._rtype,b=await this._decode(a,m),b._rtype=v}else b=a;else if(a.constructor===Object||Array.isArray(a)){const v=Array.isArray(a);b=v?[]:{};for(let c of Object.keys(a))if(v||a.hasOwnProperty(c)){const w=a[c];b[c]=await this._decode(w,m)}}else b=a;if(b===void 0)throw new Error("Failed to decode object");return a._rintf&&this._object_weakmap.set(b,a._rintf),b}async _wrap(a,m){return await this._encode(a,m)}async _unwrap(a,m){return await this._decode(a,m)}_genRemoteCallback(a,m,b){const v=this;let c;return b?(c=function(){return new Promise(async(w,k)=>{const x=await v._wrap(Array.prototype.slice.call(arguments)),E=x.length,O=E>0&&typeof x[E-1]=="object"&&x[E-1]!==null&&x[E-1]._rkwargs;O&&delete x[E-1]._rkwargs;const A=x.__transferables__;A&&delete x.__transferables__;const T=await v._wrap([w,k]);w.__promise_pair=T[1]._rvalue,k.__promise_pair=T[0]._rvalue;try{v._connection.emit({type:"callback",target_id:a,id:m,args:x,promise:T,with_kwargs:O},A)}catch{k(`Failed to exectue remote callback ( id: ${m}).`)}})},c):(c=async function(){const w=await v._wrap(Array.prototype.slice.call(arguments)),k=w.length,x=k>0&&typeof w[k-1]=="object"&&w[k-1]!==null&&w[k-1]._rkwargs;x&&delete w[k-1]._rkwargs;const E=w.__transferables__;return E&&delete w.__transferables__,v._connection.emit({type:"callback",target_id:a,id:m,args:w,with_kwargs:x},E)},c)}reset(){this._event_handlers={},this._once_handlers={},this._remote_interface=null,this._object_store={},this._method_weakmap=new WeakMap,this._object_weakmap=new WeakMap,this._local_api=null,this._store=new _,this._method_refs=new _}disconnect(){this._connection.emit({type:"disconnect"}),this.reset(),setTimeout(()=>{this._connection.disconnect()},2e3)}}class _{constructor(){this._store={},this._indices=[0],this._readyHandler=function(){},this._busyHandler=function(){},this._readyHandler()}onReady(a){this._readyHandler=a||function(){}}onBusy(a){this._busyHandler=a||function(){}}getStack(){return Object.keys(this._store).length}_genId(){let a;return this._indices.length===1?a=this._indices[0]++:a=this._indices.shift(),a}_releaseId(a){for(let m=0;m<this._indices.length;m++)if(a<this._indices[m]){this._indices.splice(m,0,a);break}for(let m=this._indices.length-1;m>=0&&this._indices[m]-1===this._indices[m-1];m--)this._indices.pop()}put(a){this._busyHandler&&Object.keys(this._store).length===0&&this._busyHandler();const m=this._genId();return this._store[m]=a,m}fetch(a){const m=this._store[a];return m&&!m.__remote_method&&(delete this._store[a],this._releaseId(a),this._readyHandler&&Object.keys(this._store).length===0&&this._readyHandler()),m&&m.__promise_pair&&this.fetch(m.__promise_pair),m}}},"./src/socketIOMain.js":function(n,t,r){r.r(t),r.d(t,"Connection",function(){return _}),r.d(t,"connectToServer",function(){return g});var i=r("./src/pluginCore.js"),s=r("./src/rpc.js");r.d(t,"RPC",function(){return s.RPC}),r.d(t,"API_VERSION",function(){return s.API_VERSION});var o=r("./src/utils.js");r.d(t,"loadRequirements",function(){return o.loadRequirements});var l=r("./node_modules/socket.io-client/build/esm/index.js"),f=r("./src/main.js");r.d(t,"setupRPC",function(){return f.setupRPC}),r.d(t,"waitForInitialization",function(){return f.waitForInitialization});var u=r("./package.json");r.d(t,"VERSION",function(){return u.version});class _ extends o.MessageEmitter{constructor(m){super(m&&m.debug),this.config=m||{},this.peer_id=Object(o.randId)()}init(){return new Promise((m,b)=>{const v=this.config,c=v.server_url,w={};v.token&&(w.Authorization="Bearer "+v.token);const k=new URL(c).pathname,x=Object(l.default)(c,{withCredentials:!0,extraHeaders:w,path:(k.endsWith("/")?k.slice(0,-1):k)+"/socket.io"});let E=!1;x.on("connect",()=>{if(E){console.warn("Skipping reconnect to the server");return}x.emit("register_plugin",v,O=>{if(!O.success){console.error(O.detail),b(O.detail);return}E=!0,this.plugin_id=O.plugin_id,x.on("plugin_message",A=>{A.peer_id===this.peer_id?this._fire(A.type,A):this.config.debug&&console.log(`connection peer id mismatch ${A.peer_id} !== ${this.peer_id}`)}),this.once("initialize",()=>{this.rpc?this.rpc.once("remoteReady",()=>{this.rpc.sendInterface()}):this.rpc=Object(i.connectRPC)(this,v),this.connect(),m()}),this.emit({type:"imjoyRPCReady",config:v,peer_id:this.peer_id})}),this._disconnected=!1}),x.on("connect_error",()=>{b("connection error"),this._fire("connectFailure")}),x.on("disconnect",()=>{b("disconnected"),this.disconnect(),this._fire("disconnected")}),this.socket=x})}connect(){this.emit({type:"initialized",config:this.config,origin:globalThis.location.origin,peer_id:this.peer_id}),this._fire("connected")}reset(){this._event_handlers={},this._once_handlers={}}execute(){throw new Error("Execution is not allowed for socketio connection")}disconnect(){this._fire("beforeDisconnect"),this.socket.disconnect(),this.init(),this._fire("disconnected")}emit(m){m.plugin_id=this.plugin_id,this.socket.emit("plugin_message",m,b=>{b.success||this._fire("error",m.detail)})}}function g(a){if(a=a||{},!a.server_url)throw new Error("Server URL is not specified.");return a.name=a.name||Object(o.randId)(),a=Object(o.normalizeConfig)(a),new Promise((m,b)=>{const v=w=>{const k=w.detail;a.expose_api_globally&&(globalThis.api=k),m(k),globalThis.removeEventListener("imjoy_remote_api_ready",v)};globalThis.addEventListener("imjoy_remote_api_ready",v),a=a||{},a.dedicated_thread=!1,a.lang="javascript",a.api_version=s.API_VERSION,new _(a).init().catch(b)})}},"./src/utils.js":function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"randId",function(){return randId}),__webpack_require__.d(__webpack_exports__,"dtypeToTypedArray",function(){return dtypeToTypedArray}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWindow",function(){return loadRequirementsInWindow}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWebworker",function(){return loadRequirementsInWebworker}),__webpack_require__.d(__webpack_exports__,"loadRequirements",function(){return loadRequirements}),__webpack_require__.d(__webpack_exports__,"normalizeConfig",function(){return normalizeConfig}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtypeMapping",function(){return typedArrayToDtypeMapping}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtype",function(){return typedArrayToDtype}),__webpack_require__.d(__webpack_exports__,"cacheRequirements",function(){return cacheRequirements}),__webpack_require__.d(__webpack_exports__,"setupServiceWorker",function(){return setupServiceWorker}),__webpack_require__.d(__webpack_exports__,"urlJoin",function(){return urlJoin}),__webpack_require__.d(__webpack_exports__,"MessageEmitter",function(){return MessageEmitter});function randId(){return Math.random().toString(36).substr(2,10)+new Date().getTime()}const dtypeToTypedArray={int8:Int8Array,int16:Int16Array,int32:Int32Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,float32:Float32Array,float64:Float64Array,array:Array};async function loadRequirementsInWindow(n){function t(o){return new Promise((l,f)=>{var u=document.createElement("script");u.src=o,u.type="text/javascript",u.onload=l,u.onreadystatechange=function(){(this.readyState==="loaded"||this.readyState==="complete")&&l()},u.onerror=f,document.head.appendChild(u)})}async function r(){for(var o=Array.prototype.slice.call(arguments),l=o.length,f=0;f<l;f++)await t(o[f])}if(n&&(Array.isArray(n)||typeof n=="string"))try{var i;if(n=typeof n=="string"?[n]:n,Array.isArray(n))for(var s=0;s<n.length;s++)n[s].toLowerCase().endsWith(".css")||n[s].startsWith("css:")?(n[s].startsWith("css:")&&(n[s]=n[s].slice(4)),i=document.createElement("link"),i.rel="stylesheet",i.href=n[s],document.head.appendChild(i)):n[s].toLowerCase().endsWith(".mjs")||n[s].startsWith("mjs:")?(n[s].startsWith("mjs:")&&(n[s]=n[s].slice(4)),await __vitePreload(()=>import(n[s]),__vite__mapDeps([]))):n[s].toLowerCase().endsWith(".js")||n[s].startsWith("js:")?(n[s].startsWith("js:")&&(n[s]=n[s].slice(3)),await r(n[s])):n[s].startsWith("http")?await r(n[s]):n[s].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[s]);else throw"unsupported requirements definition"}catch{throw"failed to import required scripts: "+n.toString()}}async function loadRequirementsInWebworker(n){if(n&&(Array.isArray(n)||typeof n=="string"))try{Array.isArray(n)||(n=[n]);for(var t=0;t<n.length;t++){if(n[t].toLowerCase().endsWith(".css")||n[t].startsWith("css:"))throw"unable to import css in a webworker";n[t].toLowerCase().endsWith(".js")||n[t].startsWith("js:")?(n[t].startsWith("js:")&&(n[t]=n[t].slice(3)),importScripts(n[t])):n[t].startsWith("http")?importScripts(n[t]):n[t].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[t])}}catch{throw"failed to import required scripts: "+n.toString()}}function loadRequirements(n){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?loadRequirementsInWebworker(n):loadRequirementsInWindow(n)}function normalizeConfig(n){return n.version=n.version||"0.1.0",n.description=n.description||`[TODO: add description for ${n.name} ]`,n.type=n.type||"rpc-window",n.id=n.id||randId(),n.target_origin=n.target_origin||"*",n.allow_execution=n.allow_execution||!1,n=Object.keys(n).reduce((t,r)=>(typeof n[r]!="function"&&(t[r]=n[r]),t),{}),n}const typedArrayToDtypeMapping={Int8Array:"int8",Int16Array:"int16",Int32Array:"int32",Uint8Array:"uint8",Uint16Array:"uint16",Uint32Array:"uint32",Float32Array:"float32",Float64Array:"float64",Array:"array"},typedArrayToDtypeKeys=[];for(const arrType of Object.keys(typedArrayToDtypeMapping))typedArrayToDtypeKeys.push(eval(arrType));function typedArrayToDtype(n){let t=typedArrayToDtypeMapping[n.constructor.name];if(!t){const r=Object.getPrototypeOf(n);for(const i of typedArrayToDtypeKeys)if(r instanceof i){t=typedArrayToDtypeMapping[i.name];break}}return t}function cacheUrlInServiceWorker(n){return new Promise(function(t,r){const i={command:"add",url:n};if(!navigator.serviceWorker||!navigator.serviceWorker.register){r("Service worker is not supported.");return}const s=new MessageChannel;s.port1.onmessage=function(o){o.data&&o.data.error?r(o.data.error):t(o.data&&o.data.result)},navigator.serviceWorker&&navigator.serviceWorker.controller?navigator.serviceWorker.controller.postMessage(i,[s.port2]):r("Service worker controller is not available")})}async function cacheRequirements(n){n=n||[],Array.isArray(n)||(n=[n]);for(let t of n)t.startsWith("js:")&&(t=t.slice(3)),t.startsWith("css:")&&(t=t.slice(4)),t.startsWith("cache:")&&(t=t.slice(6)),t.startsWith("http")&&await cacheUrlInServiceWorker(t).catch(r=>{console.error(r)})}function setupServiceWorker(n,t,r){if("serviceWorker"in navigator){if(n=n||"/",navigator.serviceWorker.register(n+"plugin-service-worker.js").then(function(i){console.log("ServiceWorker registration successful with scope: ",i.scope)},function(i){console.log("ServiceWorker registration failed: ",i)}),t=t||"*",r=r||cacheRequirements,r&&typeof r!="function")throw new Error("config.cache_requirements must be a function");window.addEventListener("message",function(i){if(t==="*"||i.origin===t){const s=i.data;s.type==="cacheRequirements"&&r(s.requirements)}})}}function urlJoin(...n){return n.join("/").replace(/[\/]+/g,"/").replace(/^(.+):\//,"$1://").replace(/^file:/,"file:/").replace(/\/(\?|&|#[^!])/g,"$1").replace(/\?/g,"&").replace("&","?")}class MessageEmitter{constructor(t){this._event_handlers={},this._once_handlers={},this._debug=t}emit(){throw new Error("emit is not implemented")}on(t,r){this._event_handlers[t]||(this._event_handlers[t]=[]),this._event_handlers[t].push(r)}once(t,r){r.___event_run_once=!0,this.on(t,r)}off(t,r){if(!t&&!r)this._event_handlers={};else if(t&&!r)this._event_handlers[t]&&(this._event_handlers[t]=[]);else if(this._event_handlers[t]){const i=this._event_handlers[t].indexOf(r);i>=0&&this._event_handlers[t].splice(i,1)}}_fire(t,r){if(this._event_handlers[t])for(var i=this._event_handlers[t].length;i--;){const s=this._event_handlers[t][i];try{s(r)}catch(o){console.error(o)}finally{s.___event_run_once&&this._event_handlers[t].splice(i,1)}}else this._debug&&console.warn("unhandled event",t,r)}}}})})})(imjoyRpcSocketio);var imjoyRpcSocketioExports=imjoyRpcSocketio.exports,hyphaRpc={exports:{}};(function(module,exports){var define_process_env_default={};(function(t,r){module.exports=r()})(window,function(){return function(n){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i,l:!1,exports:{}};return n[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=n,r.c=t,r.d=function(i,s,o){r.o(i,s)||Object.defineProperty(i,s,{enumerable:!0,get:o})},r.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},r.t=function(i,s){if(s&1&&(i=r(i)),s&8||s&4&&typeof i=="object"&&i&&i.__esModule)return i;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:i}),s&2&&typeof i!="string")for(var l in i)r.d(o,l,(function(f){return i[f]}).bind(null,l));return o},r.n=function(i){var s=i&&i.__esModule?function(){return i.default}:function(){return i};return r.d(s,"a",s),s},r.o=function(i,s){return Object.prototype.hasOwnProperty.call(i,s)},r.p="",r(r.s="./src/hypha/rpc.js")}({"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs":function(n,t,r){r.r(t),r.d(t,"CachedKeyDecoder",function(){return l});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),s=16,o=16,l=function(){function f(u,_){u===void 0&&(u=s),_===void 0&&(_=o),this.maxKeyLength=u,this.maxLengthPerKey=_,this.hit=0,this.miss=0,this.caches=[];for(var g=0;g<this.maxKeyLength;g++)this.caches.push([])}return f.prototype.canBeCached=function(u){return u>0&&u<=this.maxKeyLength},f.prototype.find=function(u,_,g){var a=this.caches[g-1];e:for(var m=0,b=a;m<b.length;m++){for(var v=b[m],c=v.bytes,w=0;w<g;w++)if(c[w]!==u[_+w])continue e;return v.str}return null},f.prototype.store=function(u,_){var g=this.caches[u.length-1],a={bytes:u,str:_};g.length>=this.maxLengthPerKey?g[Math.random()*g.length|0]=a:g.push(a)},f.prototype.decode=function(u,_,g){var a=this.find(u,_,g);if(a!=null)return this.hit++,a;this.miss++;var m=Object(i.utf8DecodeJs)(u,_,g),b=Uint8Array.prototype.slice.call(u,_,_+g);return this.store(b,m),m},f}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs":function(n,t,r){r.r(t),r.d(t,"DecodeError",function(){return s});var i=function(){var o=function(l,f){return o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(u,_){u.__proto__=_}||function(u,_){for(var g in _)Object.prototype.hasOwnProperty.call(_,g)&&(u[g]=_[g])},o(l,f)};return function(l,f){if(typeof f!="function"&&f!==null)throw new TypeError("Class extends value "+String(f)+" is not a constructor or null");o(l,f);function u(){this.constructor=l}l.prototype=f===null?Object.create(f):(u.prototype=f.prototype,new u)}}(),s=function(o){i(l,o);function l(f){var u=o.call(this,f)||this,_=Object.create(l.prototype);return Object.setPrototypeOf(u,_),Object.defineProperty(u,"name",{configurable:!0,enumerable:!1,value:l.name}),u}return l}(Error)},"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs":function(n,t,r){r.r(t),r.d(t,"DataViewIndexOutOfBoundsError",function(){return E}),r.d(t,"Decoder",function(){return T});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),f=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"),u=r("./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs"),_=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"),g=function(j,I,D,$){function N(M){return M instanceof D?M:new D(function(W){W(M)})}return new(D||(D=Promise))(function(M,W){function F(Y){try{q($.next(Y))}catch(X){W(X)}}function H(Y){try{q($.throw(Y))}catch(X){W(X)}}function q(Y){Y.done?M(Y.value):N(Y.value).then(F,H)}q(($=$.apply(j,I||[])).next())})},a=function(j,I){var D={label:0,sent:function(){if(M[0]&1)throw M[1];return M[1]},trys:[],ops:[]},$,N,M,W;return W={next:F(0),throw:F(1),return:F(2)},typeof Symbol=="function"&&(W[Symbol.iterator]=function(){return this}),W;function F(q){return function(Y){return H([q,Y])}}function H(q){if($)throw new TypeError("Generator is already executing.");for(;D;)try{if($=1,N&&(M=q[0]&2?N.return:q[0]?N.throw||((M=N.return)&&M.call(N),0):N.next)&&!(M=M.call(N,q[1])).done)return M;switch(N=0,M&&(q=[q[0]&2,M.value]),q[0]){case 0:case 1:M=q;break;case 4:return D.label++,{value:q[1],done:!1};case 5:D.label++,N=q[1],q=[0];continue;case 7:q=D.ops.pop(),D.trys.pop();continue;default:if(M=D.trys,!(M=M.length>0&&M[M.length-1])&&(q[0]===6||q[0]===2)){D=0;continue}if(q[0]===3&&(!M||q[1]>M[0]&&q[1]<M[3])){D.label=q[1];break}if(q[0]===6&&D.label<M[1]){D.label=M[1],M=q;break}if(M&&D.label<M[2]){D.label=M[2],D.ops.push(q);break}M[2]&&D.ops.pop(),D.trys.pop();continue}q=I.call(j,D)}catch(Y){q=[6,Y],N=0}finally{$=M=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:!0}}},m=function(j){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var I=j[Symbol.asyncIterator],D;return I?I.call(j):(j=typeof __values=="function"?__values(j):j[Symbol.iterator](),D={},$("next"),$("throw"),$("return"),D[Symbol.asyncIterator]=function(){return this},D);function $(M){D[M]=j[M]&&function(W){return new Promise(function(F,H){W=j[M](W),N(F,H,W.done,W.value)})}}function N(M,W,F,H){Promise.resolve(H).then(function(q){M({value:q,done:F})},W)}},b=function(j){return this instanceof b?(this.v=j,this):new b(j)},v=function(j,I,D){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var $=D.apply(j,I||[]),N,M=[];return N={},W("next"),W("throw"),W("return"),N[Symbol.asyncIterator]=function(){return this},N;function W(J){$[J]&&(N[J]=function(te){return new Promise(function(ie,de){M.push([J,te,ie,de])>1||F(J,te)})})}function F(J,te){try{H($[J](te))}catch(ie){X(M[0][3],ie)}}function H(J){J.value instanceof b?Promise.resolve(J.value.v).then(q,Y):X(M[0][2],J)}function q(J){F("next",J)}function Y(J){F("throw",J)}function X(J,te){J(te),M.shift(),M.length&&F(M[0][0],M[0][1])}},c=function(j){var I=typeof j;return I==="string"||I==="number"},w=-1,k=new DataView(new ArrayBuffer(0)),x=new Uint8Array(k.buffer),E=function(){try{k.getInt8(0)}catch(j){return j.constructor}throw new Error("never reached")}(),O=new E("Insufficient data"),A=new u.CachedKeyDecoder,T=function(){function j(I,D,$,N,M,W,F,H){I===void 0&&(I=s.ExtensionCodec.defaultCodec),D===void 0&&(D=void 0),$===void 0&&($=o.UINT32_MAX),N===void 0&&(N=o.UINT32_MAX),M===void 0&&(M=o.UINT32_MAX),W===void 0&&(W=o.UINT32_MAX),F===void 0&&(F=o.UINT32_MAX),H===void 0&&(H=A),this.extensionCodec=I,this.context=D,this.maxStrLength=$,this.maxBinLength=N,this.maxArrayLength=M,this.maxMapLength=W,this.maxExtLength=F,this.keyDecoder=H,this.totalPos=0,this.pos=0,this.view=k,this.bytes=x,this.headByte=w,this.stack=[]}return j.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=w,this.stack.length=0},j.prototype.setBuffer=function(I){this.bytes=Object(f.ensureUint8Array)(I),this.view=Object(f.createDataView)(this.bytes),this.pos=0},j.prototype.appendBuffer=function(I){if(this.headByte===w&&!this.hasRemaining(1))this.setBuffer(I);else{var D=this.bytes.subarray(this.pos),$=Object(f.ensureUint8Array)(I),N=new Uint8Array(D.length+$.length);N.set(D),N.set($,D.length),this.setBuffer(N)}},j.prototype.hasRemaining=function(I){return this.view.byteLength-this.pos>=I},j.prototype.createExtraByteError=function(I){var D=this,$=D.view,N=D.pos;return new RangeError("Extra "+($.byteLength-N)+" of "+$.byteLength+" byte(s) found at buffer["+I+"]")},j.prototype.decode=function(I){this.reinitializeState(),this.setBuffer(I);var D=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return D},j.prototype.decodeMulti=function(I){return a(this,function(D){switch(D.label){case 0:this.reinitializeState(),this.setBuffer(I),D.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return D.sent(),[3,1];case 3:return[2]}})},j.prototype.decodeAsync=function(I){var D,$,N,M;return g(this,void 0,void 0,function(){var W,F,H,q,Y,X,J,te;return a(this,function(ie){switch(ie.label){case 0:W=!1,ie.label=1;case 1:ie.trys.push([1,6,7,12]),D=m(I),ie.label=2;case 2:return[4,D.next()];case 3:if($=ie.sent(),!!$.done)return[3,5];if(H=$.value,W)throw this.createExtraByteError(this.totalPos);this.appendBuffer(H);try{F=this.doDecodeSync(),W=!0}catch(de){if(!(de instanceof E))throw de}this.totalPos+=this.pos,ie.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return q=ie.sent(),N={error:q},[3,12];case 7:return ie.trys.push([7,,10,11]),$&&!$.done&&(M=D.return)?[4,M.call(D)]:[3,9];case 8:ie.sent(),ie.label=9;case 9:return[3,11];case 10:if(N)throw N.error;return[7];case 11:return[7];case 12:if(W){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,F]}throw Y=this,X=Y.headByte,J=Y.pos,te=Y.totalPos,new RangeError("Insufficient data in parsing "+Object(i.prettyByte)(X)+" at "+te+" ("+J+" in the current buffer)")}})})},j.prototype.decodeArrayStream=function(I){return this.decodeMultiAsync(I,!0)},j.prototype.decodeStream=function(I){return this.decodeMultiAsync(I,!1)},j.prototype.decodeMultiAsync=function(I,D){return v(this,arguments,function(){var N,M,W,F,H,q,Y,X,J;return a(this,function(te){switch(te.label){case 0:N=D,M=-1,te.label=1;case 1:te.trys.push([1,13,14,19]),W=m(I),te.label=2;case 2:return[4,b(W.next())];case 3:if(F=te.sent(),!!F.done)return[3,12];if(H=F.value,D&&M===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(H),N&&(M=this.readArraySize(),N=!1,this.complete()),te.label=4;case 4:te.trys.push([4,9,,10]),te.label=5;case 5:return[4,b(this.doDecodeSync())];case 6:return[4,te.sent()];case 7:return te.sent(),--M===0?[3,8]:[3,5];case 8:return[3,10];case 9:if(q=te.sent(),!(q instanceof E))throw q;return[3,10];case 10:this.totalPos+=this.pos,te.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return Y=te.sent(),X={error:Y},[3,19];case 14:return te.trys.push([14,,17,18]),F&&!F.done&&(J=W.return)?[4,b(J.call(W))]:[3,16];case 15:te.sent(),te.label=16;case 16:return[3,18];case 17:if(X)throw X.error;return[7];case 18:return[7];case 19:return[2]}})})},j.prototype.doDecodeSync=function(){e:for(;;){var I=this.readHeadByte(),D=void 0;if(I>=224)D=I-256;else if(I<192)if(I<128)D=I;else if(I<144){var $=I-128;if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I<160){var $=I-144;if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else{var N=I-160;D=this.decodeUtf8String(N,0)}else if(I===192)D=null;else if(I===194)D=!1;else if(I===195)D=!0;else if(I===202)D=this.readF32();else if(I===203)D=this.readF64();else if(I===204)D=this.readU8();else if(I===205)D=this.readU16();else if(I===206)D=this.readU32();else if(I===207)D=this.readU64();else if(I===208)D=this.readI8();else if(I===209)D=this.readI16();else if(I===210)D=this.readI32();else if(I===211)D=this.readI64();else if(I===217){var N=this.lookU8();D=this.decodeUtf8String(N,1)}else if(I===218){var N=this.lookU16();D=this.decodeUtf8String(N,2)}else if(I===219){var N=this.lookU32();D=this.decodeUtf8String(N,4)}else if(I===220){var $=this.readU16();if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else if(I===221){var $=this.readU32();if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else if(I===222){var $=this.readU16();if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I===223){var $=this.readU32();if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I===196){var $=this.lookU8();D=this.decodeBinary($,1)}else if(I===197){var $=this.lookU16();D=this.decodeBinary($,2)}else if(I===198){var $=this.lookU32();D=this.decodeBinary($,4)}else if(I===212)D=this.decodeExtension(1,0);else if(I===213)D=this.decodeExtension(2,0);else if(I===214)D=this.decodeExtension(4,0);else if(I===215)D=this.decodeExtension(8,0);else if(I===216)D=this.decodeExtension(16,0);else if(I===199){var $=this.lookU8();D=this.decodeExtension($,1)}else if(I===200){var $=this.lookU16();D=this.decodeExtension($,2)}else if(I===201){var $=this.lookU32();D=this.decodeExtension($,4)}else throw new _.DecodeError("Unrecognized type byte: "+Object(i.prettyByte)(I));this.complete();for(var M=this.stack;M.length>0;){var W=M[M.length-1];if(W.type===0)if(W.array[W.position]=D,W.position++,W.position===W.size)M.pop(),D=W.array;else continue e;else if(W.type===1){if(!c(D))throw new _.DecodeError("The type of key must be string or number but "+typeof D);if(D==="__proto__")throw new _.DecodeError("The key __proto__ is not allowed");W.key=D,W.type=2;continue e}else if(W.map[W.key]=D,W.readCount++,W.readCount===W.size)M.pop(),D=W.map;else{W.key=null,W.type=1;continue e}}return D}},j.prototype.readHeadByte=function(){return this.headByte===w&&(this.headByte=this.readU8()),this.headByte},j.prototype.complete=function(){this.headByte=w},j.prototype.readArraySize=function(){var I=this.readHeadByte();switch(I){case 220:return this.readU16();case 221:return this.readU32();default:{if(I<160)return I-144;throw new _.DecodeError("Unrecognized array type byte: "+Object(i.prettyByte)(I))}}},j.prototype.pushMapState=function(I){if(I>this.maxMapLength)throw new _.DecodeError("Max length exceeded: map length ("+I+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:I,key:null,readCount:0,map:{}})},j.prototype.pushArrayState=function(I){if(I>this.maxArrayLength)throw new _.DecodeError("Max length exceeded: array length ("+I+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:I,array:new Array(I),position:0})},j.prototype.decodeUtf8String=function(I,D){var $;if(I>this.maxStrLength)throw new _.DecodeError("Max length exceeded: UTF-8 byte length ("+I+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+D+I)throw O;var N=this.pos+D,M;return this.stateIsMapKey()&&(!(($=this.keyDecoder)===null||$===void 0)&&$.canBeCached(I))?M=this.keyDecoder.decode(this.bytes,N,I):I>l.TEXT_DECODER_THRESHOLD?M=Object(l.utf8DecodeTD)(this.bytes,N,I):M=Object(l.utf8DecodeJs)(this.bytes,N,I),this.pos+=D+I,M},j.prototype.stateIsMapKey=function(){if(this.stack.length>0){var I=this.stack[this.stack.length-1];return I.type===1}return!1},j.prototype.decodeBinary=function(I,D){if(I>this.maxBinLength)throw new _.DecodeError("Max length exceeded: bin length ("+I+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(I+D))throw O;var $=this.pos+D,N=this.bytes.subarray($,$+I);return this.pos+=D+I,N},j.prototype.decodeExtension=function(I,D){if(I>this.maxExtLength)throw new _.DecodeError("Max length exceeded: ext length ("+I+") > maxExtLength ("+this.maxExtLength+")");var $=this.view.getInt8(this.pos+D),N=this.decodeBinary(I,D+1);return this.extensionCodec.decode(N,$,this.context)},j.prototype.lookU8=function(){return this.view.getUint8(this.pos)},j.prototype.lookU16=function(){return this.view.getUint16(this.pos)},j.prototype.lookU32=function(){return this.view.getUint32(this.pos)},j.prototype.readU8=function(){var I=this.view.getUint8(this.pos);return this.pos++,I},j.prototype.readI8=function(){var I=this.view.getInt8(this.pos);return this.pos++,I},j.prototype.readU16=function(){var I=this.view.getUint16(this.pos);return this.pos+=2,I},j.prototype.readI16=function(){var I=this.view.getInt16(this.pos);return this.pos+=2,I},j.prototype.readU32=function(){var I=this.view.getUint32(this.pos);return this.pos+=4,I},j.prototype.readI32=function(){var I=this.view.getInt32(this.pos);return this.pos+=4,I},j.prototype.readU64=function(){var I=Object(o.getUint64)(this.view,this.pos);return this.pos+=8,I},j.prototype.readI64=function(){var I=Object(o.getInt64)(this.view,this.pos);return this.pos+=8,I},j.prototype.readF32=function(){var I=this.view.getFloat32(this.pos);return this.pos+=4,I},j.prototype.readF64=function(){var I=this.view.getFloat64(this.pos);return this.pos+=8,I},j}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs":function(n,t,r){r.r(t),r.d(t,"DEFAULT_MAX_DEPTH",function(){return f}),r.d(t,"DEFAULT_INITIAL_BUFFER_SIZE",function(){return u}),r.d(t,"Encoder",function(){return _});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"),f=100,u=2048,_=function(){function g(a,m,b,v,c,w,k,x){a===void 0&&(a=s.ExtensionCodec.defaultCodec),m===void 0&&(m=void 0),b===void 0&&(b=f),v===void 0&&(v=u),c===void 0&&(c=!1),w===void 0&&(w=!1),k===void 0&&(k=!1),x===void 0&&(x=!1),this.extensionCodec=a,this.context=m,this.maxDepth=b,this.initialBufferSize=v,this.sortKeys=c,this.forceFloat32=w,this.ignoreUndefined=k,this.forceIntegerToFloat=x,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return g.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},g.prototype.reinitializeState=function(){this.pos=0},g.prototype.encode=function(a){return this.reinitializeState(),this.doEncode(a,1),this.getUint8Array()},g.prototype.doEncode=function(a,m){if(m>this.maxDepth)throw new Error("Too deep objects in depth "+m);a==null?this.encodeNil():typeof a=="boolean"?this.encodeBoolean(a):typeof a=="number"?this.encodeNumber(a):typeof a=="string"?this.encodeString(a):this.encodeObject(a,m)},g.prototype.ensureBufferSizeToWrite=function(a){var m=this.pos+a;this.view.byteLength<m&&this.resizeBuffer(m*2)},g.prototype.resizeBuffer=function(a){var m=new ArrayBuffer(a),b=new Uint8Array(m),v=new DataView(m);b.set(this.bytes),this.view=v,this.bytes=b},g.prototype.encodeNil=function(){this.writeU8(192)},g.prototype.encodeBoolean=function(a){a===!1?this.writeU8(194):this.writeU8(195)},g.prototype.encodeNumber=function(a){Number.isSafeInteger(a)&&!this.forceIntegerToFloat?a>=0?a<128?this.writeU8(a):a<256?(this.writeU8(204),this.writeU8(a)):a<65536?(this.writeU8(205),this.writeU16(a)):a<4294967296?(this.writeU8(206),this.writeU32(a)):(this.writeU8(207),this.writeU64(a)):a>=-32?this.writeU8(224|a+32):a>=-128?(this.writeU8(208),this.writeI8(a)):a>=-32768?(this.writeU8(209),this.writeI16(a)):a>=-2147483648?(this.writeU8(210),this.writeI32(a)):(this.writeU8(211),this.writeI64(a)):this.forceFloat32?(this.writeU8(202),this.writeF32(a)):(this.writeU8(203),this.writeF64(a))},g.prototype.writeStringHeader=function(a){if(a<32)this.writeU8(160+a);else if(a<256)this.writeU8(217),this.writeU8(a);else if(a<65536)this.writeU8(218),this.writeU16(a);else if(a<4294967296)this.writeU8(219),this.writeU32(a);else throw new Error("Too long string: "+a+" bytes in UTF-8")},g.prototype.encodeString=function(a){var m=5,b=a.length;if(b>i.TEXT_ENCODER_THRESHOLD){var v=Object(i.utf8Count)(a);this.ensureBufferSizeToWrite(m+v),this.writeStringHeader(v),Object(i.utf8EncodeTE)(a,this.bytes,this.pos),this.pos+=v}else{var v=Object(i.utf8Count)(a);this.ensureBufferSizeToWrite(m+v),this.writeStringHeader(v),Object(i.utf8EncodeJs)(a,this.bytes,this.pos),this.pos+=v}},g.prototype.encodeObject=function(a,m){var b=this.extensionCodec.tryToEncode(a,this.context);if(b!=null)this.encodeExtension(b);else if(Array.isArray(a))this.encodeArray(a,m);else if(ArrayBuffer.isView(a))this.encodeBinary(a);else if(typeof a=="object")this.encodeMap(a,m);else throw new Error("Unrecognized object: "+Object.prototype.toString.apply(a))},g.prototype.encodeBinary=function(a){var m=a.byteLength;if(m<256)this.writeU8(196),this.writeU8(m);else if(m<65536)this.writeU8(197),this.writeU16(m);else if(m<4294967296)this.writeU8(198),this.writeU32(m);else throw new Error("Too large binary: "+m);var b=Object(l.ensureUint8Array)(a);this.writeU8a(b)},g.prototype.encodeArray=function(a,m){var b=a.length;if(b<16)this.writeU8(144+b);else if(b<65536)this.writeU8(220),this.writeU16(b);else if(b<4294967296)this.writeU8(221),this.writeU32(b);else throw new Error("Too large array: "+b);for(var v=0,c=a;v<c.length;v++){var w=c[v];this.doEncode(w,m+1)}},g.prototype.countWithoutUndefined=function(a,m){for(var b=0,v=0,c=m;v<c.length;v++){var w=c[v];a[w]!==void 0&&b++}return b},g.prototype.encodeMap=function(a,m){var b=Object.keys(a);this.sortKeys&&b.sort();var v=this.ignoreUndefined?this.countWithoutUndefined(a,b):b.length;if(v<16)this.writeU8(128+v);else if(v<65536)this.writeU8(222),this.writeU16(v);else if(v<4294967296)this.writeU8(223),this.writeU32(v);else throw new Error("Too large map object: "+v);for(var c=0,w=b;c<w.length;c++){var k=w[c],x=a[k];this.ignoreUndefined&&x===void 0||(this.encodeString(k),this.doEncode(x,m+1))}},g.prototype.encodeExtension=function(a){var m=a.data.length;if(m===1)this.writeU8(212);else if(m===2)this.writeU8(213);else if(m===4)this.writeU8(214);else if(m===8)this.writeU8(215);else if(m===16)this.writeU8(216);else if(m<256)this.writeU8(199),this.writeU8(m);else if(m<65536)this.writeU8(200),this.writeU16(m);else if(m<4294967296)this.writeU8(201),this.writeU32(m);else throw new Error("Too large extension object: "+m);this.writeI8(a.type),this.writeU8a(a.data)},g.prototype.writeU8=function(a){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,a),this.pos++},g.prototype.writeU8a=function(a){var m=a.length;this.ensureBufferSizeToWrite(m),this.bytes.set(a,this.pos),this.pos+=m},g.prototype.writeI8=function(a){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,a),this.pos++},g.prototype.writeU16=function(a){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,a),this.pos+=2},g.prototype.writeI16=function(a){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,a),this.pos+=2},g.prototype.writeU32=function(a){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,a),this.pos+=4},g.prototype.writeI32=function(a){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,a),this.pos+=4},g.prototype.writeF32=function(a){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,a),this.pos+=4},g.prototype.writeF64=function(a){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,a),this.pos+=8},g.prototype.writeU64=function(a){this.ensureBufferSizeToWrite(8),Object(o.setUint64)(this.view,this.pos,a),this.pos+=8},g.prototype.writeI64=function(a){this.ensureBufferSizeToWrite(8),Object(o.setInt64)(this.view,this.pos,a),this.pos+=8},g}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs":function(n,t,r){r.r(t),r.d(t,"ExtData",function(){return i});var i=function(){function s(o,l){this.type=o,this.data=l}return s}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs":function(n,t,r){r.r(t),r.d(t,"ExtensionCodec",function(){return o});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs"),o=function(){function l(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(s.timestampExtension)}return l.prototype.register=function(f){var u=f.type,_=f.encode,g=f.decode;if(u>=0)this.encoders[u]=_,this.decoders[u]=g;else{var a=1+u;this.builtInEncoders[a]=_,this.builtInDecoders[a]=g}},l.prototype.tryToEncode=function(f,u){for(var _=0;_<this.builtInEncoders.length;_++){var g=this.builtInEncoders[_];if(g!=null){var a=g(f,u);if(a!=null){var m=-1-_;return new i.ExtData(m,a)}}}for(var _=0;_<this.encoders.length;_++){var g=this.encoders[_];if(g!=null){var a=g(f,u);if(a!=null){var m=_;return new i.ExtData(m,a)}}}return f instanceof i.ExtData?f:null},l.prototype.decode=function(f,u,_){var g=u<0?this.builtInDecoders[-1-u]:this.decoders[u];return g?g(f,u,_):new i.ExtData(u,f)},l.defaultCodec=new l,l}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs":function(n,t,r){r.r(t),r.d(t,"defaultDecodeOptions",function(){return s}),r.d(t,"decode",function(){return o}),r.d(t,"decodeMulti",function(){return l});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"),s={};function o(f,u){u===void 0&&(u=s);var _=new i.Decoder(u.extensionCodec,u.context,u.maxStrLength,u.maxBinLength,u.maxArrayLength,u.maxMapLength,u.maxExtLength);return _.decode(f)}function l(f,u){u===void 0&&(u=s);var _=new i.Decoder(u.extensionCodec,u.context,u.maxStrLength,u.maxBinLength,u.maxArrayLength,u.maxMapLength,u.maxExtLength);return _.decodeMulti(f)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs":function(n,t,r){r.r(t),r.d(t,"decodeAsync",function(){return u}),r.d(t,"decodeArrayStream",function(){return _}),r.d(t,"decodeMultiStream",function(){return g}),r.d(t,"decodeStream",function(){return a});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs"),l=function(m,b,v,c){function w(k){return k instanceof v?k:new v(function(x){x(k)})}return new(v||(v=Promise))(function(k,x){function E(T){try{A(c.next(T))}catch(j){x(j)}}function O(T){try{A(c.throw(T))}catch(j){x(j)}}function A(T){T.done?k(T.value):w(T.value).then(E,O)}A((c=c.apply(m,b||[])).next())})},f=function(m,b){var v={label:0,sent:function(){if(k[0]&1)throw k[1];return k[1]},trys:[],ops:[]},c,w,k,x;return x={next:E(0),throw:E(1),return:E(2)},typeof Symbol=="function"&&(x[Symbol.iterator]=function(){return this}),x;function E(A){return function(T){return O([A,T])}}function O(A){if(c)throw new TypeError("Generator is already executing.");for(;v;)try{if(c=1,w&&(k=A[0]&2?w.return:A[0]?w.throw||((k=w.return)&&k.call(w),0):w.next)&&!(k=k.call(w,A[1])).done)return k;switch(w=0,k&&(A=[A[0]&2,k.value]),A[0]){case 0:case 1:k=A;break;case 4:return v.label++,{value:A[1],done:!1};case 5:v.label++,w=A[1],A=[0];continue;case 7:A=v.ops.pop(),v.trys.pop();continue;default:if(k=v.trys,!(k=k.length>0&&k[k.length-1])&&(A[0]===6||A[0]===2)){v=0;continue}if(A[0]===3&&(!k||A[1]>k[0]&&A[1]<k[3])){v.label=A[1];break}if(A[0]===6&&v.label<k[1]){v.label=k[1],k=A;break}if(k&&v.label<k[2]){v.label=k[2],v.ops.push(A);break}k[2]&&v.ops.pop(),v.trys.pop();continue}A=b.call(m,v)}catch(T){A=[6,T],w=0}finally{c=k=0}if(A[0]&5)throw A[1];return{value:A[0]?A[1]:void 0,done:!0}}};function u(m,b){return b===void 0&&(b=o.defaultDecodeOptions),l(this,void 0,void 0,function(){var v,c;return f(this,function(w){return v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength),[2,c.decodeAsync(v)]})})}function _(m,b){b===void 0&&(b=o.defaultDecodeOptions);var v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength);return c.decodeArrayStream(v)}function g(m,b){b===void 0&&(b=o.defaultDecodeOptions);var v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength);return c.decodeStream(v)}function a(m,b){return b===void 0&&(b=o.defaultDecodeOptions),g(m,b)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs":function(n,t,r){r.r(t),r.d(t,"encode",function(){return o});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs"),s={};function o(l,f){f===void 0&&(f=s);var u=new i.Encoder(f.extensionCodec,f.context,f.maxDepth,f.initialBufferSize,f.sortKeys,f.forceFloat32,f.ignoreUndefined,f.forceIntegerToFloat);return u.encode(l)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs":function(n,t,r){r.r(t);var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs");r.d(t,"encode",function(){return i.encode});var s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs");r.d(t,"decode",function(){return s.decode}),r.d(t,"decodeMulti",function(){return s.decodeMulti});var o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs");r.d(t,"decodeAsync",function(){return o.decodeAsync}),r.d(t,"decodeArrayStream",function(){return o.decodeArrayStream}),r.d(t,"decodeMultiStream",function(){return o.decodeMultiStream}),r.d(t,"decodeStream",function(){return o.decodeStream});var l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs");r.d(t,"Decoder",function(){return l.Decoder}),r.d(t,"DataViewIndexOutOfBoundsError",function(){return l.DataViewIndexOutOfBoundsError});var f=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs");r.d(t,"DecodeError",function(){return f.DecodeError});var u=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs");r.d(t,"Encoder",function(){return u.Encoder});var _=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs");r.d(t,"ExtensionCodec",function(){return _.ExtensionCodec});var g=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs");r.d(t,"ExtData",function(){return g.ExtData});var a=r("./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs");r.d(t,"EXT_TIMESTAMP",function(){return a.EXT_TIMESTAMP}),r.d(t,"encodeDateToTimeSpec",function(){return a.encodeDateToTimeSpec}),r.d(t,"encodeTimeSpecToTimestamp",function(){return a.encodeTimeSpecToTimestamp}),r.d(t,"decodeTimestampToTimeSpec",function(){return a.decodeTimestampToTimeSpec}),r.d(t,"encodeTimestampExtension",function(){return a.encodeTimestampExtension}),r.d(t,"decodeTimestampExtension",function(){return a.decodeTimestampExtension})},"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs":function(n,t,r){r.r(t),r.d(t,"EXT_TIMESTAMP",function(){return o}),r.d(t,"encodeTimeSpecToTimestamp",function(){return u}),r.d(t,"encodeDateToTimeSpec",function(){return _}),r.d(t,"encodeTimestampExtension",function(){return g}),r.d(t,"decodeTimestampToTimeSpec",function(){return a}),r.d(t,"decodeTimestampExtension",function(){return m}),r.d(t,"timestampExtension",function(){return b});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),o=-1,l=4294967296-1,f=17179869184-1;function u(v){var c=v.sec,w=v.nsec;if(c>=0&&w>=0&&c<=f)if(w===0&&c<=l){var k=new Uint8Array(4),x=new DataView(k.buffer);return x.setUint32(0,c),k}else{var E=c/4294967296,O=c&4294967295,k=new Uint8Array(8),x=new DataView(k.buffer);return x.setUint32(0,w<<2|E&3),x.setUint32(4,O),k}else{var k=new Uint8Array(12),x=new DataView(k.buffer);return x.setUint32(0,w),Object(s.setInt64)(x,4,c),k}}function _(v){var c=v.getTime(),w=Math.floor(c/1e3),k=(c-w*1e3)*1e6,x=Math.floor(k/1e9);return{sec:w+x,nsec:k-x*1e9}}function g(v){if(v instanceof Date){var c=_(v);return u(c)}else return null}function a(v){var c=new DataView(v.buffer,v.byteOffset,v.byteLength);switch(v.byteLength){case 4:{var w=c.getUint32(0),k=0;return{sec:w,nsec:k}}case 8:{var x=c.getUint32(0),E=c.getUint32(4),w=(x&3)*4294967296+E,k=x>>>2;return{sec:w,nsec:k}}case 12:{var w=Object(s.getInt64)(c,4),k=c.getUint32(0);return{sec:w,nsec:k}}default:throw new i.DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): "+v.length)}}function m(v){var c=a(v);return new Date(c.sec*1e3+c.nsec/1e6)}var b={type:o,encode:g,decode:m}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs":function(n,t,r){r.r(t),r.d(t,"UINT32_MAX",function(){return i}),r.d(t,"setUint64",function(){return s}),r.d(t,"setInt64",function(){return o}),r.d(t,"getInt64",function(){return l}),r.d(t,"getUint64",function(){return f});var i=4294967295;function s(u,_,g){var a=g/4294967296,m=g;u.setUint32(_,a),u.setUint32(_+4,m)}function o(u,_,g){var a=Math.floor(g/4294967296),m=g;u.setUint32(_,a),u.setUint32(_+4,m)}function l(u,_){var g=u.getInt32(_),a=u.getUint32(_+4);return g*4294967296+a}function f(u,_){var g=u.getUint32(_),a=u.getUint32(_+4);return g*4294967296+a}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs":function(n,t,r){r.r(t),r.d(t,"prettyByte",function(){return i});function i(s){return(s<0?"-":"")+"0x"+Math.abs(s).toString(16).padStart(2,"0")}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs":function(n,t,r){r.r(t),r.d(t,"isAsyncIterable",function(){return l}),r.d(t,"asyncIterableFromStream",function(){return u}),r.d(t,"ensureAsyncIterable",function(){return _});var i=function(g,a){var m={label:0,sent:function(){if(c[0]&1)throw c[1];return c[1]},trys:[],ops:[]},b,v,c,w;return w={next:k(0),throw:k(1),return:k(2)},typeof Symbol=="function"&&(w[Symbol.iterator]=function(){return this}),w;function k(E){return function(O){return x([E,O])}}function x(E){if(b)throw new TypeError("Generator is already executing.");for(;m;)try{if(b=1,v&&(c=E[0]&2?v.return:E[0]?v.throw||((c=v.return)&&c.call(v),0):v.next)&&!(c=c.call(v,E[1])).done)return c;switch(v=0,c&&(E=[E[0]&2,c.value]),E[0]){case 0:case 1:c=E;break;case 4:return m.label++,{value:E[1],done:!1};case 5:m.label++,v=E[1],E=[0];continue;case 7:E=m.ops.pop(),m.trys.pop();continue;default:if(c=m.trys,!(c=c.length>0&&c[c.length-1])&&(E[0]===6||E[0]===2)){m=0;continue}if(E[0]===3&&(!c||E[1]>c[0]&&E[1]<c[3])){m.label=E[1];break}if(E[0]===6&&m.label<c[1]){m.label=c[1],c=E;break}if(c&&m.label<c[2]){m.label=c[2],m.ops.push(E);break}c[2]&&m.ops.pop(),m.trys.pop();continue}E=a.call(g,m)}catch(O){E=[6,O],v=0}finally{b=c=0}if(E[0]&5)throw E[1];return{value:E[0]?E[1]:void 0,done:!0}}},s=function(g){return this instanceof s?(this.v=g,this):new s(g)},o=function(g,a,m){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var b=m.apply(g,a||[]),v,c=[];return v={},w("next"),w("throw"),w("return"),v[Symbol.asyncIterator]=function(){return this},v;function w(T){b[T]&&(v[T]=function(j){return new Promise(function(I,D){c.push([T,j,I,D])>1||k(T,j)})})}function k(T,j){try{x(b[T](j))}catch(I){A(c[0][3],I)}}function x(T){T.value instanceof s?Promise.resolve(T.value.v).then(E,O):A(c[0][2],T)}function E(T){k("next",T)}function O(T){k("throw",T)}function A(T,j){T(j),c.shift(),c.length&&k(c[0][0],c[0][1])}};function l(g){return g[Symbol.asyncIterator]!=null}function f(g){if(g==null)throw new Error("Assertion Failure: value must not be null nor undefined")}function u(g){return o(this,arguments,function(){var m,b,v,c;return i(this,function(w){switch(w.label){case 0:m=g.getReader(),w.label=1;case 1:w.trys.push([1,,9,10]),w.label=2;case 2:return[4,s(m.read())];case 3:return b=w.sent(),v=b.done,c=b.value,v?[4,s(void 0)]:[3,5];case 4:return[2,w.sent()];case 5:return f(c),[4,s(c)];case 6:return[4,w.sent()];case 7:return w.sent(),[3,2];case 8:return[3,10];case 9:return m.releaseLock(),[7];case 10:return[2]}})})}function _(g){return l(g)?g:u(g)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs":function(n,t,r){r.r(t),r.d(t,"ensureUint8Array",function(){return i}),r.d(t,"createDataView",function(){return s});function i(o){return o instanceof Uint8Array?o:ArrayBuffer.isView(o)?new Uint8Array(o.buffer,o.byteOffset,o.byteLength):o instanceof ArrayBuffer?new Uint8Array(o):Uint8Array.from(o)}function s(o){if(o instanceof ArrayBuffer)return new DataView(o);var l=i(o);return new DataView(l.buffer,l.byteOffset,l.byteLength)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs":function(n,t,r){r.r(t),r.d(t,"utf8Count",function(){return o}),r.d(t,"utf8EncodeJs",function(){return l}),r.d(t,"TEXT_ENCODER_THRESHOLD",function(){return u}),r.d(t,"utf8EncodeTE",function(){return a}),r.d(t,"utf8DecodeJs",function(){return b}),r.d(t,"TEXT_DECODER_THRESHOLD",function(){return c}),r.d(t,"utf8DecodeTD",function(){return w});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),s=(typeof process>"u"||define_process_env_default.TEXT_ENCODING!=="never")&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function o(k){for(var x=k.length,E=0,O=0;O<x;){var A=k.charCodeAt(O++);if(A&4294967168)if(!(A&4294965248))E+=2;else{if(A>=55296&&A<=56319&&O<x){var T=k.charCodeAt(O);(T&64512)===56320&&(++O,A=((A&1023)<<10)+(T&1023)+65536)}A&4294901760?E+=4:E+=3}else{E++;continue}}return E}function l(k,x,E){for(var O=k.length,A=E,T=0;T<O;){var j=k.charCodeAt(T++);if(j&4294967168)if(!(j&4294965248))x[A++]=j>>6&31|192;else{if(j>=55296&&j<=56319&&T<O){var I=k.charCodeAt(T);(I&64512)===56320&&(++T,j=((j&1023)<<10)+(I&1023)+65536)}j&4294901760?(x[A++]=j>>18&7|240,x[A++]=j>>12&63|128,x[A++]=j>>6&63|128):(x[A++]=j>>12&15|224,x[A++]=j>>6&63|128)}else{x[A++]=j;continue}x[A++]=j&63|128}}var f=s?new TextEncoder:void 0,u=s?typeof process<"u"&&define_process_env_default.TEXT_ENCODING!=="force"?200:0:i.UINT32_MAX;function _(k,x,E){x.set(f.encode(k),E)}function g(k,x,E){f.encodeInto(k,x.subarray(E))}var a=f!=null&&f.encodeInto?g:_,m=4096;function b(k,x,E){for(var O=x,A=O+E,T=[],j="";O<A;){var I=k[O++];if(!(I&128))T.push(I);else if((I&224)===192){var D=k[O++]&63;T.push((I&31)<<6|D)}else if((I&240)===224){var D=k[O++]&63,$=k[O++]&63;T.push((I&31)<<12|D<<6|$)}else if((I&248)===240){var D=k[O++]&63,$=k[O++]&63,N=k[O++]&63,M=(I&7)<<18|D<<12|$<<6|N;M>65535&&(M-=65536,T.push(M>>>10&1023|55296),M=56320|M&1023),T.push(M)}else T.push(I);T.length>=m&&(j+=String.fromCharCode.apply(String,T),T.length=0)}return T.length>0&&(j+=String.fromCharCode.apply(String,T)),j}var v=s?new TextDecoder:null,c=s?typeof process<"u"&&define_process_env_default.TEXT_DECODER!=="force"?200:0:i.UINT32_MAX;function w(k,x,E){var O=k.subarray(x,x+E);return v.decode(O)}},"./src/hypha/rpc.js":function(n,t,r){r.r(t),r.d(t,"API_VERSION",function(){return o}),r.d(t,"RPC",function(){return b});var i=r("./src/hypha/utils.js"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs");const o="0.3.0",l=1024*500,f=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor;function u(v,c){const w=new Uint8Array(v.byteLength+c.byteLength);return w.set(new Uint8Array(v),0),w.set(new Uint8Array(c),v.byteLength),w.buffer}function _(v,c){if(!c)throw new Error("undefined index");return typeof c=="string"?_(v,c.split(".")):c.length===0?v:_(v[c[0]],c.slice(1))}function g(v){const c=v.toString(),w=c.match(/function\s*(\w*)/),k=w&&w[1]||"",x=c.match(/\(([^)]*)\)/);let E="";x&&(E=x[1].split(",").map(I=>I.replace(/\/\*.*?\*\//g,"").replace(/\/\/.*$/g,"")).filter(I=>I.trim().length>0).map(I=>I.trim()).join(", "));let O=c.match(/\)\s*\{\s*\/\*([\s\S]*?)\*\//);const A=O&&O[1].trim()||"";O=c.match(/\)\s*\{\s*(\/\/[\s\S]*?)\n\s*[^\s\/]/);const T=O&&O[1].split(`
`).map(I=>I.replace(/^\/\/\s*/,"").trim()).join(`
`)||"",j=A||T;return k&&E.length>0&&{name:k,sig:E,doc:j}}function a(v){var c=v.map(function(x){return x.byteLength}),w=c.reduce(function(x,E){return x+E},0),k=new Uint8Array(w);return c.reduce(function(x,E,O){return k.set(new Uint8Array(v[O]),x),x+E},0),k.buffer}class m{constructor(c,w,k,x){this._timeout=c,this._callback=w,this._args=k,this._label=x||"timer",this._task=null,this.started=!1}start(){this.started?this.reset():(this._task=setTimeout(()=>{this._callback.apply(this,this._args)},this._timeout*1e3),this.started=!0)}clear(){this._task?(clearTimeout(this._task),this._task=null,this.started=!1):console.warn(`Clearing a timer (${this._label}) which is not started`)}reset(){this._task&&clearTimeout(this._task),this._task=setTimeout(()=>{this._callback.apply(this,this._args)},this._timeout*1e3),this.started=!0}}class b extends i.MessageEmitter{constructor(c,{client_id:w=null,manager_id:k=null,default_context:x=null,name:E=null,codecs:O=null,method_timeout:A=null,max_message_buffer_size:T=0,debug:j=!1,workspace:I=null}){super(j),this._codecs=O||{},Object(i.assert)(w&&typeof w=="string"),Object(i.assert)(w,"client_id is required"),this._client_id=w,this._name=E,this._connection_info=null,this._workspace=null,this._local_workspace=I,this.manager_id=k,this.default_context=x||{},this._method_annotations=new WeakMap,this._manager_service=null,this._max_message_buffer_size=T,this._chunk_store={},this._method_timeout=A||30,this._services={},this._object_store={services:this._services},c?(this.add_service({id:"built-in",type:"built-in",name:"RPC built-in services",config:{require_context:!0,visibility:"public"},ping:this._ping.bind(this),get_service:this.get_local_service.bind(this),register_service:this.register_service.bind(this),message_cache:{create:this._create_message.bind(this),append:this._append_message.bind(this),process:this._process_message.bind(this),remove:this._remove_message.bind(this)}}),this.on("method",this._handle_method.bind(this)),Object(i.assert)(c.emit_message&&c.on_message),this._emit_message=c.emit_message.bind(c),c.on_message(this._on_message.bind(this)),this._connection=c,this._get_connection_info()):this._emit_message=function(){console.log("No connection to emit message")}}async _get_connection_info(){if(this.manager_id)try{if(await this.get_manager_service(30),Object(i.assert)(this._manager_service),this._connection_info=await this._manager_service.get_connection_info(),this._connection_info.reconnection_token&&this._connection.set_reconnection_token){this._connection.set_reconnection_token(this._connection_info.reconnection_token);const c=this._connection_info.reconnection_expires_in*.8;this._get_connection_info_task=setTimeout(this._get_connection_info.bind(this),c*1e3)}}catch(c){console.warn("Failed to fetch user info from ",this.manager_id,c)}}register_codec(c){if(!c.name||!c.encoder&&!c.decoder)throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");if(c.type)for(let w of Object.keys(this._codecs))(this._codecs[w].type===c.type||w===c.name)&&(delete this._codecs[w],console.warn("Remove duplicated codec: "+w));this._codecs[c.name]=c}async _ping(c,w){return Object(i.assert)(c=="ping"),"pong"}async ping(c,w){let k=this._generate_remote_method({_rtarget:c,_rmethod:"services.built-in.ping",_rpromise:!0,_rdoc:"Ping a remote client",_rsig:"ping(msg)"});Object(i.assert)(await k("ping",w)=="pong")}_create_message(c,w,k,x){if(w){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}if(this._object_store.message_cache||(this._object_store.message_cache={}),!k&&this._object_store.message_cache[c])throw new Error(`Message with the same key (${c}) already exists in the cache store, please use overwrite=true or remove it first.`);this._object_store.message_cache[c]=[]}_append_message(c,w,k,x){if(k){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}const E=this._object_store.message_cache;if(!E[c])throw new Error(`Message with key ${c} does not exists.`);Object(i.assert)(w instanceof f),E[c].push(w)}_remove_message(c,w){const k=this._object_store.message_cache;if(!k[c])throw new Error(`Message with key ${c} does not exists.`);delete k[c]}_process_message(c,w,k){if(w){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}const x=this._object_store.message_cache;if(Object(i.assert)(!!k,"Context is required"),!x[c])throw new Error(`Message with key ${c} does not exists.`);x[c]=a(x[c]),console.debug(`Processing message ${c} (size=${x[c].length})`);let E=Object(s.decodeMulti)(x[c]);const{done:O,value:A}=E.next(),T=A;if(Object.assign(T,{from:k.from,to:k.to,user:k.user}),T.ctx=JSON.parse(JSON.stringify(T)),Object.assign(T.ctx,this.default_context),!O){let j=E.next();Object.assign(T,j.value)}this._fire(T.type,T),delete x[c]}_on_message(c){try{Object(i.assert)(c instanceof ArrayBuffer);let w=Object(s.decodeMulti)(c);const{done:k,value:x}=w.next(),E=x;if(E.ctx=JSON.parse(JSON.stringify(E)),Object.assign(E.ctx,this.default_context),!k){let O=w.next();Object.assign(E,O.value)}this._fire(E.type,E)}catch{console.error(e)}}reset(){this._event_handlers={},this._services={}}async disconnect(){this._get_connection_info_task&&(clearTimeout(this._get_connection_info_task),this._get_connection_info_task=null),this._fire("disconnect")}async get_manager_service(c){this.manager_id&&!this._manager_service&&(this._manager_service=await this.get_remote_service(`${this.manager_id}:default`,c))}get_all_local_services(){return this._services}get_local_service(c,w){Object(i.assert)(c);const[k,x]=w.to.split("/");Object(i.assert)(x===this._client_id,"Services can only be accessed locally");const E=this._services[c];if(!E)throw new Error("Service not found: "+c);if(E.config.visibility=="public"||w.from.startsWith(k+"/"))return E;throw new Error("Permission denied for service: "+c)}async get_remote_service(c,w){w=w===void 0?this._method_timeout:w,!c&&this.manager_id?c=this.manager_id:c.includes(":")||(c=this._client_id+":"+c);const k=c.split(":")[0];Object(i.assert)(k);try{const x=this._generate_remote_method({_rtarget:k,_rmethod:"services.built-in.get_service",_rpromise:!0,_rdoc:"Get a remote service",_rsig:"get_service(service_id)"}),E=await Object(i.waitFor)(x(c.split(":")[1]),w,"Timeout Error: Failed to get remote service: "+c);return E.id=c,E}catch(x){throw console.error("Failed to get remote service: "+c,x),x}}_annotate_service_methods(c,w,k,x,E){if(typeof c=="function"){let O=w.split(".")[1];this._method_annotations.set(c,{require_context:Array.isArray(k)?k.includes(O):!!k,run_in_executor:x,method_id:"services."+w,visibility:E})}else if(c instanceof Array||c instanceof Object)for(let O of Object.keys(c)){let A=c[O];if(typeof A=="function"&&A.__rpc_object__){let T=A.__rpc_object__._rtarget;if(T.includes("/")&&(T=T.split("/")[1]),this._client_id===T)c instanceof Array&&(c=c.slice()),c[O]=_(this._object_store,A.__rpc_object__._rmethod),A=c[O];else throw new Error(`Local method not found: ${A.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${T}`)}this._annotate_service_methods(A,w+"."+O,k,x,E)}}add_service(c,w){if(!c||Array.isArray(c))throw new Error("Invalid service object");if(c.constructor===Object)c=Object.assign({},c);else{const O={},A=Object.getOwnPropertyNames(c).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(c)));for(let T of A)T!=="constructor"&&(typeof c[T]=="function"?O[T]=c[T].bind(c):O[T]=c[T]);c.id=c.id||"default",c=O}Object(i.assert)(c.id&&typeof c.id=="string",`Service id not found: ${c}`),c.name||(c.name=c.id),c.config||(c.config={}),c.type||(c.type="generic");let k=!1,x=!1;c.config.require_context&&(k=c.config.require_context),c.config.run_in_executor&&(x=!0);const E=c.config.visibility||"protected";if(Object(i.assert)(["protected","public"].includes(E)),this._annotate_service_methods(c,c.id,k,x,E),this._services[c.id])if(w)delete this._services[c.id];else throw new Error(`Service already exists: ${c.id}, please specify a different id (not ${c.id}) or overwrite=true`);return this._services[c.id]=c,c}async register_service(c,w,k,x){if(k===void 0&&(k=!0),x){const[O,A]=x.to.split("/");Object(i.assert)(A===this._client_id),Object(i.assert)(O===x.from.split("/")[0],"Services can only be registered from the same workspace")}const E=this.add_service(c,w);return k&&(this._fire("service-updated",{service_id:E.id,api:E,type:"add"}),await this._notify_service_update()),{id:`${this._client_id}:${E.id}`,type:E.type,name:E.name,description:E.description||"",config:E.config}}async unregister_service(c,w){if(c instanceof Object&&(c=c.id),!this._services[c])throw new Error(`Service not found: ${c}`);const k=this._services[c];delete this._services[c],this._fire("service-updated",{service_id:c,api:k,type:"remove"}),await this._notify_service_update()}_ndarray(c,w,k){const x=Object(i.typedArrayToDtype)(c);if(k&&k!==x)throw"dtype doesn't match the type of the array: "+x+" != "+k;return w=w||[c.length],{_rtype:"ndarray",_rvalue:c.buffer,_rshape:w,_rdtype:x}}_encode_callback(c,w,k,x,E,O){let A=`${k}.${c}`,T={_rtype:"method",_rtarget:O?`${O}/${this._client_id}`:this._client_id,_rmethod:A,_rpromise:!1};const j=this;return[T,function(){try{w.apply(null,Array.prototype.slice.call(arguments))}catch(D){console.error("Error in callback:",A,D)}finally{x&&j._object_store[k]&&delete j._object_store[k],E&&E.started&&E.clear()}}]}async _encode_promise(c,w,k,x,E,O){let A=this._get_session_store(k,!0);Object(i.assert)(A,`Failed to create session store ${k} due to invalid parent`);let T={};return E&&w&&this._method_timeout?(T.heartbeat=await this._encode(E.reset.bind(E),k,O),T.interval=this._method_timeout/2,A.timer=E):E=null,[T.resolve,A.resolve]=this._encode_callback("resolve",c,k,x,E,O),[T.reject,A.reject]=this._encode_callback("reject",w,k,x,E,O),T}async _send_chunks(c,w,k){let x=await this.get_remote_service(`${w}:built-in`);Object(i.assert)(x.message_cache,"Remote client does not support message caching for long message.");let E=x.message_cache,O=k||Object(i.randId)();await E.create(O,!!k);let A=c.length,T=Math.ceil(A/l);for(let j=0;j<T;j++){let I=j*l;await E.append(O,c.slice(I,I+l),!!k)}await E.process(O,!!k)}_generate_remote_method(c,w,k,x,E){let O=c._rtarget;x&&!O.includes("/")&&(O=x+"/"+O,c._rtarget=O);let A=c._rmethod,T=c._rpromise;const j=this;function I(){return new Promise(async($,N)=>{let M=Object(i.randId)();k&&(M=k+"."+M);let W=j._get_session_store(M,!0);if(!W){N(new Error(`Runtime Error: Failed to get session store ${M}`));return}W.target_id=O;const F=await j._encode(Array.prototype.slice.call(arguments),M,E),H=F.length,q=H>0&&typeof F[H-1]=="object"&&F[H-1]!==null&&F[H-1]._rkwargs;q&&delete F[H-1]._rkwargs;let Y={type:"method",from:j._local_workspace?j._local_workspace+"/"+j._client_id:j._client_id,to:O,method:A},X={};F&&(X.args=F),q&&(X.with_kwargs=q),w&&(Y.parent=w);let J=null;if(T){Y.session=M;let de=`${O}:${A}`;J=new m(j._method_timeout,N,[`Method call time out: ${de}`],de),X.promise=await j._encode_promise($,N,M,!0,J,E)}let te=Object(s.encode)(Y);if(X){const de=Object(s.encode)(X);te=new Uint8Array([...te,...de])}te.length<=l+1024?j._emit_message(te).then(function(){J&&J.start()}):j._send_chunks(te,O,w).then(function(){J&&J.start()})})}I.__rpc_object__=c;const D=A.split(".");return I.__name__=D[D.length-1],I.__doc__=c._rdoc,I.__sig__=c._rsig,I}async _notify_service_update(){if(this.manager_id)try{await this.get_manager_service(30),Object(i.assert)(this._manager_service),await this._manager_service.update_client_info(this.get_client_info())}catch(c){console.warn("Failed to notify service update to",this.manager_id,c)}}get_client_info(){const c=[];for(let w of Object.values(this._services))c.push({id:`${this._client_id}:${w.id}`,type:w.type,name:w.name,description:w.description||"",config:w.config});return{id:this._client_id,services:c}}async _handle_method(c){let w=null;try{Object(i.assert)(c.method&&c.ctx&&c.from);const k=c.from+":"+c.method,x=c.from.split("/")[0];c.to=c.to.includes("/")?c.to:x+"/"+c.to,c.ctx.to=c.to;const E=c.to.split("/")[0],O=c.parent;let A,T;if(c.promise){const D=await this._decode(c.promise,c.session,O,x,E);if(A=D.resolve,T=D.reject,D.heartbeat&&D.interval){async function $(){try{await D.heartbeat()}catch(N){console.error(N)}}w=setInterval($,D.interval*1e3)}}let j;try{j=_(this._object_store,c.method)}catch(D){throw console.debug("Failed to find method",k,D),new Error(`Method not found: ${k}`)}if(Object(i.assert)(j&&typeof j=="function","Invalid method: "+k),this._method_annotations.has(j)){if(this._method_annotations.get(j).visibility==="protected"&&E!==x)throw new Error("Permission denied for protected method "+k+", workspace mismatch: "+E+" != "+x)}else{let D=this._object_store[c.method.split(".")[0]].target_id;if(E===x&&D&&D.indexOf("/")===-1&&(D=E+"/"+D),D!==c.from)throw new Error("Access denied for method call ("+k+") from "+c.from)}O&&Object(i.assert)(this._get_session_store(O,!0)!==null,"Parent session was closed: "+O);let I;if(c.args?I=await this._decode(c.args,c.session,null,x,null):I=[],this._method_annotations.has(j)&&this._method_annotations.get(j).require_context&&I.push(c.ctx),c.promise){const D=j.apply(null,I);D instanceof Promise?D.then($=>{A($),clearInterval(w)}).catch($=>{T($),clearInterval(w)}):(A(D),clearInterval(w))}else j.apply(null,I),clearInterval(w)}catch(k){console.error("Error during calling method: ",k),clearInterval(w)}}encode(c,w){return this._encode(c,w)}_get_session_store(c,w){let k=this._object_store;const x=c.split(".");if(w){const E=x.length-1;for(let O of x.slice(0,E)){if(!k[O])return null;k=k[O]}return k[x[E]]||(k[x[E]]={}),k[x[E]]}else{for(let E of x){if(!k[E])return null;k=k[E]}return k}}async _encode(c,w,k){const x=typeof c;if(x==="number"||x==="string"||x==="boolean"||c===null||c===void 0||c instanceof Uint8Array)return c;if(c instanceof ArrayBuffer)return{_rtype:"memoryview",_rvalue:new Uint8Array(c)};if(c.__rpc_object__)return c.__rpc_object__;let E;if(c.constructor instanceof Object&&c._rtype){const A=c._rtype;return delete c._rtype,E=await this._encode(c,w,k),E._rtype=A,E}if(typeof c=="function"){if(this._method_annotations.has(c)){let A=this._method_annotations.get(c);E={_rtype:"method",_rtarget:this._client_id,_rmethod:A.method_id,_rpromise:!0}}else{Object(i.assert)(typeof w=="string");let A;c.__name__?A=`${Object(i.randId)()}-${c.__name__}`:A=Object(i.randId)(),E={_rtype:"method",_rtarget:this._client_id,_rmethod:`${w}.${A}`,_rpromise:!0};let T=this._get_session_store(w,!0);Object(i.assert)(T!==null,`Failed to create session store ${w} due to invalid parent`),T[A]=c}if(E._rdoc=c.__doc__,E._rsig=c.__sig__,!E._rdoc||!E._rsig)try{const A=g(c);A&&!E._rdoc&&(E._rdoc=`${A.doc}`),A&&!E._rsig&&(E._rsig=`${A.name}(${A.sig})`)}catch{console.error("Failed to extract function docstring:",c)}return E}const O=Array.isArray(c);for(let A of Object.keys(this._codecs)){const T=this._codecs[A];if(T.encoder&&c instanceof T.type){let j=await Promise.resolve(T.encoder(c));if(j&&!j._rtype&&(j._rtype=T.name),typeof j=="object"){const I=j._rtype;delete j._rtype,j=await this._encode(j,w,k),j._rtype=I}return E=j,E}}if(typeof tf<"u"&&tf.Tensor&&c instanceof tf.Tensor){const A=c.dataSync();E={_rtype:"ndarray",_rvalue:new Uint8Array(A.buffer),_rshape:c.shape,_rdtype:c.dtype}}else if(typeof nj<"u"&&nj.NdArray&&c instanceof nj.NdArray){const A=Object(i.typedArrayToDtype)(c.selection.data);E={_rtype:"ndarray",_rvalue:new Uint8Array(c.selection.data.buffer),_rshape:c.shape,_rdtype:A}}else if(c instanceof Error)console.error(c),E={_rtype:"error",_rvalue:c.toString()};else if(c!==Object(c)||c instanceof Boolean||c instanceof String||c instanceof Date||c instanceof RegExp||c instanceof ImageData||typeof FileList<"u"&&c instanceof FileList||typeof FileSystemDirectoryHandle<"u"&&c instanceof FileSystemDirectoryHandle||typeof FileSystemFileHandle<"u"&&c instanceof FileSystemFileHandle||typeof FileSystemHandle<"u"&&c instanceof FileSystemHandle||typeof FileSystemWritableFileStream<"u"&&c instanceof FileSystemWritableFileStream)E=c;else if(c instanceof Blob){let A=function(I){T=I},T=0;async function j(I){let D;I?D=c.slice(T,T+I):D=c.slice(T);const $=new Uint8Array(await D.arrayBuffer());return T=T+$.byteLength,$}E={_rtype:"iostream",_rnative:"js:blob",type:c.type,name:c.name,size:c.size,path:c._path||c.webkitRelativePath,read:await this._encode(j,w,k),seek:await this._encode(A,w,k)}}else if(c instanceof f){const A=Object(i.typedArrayToDtype)(c);E={_rtype:"typedarray",_rvalue:new Uint8Array(c.buffer),_rdtype:A}}else if(c instanceof DataView)E={_rtype:"memoryview",_rvalue:new Uint8Array(c.buffer)};else if(c instanceof Set)E={_rtype:"set",_rvalue:await this._encode(Array.from(c),w,k)};else if(c instanceof Map)E={_rtype:"orderedmap",_rvalue:await this._encode(Array.from(c),w,k)};else if(c.constructor instanceof Object||Array.isArray(c)){E=O?[]:{};const A=Object.keys(c);for(let T of A)E[T]=await this._encode(c[T],w,k)}else throw`imjoy-rpc: Unsupported data type: ${c}, you can register a custom codec to encode/decode the object.`;if(!E)throw new Error("Failed to encode object");return E}async decode(c){return await this._decode(c)}async _decode(c,w,k,x,E){if(!c)return c;let O;if(c._rtype)if(this._codecs[c._rtype]&&this._codecs[c._rtype].decoder){const A=c._rtype;delete c._rtype,c=await this._decode(c,w,k,x,E),c._rtype=A,O=await Promise.resolve(this._codecs[c._rtype].decoder(c))}else if(c._rtype==="method")O=this._generate_remote_method(c,w,k,x,E);else if(c._rtype==="ndarray")if(typeof nj<"u"&&nj.array)Array.isArray(c._rvalue)&&(c._rvalue=c._rvalue.reduce(u)),O=nj.array(new Uint8(c._rvalue),c._rdtype).reshape(c._rshape);else if(typeof tf<"u"&&tf.Tensor){Array.isArray(c._rvalue)&&(c._rvalue=c._rvalue.reduce(u));const A=i.dtypeToTypedArray[c._rdtype];O=tf.tensor(new A(c._rvalue),c._rshape,c._rdtype)}else O=c;else if(c._rtype==="error")O=new Error(c._rvalue);else if(c._rtype==="typedarray"){const A=i.dtypeToTypedArray[c._rdtype];if(!A)throw new Error("unsupported dtype: "+c._rdtype);const T=c._rvalue.buffer.slice(c._rvalue.byteOffset,c._rvalue.byteOffset+c._rvalue.byteLength);O=new A(T)}else if(c._rtype==="memoryview")O=c._rvalue.buffer.slice(c._rvalue.byteOffset,c._rvalue.byteOffset+c._rvalue.byteLength);else if(c._rtype==="iostream"){if(c._rnative==="js:blob"){const T=await(await this._generate_remote_method(c.read,w,k,x,E))();O=new Blob([T],{type:c.type,name:c.name})}else{O={};for(let A of Object.keys(c))A.startsWith("_")||(O[A]=await this._decode(c[A],w,k,x,E))}O.__rpc_object__=c}else if(c._rtype==="orderedmap")O=new Map(await this._decode(c._rvalue,w,k,x,E));else if(c._rtype==="set")O=new Set(await this._decode(c._rvalue,w,k,x,E));else{const A=c._rtype;delete c._rtype,O=await this._decode(c,w,k,x,E),O._rtype=A}else if(c.constructor===Object||Array.isArray(c)){const A=Array.isArray(c);O=A?[]:{};for(let T of Object.keys(c))if(A||c.hasOwnProperty(T)){const j=c[T];O[T]=await this._decode(j,w,k,x,E)}}else O=c;if(O===void 0)throw new Error("Failed to decode object");return O}}},"./src/hypha/utils.js":function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"randId",function(){return randId}),__webpack_require__.d(__webpack_exports__,"dtypeToTypedArray",function(){return dtypeToTypedArray}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWindow",function(){return loadRequirementsInWindow}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWebworker",function(){return loadRequirementsInWebworker}),__webpack_require__.d(__webpack_exports__,"loadRequirements",function(){return loadRequirements}),__webpack_require__.d(__webpack_exports__,"normalizeConfig",function(){return normalizeConfig}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtypeMapping",function(){return typedArrayToDtypeMapping}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtype",function(){return typedArrayToDtype}),__webpack_require__.d(__webpack_exports__,"cacheRequirements",function(){return cacheRequirements}),__webpack_require__.d(__webpack_exports__,"setupServiceWorker",function(){return setupServiceWorker}),__webpack_require__.d(__webpack_exports__,"assert",function(){return assert}),__webpack_require__.d(__webpack_exports__,"urlJoin",function(){return urlJoin}),__webpack_require__.d(__webpack_exports__,"waitFor",function(){return waitFor}),__webpack_require__.d(__webpack_exports__,"MessageEmitter",function(){return MessageEmitter});function randId(){return Math.random().toString(36).substr(2,10)+new Date().getTime()}const dtypeToTypedArray={int8:Int8Array,int16:Int16Array,int32:Int32Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,float32:Float32Array,float64:Float64Array,array:Array};async function loadRequirementsInWindow(n){function t(o){return new Promise((l,f)=>{var u=document.createElement("script");u.src=o,u.type="text/javascript",u.onload=l,u.onreadystatechange=function(){(this.readyState==="loaded"||this.readyState==="complete")&&l()},u.onerror=f,document.head.appendChild(u)})}async function r(){for(var o=Array.prototype.slice.call(arguments),l=o.length,f=0;f<l;f++)await t(o[f])}if(n&&(Array.isArray(n)||typeof n=="string"))try{var i;if(n=typeof n=="string"?[n]:n,Array.isArray(n))for(var s=0;s<n.length;s++)n[s].toLowerCase().endsWith(".css")||n[s].startsWith("css:")?(n[s].startsWith("css:")&&(n[s]=n[s].slice(4)),i=document.createElement("link"),i.rel="stylesheet",i.href=n[s],document.head.appendChild(i)):n[s].toLowerCase().endsWith(".mjs")||n[s].startsWith("mjs:")?(n[s].startsWith("mjs:")&&(n[s]=n[s].slice(4)),await __vitePreload(()=>import(n[s]),__vite__mapDeps([]))):n[s].toLowerCase().endsWith(".js")||n[s].startsWith("js:")?(n[s].startsWith("js:")&&(n[s]=n[s].slice(3)),await r(n[s])):n[s].startsWith("http")?await r(n[s]):n[s].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[s]);else throw"unsupported requirements definition"}catch{throw"failed to import required scripts: "+n.toString()}}async function loadRequirementsInWebworker(n){if(n&&(Array.isArray(n)||typeof n=="string"))try{Array.isArray(n)||(n=[n]);for(var t=0;t<n.length;t++){if(n[t].toLowerCase().endsWith(".css")||n[t].startsWith("css:"))throw"unable to import css in a webworker";n[t].toLowerCase().endsWith(".js")||n[t].startsWith("js:")?(n[t].startsWith("js:")&&(n[t]=n[t].slice(3)),importScripts(n[t])):n[t].startsWith("http")?importScripts(n[t]):n[t].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[t])}}catch{throw"failed to import required scripts: "+n.toString()}}function loadRequirements(n){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?loadRequirementsInWebworker(n):loadRequirementsInWindow(n)}function normalizeConfig(n){return n.version=n.version||"0.1.0",n.description=n.description||`[TODO: add description for ${n.name} ]`,n.type=n.type||"rpc-window",n.id=n.id||randId(),n.target_origin=n.target_origin||"*",n.allow_execution=n.allow_execution||!1,n=Object.keys(n).reduce((t,r)=>(typeof n[r]!="function"&&(t[r]=n[r]),t),{}),n}const typedArrayToDtypeMapping={Int8Array:"int8",Int16Array:"int16",Int32Array:"int32",Uint8Array:"uint8",Uint16Array:"uint16",Uint32Array:"uint32",Float32Array:"float32",Float64Array:"float64",Array:"array"},typedArrayToDtypeKeys=[];for(const arrType of Object.keys(typedArrayToDtypeMapping))typedArrayToDtypeKeys.push(eval(arrType));function typedArrayToDtype(n){let t=typedArrayToDtypeMapping[n.constructor.name];if(!t){const r=Object.getPrototypeOf(n);for(const i of typedArrayToDtypeKeys)if(r instanceof i){t=typedArrayToDtypeMapping[i.name];break}}return t}function cacheUrlInServiceWorker(n){return new Promise(function(t,r){const i={command:"add",url:n};if(!navigator.serviceWorker||!navigator.serviceWorker.register){r("Service worker is not supported.");return}const s=new MessageChannel;s.port1.onmessage=function(o){o.data&&o.data.error?r(o.data.error):t(o.data&&o.data.result)},navigator.serviceWorker&&navigator.serviceWorker.controller?navigator.serviceWorker.controller.postMessage(i,[s.port2]):r("Service worker controller is not available")})}async function cacheRequirements(n){n=n||[],Array.isArray(n)||(n=[n]);for(let t of n)t.startsWith("js:")&&(t=t.slice(3)),t.startsWith("css:")&&(t=t.slice(4)),t.startsWith("cache:")&&(t=t.slice(6)),t.startsWith("http")&&await cacheUrlInServiceWorker(t).catch(r=>{console.error(r)})}function setupServiceWorker(n,t,r){if("serviceWorker"in navigator){if(n=n||"/",navigator.serviceWorker.register(n+"plugin-service-worker.js").then(function(i){console.log("ServiceWorker registration successful with scope: ",i.scope)},function(i){console.log("ServiceWorker registration failed: ",i)}),t=t||"*",r=r||cacheRequirements,r&&typeof r!="function")throw new Error("config.cache_requirements must be a function");window.addEventListener("message",function(i){if(t==="*"||i.origin===t){const s=i.data;s.type==="cacheRequirements"&&r(s.requirements)}})}}function assert(n,t){if(!n)throw new Error(t||"Assertion failed")}function urlJoin(...n){return n.join("/").replace(/[\/]+/g,"/").replace(/^(.+):\//,"$1://").replace(/^file:/,"file:/").replace(/\/(\?|&|#[^!])/g,"$1").replace(/\?/g,"&").replace("&","?")}function waitFor(n,t,r){let i;return Promise.race([n,new Promise((s,o)=>i=setTimeout(()=>{o(r||"Timeout Error")},t*1e3))]).finally(()=>clearTimeout(i))}class MessageEmitter{constructor(t){this._event_handlers={},this._once_handlers={},this._debug=t}emit(){throw new Error("emit is not implemented")}on(t,r){this._event_handlers[t]||(this._event_handlers[t]=[]),this._event_handlers[t].push(r)}once(t,r){r.___event_run_once=!0,this.on(t,r)}off(t,r){if(!t&&!r)this._event_handlers={};else if(t&&!r)this._event_handlers[t]&&(this._event_handlers[t]=[]);else if(this._event_handlers[t]){const i=this._event_handlers[t].indexOf(r);i>=0&&this._event_handlers[t].splice(i,1)}}_fire(t,r){if(this._event_handlers[t])for(var i=this._event_handlers[t].length;i--;){const s=this._event_handlers[t][i];try{s(r)}catch(o){console.error(o)}finally{s.___event_run_once&&this._event_handlers[t].splice(i,1)}}else this._debug&&console.warn("unhandled event",t,r)}}}})})})(hyphaRpc);var hyphaRpcExports=hyphaRpc.exports,hyphaRpcWebsocket={exports:{}};(function(module,exports){var define_process_env_default={};(function(t,r){module.exports=r()})(window,function(){return function(n){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i,l:!1,exports:{}};return n[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=n,r.c=t,r.d=function(i,s,o){r.o(i,s)||Object.defineProperty(i,s,{enumerable:!0,get:o})},r.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},r.t=function(i,s){if(s&1&&(i=r(i)),s&8||s&4&&typeof i=="object"&&i&&i.__esModule)return i;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:i}),s&2&&typeof i!="string")for(var l in i)r.d(o,l,(function(f){return i[f]}).bind(null,l));return o},r.n=function(i){var s=i&&i.__esModule?function(){return i.default}:function(){return i};return r.d(s,"a",s),s},r.o=function(i,s){return Object.prototype.hasOwnProperty.call(i,s)},r.p="",r(r.s="./src/hypha/websocket-client.js")}({"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs":function(n,t,r){r.r(t),r.d(t,"CachedKeyDecoder",function(){return l});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),s=16,o=16,l=function(){function f(u,_){u===void 0&&(u=s),_===void 0&&(_=o),this.maxKeyLength=u,this.maxLengthPerKey=_,this.hit=0,this.miss=0,this.caches=[];for(var g=0;g<this.maxKeyLength;g++)this.caches.push([])}return f.prototype.canBeCached=function(u){return u>0&&u<=this.maxKeyLength},f.prototype.find=function(u,_,g){var a=this.caches[g-1];e:for(var m=0,b=a;m<b.length;m++){for(var v=b[m],c=v.bytes,w=0;w<g;w++)if(c[w]!==u[_+w])continue e;return v.str}return null},f.prototype.store=function(u,_){var g=this.caches[u.length-1],a={bytes:u,str:_};g.length>=this.maxLengthPerKey?g[Math.random()*g.length|0]=a:g.push(a)},f.prototype.decode=function(u,_,g){var a=this.find(u,_,g);if(a!=null)return this.hit++,a;this.miss++;var m=Object(i.utf8DecodeJs)(u,_,g),b=Uint8Array.prototype.slice.call(u,_,_+g);return this.store(b,m),m},f}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs":function(n,t,r){r.r(t),r.d(t,"DecodeError",function(){return s});var i=function(){var o=function(l,f){return o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(u,_){u.__proto__=_}||function(u,_){for(var g in _)Object.prototype.hasOwnProperty.call(_,g)&&(u[g]=_[g])},o(l,f)};return function(l,f){if(typeof f!="function"&&f!==null)throw new TypeError("Class extends value "+String(f)+" is not a constructor or null");o(l,f);function u(){this.constructor=l}l.prototype=f===null?Object.create(f):(u.prototype=f.prototype,new u)}}(),s=function(o){i(l,o);function l(f){var u=o.call(this,f)||this,_=Object.create(l.prototype);return Object.setPrototypeOf(u,_),Object.defineProperty(u,"name",{configurable:!0,enumerable:!1,value:l.name}),u}return l}(Error)},"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs":function(n,t,r){r.r(t),r.d(t,"DataViewIndexOutOfBoundsError",function(){return E}),r.d(t,"Decoder",function(){return T});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),f=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"),u=r("./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs"),_=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"),g=function(j,I,D,$){function N(M){return M instanceof D?M:new D(function(W){W(M)})}return new(D||(D=Promise))(function(M,W){function F(Y){try{q($.next(Y))}catch(X){W(X)}}function H(Y){try{q($.throw(Y))}catch(X){W(X)}}function q(Y){Y.done?M(Y.value):N(Y.value).then(F,H)}q(($=$.apply(j,I||[])).next())})},a=function(j,I){var D={label:0,sent:function(){if(M[0]&1)throw M[1];return M[1]},trys:[],ops:[]},$,N,M,W;return W={next:F(0),throw:F(1),return:F(2)},typeof Symbol=="function"&&(W[Symbol.iterator]=function(){return this}),W;function F(q){return function(Y){return H([q,Y])}}function H(q){if($)throw new TypeError("Generator is already executing.");for(;D;)try{if($=1,N&&(M=q[0]&2?N.return:q[0]?N.throw||((M=N.return)&&M.call(N),0):N.next)&&!(M=M.call(N,q[1])).done)return M;switch(N=0,M&&(q=[q[0]&2,M.value]),q[0]){case 0:case 1:M=q;break;case 4:return D.label++,{value:q[1],done:!1};case 5:D.label++,N=q[1],q=[0];continue;case 7:q=D.ops.pop(),D.trys.pop();continue;default:if(M=D.trys,!(M=M.length>0&&M[M.length-1])&&(q[0]===6||q[0]===2)){D=0;continue}if(q[0]===3&&(!M||q[1]>M[0]&&q[1]<M[3])){D.label=q[1];break}if(q[0]===6&&D.label<M[1]){D.label=M[1],M=q;break}if(M&&D.label<M[2]){D.label=M[2],D.ops.push(q);break}M[2]&&D.ops.pop(),D.trys.pop();continue}q=I.call(j,D)}catch(Y){q=[6,Y],N=0}finally{$=M=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:!0}}},m=function(j){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var I=j[Symbol.asyncIterator],D;return I?I.call(j):(j=typeof __values=="function"?__values(j):j[Symbol.iterator](),D={},$("next"),$("throw"),$("return"),D[Symbol.asyncIterator]=function(){return this},D);function $(M){D[M]=j[M]&&function(W){return new Promise(function(F,H){W=j[M](W),N(F,H,W.done,W.value)})}}function N(M,W,F,H){Promise.resolve(H).then(function(q){M({value:q,done:F})},W)}},b=function(j){return this instanceof b?(this.v=j,this):new b(j)},v=function(j,I,D){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var $=D.apply(j,I||[]),N,M=[];return N={},W("next"),W("throw"),W("return"),N[Symbol.asyncIterator]=function(){return this},N;function W(J){$[J]&&(N[J]=function(te){return new Promise(function(ie,de){M.push([J,te,ie,de])>1||F(J,te)})})}function F(J,te){try{H($[J](te))}catch(ie){X(M[0][3],ie)}}function H(J){J.value instanceof b?Promise.resolve(J.value.v).then(q,Y):X(M[0][2],J)}function q(J){F("next",J)}function Y(J){F("throw",J)}function X(J,te){J(te),M.shift(),M.length&&F(M[0][0],M[0][1])}},c=function(j){var I=typeof j;return I==="string"||I==="number"},w=-1,k=new DataView(new ArrayBuffer(0)),x=new Uint8Array(k.buffer),E=function(){try{k.getInt8(0)}catch(j){return j.constructor}throw new Error("never reached")}(),O=new E("Insufficient data"),A=new u.CachedKeyDecoder,T=function(){function j(I,D,$,N,M,W,F,H){I===void 0&&(I=s.ExtensionCodec.defaultCodec),D===void 0&&(D=void 0),$===void 0&&($=o.UINT32_MAX),N===void 0&&(N=o.UINT32_MAX),M===void 0&&(M=o.UINT32_MAX),W===void 0&&(W=o.UINT32_MAX),F===void 0&&(F=o.UINT32_MAX),H===void 0&&(H=A),this.extensionCodec=I,this.context=D,this.maxStrLength=$,this.maxBinLength=N,this.maxArrayLength=M,this.maxMapLength=W,this.maxExtLength=F,this.keyDecoder=H,this.totalPos=0,this.pos=0,this.view=k,this.bytes=x,this.headByte=w,this.stack=[]}return j.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=w,this.stack.length=0},j.prototype.setBuffer=function(I){this.bytes=Object(f.ensureUint8Array)(I),this.view=Object(f.createDataView)(this.bytes),this.pos=0},j.prototype.appendBuffer=function(I){if(this.headByte===w&&!this.hasRemaining(1))this.setBuffer(I);else{var D=this.bytes.subarray(this.pos),$=Object(f.ensureUint8Array)(I),N=new Uint8Array(D.length+$.length);N.set(D),N.set($,D.length),this.setBuffer(N)}},j.prototype.hasRemaining=function(I){return this.view.byteLength-this.pos>=I},j.prototype.createExtraByteError=function(I){var D=this,$=D.view,N=D.pos;return new RangeError("Extra "+($.byteLength-N)+" of "+$.byteLength+" byte(s) found at buffer["+I+"]")},j.prototype.decode=function(I){this.reinitializeState(),this.setBuffer(I);var D=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return D},j.prototype.decodeMulti=function(I){return a(this,function(D){switch(D.label){case 0:this.reinitializeState(),this.setBuffer(I),D.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return D.sent(),[3,1];case 3:return[2]}})},j.prototype.decodeAsync=function(I){var D,$,N,M;return g(this,void 0,void 0,function(){var W,F,H,q,Y,X,J,te;return a(this,function(ie){switch(ie.label){case 0:W=!1,ie.label=1;case 1:ie.trys.push([1,6,7,12]),D=m(I),ie.label=2;case 2:return[4,D.next()];case 3:if($=ie.sent(),!!$.done)return[3,5];if(H=$.value,W)throw this.createExtraByteError(this.totalPos);this.appendBuffer(H);try{F=this.doDecodeSync(),W=!0}catch(de){if(!(de instanceof E))throw de}this.totalPos+=this.pos,ie.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return q=ie.sent(),N={error:q},[3,12];case 7:return ie.trys.push([7,,10,11]),$&&!$.done&&(M=D.return)?[4,M.call(D)]:[3,9];case 8:ie.sent(),ie.label=9;case 9:return[3,11];case 10:if(N)throw N.error;return[7];case 11:return[7];case 12:if(W){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,F]}throw Y=this,X=Y.headByte,J=Y.pos,te=Y.totalPos,new RangeError("Insufficient data in parsing "+Object(i.prettyByte)(X)+" at "+te+" ("+J+" in the current buffer)")}})})},j.prototype.decodeArrayStream=function(I){return this.decodeMultiAsync(I,!0)},j.prototype.decodeStream=function(I){return this.decodeMultiAsync(I,!1)},j.prototype.decodeMultiAsync=function(I,D){return v(this,arguments,function(){var N,M,W,F,H,q,Y,X,J;return a(this,function(te){switch(te.label){case 0:N=D,M=-1,te.label=1;case 1:te.trys.push([1,13,14,19]),W=m(I),te.label=2;case 2:return[4,b(W.next())];case 3:if(F=te.sent(),!!F.done)return[3,12];if(H=F.value,D&&M===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(H),N&&(M=this.readArraySize(),N=!1,this.complete()),te.label=4;case 4:te.trys.push([4,9,,10]),te.label=5;case 5:return[4,b(this.doDecodeSync())];case 6:return[4,te.sent()];case 7:return te.sent(),--M===0?[3,8]:[3,5];case 8:return[3,10];case 9:if(q=te.sent(),!(q instanceof E))throw q;return[3,10];case 10:this.totalPos+=this.pos,te.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return Y=te.sent(),X={error:Y},[3,19];case 14:return te.trys.push([14,,17,18]),F&&!F.done&&(J=W.return)?[4,b(J.call(W))]:[3,16];case 15:te.sent(),te.label=16;case 16:return[3,18];case 17:if(X)throw X.error;return[7];case 18:return[7];case 19:return[2]}})})},j.prototype.doDecodeSync=function(){e:for(;;){var I=this.readHeadByte(),D=void 0;if(I>=224)D=I-256;else if(I<192)if(I<128)D=I;else if(I<144){var $=I-128;if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I<160){var $=I-144;if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else{var N=I-160;D=this.decodeUtf8String(N,0)}else if(I===192)D=null;else if(I===194)D=!1;else if(I===195)D=!0;else if(I===202)D=this.readF32();else if(I===203)D=this.readF64();else if(I===204)D=this.readU8();else if(I===205)D=this.readU16();else if(I===206)D=this.readU32();else if(I===207)D=this.readU64();else if(I===208)D=this.readI8();else if(I===209)D=this.readI16();else if(I===210)D=this.readI32();else if(I===211)D=this.readI64();else if(I===217){var N=this.lookU8();D=this.decodeUtf8String(N,1)}else if(I===218){var N=this.lookU16();D=this.decodeUtf8String(N,2)}else if(I===219){var N=this.lookU32();D=this.decodeUtf8String(N,4)}else if(I===220){var $=this.readU16();if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else if(I===221){var $=this.readU32();if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else if(I===222){var $=this.readU16();if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I===223){var $=this.readU32();if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I===196){var $=this.lookU8();D=this.decodeBinary($,1)}else if(I===197){var $=this.lookU16();D=this.decodeBinary($,2)}else if(I===198){var $=this.lookU32();D=this.decodeBinary($,4)}else if(I===212)D=this.decodeExtension(1,0);else if(I===213)D=this.decodeExtension(2,0);else if(I===214)D=this.decodeExtension(4,0);else if(I===215)D=this.decodeExtension(8,0);else if(I===216)D=this.decodeExtension(16,0);else if(I===199){var $=this.lookU8();D=this.decodeExtension($,1)}else if(I===200){var $=this.lookU16();D=this.decodeExtension($,2)}else if(I===201){var $=this.lookU32();D=this.decodeExtension($,4)}else throw new _.DecodeError("Unrecognized type byte: "+Object(i.prettyByte)(I));this.complete();for(var M=this.stack;M.length>0;){var W=M[M.length-1];if(W.type===0)if(W.array[W.position]=D,W.position++,W.position===W.size)M.pop(),D=W.array;else continue e;else if(W.type===1){if(!c(D))throw new _.DecodeError("The type of key must be string or number but "+typeof D);if(D==="__proto__")throw new _.DecodeError("The key __proto__ is not allowed");W.key=D,W.type=2;continue e}else if(W.map[W.key]=D,W.readCount++,W.readCount===W.size)M.pop(),D=W.map;else{W.key=null,W.type=1;continue e}}return D}},j.prototype.readHeadByte=function(){return this.headByte===w&&(this.headByte=this.readU8()),this.headByte},j.prototype.complete=function(){this.headByte=w},j.prototype.readArraySize=function(){var I=this.readHeadByte();switch(I){case 220:return this.readU16();case 221:return this.readU32();default:{if(I<160)return I-144;throw new _.DecodeError("Unrecognized array type byte: "+Object(i.prettyByte)(I))}}},j.prototype.pushMapState=function(I){if(I>this.maxMapLength)throw new _.DecodeError("Max length exceeded: map length ("+I+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:I,key:null,readCount:0,map:{}})},j.prototype.pushArrayState=function(I){if(I>this.maxArrayLength)throw new _.DecodeError("Max length exceeded: array length ("+I+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:I,array:new Array(I),position:0})},j.prototype.decodeUtf8String=function(I,D){var $;if(I>this.maxStrLength)throw new _.DecodeError("Max length exceeded: UTF-8 byte length ("+I+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+D+I)throw O;var N=this.pos+D,M;return this.stateIsMapKey()&&(!(($=this.keyDecoder)===null||$===void 0)&&$.canBeCached(I))?M=this.keyDecoder.decode(this.bytes,N,I):I>l.TEXT_DECODER_THRESHOLD?M=Object(l.utf8DecodeTD)(this.bytes,N,I):M=Object(l.utf8DecodeJs)(this.bytes,N,I),this.pos+=D+I,M},j.prototype.stateIsMapKey=function(){if(this.stack.length>0){var I=this.stack[this.stack.length-1];return I.type===1}return!1},j.prototype.decodeBinary=function(I,D){if(I>this.maxBinLength)throw new _.DecodeError("Max length exceeded: bin length ("+I+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(I+D))throw O;var $=this.pos+D,N=this.bytes.subarray($,$+I);return this.pos+=D+I,N},j.prototype.decodeExtension=function(I,D){if(I>this.maxExtLength)throw new _.DecodeError("Max length exceeded: ext length ("+I+") > maxExtLength ("+this.maxExtLength+")");var $=this.view.getInt8(this.pos+D),N=this.decodeBinary(I,D+1);return this.extensionCodec.decode(N,$,this.context)},j.prototype.lookU8=function(){return this.view.getUint8(this.pos)},j.prototype.lookU16=function(){return this.view.getUint16(this.pos)},j.prototype.lookU32=function(){return this.view.getUint32(this.pos)},j.prototype.readU8=function(){var I=this.view.getUint8(this.pos);return this.pos++,I},j.prototype.readI8=function(){var I=this.view.getInt8(this.pos);return this.pos++,I},j.prototype.readU16=function(){var I=this.view.getUint16(this.pos);return this.pos+=2,I},j.prototype.readI16=function(){var I=this.view.getInt16(this.pos);return this.pos+=2,I},j.prototype.readU32=function(){var I=this.view.getUint32(this.pos);return this.pos+=4,I},j.prototype.readI32=function(){var I=this.view.getInt32(this.pos);return this.pos+=4,I},j.prototype.readU64=function(){var I=Object(o.getUint64)(this.view,this.pos);return this.pos+=8,I},j.prototype.readI64=function(){var I=Object(o.getInt64)(this.view,this.pos);return this.pos+=8,I},j.prototype.readF32=function(){var I=this.view.getFloat32(this.pos);return this.pos+=4,I},j.prototype.readF64=function(){var I=this.view.getFloat64(this.pos);return this.pos+=8,I},j}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs":function(n,t,r){r.r(t),r.d(t,"DEFAULT_MAX_DEPTH",function(){return f}),r.d(t,"DEFAULT_INITIAL_BUFFER_SIZE",function(){return u}),r.d(t,"Encoder",function(){return _});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"),f=100,u=2048,_=function(){function g(a,m,b,v,c,w,k,x){a===void 0&&(a=s.ExtensionCodec.defaultCodec),m===void 0&&(m=void 0),b===void 0&&(b=f),v===void 0&&(v=u),c===void 0&&(c=!1),w===void 0&&(w=!1),k===void 0&&(k=!1),x===void 0&&(x=!1),this.extensionCodec=a,this.context=m,this.maxDepth=b,this.initialBufferSize=v,this.sortKeys=c,this.forceFloat32=w,this.ignoreUndefined=k,this.forceIntegerToFloat=x,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return g.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},g.prototype.reinitializeState=function(){this.pos=0},g.prototype.encode=function(a){return this.reinitializeState(),this.doEncode(a,1),this.getUint8Array()},g.prototype.doEncode=function(a,m){if(m>this.maxDepth)throw new Error("Too deep objects in depth "+m);a==null?this.encodeNil():typeof a=="boolean"?this.encodeBoolean(a):typeof a=="number"?this.encodeNumber(a):typeof a=="string"?this.encodeString(a):this.encodeObject(a,m)},g.prototype.ensureBufferSizeToWrite=function(a){var m=this.pos+a;this.view.byteLength<m&&this.resizeBuffer(m*2)},g.prototype.resizeBuffer=function(a){var m=new ArrayBuffer(a),b=new Uint8Array(m),v=new DataView(m);b.set(this.bytes),this.view=v,this.bytes=b},g.prototype.encodeNil=function(){this.writeU8(192)},g.prototype.encodeBoolean=function(a){a===!1?this.writeU8(194):this.writeU8(195)},g.prototype.encodeNumber=function(a){Number.isSafeInteger(a)&&!this.forceIntegerToFloat?a>=0?a<128?this.writeU8(a):a<256?(this.writeU8(204),this.writeU8(a)):a<65536?(this.writeU8(205),this.writeU16(a)):a<4294967296?(this.writeU8(206),this.writeU32(a)):(this.writeU8(207),this.writeU64(a)):a>=-32?this.writeU8(224|a+32):a>=-128?(this.writeU8(208),this.writeI8(a)):a>=-32768?(this.writeU8(209),this.writeI16(a)):a>=-2147483648?(this.writeU8(210),this.writeI32(a)):(this.writeU8(211),this.writeI64(a)):this.forceFloat32?(this.writeU8(202),this.writeF32(a)):(this.writeU8(203),this.writeF64(a))},g.prototype.writeStringHeader=function(a){if(a<32)this.writeU8(160+a);else if(a<256)this.writeU8(217),this.writeU8(a);else if(a<65536)this.writeU8(218),this.writeU16(a);else if(a<4294967296)this.writeU8(219),this.writeU32(a);else throw new Error("Too long string: "+a+" bytes in UTF-8")},g.prototype.encodeString=function(a){var m=5,b=a.length;if(b>i.TEXT_ENCODER_THRESHOLD){var v=Object(i.utf8Count)(a);this.ensureBufferSizeToWrite(m+v),this.writeStringHeader(v),Object(i.utf8EncodeTE)(a,this.bytes,this.pos),this.pos+=v}else{var v=Object(i.utf8Count)(a);this.ensureBufferSizeToWrite(m+v),this.writeStringHeader(v),Object(i.utf8EncodeJs)(a,this.bytes,this.pos),this.pos+=v}},g.prototype.encodeObject=function(a,m){var b=this.extensionCodec.tryToEncode(a,this.context);if(b!=null)this.encodeExtension(b);else if(Array.isArray(a))this.encodeArray(a,m);else if(ArrayBuffer.isView(a))this.encodeBinary(a);else if(typeof a=="object")this.encodeMap(a,m);else throw new Error("Unrecognized object: "+Object.prototype.toString.apply(a))},g.prototype.encodeBinary=function(a){var m=a.byteLength;if(m<256)this.writeU8(196),this.writeU8(m);else if(m<65536)this.writeU8(197),this.writeU16(m);else if(m<4294967296)this.writeU8(198),this.writeU32(m);else throw new Error("Too large binary: "+m);var b=Object(l.ensureUint8Array)(a);this.writeU8a(b)},g.prototype.encodeArray=function(a,m){var b=a.length;if(b<16)this.writeU8(144+b);else if(b<65536)this.writeU8(220),this.writeU16(b);else if(b<4294967296)this.writeU8(221),this.writeU32(b);else throw new Error("Too large array: "+b);for(var v=0,c=a;v<c.length;v++){var w=c[v];this.doEncode(w,m+1)}},g.prototype.countWithoutUndefined=function(a,m){for(var b=0,v=0,c=m;v<c.length;v++){var w=c[v];a[w]!==void 0&&b++}return b},g.prototype.encodeMap=function(a,m){var b=Object.keys(a);this.sortKeys&&b.sort();var v=this.ignoreUndefined?this.countWithoutUndefined(a,b):b.length;if(v<16)this.writeU8(128+v);else if(v<65536)this.writeU8(222),this.writeU16(v);else if(v<4294967296)this.writeU8(223),this.writeU32(v);else throw new Error("Too large map object: "+v);for(var c=0,w=b;c<w.length;c++){var k=w[c],x=a[k];this.ignoreUndefined&&x===void 0||(this.encodeString(k),this.doEncode(x,m+1))}},g.prototype.encodeExtension=function(a){var m=a.data.length;if(m===1)this.writeU8(212);else if(m===2)this.writeU8(213);else if(m===4)this.writeU8(214);else if(m===8)this.writeU8(215);else if(m===16)this.writeU8(216);else if(m<256)this.writeU8(199),this.writeU8(m);else if(m<65536)this.writeU8(200),this.writeU16(m);else if(m<4294967296)this.writeU8(201),this.writeU32(m);else throw new Error("Too large extension object: "+m);this.writeI8(a.type),this.writeU8a(a.data)},g.prototype.writeU8=function(a){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,a),this.pos++},g.prototype.writeU8a=function(a){var m=a.length;this.ensureBufferSizeToWrite(m),this.bytes.set(a,this.pos),this.pos+=m},g.prototype.writeI8=function(a){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,a),this.pos++},g.prototype.writeU16=function(a){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,a),this.pos+=2},g.prototype.writeI16=function(a){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,a),this.pos+=2},g.prototype.writeU32=function(a){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,a),this.pos+=4},g.prototype.writeI32=function(a){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,a),this.pos+=4},g.prototype.writeF32=function(a){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,a),this.pos+=4},g.prototype.writeF64=function(a){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,a),this.pos+=8},g.prototype.writeU64=function(a){this.ensureBufferSizeToWrite(8),Object(o.setUint64)(this.view,this.pos,a),this.pos+=8},g.prototype.writeI64=function(a){this.ensureBufferSizeToWrite(8),Object(o.setInt64)(this.view,this.pos,a),this.pos+=8},g}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs":function(n,t,r){r.r(t),r.d(t,"ExtData",function(){return i});var i=function(){function s(o,l){this.type=o,this.data=l}return s}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs":function(n,t,r){r.r(t),r.d(t,"ExtensionCodec",function(){return o});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs"),o=function(){function l(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(s.timestampExtension)}return l.prototype.register=function(f){var u=f.type,_=f.encode,g=f.decode;if(u>=0)this.encoders[u]=_,this.decoders[u]=g;else{var a=1+u;this.builtInEncoders[a]=_,this.builtInDecoders[a]=g}},l.prototype.tryToEncode=function(f,u){for(var _=0;_<this.builtInEncoders.length;_++){var g=this.builtInEncoders[_];if(g!=null){var a=g(f,u);if(a!=null){var m=-1-_;return new i.ExtData(m,a)}}}for(var _=0;_<this.encoders.length;_++){var g=this.encoders[_];if(g!=null){var a=g(f,u);if(a!=null){var m=_;return new i.ExtData(m,a)}}}return f instanceof i.ExtData?f:null},l.prototype.decode=function(f,u,_){var g=u<0?this.builtInDecoders[-1-u]:this.decoders[u];return g?g(f,u,_):new i.ExtData(u,f)},l.defaultCodec=new l,l}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs":function(n,t,r){r.r(t),r.d(t,"defaultDecodeOptions",function(){return s}),r.d(t,"decode",function(){return o}),r.d(t,"decodeMulti",function(){return l});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"),s={};function o(f,u){u===void 0&&(u=s);var _=new i.Decoder(u.extensionCodec,u.context,u.maxStrLength,u.maxBinLength,u.maxArrayLength,u.maxMapLength,u.maxExtLength);return _.decode(f)}function l(f,u){u===void 0&&(u=s);var _=new i.Decoder(u.extensionCodec,u.context,u.maxStrLength,u.maxBinLength,u.maxArrayLength,u.maxMapLength,u.maxExtLength);return _.decodeMulti(f)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs":function(n,t,r){r.r(t),r.d(t,"decodeAsync",function(){return u}),r.d(t,"decodeArrayStream",function(){return _}),r.d(t,"decodeMultiStream",function(){return g}),r.d(t,"decodeStream",function(){return a});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs"),l=function(m,b,v,c){function w(k){return k instanceof v?k:new v(function(x){x(k)})}return new(v||(v=Promise))(function(k,x){function E(T){try{A(c.next(T))}catch(j){x(j)}}function O(T){try{A(c.throw(T))}catch(j){x(j)}}function A(T){T.done?k(T.value):w(T.value).then(E,O)}A((c=c.apply(m,b||[])).next())})},f=function(m,b){var v={label:0,sent:function(){if(k[0]&1)throw k[1];return k[1]},trys:[],ops:[]},c,w,k,x;return x={next:E(0),throw:E(1),return:E(2)},typeof Symbol=="function"&&(x[Symbol.iterator]=function(){return this}),x;function E(A){return function(T){return O([A,T])}}function O(A){if(c)throw new TypeError("Generator is already executing.");for(;v;)try{if(c=1,w&&(k=A[0]&2?w.return:A[0]?w.throw||((k=w.return)&&k.call(w),0):w.next)&&!(k=k.call(w,A[1])).done)return k;switch(w=0,k&&(A=[A[0]&2,k.value]),A[0]){case 0:case 1:k=A;break;case 4:return v.label++,{value:A[1],done:!1};case 5:v.label++,w=A[1],A=[0];continue;case 7:A=v.ops.pop(),v.trys.pop();continue;default:if(k=v.trys,!(k=k.length>0&&k[k.length-1])&&(A[0]===6||A[0]===2)){v=0;continue}if(A[0]===3&&(!k||A[1]>k[0]&&A[1]<k[3])){v.label=A[1];break}if(A[0]===6&&v.label<k[1]){v.label=k[1],k=A;break}if(k&&v.label<k[2]){v.label=k[2],v.ops.push(A);break}k[2]&&v.ops.pop(),v.trys.pop();continue}A=b.call(m,v)}catch(T){A=[6,T],w=0}finally{c=k=0}if(A[0]&5)throw A[1];return{value:A[0]?A[1]:void 0,done:!0}}};function u(m,b){return b===void 0&&(b=o.defaultDecodeOptions),l(this,void 0,void 0,function(){var v,c;return f(this,function(w){return v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength),[2,c.decodeAsync(v)]})})}function _(m,b){b===void 0&&(b=o.defaultDecodeOptions);var v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength);return c.decodeArrayStream(v)}function g(m,b){b===void 0&&(b=o.defaultDecodeOptions);var v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength);return c.decodeStream(v)}function a(m,b){return b===void 0&&(b=o.defaultDecodeOptions),g(m,b)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs":function(n,t,r){r.r(t),r.d(t,"encode",function(){return o});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs"),s={};function o(l,f){f===void 0&&(f=s);var u=new i.Encoder(f.extensionCodec,f.context,f.maxDepth,f.initialBufferSize,f.sortKeys,f.forceFloat32,f.ignoreUndefined,f.forceIntegerToFloat);return u.encode(l)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs":function(n,t,r){r.r(t);var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs");r.d(t,"encode",function(){return i.encode});var s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs");r.d(t,"decode",function(){return s.decode}),r.d(t,"decodeMulti",function(){return s.decodeMulti});var o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs");r.d(t,"decodeAsync",function(){return o.decodeAsync}),r.d(t,"decodeArrayStream",function(){return o.decodeArrayStream}),r.d(t,"decodeMultiStream",function(){return o.decodeMultiStream}),r.d(t,"decodeStream",function(){return o.decodeStream});var l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs");r.d(t,"Decoder",function(){return l.Decoder}),r.d(t,"DataViewIndexOutOfBoundsError",function(){return l.DataViewIndexOutOfBoundsError});var f=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs");r.d(t,"DecodeError",function(){return f.DecodeError});var u=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs");r.d(t,"Encoder",function(){return u.Encoder});var _=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs");r.d(t,"ExtensionCodec",function(){return _.ExtensionCodec});var g=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs");r.d(t,"ExtData",function(){return g.ExtData});var a=r("./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs");r.d(t,"EXT_TIMESTAMP",function(){return a.EXT_TIMESTAMP}),r.d(t,"encodeDateToTimeSpec",function(){return a.encodeDateToTimeSpec}),r.d(t,"encodeTimeSpecToTimestamp",function(){return a.encodeTimeSpecToTimestamp}),r.d(t,"decodeTimestampToTimeSpec",function(){return a.decodeTimestampToTimeSpec}),r.d(t,"encodeTimestampExtension",function(){return a.encodeTimestampExtension}),r.d(t,"decodeTimestampExtension",function(){return a.decodeTimestampExtension})},"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs":function(n,t,r){r.r(t),r.d(t,"EXT_TIMESTAMP",function(){return o}),r.d(t,"encodeTimeSpecToTimestamp",function(){return u}),r.d(t,"encodeDateToTimeSpec",function(){return _}),r.d(t,"encodeTimestampExtension",function(){return g}),r.d(t,"decodeTimestampToTimeSpec",function(){return a}),r.d(t,"decodeTimestampExtension",function(){return m}),r.d(t,"timestampExtension",function(){return b});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),o=-1,l=4294967296-1,f=17179869184-1;function u(v){var c=v.sec,w=v.nsec;if(c>=0&&w>=0&&c<=f)if(w===0&&c<=l){var k=new Uint8Array(4),x=new DataView(k.buffer);return x.setUint32(0,c),k}else{var E=c/4294967296,O=c&4294967295,k=new Uint8Array(8),x=new DataView(k.buffer);return x.setUint32(0,w<<2|E&3),x.setUint32(4,O),k}else{var k=new Uint8Array(12),x=new DataView(k.buffer);return x.setUint32(0,w),Object(s.setInt64)(x,4,c),k}}function _(v){var c=v.getTime(),w=Math.floor(c/1e3),k=(c-w*1e3)*1e6,x=Math.floor(k/1e9);return{sec:w+x,nsec:k-x*1e9}}function g(v){if(v instanceof Date){var c=_(v);return u(c)}else return null}function a(v){var c=new DataView(v.buffer,v.byteOffset,v.byteLength);switch(v.byteLength){case 4:{var w=c.getUint32(0),k=0;return{sec:w,nsec:k}}case 8:{var x=c.getUint32(0),E=c.getUint32(4),w=(x&3)*4294967296+E,k=x>>>2;return{sec:w,nsec:k}}case 12:{var w=Object(s.getInt64)(c,4),k=c.getUint32(0);return{sec:w,nsec:k}}default:throw new i.DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): "+v.length)}}function m(v){var c=a(v);return new Date(c.sec*1e3+c.nsec/1e6)}var b={type:o,encode:g,decode:m}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs":function(n,t,r){r.r(t),r.d(t,"UINT32_MAX",function(){return i}),r.d(t,"setUint64",function(){return s}),r.d(t,"setInt64",function(){return o}),r.d(t,"getInt64",function(){return l}),r.d(t,"getUint64",function(){return f});var i=4294967295;function s(u,_,g){var a=g/4294967296,m=g;u.setUint32(_,a),u.setUint32(_+4,m)}function o(u,_,g){var a=Math.floor(g/4294967296),m=g;u.setUint32(_,a),u.setUint32(_+4,m)}function l(u,_){var g=u.getInt32(_),a=u.getUint32(_+4);return g*4294967296+a}function f(u,_){var g=u.getUint32(_),a=u.getUint32(_+4);return g*4294967296+a}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs":function(n,t,r){r.r(t),r.d(t,"prettyByte",function(){return i});function i(s){return(s<0?"-":"")+"0x"+Math.abs(s).toString(16).padStart(2,"0")}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs":function(n,t,r){r.r(t),r.d(t,"isAsyncIterable",function(){return l}),r.d(t,"asyncIterableFromStream",function(){return u}),r.d(t,"ensureAsyncIterable",function(){return _});var i=function(g,a){var m={label:0,sent:function(){if(c[0]&1)throw c[1];return c[1]},trys:[],ops:[]},b,v,c,w;return w={next:k(0),throw:k(1),return:k(2)},typeof Symbol=="function"&&(w[Symbol.iterator]=function(){return this}),w;function k(E){return function(O){return x([E,O])}}function x(E){if(b)throw new TypeError("Generator is already executing.");for(;m;)try{if(b=1,v&&(c=E[0]&2?v.return:E[0]?v.throw||((c=v.return)&&c.call(v),0):v.next)&&!(c=c.call(v,E[1])).done)return c;switch(v=0,c&&(E=[E[0]&2,c.value]),E[0]){case 0:case 1:c=E;break;case 4:return m.label++,{value:E[1],done:!1};case 5:m.label++,v=E[1],E=[0];continue;case 7:E=m.ops.pop(),m.trys.pop();continue;default:if(c=m.trys,!(c=c.length>0&&c[c.length-1])&&(E[0]===6||E[0]===2)){m=0;continue}if(E[0]===3&&(!c||E[1]>c[0]&&E[1]<c[3])){m.label=E[1];break}if(E[0]===6&&m.label<c[1]){m.label=c[1],c=E;break}if(c&&m.label<c[2]){m.label=c[2],m.ops.push(E);break}c[2]&&m.ops.pop(),m.trys.pop();continue}E=a.call(g,m)}catch(O){E=[6,O],v=0}finally{b=c=0}if(E[0]&5)throw E[1];return{value:E[0]?E[1]:void 0,done:!0}}},s=function(g){return this instanceof s?(this.v=g,this):new s(g)},o=function(g,a,m){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var b=m.apply(g,a||[]),v,c=[];return v={},w("next"),w("throw"),w("return"),v[Symbol.asyncIterator]=function(){return this},v;function w(T){b[T]&&(v[T]=function(j){return new Promise(function(I,D){c.push([T,j,I,D])>1||k(T,j)})})}function k(T,j){try{x(b[T](j))}catch(I){A(c[0][3],I)}}function x(T){T.value instanceof s?Promise.resolve(T.value.v).then(E,O):A(c[0][2],T)}function E(T){k("next",T)}function O(T){k("throw",T)}function A(T,j){T(j),c.shift(),c.length&&k(c[0][0],c[0][1])}};function l(g){return g[Symbol.asyncIterator]!=null}function f(g){if(g==null)throw new Error("Assertion Failure: value must not be null nor undefined")}function u(g){return o(this,arguments,function(){var m,b,v,c;return i(this,function(w){switch(w.label){case 0:m=g.getReader(),w.label=1;case 1:w.trys.push([1,,9,10]),w.label=2;case 2:return[4,s(m.read())];case 3:return b=w.sent(),v=b.done,c=b.value,v?[4,s(void 0)]:[3,5];case 4:return[2,w.sent()];case 5:return f(c),[4,s(c)];case 6:return[4,w.sent()];case 7:return w.sent(),[3,2];case 8:return[3,10];case 9:return m.releaseLock(),[7];case 10:return[2]}})})}function _(g){return l(g)?g:u(g)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs":function(n,t,r){r.r(t),r.d(t,"ensureUint8Array",function(){return i}),r.d(t,"createDataView",function(){return s});function i(o){return o instanceof Uint8Array?o:ArrayBuffer.isView(o)?new Uint8Array(o.buffer,o.byteOffset,o.byteLength):o instanceof ArrayBuffer?new Uint8Array(o):Uint8Array.from(o)}function s(o){if(o instanceof ArrayBuffer)return new DataView(o);var l=i(o);return new DataView(l.buffer,l.byteOffset,l.byteLength)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs":function(n,t,r){r.r(t),r.d(t,"utf8Count",function(){return o}),r.d(t,"utf8EncodeJs",function(){return l}),r.d(t,"TEXT_ENCODER_THRESHOLD",function(){return u}),r.d(t,"utf8EncodeTE",function(){return a}),r.d(t,"utf8DecodeJs",function(){return b}),r.d(t,"TEXT_DECODER_THRESHOLD",function(){return c}),r.d(t,"utf8DecodeTD",function(){return w});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),s=(typeof process>"u"||define_process_env_default.TEXT_ENCODING!=="never")&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function o(k){for(var x=k.length,E=0,O=0;O<x;){var A=k.charCodeAt(O++);if(A&4294967168)if(!(A&4294965248))E+=2;else{if(A>=55296&&A<=56319&&O<x){var T=k.charCodeAt(O);(T&64512)===56320&&(++O,A=((A&1023)<<10)+(T&1023)+65536)}A&4294901760?E+=4:E+=3}else{E++;continue}}return E}function l(k,x,E){for(var O=k.length,A=E,T=0;T<O;){var j=k.charCodeAt(T++);if(j&4294967168)if(!(j&4294965248))x[A++]=j>>6&31|192;else{if(j>=55296&&j<=56319&&T<O){var I=k.charCodeAt(T);(I&64512)===56320&&(++T,j=((j&1023)<<10)+(I&1023)+65536)}j&4294901760?(x[A++]=j>>18&7|240,x[A++]=j>>12&63|128,x[A++]=j>>6&63|128):(x[A++]=j>>12&15|224,x[A++]=j>>6&63|128)}else{x[A++]=j;continue}x[A++]=j&63|128}}var f=s?new TextEncoder:void 0,u=s?typeof process<"u"&&define_process_env_default.TEXT_ENCODING!=="force"?200:0:i.UINT32_MAX;function _(k,x,E){x.set(f.encode(k),E)}function g(k,x,E){f.encodeInto(k,x.subarray(E))}var a=f!=null&&f.encodeInto?g:_,m=4096;function b(k,x,E){for(var O=x,A=O+E,T=[],j="";O<A;){var I=k[O++];if(!(I&128))T.push(I);else if((I&224)===192){var D=k[O++]&63;T.push((I&31)<<6|D)}else if((I&240)===224){var D=k[O++]&63,$=k[O++]&63;T.push((I&31)<<12|D<<6|$)}else if((I&248)===240){var D=k[O++]&63,$=k[O++]&63,N=k[O++]&63,M=(I&7)<<18|D<<12|$<<6|N;M>65535&&(M-=65536,T.push(M>>>10&1023|55296),M=56320|M&1023),T.push(M)}else T.push(I);T.length>=m&&(j+=String.fromCharCode.apply(String,T),T.length=0)}return T.length>0&&(j+=String.fromCharCode.apply(String,T)),j}var v=s?new TextDecoder:null,c=s?typeof process<"u"&&define_process_env_default.TEXT_DECODER!=="force"?200:0:i.UINT32_MAX;function w(k,x,E){var O=k.subarray(x,x+E);return v.decode(O)}},"./package.json":function(n){n.exports=JSON.parse('{"name":"imjoy-rpc","version":"0.5.46","description":"Remote procedure calls for ImJoy.","module":"index.js","types":"index.d.ts","scripts":{"build":"rm -rf dist && npm run build-umd","build-umd":"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map ","watch":"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map","publish-npm":"npm install && npm run build && npm publish","serve":"webpack-dev-server","stats":"webpack --profile --json > stats.json","stats-prod":"webpack --profile --json --mode production > stats-prod.json","analyze":"webpack-bundle-analyzer -p 9999 stats.json","analyze-prod":"webpack-bundle-analyzer -p 9999 stats-prod.json","clean":"rimraf dist/*","deploy":"npm run build && node deploy-site.js","format":"prettier --write \\"{src,tests}/**/**\\"","check-format":"prettier --check \\"{src,tests}/**/**\\"","test":"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js","test-watch":"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug"},"repository":{"type":"git","url":"git+https://github.com/imjoy-team/imjoy-rpc.git"},"keywords":["imjoy","rpc"],"author":"imjoy-team <imjoy.team@gmail.com>","license":"MIT","bugs":{"url":"https://github.com/imjoy-team/imjoy-rpc/issues"},"homepage":"https://github.com/imjoy-team/imjoy-rpc","dependencies":{"@msgpack/msgpack":"^2.7.1","socket.io-client":"^4.6.2"},"devDependencies":{"@babel/core":"^7.16.12","@babel/plugin-syntax-dynamic-import":"^7.8.3","@babel/polyfill":"^7.12.1","@babel/preset-env":"^7.16.11","@types/requirejs":"^2.1.34","babel-core":"^6.26.0","babel-eslint":"^10.1.0","babel-loader":"^8.2.3","babel-runtime":"^6.26.0","chai":"^4.3.6","clean-webpack-plugin":"^0.1.19","copy-webpack-plugin":"^5.1.2","eslint":"^6.8.0","eslint-config-prettier":"^4.2.0","eslint-loader":"^4.0.2","file-loader":"^0.11.2","fs-extra":"^0.30.0","gh-pages":"^2.0.1","html-loader":"^0.5.5","html-webpack-plugin":"^3.2.0","json-loader":"^0.5.4","karma":"^6.3.12","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^1.3.0","karma-mocha":"^2.0.1","karma-sourcemap-loader":"^0.3.8","karma-spec-reporter":"0.0.32","karma-webpack":"^4.0.2","lerna":"^6.0.3","lodash.debounce":"^4.0.8","mocha":"^10.1.0","postcss":"^7.0.36","prettier":"^1.6.1","rimraf":"^2.6.2","schema-utils":"^0.4.3","style-loader":"^0.18.1","ts-loader":"^9.4.3","url-loader":"^0.5.9","webpack":"^4.46.0","webpack-bundle-analyzer":"^4.7.0","webpack-cli":"^3.3.12","webpack-dev-server":"^3.11.3","webpack-merge":"^4.1.1","workbox-webpack-plugin":"^4.3.1","worker-loader":"^2.0.0","write-file-webpack-plugin":"^4.5.1"},"eslintConfig":{"globals":{"document":true,"window":true}}}')},"./src/hypha/rpc.js":function(n,t,r){r.r(t),r.d(t,"API_VERSION",function(){return o}),r.d(t,"RPC",function(){return b});var i=r("./src/hypha/utils.js"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs");const o="0.3.0",l=1024*500,f=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor;function u(v,c){const w=new Uint8Array(v.byteLength+c.byteLength);return w.set(new Uint8Array(v),0),w.set(new Uint8Array(c),v.byteLength),w.buffer}function _(v,c){if(!c)throw new Error("undefined index");return typeof c=="string"?_(v,c.split(".")):c.length===0?v:_(v[c[0]],c.slice(1))}function g(v){const c=v.toString(),w=c.match(/function\s*(\w*)/),k=w&&w[1]||"",x=c.match(/\(([^)]*)\)/);let E="";x&&(E=x[1].split(",").map(I=>I.replace(/\/\*.*?\*\//g,"").replace(/\/\/.*$/g,"")).filter(I=>I.trim().length>0).map(I=>I.trim()).join(", "));let O=c.match(/\)\s*\{\s*\/\*([\s\S]*?)\*\//);const A=O&&O[1].trim()||"";O=c.match(/\)\s*\{\s*(\/\/[\s\S]*?)\n\s*[^\s\/]/);const T=O&&O[1].split(`
`).map(I=>I.replace(/^\/\/\s*/,"").trim()).join(`
`)||"",j=A||T;return k&&E.length>0&&{name:k,sig:E,doc:j}}function a(v){var c=v.map(function(x){return x.byteLength}),w=c.reduce(function(x,E){return x+E},0),k=new Uint8Array(w);return c.reduce(function(x,E,O){return k.set(new Uint8Array(v[O]),x),x+E},0),k.buffer}class m{constructor(c,w,k,x){this._timeout=c,this._callback=w,this._args=k,this._label=x||"timer",this._task=null,this.started=!1}start(){this.started?this.reset():(this._task=setTimeout(()=>{this._callback.apply(this,this._args)},this._timeout*1e3),this.started=!0)}clear(){this._task?(clearTimeout(this._task),this._task=null,this.started=!1):console.warn(`Clearing a timer (${this._label}) which is not started`)}reset(){this._task&&clearTimeout(this._task),this._task=setTimeout(()=>{this._callback.apply(this,this._args)},this._timeout*1e3),this.started=!0}}class b extends i.MessageEmitter{constructor(c,{client_id:w=null,manager_id:k=null,default_context:x=null,name:E=null,codecs:O=null,method_timeout:A=null,max_message_buffer_size:T=0,debug:j=!1,workspace:I=null}){super(j),this._codecs=O||{},Object(i.assert)(w&&typeof w=="string"),Object(i.assert)(w,"client_id is required"),this._client_id=w,this._name=E,this._connection_info=null,this._workspace=null,this._local_workspace=I,this.manager_id=k,this.default_context=x||{},this._method_annotations=new WeakMap,this._manager_service=null,this._max_message_buffer_size=T,this._chunk_store={},this._method_timeout=A||30,this._services={},this._object_store={services:this._services},c?(this.add_service({id:"built-in",type:"built-in",name:"RPC built-in services",config:{require_context:!0,visibility:"public"},ping:this._ping.bind(this),get_service:this.get_local_service.bind(this),register_service:this.register_service.bind(this),message_cache:{create:this._create_message.bind(this),append:this._append_message.bind(this),process:this._process_message.bind(this),remove:this._remove_message.bind(this)}}),this.on("method",this._handle_method.bind(this)),Object(i.assert)(c.emit_message&&c.on_message),this._emit_message=c.emit_message.bind(c),c.on_message(this._on_message.bind(this)),this._connection=c,this._get_connection_info()):this._emit_message=function(){console.log("No connection to emit message")}}async _get_connection_info(){if(this.manager_id)try{if(await this.get_manager_service(30),Object(i.assert)(this._manager_service),this._connection_info=await this._manager_service.get_connection_info(),this._connection_info.reconnection_token&&this._connection.set_reconnection_token){this._connection.set_reconnection_token(this._connection_info.reconnection_token);const c=this._connection_info.reconnection_expires_in*.8;this._get_connection_info_task=setTimeout(this._get_connection_info.bind(this),c*1e3)}}catch(c){console.warn("Failed to fetch user info from ",this.manager_id,c)}}register_codec(c){if(!c.name||!c.encoder&&!c.decoder)throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");if(c.type)for(let w of Object.keys(this._codecs))(this._codecs[w].type===c.type||w===c.name)&&(delete this._codecs[w],console.warn("Remove duplicated codec: "+w));this._codecs[c.name]=c}async _ping(c,w){return Object(i.assert)(c=="ping"),"pong"}async ping(c,w){let k=this._generate_remote_method({_rtarget:c,_rmethod:"services.built-in.ping",_rpromise:!0,_rdoc:"Ping a remote client",_rsig:"ping(msg)"});Object(i.assert)(await k("ping",w)=="pong")}_create_message(c,w,k,x){if(w){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}if(this._object_store.message_cache||(this._object_store.message_cache={}),!k&&this._object_store.message_cache[c])throw new Error(`Message with the same key (${c}) already exists in the cache store, please use overwrite=true or remove it first.`);this._object_store.message_cache[c]=[]}_append_message(c,w,k,x){if(k){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}const E=this._object_store.message_cache;if(!E[c])throw new Error(`Message with key ${c} does not exists.`);Object(i.assert)(w instanceof f),E[c].push(w)}_remove_message(c,w){const k=this._object_store.message_cache;if(!k[c])throw new Error(`Message with key ${c} does not exists.`);delete k[c]}_process_message(c,w,k){if(w){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}const x=this._object_store.message_cache;if(Object(i.assert)(!!k,"Context is required"),!x[c])throw new Error(`Message with key ${c} does not exists.`);x[c]=a(x[c]),console.debug(`Processing message ${c} (size=${x[c].length})`);let E=Object(s.decodeMulti)(x[c]);const{done:O,value:A}=E.next(),T=A;if(Object.assign(T,{from:k.from,to:k.to,user:k.user}),T.ctx=JSON.parse(JSON.stringify(T)),Object.assign(T.ctx,this.default_context),!O){let j=E.next();Object.assign(T,j.value)}this._fire(T.type,T),delete x[c]}_on_message(c){try{Object(i.assert)(c instanceof ArrayBuffer);let w=Object(s.decodeMulti)(c);const{done:k,value:x}=w.next(),E=x;if(E.ctx=JSON.parse(JSON.stringify(E)),Object.assign(E.ctx,this.default_context),!k){let O=w.next();Object.assign(E,O.value)}this._fire(E.type,E)}catch{console.error(e)}}reset(){this._event_handlers={},this._services={}}async disconnect(){this._get_connection_info_task&&(clearTimeout(this._get_connection_info_task),this._get_connection_info_task=null),this._fire("disconnect")}async get_manager_service(c){this.manager_id&&!this._manager_service&&(this._manager_service=await this.get_remote_service(`${this.manager_id}:default`,c))}get_all_local_services(){return this._services}get_local_service(c,w){Object(i.assert)(c);const[k,x]=w.to.split("/");Object(i.assert)(x===this._client_id,"Services can only be accessed locally");const E=this._services[c];if(!E)throw new Error("Service not found: "+c);if(E.config.visibility=="public"||w.from.startsWith(k+"/"))return E;throw new Error("Permission denied for service: "+c)}async get_remote_service(c,w){w=w===void 0?this._method_timeout:w,!c&&this.manager_id?c=this.manager_id:c.includes(":")||(c=this._client_id+":"+c);const k=c.split(":")[0];Object(i.assert)(k);try{const x=this._generate_remote_method({_rtarget:k,_rmethod:"services.built-in.get_service",_rpromise:!0,_rdoc:"Get a remote service",_rsig:"get_service(service_id)"}),E=await Object(i.waitFor)(x(c.split(":")[1]),w,"Timeout Error: Failed to get remote service: "+c);return E.id=c,E}catch(x){throw console.error("Failed to get remote service: "+c,x),x}}_annotate_service_methods(c,w,k,x,E){if(typeof c=="function"){let O=w.split(".")[1];this._method_annotations.set(c,{require_context:Array.isArray(k)?k.includes(O):!!k,run_in_executor:x,method_id:"services."+w,visibility:E})}else if(c instanceof Array||c instanceof Object)for(let O of Object.keys(c)){let A=c[O];if(typeof A=="function"&&A.__rpc_object__){let T=A.__rpc_object__._rtarget;if(T.includes("/")&&(T=T.split("/")[1]),this._client_id===T)c instanceof Array&&(c=c.slice()),c[O]=_(this._object_store,A.__rpc_object__._rmethod),A=c[O];else throw new Error(`Local method not found: ${A.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${T}`)}this._annotate_service_methods(A,w+"."+O,k,x,E)}}add_service(c,w){if(!c||Array.isArray(c))throw new Error("Invalid service object");if(c.constructor===Object)c=Object.assign({},c);else{const O={},A=Object.getOwnPropertyNames(c).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(c)));for(let T of A)T!=="constructor"&&(typeof c[T]=="function"?O[T]=c[T].bind(c):O[T]=c[T]);c.id=c.id||"default",c=O}Object(i.assert)(c.id&&typeof c.id=="string",`Service id not found: ${c}`),c.name||(c.name=c.id),c.config||(c.config={}),c.type||(c.type="generic");let k=!1,x=!1;c.config.require_context&&(k=c.config.require_context),c.config.run_in_executor&&(x=!0);const E=c.config.visibility||"protected";if(Object(i.assert)(["protected","public"].includes(E)),this._annotate_service_methods(c,c.id,k,x,E),this._services[c.id])if(w)delete this._services[c.id];else throw new Error(`Service already exists: ${c.id}, please specify a different id (not ${c.id}) or overwrite=true`);return this._services[c.id]=c,c}async register_service(c,w,k,x){if(k===void 0&&(k=!0),x){const[O,A]=x.to.split("/");Object(i.assert)(A===this._client_id),Object(i.assert)(O===x.from.split("/")[0],"Services can only be registered from the same workspace")}const E=this.add_service(c,w);return k&&(this._fire("service-updated",{service_id:E.id,api:E,type:"add"}),await this._notify_service_update()),{id:`${this._client_id}:${E.id}`,type:E.type,name:E.name,description:E.description||"",config:E.config}}async unregister_service(c,w){if(c instanceof Object&&(c=c.id),!this._services[c])throw new Error(`Service not found: ${c}`);const k=this._services[c];delete this._services[c],this._fire("service-updated",{service_id:c,api:k,type:"remove"}),await this._notify_service_update()}_ndarray(c,w,k){const x=Object(i.typedArrayToDtype)(c);if(k&&k!==x)throw"dtype doesn't match the type of the array: "+x+" != "+k;return w=w||[c.length],{_rtype:"ndarray",_rvalue:c.buffer,_rshape:w,_rdtype:x}}_encode_callback(c,w,k,x,E,O){let A=`${k}.${c}`,T={_rtype:"method",_rtarget:O?`${O}/${this._client_id}`:this._client_id,_rmethod:A,_rpromise:!1};const j=this;return[T,function(){try{w.apply(null,Array.prototype.slice.call(arguments))}catch(D){console.error("Error in callback:",A,D)}finally{x&&j._object_store[k]&&delete j._object_store[k],E&&E.started&&E.clear()}}]}async _encode_promise(c,w,k,x,E,O){let A=this._get_session_store(k,!0);Object(i.assert)(A,`Failed to create session store ${k} due to invalid parent`);let T={};return E&&w&&this._method_timeout?(T.heartbeat=await this._encode(E.reset.bind(E),k,O),T.interval=this._method_timeout/2,A.timer=E):E=null,[T.resolve,A.resolve]=this._encode_callback("resolve",c,k,x,E,O),[T.reject,A.reject]=this._encode_callback("reject",w,k,x,E,O),T}async _send_chunks(c,w,k){let x=await this.get_remote_service(`${w}:built-in`);Object(i.assert)(x.message_cache,"Remote client does not support message caching for long message.");let E=x.message_cache,O=k||Object(i.randId)();await E.create(O,!!k);let A=c.length,T=Math.ceil(A/l);for(let j=0;j<T;j++){let I=j*l;await E.append(O,c.slice(I,I+l),!!k)}await E.process(O,!!k)}_generate_remote_method(c,w,k,x,E){let O=c._rtarget;x&&!O.includes("/")&&(O=x+"/"+O,c._rtarget=O);let A=c._rmethod,T=c._rpromise;const j=this;function I(){return new Promise(async($,N)=>{let M=Object(i.randId)();k&&(M=k+"."+M);let W=j._get_session_store(M,!0);if(!W){N(new Error(`Runtime Error: Failed to get session store ${M}`));return}W.target_id=O;const F=await j._encode(Array.prototype.slice.call(arguments),M,E),H=F.length,q=H>0&&typeof F[H-1]=="object"&&F[H-1]!==null&&F[H-1]._rkwargs;q&&delete F[H-1]._rkwargs;let Y={type:"method",from:j._local_workspace?j._local_workspace+"/"+j._client_id:j._client_id,to:O,method:A},X={};F&&(X.args=F),q&&(X.with_kwargs=q),w&&(Y.parent=w);let J=null;if(T){Y.session=M;let de=`${O}:${A}`;J=new m(j._method_timeout,N,[`Method call time out: ${de}`],de),X.promise=await j._encode_promise($,N,M,!0,J,E)}let te=Object(s.encode)(Y);if(X){const de=Object(s.encode)(X);te=new Uint8Array([...te,...de])}te.length<=l+1024?j._emit_message(te).then(function(){J&&J.start()}):j._send_chunks(te,O,w).then(function(){J&&J.start()})})}I.__rpc_object__=c;const D=A.split(".");return I.__name__=D[D.length-1],I.__doc__=c._rdoc,I.__sig__=c._rsig,I}async _notify_service_update(){if(this.manager_id)try{await this.get_manager_service(30),Object(i.assert)(this._manager_service),await this._manager_service.update_client_info(this.get_client_info())}catch(c){console.warn("Failed to notify service update to",this.manager_id,c)}}get_client_info(){const c=[];for(let w of Object.values(this._services))c.push({id:`${this._client_id}:${w.id}`,type:w.type,name:w.name,description:w.description||"",config:w.config});return{id:this._client_id,services:c}}async _handle_method(c){let w=null;try{Object(i.assert)(c.method&&c.ctx&&c.from);const k=c.from+":"+c.method,x=c.from.split("/")[0];c.to=c.to.includes("/")?c.to:x+"/"+c.to,c.ctx.to=c.to;const E=c.to.split("/")[0],O=c.parent;let A,T;if(c.promise){const D=await this._decode(c.promise,c.session,O,x,E);if(A=D.resolve,T=D.reject,D.heartbeat&&D.interval){async function $(){try{await D.heartbeat()}catch(N){console.error(N)}}w=setInterval($,D.interval*1e3)}}let j;try{j=_(this._object_store,c.method)}catch(D){throw console.debug("Failed to find method",k,D),new Error(`Method not found: ${k}`)}if(Object(i.assert)(j&&typeof j=="function","Invalid method: "+k),this._method_annotations.has(j)){if(this._method_annotations.get(j).visibility==="protected"&&E!==x)throw new Error("Permission denied for protected method "+k+", workspace mismatch: "+E+" != "+x)}else{let D=this._object_store[c.method.split(".")[0]].target_id;if(E===x&&D&&D.indexOf("/")===-1&&(D=E+"/"+D),D!==c.from)throw new Error("Access denied for method call ("+k+") from "+c.from)}O&&Object(i.assert)(this._get_session_store(O,!0)!==null,"Parent session was closed: "+O);let I;if(c.args?I=await this._decode(c.args,c.session,null,x,null):I=[],this._method_annotations.has(j)&&this._method_annotations.get(j).require_context&&I.push(c.ctx),c.promise){const D=j.apply(null,I);D instanceof Promise?D.then($=>{A($),clearInterval(w)}).catch($=>{T($),clearInterval(w)}):(A(D),clearInterval(w))}else j.apply(null,I),clearInterval(w)}catch(k){console.error("Error during calling method: ",k),clearInterval(w)}}encode(c,w){return this._encode(c,w)}_get_session_store(c,w){let k=this._object_store;const x=c.split(".");if(w){const E=x.length-1;for(let O of x.slice(0,E)){if(!k[O])return null;k=k[O]}return k[x[E]]||(k[x[E]]={}),k[x[E]]}else{for(let E of x){if(!k[E])return null;k=k[E]}return k}}async _encode(c,w,k){const x=typeof c;if(x==="number"||x==="string"||x==="boolean"||c===null||c===void 0||c instanceof Uint8Array)return c;if(c instanceof ArrayBuffer)return{_rtype:"memoryview",_rvalue:new Uint8Array(c)};if(c.__rpc_object__)return c.__rpc_object__;let E;if(c.constructor instanceof Object&&c._rtype){const A=c._rtype;return delete c._rtype,E=await this._encode(c,w,k),E._rtype=A,E}if(typeof c=="function"){if(this._method_annotations.has(c)){let A=this._method_annotations.get(c);E={_rtype:"method",_rtarget:this._client_id,_rmethod:A.method_id,_rpromise:!0}}else{Object(i.assert)(typeof w=="string");let A;c.__name__?A=`${Object(i.randId)()}-${c.__name__}`:A=Object(i.randId)(),E={_rtype:"method",_rtarget:this._client_id,_rmethod:`${w}.${A}`,_rpromise:!0};let T=this._get_session_store(w,!0);Object(i.assert)(T!==null,`Failed to create session store ${w} due to invalid parent`),T[A]=c}if(E._rdoc=c.__doc__,E._rsig=c.__sig__,!E._rdoc||!E._rsig)try{const A=g(c);A&&!E._rdoc&&(E._rdoc=`${A.doc}`),A&&!E._rsig&&(E._rsig=`${A.name}(${A.sig})`)}catch{console.error("Failed to extract function docstring:",c)}return E}const O=Array.isArray(c);for(let A of Object.keys(this._codecs)){const T=this._codecs[A];if(T.encoder&&c instanceof T.type){let j=await Promise.resolve(T.encoder(c));if(j&&!j._rtype&&(j._rtype=T.name),typeof j=="object"){const I=j._rtype;delete j._rtype,j=await this._encode(j,w,k),j._rtype=I}return E=j,E}}if(typeof tf<"u"&&tf.Tensor&&c instanceof tf.Tensor){const A=c.dataSync();E={_rtype:"ndarray",_rvalue:new Uint8Array(A.buffer),_rshape:c.shape,_rdtype:c.dtype}}else if(typeof nj<"u"&&nj.NdArray&&c instanceof nj.NdArray){const A=Object(i.typedArrayToDtype)(c.selection.data);E={_rtype:"ndarray",_rvalue:new Uint8Array(c.selection.data.buffer),_rshape:c.shape,_rdtype:A}}else if(c instanceof Error)console.error(c),E={_rtype:"error",_rvalue:c.toString()};else if(c!==Object(c)||c instanceof Boolean||c instanceof String||c instanceof Date||c instanceof RegExp||c instanceof ImageData||typeof FileList<"u"&&c instanceof FileList||typeof FileSystemDirectoryHandle<"u"&&c instanceof FileSystemDirectoryHandle||typeof FileSystemFileHandle<"u"&&c instanceof FileSystemFileHandle||typeof FileSystemHandle<"u"&&c instanceof FileSystemHandle||typeof FileSystemWritableFileStream<"u"&&c instanceof FileSystemWritableFileStream)E=c;else if(c instanceof Blob){let A=function(I){T=I},T=0;async function j(I){let D;I?D=c.slice(T,T+I):D=c.slice(T);const $=new Uint8Array(await D.arrayBuffer());return T=T+$.byteLength,$}E={_rtype:"iostream",_rnative:"js:blob",type:c.type,name:c.name,size:c.size,path:c._path||c.webkitRelativePath,read:await this._encode(j,w,k),seek:await this._encode(A,w,k)}}else if(c instanceof f){const A=Object(i.typedArrayToDtype)(c);E={_rtype:"typedarray",_rvalue:new Uint8Array(c.buffer),_rdtype:A}}else if(c instanceof DataView)E={_rtype:"memoryview",_rvalue:new Uint8Array(c.buffer)};else if(c instanceof Set)E={_rtype:"set",_rvalue:await this._encode(Array.from(c),w,k)};else if(c instanceof Map)E={_rtype:"orderedmap",_rvalue:await this._encode(Array.from(c),w,k)};else if(c.constructor instanceof Object||Array.isArray(c)){E=O?[]:{};const A=Object.keys(c);for(let T of A)E[T]=await this._encode(c[T],w,k)}else throw`imjoy-rpc: Unsupported data type: ${c}, you can register a custom codec to encode/decode the object.`;if(!E)throw new Error("Failed to encode object");return E}async decode(c){return await this._decode(c)}async _decode(c,w,k,x,E){if(!c)return c;let O;if(c._rtype)if(this._codecs[c._rtype]&&this._codecs[c._rtype].decoder){const A=c._rtype;delete c._rtype,c=await this._decode(c,w,k,x,E),c._rtype=A,O=await Promise.resolve(this._codecs[c._rtype].decoder(c))}else if(c._rtype==="method")O=this._generate_remote_method(c,w,k,x,E);else if(c._rtype==="ndarray")if(typeof nj<"u"&&nj.array)Array.isArray(c._rvalue)&&(c._rvalue=c._rvalue.reduce(u)),O=nj.array(new Uint8(c._rvalue),c._rdtype).reshape(c._rshape);else if(typeof tf<"u"&&tf.Tensor){Array.isArray(c._rvalue)&&(c._rvalue=c._rvalue.reduce(u));const A=i.dtypeToTypedArray[c._rdtype];O=tf.tensor(new A(c._rvalue),c._rshape,c._rdtype)}else O=c;else if(c._rtype==="error")O=new Error(c._rvalue);else if(c._rtype==="typedarray"){const A=i.dtypeToTypedArray[c._rdtype];if(!A)throw new Error("unsupported dtype: "+c._rdtype);const T=c._rvalue.buffer.slice(c._rvalue.byteOffset,c._rvalue.byteOffset+c._rvalue.byteLength);O=new A(T)}else if(c._rtype==="memoryview")O=c._rvalue.buffer.slice(c._rvalue.byteOffset,c._rvalue.byteOffset+c._rvalue.byteLength);else if(c._rtype==="iostream"){if(c._rnative==="js:blob"){const T=await(await this._generate_remote_method(c.read,w,k,x,E))();O=new Blob([T],{type:c.type,name:c.name})}else{O={};for(let A of Object.keys(c))A.startsWith("_")||(O[A]=await this._decode(c[A],w,k,x,E))}O.__rpc_object__=c}else if(c._rtype==="orderedmap")O=new Map(await this._decode(c._rvalue,w,k,x,E));else if(c._rtype==="set")O=new Set(await this._decode(c._rvalue,w,k,x,E));else{const A=c._rtype;delete c._rtype,O=await this._decode(c,w,k,x,E),O._rtype=A}else if(c.constructor===Object||Array.isArray(c)){const A=Array.isArray(c);O=A?[]:{};for(let T of Object.keys(c))if(A||c.hasOwnProperty(T)){const j=c[T];O[T]=await this._decode(j,w,k,x,E)}}else O=c;if(O===void 0)throw new Error("Failed to decode object");return O}}},"./src/hypha/utils.js":function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"randId",function(){return randId}),__webpack_require__.d(__webpack_exports__,"dtypeToTypedArray",function(){return dtypeToTypedArray}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWindow",function(){return loadRequirementsInWindow}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWebworker",function(){return loadRequirementsInWebworker}),__webpack_require__.d(__webpack_exports__,"loadRequirements",function(){return loadRequirements}),__webpack_require__.d(__webpack_exports__,"normalizeConfig",function(){return normalizeConfig}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtypeMapping",function(){return typedArrayToDtypeMapping}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtype",function(){return typedArrayToDtype}),__webpack_require__.d(__webpack_exports__,"cacheRequirements",function(){return cacheRequirements}),__webpack_require__.d(__webpack_exports__,"setupServiceWorker",function(){return setupServiceWorker}),__webpack_require__.d(__webpack_exports__,"assert",function(){return assert}),__webpack_require__.d(__webpack_exports__,"urlJoin",function(){return urlJoin}),__webpack_require__.d(__webpack_exports__,"waitFor",function(){return waitFor}),__webpack_require__.d(__webpack_exports__,"MessageEmitter",function(){return MessageEmitter});function randId(){return Math.random().toString(36).substr(2,10)+new Date().getTime()}const dtypeToTypedArray={int8:Int8Array,int16:Int16Array,int32:Int32Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,float32:Float32Array,float64:Float64Array,array:Array};async function loadRequirementsInWindow(n){function t(o){return new Promise((l,f)=>{var u=document.createElement("script");u.src=o,u.type="text/javascript",u.onload=l,u.onreadystatechange=function(){(this.readyState==="loaded"||this.readyState==="complete")&&l()},u.onerror=f,document.head.appendChild(u)})}async function r(){for(var o=Array.prototype.slice.call(arguments),l=o.length,f=0;f<l;f++)await t(o[f])}if(n&&(Array.isArray(n)||typeof n=="string"))try{var i;if(n=typeof n=="string"?[n]:n,Array.isArray(n))for(var s=0;s<n.length;s++)n[s].toLowerCase().endsWith(".css")||n[s].startsWith("css:")?(n[s].startsWith("css:")&&(n[s]=n[s].slice(4)),i=document.createElement("link"),i.rel="stylesheet",i.href=n[s],document.head.appendChild(i)):n[s].toLowerCase().endsWith(".mjs")||n[s].startsWith("mjs:")?(n[s].startsWith("mjs:")&&(n[s]=n[s].slice(4)),await __vitePreload(()=>import(n[s]),__vite__mapDeps([]))):n[s].toLowerCase().endsWith(".js")||n[s].startsWith("js:")?(n[s].startsWith("js:")&&(n[s]=n[s].slice(3)),await r(n[s])):n[s].startsWith("http")?await r(n[s]):n[s].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[s]);else throw"unsupported requirements definition"}catch{throw"failed to import required scripts: "+n.toString()}}async function loadRequirementsInWebworker(n){if(n&&(Array.isArray(n)||typeof n=="string"))try{Array.isArray(n)||(n=[n]);for(var t=0;t<n.length;t++){if(n[t].toLowerCase().endsWith(".css")||n[t].startsWith("css:"))throw"unable to import css in a webworker";n[t].toLowerCase().endsWith(".js")||n[t].startsWith("js:")?(n[t].startsWith("js:")&&(n[t]=n[t].slice(3)),importScripts(n[t])):n[t].startsWith("http")?importScripts(n[t]):n[t].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[t])}}catch{throw"failed to import required scripts: "+n.toString()}}function loadRequirements(n){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?loadRequirementsInWebworker(n):loadRequirementsInWindow(n)}function normalizeConfig(n){return n.version=n.version||"0.1.0",n.description=n.description||`[TODO: add description for ${n.name} ]`,n.type=n.type||"rpc-window",n.id=n.id||randId(),n.target_origin=n.target_origin||"*",n.allow_execution=n.allow_execution||!1,n=Object.keys(n).reduce((t,r)=>(typeof n[r]!="function"&&(t[r]=n[r]),t),{}),n}const typedArrayToDtypeMapping={Int8Array:"int8",Int16Array:"int16",Int32Array:"int32",Uint8Array:"uint8",Uint16Array:"uint16",Uint32Array:"uint32",Float32Array:"float32",Float64Array:"float64",Array:"array"},typedArrayToDtypeKeys=[];for(const arrType of Object.keys(typedArrayToDtypeMapping))typedArrayToDtypeKeys.push(eval(arrType));function typedArrayToDtype(n){let t=typedArrayToDtypeMapping[n.constructor.name];if(!t){const r=Object.getPrototypeOf(n);for(const i of typedArrayToDtypeKeys)if(r instanceof i){t=typedArrayToDtypeMapping[i.name];break}}return t}function cacheUrlInServiceWorker(n){return new Promise(function(t,r){const i={command:"add",url:n};if(!navigator.serviceWorker||!navigator.serviceWorker.register){r("Service worker is not supported.");return}const s=new MessageChannel;s.port1.onmessage=function(o){o.data&&o.data.error?r(o.data.error):t(o.data&&o.data.result)},navigator.serviceWorker&&navigator.serviceWorker.controller?navigator.serviceWorker.controller.postMessage(i,[s.port2]):r("Service worker controller is not available")})}async function cacheRequirements(n){n=n||[],Array.isArray(n)||(n=[n]);for(let t of n)t.startsWith("js:")&&(t=t.slice(3)),t.startsWith("css:")&&(t=t.slice(4)),t.startsWith("cache:")&&(t=t.slice(6)),t.startsWith("http")&&await cacheUrlInServiceWorker(t).catch(r=>{console.error(r)})}function setupServiceWorker(n,t,r){if("serviceWorker"in navigator){if(n=n||"/",navigator.serviceWorker.register(n+"plugin-service-worker.js").then(function(i){console.log("ServiceWorker registration successful with scope: ",i.scope)},function(i){console.log("ServiceWorker registration failed: ",i)}),t=t||"*",r=r||cacheRequirements,r&&typeof r!="function")throw new Error("config.cache_requirements must be a function");window.addEventListener("message",function(i){if(t==="*"||i.origin===t){const s=i.data;s.type==="cacheRequirements"&&r(s.requirements)}})}}function assert(n,t){if(!n)throw new Error(t||"Assertion failed")}function urlJoin(...n){return n.join("/").replace(/[\/]+/g,"/").replace(/^(.+):\//,"$1://").replace(/^file:/,"file:/").replace(/\/(\?|&|#[^!])/g,"$1").replace(/\?/g,"&").replace("&","?")}function waitFor(n,t,r){let i;return Promise.race([n,new Promise((s,o)=>i=setTimeout(()=>{o(r||"Timeout Error")},t*1e3))]).finally(()=>clearTimeout(i))}class MessageEmitter{constructor(t){this._event_handlers={},this._once_handlers={},this._debug=t}emit(){throw new Error("emit is not implemented")}on(t,r){this._event_handlers[t]||(this._event_handlers[t]=[]),this._event_handlers[t].push(r)}once(t,r){r.___event_run_once=!0,this.on(t,r)}off(t,r){if(!t&&!r)this._event_handlers={};else if(t&&!r)this._event_handlers[t]&&(this._event_handlers[t]=[]);else if(this._event_handlers[t]){const i=this._event_handlers[t].indexOf(r);i>=0&&this._event_handlers[t].splice(i,1)}}_fire(t,r){if(this._event_handlers[t])for(var i=this._event_handlers[t].length;i--;){const s=this._event_handlers[t][i];try{s(r)}catch(o){console.error(o)}finally{s.___event_run_once&&this._event_handlers[t].splice(i,1)}}else this._debug&&console.warn("unhandled event",t,r)}}},"./src/hypha/webrtc-client.js":function(n,t,r){r.r(t),r.d(t,"getRTCService",function(){return u}),r.d(t,"registerRTCService",function(){return _});var i=r("./src/hypha/rpc.js"),s=r("./src/hypha/utils.js");class o{constructor(a){this._data_channel=a,this._handle_message=null,this._reconnection_token=null,this._data_channel.onmessage=async b=>{let v=b.data;v instanceof Blob&&(v=await v.arrayBuffer()),this._handle_message(v)};const m=this;this._data_channel.onclose=function(){console.log("websocket closed"),m._data_channel=null}}set_reconnection_token(a){this._reconnection_token=a}on_message(a){Object(s.assert)(a,"handler is required"),this._handle_message=a}async emit_message(a){Object(s.assert)(this._handle_message,"No handler for message");try{this._data_channel.send(a)}catch(m){throw console.error(`Failed to send data, error: ${m}`),m}}async disconnect(a){this._data_channel=null,console.info(`data channel connection disconnected (${a})`)}}async function l(g){Object(s.assert)(g.channel,"No channel provided"),Object(s.assert)(g.workspace,"No workspace provided");const a=g.channel,m=g.client_id||Object(s.randId)(),b=new o(a);return g.context=g.context||{},g.context.connection_type="webrtc",new i.RPC(b,{client_id:m,manager_id:null,default_context:g.context,name:g.name,method_timeout:g.method_timeout||10,workspace:g.workspace})}async function f(g,a,m,b,v){m=m||{};let c=new RTCSessionDescription({sdp:g.sdp,type:g.type}),w=new RTCPeerConnection({iceServers:m.ice_servers||[{urls:["stun:stun.l.google.com:19302"]}],sdpSemantics:"unified-plan"});a&&w.addEventListener("datachannel",async x=>{const E=x.channel;let O=null;v&&v.user&&(O={user:v.user});const A=await l({channel:E,client_id:E.label,workspace:a.config.workspace,context:O});A._services=a.rpc._services}),b&&await b(w),await w.setRemoteDescription(c);let k=await w.createAnswer();return await w.setLocalDescription(k),{sdp:w.localDescription.sdp,type:w.localDescription.type,workspace:a.config.workspace}}async function u(g,a,m){m=m||{},m.peer_id=m.peer_id||Object(s.randId)();const b=new RTCPeerConnection({iceServers:m.ice_servers||[{urls:["stun:stun.l.google.com:19302"]}],sdpSemantics:"unified-plan"});return new Promise(async(v,c)=>{try{b.addEventListener("connectionstatechange",()=>{b.connectionState==="failed"&&(b.close(),c(new Error("Connection failed")))},!1),m.on_init&&(await m.on_init(b),delete m.on_init);let w=b.createDataChannel(m.peer_id,{ordered:!0});w.binaryType="arraybuffer";const k=await b.createOffer();await b.setLocalDescription(k);const E=await(await g.getService(a)).offer({sdp:b.localDescription.sdp,type:b.localDescription.type});w.onopen=()=>{m.channel=w,m.workspace=E.workspace,setTimeout(async()=>{const O=await l(m);b.rpc=O;async function A(j){return await O.get_remote_service(m.peer_id+":"+j)}async function T(){await O.disconnect(),b.close()}b.get_service=A,b.getService=A,b.disconnect=T,b.register_codec=O.register_codec,b.registerCodec=O.register_codec,v(b)},500)},w.onclose=()=>c(new Error("Data channel closed")),await b.setRemoteDescription(new RTCSessionDescription({sdp:E.sdp,type:E.type}))}catch(w){c(w)}})}async function _(g,a,m){m=m||{visibility:"protected",require_context:!0};const b=m.on_init;delete m.on_init,await g.registerService({id:a,config:m,offer:(v,c)=>f(v,g,m,b,c)})}},"./src/hypha/websocket-client.js":function(n,t,r){r.r(t),r.d(t,"login",function(){return _}),r.d(t,"connectToServer",function(){return g});var i=r("./src/hypha/rpc.js");r.d(t,"RPC",function(){return i.RPC}),r.d(t,"API_VERSION",function(){return i.API_VERSION});var s=r("./src/hypha/utils.js");r.d(t,"loadRequirements",function(){return s.loadRequirements});var o=r("./src/hypha/webrtc-client.js");r.d(t,"getRTCService",function(){return o.getRTCService}),r.d(t,"registerRTCService",function(){return o.registerRTCService});var l=r("./package.json");r.d(t,"VERSION",function(){return l.version});class f{constructor(m,b,v,c,w=60){Object(s.assert)(m&&b,"server_url and client_id are required"),m=m+"?client_id="+b,v&&(m+="&workspace="+v),c&&(m+="&token="+c),this._websocket=null,this._handle_message=null,this._reconnection_token=null,this._server_url=m,this._timeout=w*1e3,this._opening=null,this._retry_count=0,this._closing=!1}set_reconnection_token(m){this._reconnection_token=m}on_message(m){Object(s.assert)(m,"handler is required"),this._handle_message=m}async open(){return this._opening?this._opening:(this._opening=new Promise((m,b)=>{const v=this._reconnection_token?`${this._server_url}&reconnection_token=${this._reconnection_token}`:this._server_url;console.info("Creating a new connection to ",v.split("?")[0]);const c=new WebSocket(v);c.binaryType="arraybuffer",c.onmessage=w=>{const k=w.data;this._handle_message(k)},c.onopen=()=>{this._websocket=c,console.info("WebSocket connection established"),this._retry_count=0,m()},c.onclose=w=>{console.log("websocket closed"),this._closing||(console.log("Websocket connection interrupted, retrying..."),this._retry_count++,setTimeout(()=>this.open(),this._timeout)),this._websocket=null},c.onerror=w=>{console.log("Error occurred in websocket connection: ",w),b(new Error("Websocket connection failed.")),this._websocket=null}}).finally(()=>{this._opening=null}),this._opening)}async emit_message(m){return Object(s.assert)(this._handle_message,"No handler for message"),(!this._websocket||this._websocket.readyState!==WebSocket.OPEN)&&await this.open(),new Promise((b,v)=>{if(!this._websocket)v(new Error("Websocket connection not available"));else if(this._websocket.readyState===WebSocket.CONNECTING){const c=setTimeout(()=>{v(new Error("WebSocket connection timed out"))},this._timeout);this._websocket.addEventListener("open",()=>{clearTimeout(c);try{this._websocket.send(m),b()}catch(w){console.error(`Failed to send data, error: ${w}`),v(w)}})}else if(this._websocket.readyState===WebSocket.OPEN)try{this._websocket.send(m),b()}catch(c){console.error(`Failed to send data, error: ${c}`),v(c)}else v(new Error("WebSocket is not in the OPEN or CONNECTING state"))})}disconnect(m){this._closing=!0;const b=this._websocket;this._websocket=null,b&&b.readyState===WebSocket.OPEN&&b.close(1e3,m),console.info(`Websocket connection disconnected (${m})`)}}function u(a){if(!a)throw new Error("server_url is required");return a.startsWith("http://")?a=a.replace("http://","ws://").replace(/\/$/,"")+"/ws":a.startsWith("https://")&&(a=a.replace("https://","wss://").replace(/\/$/,"")+"/ws"),a}async function _(a){const m=a.login_service_id||"public/*:hypha-login",b=a.login_timeout||60,v=a.login_callback,c=await g({name:"initial login client",server_url:a.server_url});try{const w=await c.get_service(m),k=await w.start();return v?await v(k):console.log(`Please open your browser and login at ${k.login_url}`),await w.check(k.key,b)}catch(w){throw w}finally{await c.disconnect()}}async function g(a){let m=a.client_id;m||(m=Object(s.randId)());let b=u(a.server_url),v=new f(b,m,a.workspace,a.token,a.method_timeout||60);await v.open();const c=new i.RPC(v,{client_id:m,manager_id:"workspace-manager",default_context:{connection_type:"websocket"},name:a.name,method_timeout:a.method_timeout}),w=await c.get_remote_service("workspace-manager:default");w.rpc=c;async function k(O){O.id="default",O.name=a.name||O.id,await c.register_service(O,!0)}async function x(O){return await w.get_service(O+":default")}async function E(){await c.disconnect(),await v.disconnect()}if(w.export=k,w.getPlugin=x,w.listPlugins=w.listServices,w.disconnect=E,w.registerCodec=c.register_codec.bind(c),a.webrtc&&await Object(o.registerRTCService)(w,m+"-rtc",a.webrtc_config),w.get_service||w.getService){const O=w.get_service||w.getService;w.get_service=async function(A,T,j){Object(s.assert)([void 0,!0,!1,"auto"].includes(T),"webrtc must be true, false or 'auto'");const I=await O(A);if(T===!0||T==="auto"){if(I.id.includes(":")&&I.id.includes("/")){const D=I.id.split(":")[0];try{const $=await Object(o.getRTCService)(w,D+":"+D.split("/")[1]+"-rtc",j),N=await $.get_service(I.id.split(":")[1]);return N._webrtc=!0,N._peer=$,N._service=I,N}catch($){console.warn("Failed to get webrtc service, using websocket connection",$)}}if(T===!0)throw new Error("Failed to get the service via webrtc")}return I},w.getService=w.get_service}return w}}})})})(hyphaRpcWebsocket);var hyphaRpcWebsocketExports=hyphaRpcWebsocket.exports,hyphaRpcSse={exports:{}};(function(module,exports){var define_process_env_default={};(function(t,r){module.exports=r()})(window,function(){return function(n){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i,l:!1,exports:{}};return n[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=n,r.c=t,r.d=function(i,s,o){r.o(i,s)||Object.defineProperty(i,s,{enumerable:!0,get:o})},r.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},r.t=function(i,s){if(s&1&&(i=r(i)),s&8||s&4&&typeof i=="object"&&i&&i.__esModule)return i;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:i}),s&2&&typeof i!="string")for(var l in i)r.d(o,l,(function(f){return i[f]}).bind(null,l));return o},r.n=function(i){var s=i&&i.__esModule?function(){return i.default}:function(){return i};return r.d(s,"a",s),s},r.o=function(i,s){return Object.prototype.hasOwnProperty.call(i,s)},r.p="",r(r.s="./src/hypha/sse-client.js")}({"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs":function(n,t,r){r.r(t),r.d(t,"CachedKeyDecoder",function(){return l});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),s=16,o=16,l=function(){function f(u,_){u===void 0&&(u=s),_===void 0&&(_=o),this.maxKeyLength=u,this.maxLengthPerKey=_,this.hit=0,this.miss=0,this.caches=[];for(var g=0;g<this.maxKeyLength;g++)this.caches.push([])}return f.prototype.canBeCached=function(u){return u>0&&u<=this.maxKeyLength},f.prototype.find=function(u,_,g){var a=this.caches[g-1];e:for(var m=0,b=a;m<b.length;m++){for(var v=b[m],c=v.bytes,w=0;w<g;w++)if(c[w]!==u[_+w])continue e;return v.str}return null},f.prototype.store=function(u,_){var g=this.caches[u.length-1],a={bytes:u,str:_};g.length>=this.maxLengthPerKey?g[Math.random()*g.length|0]=a:g.push(a)},f.prototype.decode=function(u,_,g){var a=this.find(u,_,g);if(a!=null)return this.hit++,a;this.miss++;var m=Object(i.utf8DecodeJs)(u,_,g),b=Uint8Array.prototype.slice.call(u,_,_+g);return this.store(b,m),m},f}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs":function(n,t,r){r.r(t),r.d(t,"DecodeError",function(){return s});var i=function(){var o=function(l,f){return o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(u,_){u.__proto__=_}||function(u,_){for(var g in _)Object.prototype.hasOwnProperty.call(_,g)&&(u[g]=_[g])},o(l,f)};return function(l,f){if(typeof f!="function"&&f!==null)throw new TypeError("Class extends value "+String(f)+" is not a constructor or null");o(l,f);function u(){this.constructor=l}l.prototype=f===null?Object.create(f):(u.prototype=f.prototype,new u)}}(),s=function(o){i(l,o);function l(f){var u=o.call(this,f)||this,_=Object.create(l.prototype);return Object.setPrototypeOf(u,_),Object.defineProperty(u,"name",{configurable:!0,enumerable:!1,value:l.name}),u}return l}(Error)},"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs":function(n,t,r){r.r(t),r.d(t,"DataViewIndexOutOfBoundsError",function(){return E}),r.d(t,"Decoder",function(){return T});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),f=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"),u=r("./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs"),_=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"),g=function(j,I,D,$){function N(M){return M instanceof D?M:new D(function(W){W(M)})}return new(D||(D=Promise))(function(M,W){function F(Y){try{q($.next(Y))}catch(X){W(X)}}function H(Y){try{q($.throw(Y))}catch(X){W(X)}}function q(Y){Y.done?M(Y.value):N(Y.value).then(F,H)}q(($=$.apply(j,I||[])).next())})},a=function(j,I){var D={label:0,sent:function(){if(M[0]&1)throw M[1];return M[1]},trys:[],ops:[]},$,N,M,W;return W={next:F(0),throw:F(1),return:F(2)},typeof Symbol=="function"&&(W[Symbol.iterator]=function(){return this}),W;function F(q){return function(Y){return H([q,Y])}}function H(q){if($)throw new TypeError("Generator is already executing.");for(;D;)try{if($=1,N&&(M=q[0]&2?N.return:q[0]?N.throw||((M=N.return)&&M.call(N),0):N.next)&&!(M=M.call(N,q[1])).done)return M;switch(N=0,M&&(q=[q[0]&2,M.value]),q[0]){case 0:case 1:M=q;break;case 4:return D.label++,{value:q[1],done:!1};case 5:D.label++,N=q[1],q=[0];continue;case 7:q=D.ops.pop(),D.trys.pop();continue;default:if(M=D.trys,!(M=M.length>0&&M[M.length-1])&&(q[0]===6||q[0]===2)){D=0;continue}if(q[0]===3&&(!M||q[1]>M[0]&&q[1]<M[3])){D.label=q[1];break}if(q[0]===6&&D.label<M[1]){D.label=M[1],M=q;break}if(M&&D.label<M[2]){D.label=M[2],D.ops.push(q);break}M[2]&&D.ops.pop(),D.trys.pop();continue}q=I.call(j,D)}catch(Y){q=[6,Y],N=0}finally{$=M=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:!0}}},m=function(j){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var I=j[Symbol.asyncIterator],D;return I?I.call(j):(j=typeof __values=="function"?__values(j):j[Symbol.iterator](),D={},$("next"),$("throw"),$("return"),D[Symbol.asyncIterator]=function(){return this},D);function $(M){D[M]=j[M]&&function(W){return new Promise(function(F,H){W=j[M](W),N(F,H,W.done,W.value)})}}function N(M,W,F,H){Promise.resolve(H).then(function(q){M({value:q,done:F})},W)}},b=function(j){return this instanceof b?(this.v=j,this):new b(j)},v=function(j,I,D){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var $=D.apply(j,I||[]),N,M=[];return N={},W("next"),W("throw"),W("return"),N[Symbol.asyncIterator]=function(){return this},N;function W(J){$[J]&&(N[J]=function(te){return new Promise(function(ie,de){M.push([J,te,ie,de])>1||F(J,te)})})}function F(J,te){try{H($[J](te))}catch(ie){X(M[0][3],ie)}}function H(J){J.value instanceof b?Promise.resolve(J.value.v).then(q,Y):X(M[0][2],J)}function q(J){F("next",J)}function Y(J){F("throw",J)}function X(J,te){J(te),M.shift(),M.length&&F(M[0][0],M[0][1])}},c=function(j){var I=typeof j;return I==="string"||I==="number"},w=-1,k=new DataView(new ArrayBuffer(0)),x=new Uint8Array(k.buffer),E=function(){try{k.getInt8(0)}catch(j){return j.constructor}throw new Error("never reached")}(),O=new E("Insufficient data"),A=new u.CachedKeyDecoder,T=function(){function j(I,D,$,N,M,W,F,H){I===void 0&&(I=s.ExtensionCodec.defaultCodec),D===void 0&&(D=void 0),$===void 0&&($=o.UINT32_MAX),N===void 0&&(N=o.UINT32_MAX),M===void 0&&(M=o.UINT32_MAX),W===void 0&&(W=o.UINT32_MAX),F===void 0&&(F=o.UINT32_MAX),H===void 0&&(H=A),this.extensionCodec=I,this.context=D,this.maxStrLength=$,this.maxBinLength=N,this.maxArrayLength=M,this.maxMapLength=W,this.maxExtLength=F,this.keyDecoder=H,this.totalPos=0,this.pos=0,this.view=k,this.bytes=x,this.headByte=w,this.stack=[]}return j.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=w,this.stack.length=0},j.prototype.setBuffer=function(I){this.bytes=Object(f.ensureUint8Array)(I),this.view=Object(f.createDataView)(this.bytes),this.pos=0},j.prototype.appendBuffer=function(I){if(this.headByte===w&&!this.hasRemaining(1))this.setBuffer(I);else{var D=this.bytes.subarray(this.pos),$=Object(f.ensureUint8Array)(I),N=new Uint8Array(D.length+$.length);N.set(D),N.set($,D.length),this.setBuffer(N)}},j.prototype.hasRemaining=function(I){return this.view.byteLength-this.pos>=I},j.prototype.createExtraByteError=function(I){var D=this,$=D.view,N=D.pos;return new RangeError("Extra "+($.byteLength-N)+" of "+$.byteLength+" byte(s) found at buffer["+I+"]")},j.prototype.decode=function(I){this.reinitializeState(),this.setBuffer(I);var D=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return D},j.prototype.decodeMulti=function(I){return a(this,function(D){switch(D.label){case 0:this.reinitializeState(),this.setBuffer(I),D.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return D.sent(),[3,1];case 3:return[2]}})},j.prototype.decodeAsync=function(I){var D,$,N,M;return g(this,void 0,void 0,function(){var W,F,H,q,Y,X,J,te;return a(this,function(ie){switch(ie.label){case 0:W=!1,ie.label=1;case 1:ie.trys.push([1,6,7,12]),D=m(I),ie.label=2;case 2:return[4,D.next()];case 3:if($=ie.sent(),!!$.done)return[3,5];if(H=$.value,W)throw this.createExtraByteError(this.totalPos);this.appendBuffer(H);try{F=this.doDecodeSync(),W=!0}catch(de){if(!(de instanceof E))throw de}this.totalPos+=this.pos,ie.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return q=ie.sent(),N={error:q},[3,12];case 7:return ie.trys.push([7,,10,11]),$&&!$.done&&(M=D.return)?[4,M.call(D)]:[3,9];case 8:ie.sent(),ie.label=9;case 9:return[3,11];case 10:if(N)throw N.error;return[7];case 11:return[7];case 12:if(W){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,F]}throw Y=this,X=Y.headByte,J=Y.pos,te=Y.totalPos,new RangeError("Insufficient data in parsing "+Object(i.prettyByte)(X)+" at "+te+" ("+J+" in the current buffer)")}})})},j.prototype.decodeArrayStream=function(I){return this.decodeMultiAsync(I,!0)},j.prototype.decodeStream=function(I){return this.decodeMultiAsync(I,!1)},j.prototype.decodeMultiAsync=function(I,D){return v(this,arguments,function(){var N,M,W,F,H,q,Y,X,J;return a(this,function(te){switch(te.label){case 0:N=D,M=-1,te.label=1;case 1:te.trys.push([1,13,14,19]),W=m(I),te.label=2;case 2:return[4,b(W.next())];case 3:if(F=te.sent(),!!F.done)return[3,12];if(H=F.value,D&&M===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(H),N&&(M=this.readArraySize(),N=!1,this.complete()),te.label=4;case 4:te.trys.push([4,9,,10]),te.label=5;case 5:return[4,b(this.doDecodeSync())];case 6:return[4,te.sent()];case 7:return te.sent(),--M===0?[3,8]:[3,5];case 8:return[3,10];case 9:if(q=te.sent(),!(q instanceof E))throw q;return[3,10];case 10:this.totalPos+=this.pos,te.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return Y=te.sent(),X={error:Y},[3,19];case 14:return te.trys.push([14,,17,18]),F&&!F.done&&(J=W.return)?[4,b(J.call(W))]:[3,16];case 15:te.sent(),te.label=16;case 16:return[3,18];case 17:if(X)throw X.error;return[7];case 18:return[7];case 19:return[2]}})})},j.prototype.doDecodeSync=function(){e:for(;;){var I=this.readHeadByte(),D=void 0;if(I>=224)D=I-256;else if(I<192)if(I<128)D=I;else if(I<144){var $=I-128;if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I<160){var $=I-144;if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else{var N=I-160;D=this.decodeUtf8String(N,0)}else if(I===192)D=null;else if(I===194)D=!1;else if(I===195)D=!0;else if(I===202)D=this.readF32();else if(I===203)D=this.readF64();else if(I===204)D=this.readU8();else if(I===205)D=this.readU16();else if(I===206)D=this.readU32();else if(I===207)D=this.readU64();else if(I===208)D=this.readI8();else if(I===209)D=this.readI16();else if(I===210)D=this.readI32();else if(I===211)D=this.readI64();else if(I===217){var N=this.lookU8();D=this.decodeUtf8String(N,1)}else if(I===218){var N=this.lookU16();D=this.decodeUtf8String(N,2)}else if(I===219){var N=this.lookU32();D=this.decodeUtf8String(N,4)}else if(I===220){var $=this.readU16();if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else if(I===221){var $=this.readU32();if($!==0){this.pushArrayState($),this.complete();continue e}else D=[]}else if(I===222){var $=this.readU16();if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I===223){var $=this.readU32();if($!==0){this.pushMapState($),this.complete();continue e}else D={}}else if(I===196){var $=this.lookU8();D=this.decodeBinary($,1)}else if(I===197){var $=this.lookU16();D=this.decodeBinary($,2)}else if(I===198){var $=this.lookU32();D=this.decodeBinary($,4)}else if(I===212)D=this.decodeExtension(1,0);else if(I===213)D=this.decodeExtension(2,0);else if(I===214)D=this.decodeExtension(4,0);else if(I===215)D=this.decodeExtension(8,0);else if(I===216)D=this.decodeExtension(16,0);else if(I===199){var $=this.lookU8();D=this.decodeExtension($,1)}else if(I===200){var $=this.lookU16();D=this.decodeExtension($,2)}else if(I===201){var $=this.lookU32();D=this.decodeExtension($,4)}else throw new _.DecodeError("Unrecognized type byte: "+Object(i.prettyByte)(I));this.complete();for(var M=this.stack;M.length>0;){var W=M[M.length-1];if(W.type===0)if(W.array[W.position]=D,W.position++,W.position===W.size)M.pop(),D=W.array;else continue e;else if(W.type===1){if(!c(D))throw new _.DecodeError("The type of key must be string or number but "+typeof D);if(D==="__proto__")throw new _.DecodeError("The key __proto__ is not allowed");W.key=D,W.type=2;continue e}else if(W.map[W.key]=D,W.readCount++,W.readCount===W.size)M.pop(),D=W.map;else{W.key=null,W.type=1;continue e}}return D}},j.prototype.readHeadByte=function(){return this.headByte===w&&(this.headByte=this.readU8()),this.headByte},j.prototype.complete=function(){this.headByte=w},j.prototype.readArraySize=function(){var I=this.readHeadByte();switch(I){case 220:return this.readU16();case 221:return this.readU32();default:{if(I<160)return I-144;throw new _.DecodeError("Unrecognized array type byte: "+Object(i.prettyByte)(I))}}},j.prototype.pushMapState=function(I){if(I>this.maxMapLength)throw new _.DecodeError("Max length exceeded: map length ("+I+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:I,key:null,readCount:0,map:{}})},j.prototype.pushArrayState=function(I){if(I>this.maxArrayLength)throw new _.DecodeError("Max length exceeded: array length ("+I+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:I,array:new Array(I),position:0})},j.prototype.decodeUtf8String=function(I,D){var $;if(I>this.maxStrLength)throw new _.DecodeError("Max length exceeded: UTF-8 byte length ("+I+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+D+I)throw O;var N=this.pos+D,M;return this.stateIsMapKey()&&(!(($=this.keyDecoder)===null||$===void 0)&&$.canBeCached(I))?M=this.keyDecoder.decode(this.bytes,N,I):I>l.TEXT_DECODER_THRESHOLD?M=Object(l.utf8DecodeTD)(this.bytes,N,I):M=Object(l.utf8DecodeJs)(this.bytes,N,I),this.pos+=D+I,M},j.prototype.stateIsMapKey=function(){if(this.stack.length>0){var I=this.stack[this.stack.length-1];return I.type===1}return!1},j.prototype.decodeBinary=function(I,D){if(I>this.maxBinLength)throw new _.DecodeError("Max length exceeded: bin length ("+I+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(I+D))throw O;var $=this.pos+D,N=this.bytes.subarray($,$+I);return this.pos+=D+I,N},j.prototype.decodeExtension=function(I,D){if(I>this.maxExtLength)throw new _.DecodeError("Max length exceeded: ext length ("+I+") > maxExtLength ("+this.maxExtLength+")");var $=this.view.getInt8(this.pos+D),N=this.decodeBinary(I,D+1);return this.extensionCodec.decode(N,$,this.context)},j.prototype.lookU8=function(){return this.view.getUint8(this.pos)},j.prototype.lookU16=function(){return this.view.getUint16(this.pos)},j.prototype.lookU32=function(){return this.view.getUint32(this.pos)},j.prototype.readU8=function(){var I=this.view.getUint8(this.pos);return this.pos++,I},j.prototype.readI8=function(){var I=this.view.getInt8(this.pos);return this.pos++,I},j.prototype.readU16=function(){var I=this.view.getUint16(this.pos);return this.pos+=2,I},j.prototype.readI16=function(){var I=this.view.getInt16(this.pos);return this.pos+=2,I},j.prototype.readU32=function(){var I=this.view.getUint32(this.pos);return this.pos+=4,I},j.prototype.readI32=function(){var I=this.view.getInt32(this.pos);return this.pos+=4,I},j.prototype.readU64=function(){var I=Object(o.getUint64)(this.view,this.pos);return this.pos+=8,I},j.prototype.readI64=function(){var I=Object(o.getInt64)(this.view,this.pos);return this.pos+=8,I},j.prototype.readF32=function(){var I=this.view.getFloat32(this.pos);return this.pos+=4,I},j.prototype.readF64=function(){var I=this.view.getFloat64(this.pos);return this.pos+=8,I},j}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs":function(n,t,r){r.r(t),r.d(t,"DEFAULT_MAX_DEPTH",function(){return f}),r.d(t,"DEFAULT_INITIAL_BUFFER_SIZE",function(){return u}),r.d(t,"Encoder",function(){return _});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"),f=100,u=2048,_=function(){function g(a,m,b,v,c,w,k,x){a===void 0&&(a=s.ExtensionCodec.defaultCodec),m===void 0&&(m=void 0),b===void 0&&(b=f),v===void 0&&(v=u),c===void 0&&(c=!1),w===void 0&&(w=!1),k===void 0&&(k=!1),x===void 0&&(x=!1),this.extensionCodec=a,this.context=m,this.maxDepth=b,this.initialBufferSize=v,this.sortKeys=c,this.forceFloat32=w,this.ignoreUndefined=k,this.forceIntegerToFloat=x,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return g.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},g.prototype.reinitializeState=function(){this.pos=0},g.prototype.encode=function(a){return this.reinitializeState(),this.doEncode(a,1),this.getUint8Array()},g.prototype.doEncode=function(a,m){if(m>this.maxDepth)throw new Error("Too deep objects in depth "+m);a==null?this.encodeNil():typeof a=="boolean"?this.encodeBoolean(a):typeof a=="number"?this.encodeNumber(a):typeof a=="string"?this.encodeString(a):this.encodeObject(a,m)},g.prototype.ensureBufferSizeToWrite=function(a){var m=this.pos+a;this.view.byteLength<m&&this.resizeBuffer(m*2)},g.prototype.resizeBuffer=function(a){var m=new ArrayBuffer(a),b=new Uint8Array(m),v=new DataView(m);b.set(this.bytes),this.view=v,this.bytes=b},g.prototype.encodeNil=function(){this.writeU8(192)},g.prototype.encodeBoolean=function(a){a===!1?this.writeU8(194):this.writeU8(195)},g.prototype.encodeNumber=function(a){Number.isSafeInteger(a)&&!this.forceIntegerToFloat?a>=0?a<128?this.writeU8(a):a<256?(this.writeU8(204),this.writeU8(a)):a<65536?(this.writeU8(205),this.writeU16(a)):a<4294967296?(this.writeU8(206),this.writeU32(a)):(this.writeU8(207),this.writeU64(a)):a>=-32?this.writeU8(224|a+32):a>=-128?(this.writeU8(208),this.writeI8(a)):a>=-32768?(this.writeU8(209),this.writeI16(a)):a>=-2147483648?(this.writeU8(210),this.writeI32(a)):(this.writeU8(211),this.writeI64(a)):this.forceFloat32?(this.writeU8(202),this.writeF32(a)):(this.writeU8(203),this.writeF64(a))},g.prototype.writeStringHeader=function(a){if(a<32)this.writeU8(160+a);else if(a<256)this.writeU8(217),this.writeU8(a);else if(a<65536)this.writeU8(218),this.writeU16(a);else if(a<4294967296)this.writeU8(219),this.writeU32(a);else throw new Error("Too long string: "+a+" bytes in UTF-8")},g.prototype.encodeString=function(a){var m=5,b=a.length;if(b>i.TEXT_ENCODER_THRESHOLD){var v=Object(i.utf8Count)(a);this.ensureBufferSizeToWrite(m+v),this.writeStringHeader(v),Object(i.utf8EncodeTE)(a,this.bytes,this.pos),this.pos+=v}else{var v=Object(i.utf8Count)(a);this.ensureBufferSizeToWrite(m+v),this.writeStringHeader(v),Object(i.utf8EncodeJs)(a,this.bytes,this.pos),this.pos+=v}},g.prototype.encodeObject=function(a,m){var b=this.extensionCodec.tryToEncode(a,this.context);if(b!=null)this.encodeExtension(b);else if(Array.isArray(a))this.encodeArray(a,m);else if(ArrayBuffer.isView(a))this.encodeBinary(a);else if(typeof a=="object")this.encodeMap(a,m);else throw new Error("Unrecognized object: "+Object.prototype.toString.apply(a))},g.prototype.encodeBinary=function(a){var m=a.byteLength;if(m<256)this.writeU8(196),this.writeU8(m);else if(m<65536)this.writeU8(197),this.writeU16(m);else if(m<4294967296)this.writeU8(198),this.writeU32(m);else throw new Error("Too large binary: "+m);var b=Object(l.ensureUint8Array)(a);this.writeU8a(b)},g.prototype.encodeArray=function(a,m){var b=a.length;if(b<16)this.writeU8(144+b);else if(b<65536)this.writeU8(220),this.writeU16(b);else if(b<4294967296)this.writeU8(221),this.writeU32(b);else throw new Error("Too large array: "+b);for(var v=0,c=a;v<c.length;v++){var w=c[v];this.doEncode(w,m+1)}},g.prototype.countWithoutUndefined=function(a,m){for(var b=0,v=0,c=m;v<c.length;v++){var w=c[v];a[w]!==void 0&&b++}return b},g.prototype.encodeMap=function(a,m){var b=Object.keys(a);this.sortKeys&&b.sort();var v=this.ignoreUndefined?this.countWithoutUndefined(a,b):b.length;if(v<16)this.writeU8(128+v);else if(v<65536)this.writeU8(222),this.writeU16(v);else if(v<4294967296)this.writeU8(223),this.writeU32(v);else throw new Error("Too large map object: "+v);for(var c=0,w=b;c<w.length;c++){var k=w[c],x=a[k];this.ignoreUndefined&&x===void 0||(this.encodeString(k),this.doEncode(x,m+1))}},g.prototype.encodeExtension=function(a){var m=a.data.length;if(m===1)this.writeU8(212);else if(m===2)this.writeU8(213);else if(m===4)this.writeU8(214);else if(m===8)this.writeU8(215);else if(m===16)this.writeU8(216);else if(m<256)this.writeU8(199),this.writeU8(m);else if(m<65536)this.writeU8(200),this.writeU16(m);else if(m<4294967296)this.writeU8(201),this.writeU32(m);else throw new Error("Too large extension object: "+m);this.writeI8(a.type),this.writeU8a(a.data)},g.prototype.writeU8=function(a){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,a),this.pos++},g.prototype.writeU8a=function(a){var m=a.length;this.ensureBufferSizeToWrite(m),this.bytes.set(a,this.pos),this.pos+=m},g.prototype.writeI8=function(a){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,a),this.pos++},g.prototype.writeU16=function(a){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,a),this.pos+=2},g.prototype.writeI16=function(a){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,a),this.pos+=2},g.prototype.writeU32=function(a){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,a),this.pos+=4},g.prototype.writeI32=function(a){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,a),this.pos+=4},g.prototype.writeF32=function(a){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,a),this.pos+=4},g.prototype.writeF64=function(a){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,a),this.pos+=8},g.prototype.writeU64=function(a){this.ensureBufferSizeToWrite(8),Object(o.setUint64)(this.view,this.pos,a),this.pos+=8},g.prototype.writeI64=function(a){this.ensureBufferSizeToWrite(8),Object(o.setInt64)(this.view,this.pos,a),this.pos+=8},g}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs":function(n,t,r){r.r(t),r.d(t,"ExtData",function(){return i});var i=function(){function s(o,l){this.type=o,this.data=l}return s}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs":function(n,t,r){r.r(t),r.d(t,"ExtensionCodec",function(){return o});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs"),o=function(){function l(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(s.timestampExtension)}return l.prototype.register=function(f){var u=f.type,_=f.encode,g=f.decode;if(u>=0)this.encoders[u]=_,this.decoders[u]=g;else{var a=1+u;this.builtInEncoders[a]=_,this.builtInDecoders[a]=g}},l.prototype.tryToEncode=function(f,u){for(var _=0;_<this.builtInEncoders.length;_++){var g=this.builtInEncoders[_];if(g!=null){var a=g(f,u);if(a!=null){var m=-1-_;return new i.ExtData(m,a)}}}for(var _=0;_<this.encoders.length;_++){var g=this.encoders[_];if(g!=null){var a=g(f,u);if(a!=null){var m=_;return new i.ExtData(m,a)}}}return f instanceof i.ExtData?f:null},l.prototype.decode=function(f,u,_){var g=u<0?this.builtInDecoders[-1-u]:this.decoders[u];return g?g(f,u,_):new i.ExtData(u,f)},l.defaultCodec=new l,l}()},"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs":function(n,t,r){r.r(t),r.d(t,"defaultDecodeOptions",function(){return s}),r.d(t,"decode",function(){return o}),r.d(t,"decodeMulti",function(){return l});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"),s={};function o(f,u){u===void 0&&(u=s);var _=new i.Decoder(u.extensionCodec,u.context,u.maxStrLength,u.maxBinLength,u.maxArrayLength,u.maxMapLength,u.maxExtLength);return _.decode(f)}function l(f,u){u===void 0&&(u=s);var _=new i.Decoder(u.extensionCodec,u.context,u.maxStrLength,u.maxBinLength,u.maxArrayLength,u.maxMapLength,u.maxExtLength);return _.decodeMulti(f)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs":function(n,t,r){r.r(t),r.d(t,"decodeAsync",function(){return u}),r.d(t,"decodeArrayStream",function(){return _}),r.d(t,"decodeMultiStream",function(){return g}),r.d(t,"decodeStream",function(){return a});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs"),o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs"),l=function(m,b,v,c){function w(k){return k instanceof v?k:new v(function(x){x(k)})}return new(v||(v=Promise))(function(k,x){function E(T){try{A(c.next(T))}catch(j){x(j)}}function O(T){try{A(c.throw(T))}catch(j){x(j)}}function A(T){T.done?k(T.value):w(T.value).then(E,O)}A((c=c.apply(m,b||[])).next())})},f=function(m,b){var v={label:0,sent:function(){if(k[0]&1)throw k[1];return k[1]},trys:[],ops:[]},c,w,k,x;return x={next:E(0),throw:E(1),return:E(2)},typeof Symbol=="function"&&(x[Symbol.iterator]=function(){return this}),x;function E(A){return function(T){return O([A,T])}}function O(A){if(c)throw new TypeError("Generator is already executing.");for(;v;)try{if(c=1,w&&(k=A[0]&2?w.return:A[0]?w.throw||((k=w.return)&&k.call(w),0):w.next)&&!(k=k.call(w,A[1])).done)return k;switch(w=0,k&&(A=[A[0]&2,k.value]),A[0]){case 0:case 1:k=A;break;case 4:return v.label++,{value:A[1],done:!1};case 5:v.label++,w=A[1],A=[0];continue;case 7:A=v.ops.pop(),v.trys.pop();continue;default:if(k=v.trys,!(k=k.length>0&&k[k.length-1])&&(A[0]===6||A[0]===2)){v=0;continue}if(A[0]===3&&(!k||A[1]>k[0]&&A[1]<k[3])){v.label=A[1];break}if(A[0]===6&&v.label<k[1]){v.label=k[1],k=A;break}if(k&&v.label<k[2]){v.label=k[2],v.ops.push(A);break}k[2]&&v.ops.pop(),v.trys.pop();continue}A=b.call(m,v)}catch(T){A=[6,T],w=0}finally{c=k=0}if(A[0]&5)throw A[1];return{value:A[0]?A[1]:void 0,done:!0}}};function u(m,b){return b===void 0&&(b=o.defaultDecodeOptions),l(this,void 0,void 0,function(){var v,c;return f(this,function(w){return v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength),[2,c.decodeAsync(v)]})})}function _(m,b){b===void 0&&(b=o.defaultDecodeOptions);var v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength);return c.decodeArrayStream(v)}function g(m,b){b===void 0&&(b=o.defaultDecodeOptions);var v=Object(s.ensureAsyncIterable)(m),c=new i.Decoder(b.extensionCodec,b.context,b.maxStrLength,b.maxBinLength,b.maxArrayLength,b.maxMapLength,b.maxExtLength);return c.decodeStream(v)}function a(m,b){return b===void 0&&(b=o.defaultDecodeOptions),g(m,b)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs":function(n,t,r){r.r(t),r.d(t,"encode",function(){return o});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs"),s={};function o(l,f){f===void 0&&(f=s);var u=new i.Encoder(f.extensionCodec,f.context,f.maxDepth,f.initialBufferSize,f.sortKeys,f.forceFloat32,f.ignoreUndefined,f.forceIntegerToFloat);return u.encode(l)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs":function(n,t,r){r.r(t);var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs");r.d(t,"encode",function(){return i.encode});var s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs");r.d(t,"decode",function(){return s.decode}),r.d(t,"decodeMulti",function(){return s.decodeMulti});var o=r("./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs");r.d(t,"decodeAsync",function(){return o.decodeAsync}),r.d(t,"decodeArrayStream",function(){return o.decodeArrayStream}),r.d(t,"decodeMultiStream",function(){return o.decodeMultiStream}),r.d(t,"decodeStream",function(){return o.decodeStream});var l=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs");r.d(t,"Decoder",function(){return l.Decoder}),r.d(t,"DataViewIndexOutOfBoundsError",function(){return l.DataViewIndexOutOfBoundsError});var f=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs");r.d(t,"DecodeError",function(){return f.DecodeError});var u=r("./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs");r.d(t,"Encoder",function(){return u.Encoder});var _=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs");r.d(t,"ExtensionCodec",function(){return _.ExtensionCodec});var g=r("./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs");r.d(t,"ExtData",function(){return g.ExtData});var a=r("./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs");r.d(t,"EXT_TIMESTAMP",function(){return a.EXT_TIMESTAMP}),r.d(t,"encodeDateToTimeSpec",function(){return a.encodeDateToTimeSpec}),r.d(t,"encodeTimeSpecToTimestamp",function(){return a.encodeTimeSpecToTimestamp}),r.d(t,"decodeTimestampToTimeSpec",function(){return a.decodeTimestampToTimeSpec}),r.d(t,"encodeTimestampExtension",function(){return a.encodeTimestampExtension}),r.d(t,"decodeTimestampExtension",function(){return a.decodeTimestampExtension})},"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs":function(n,t,r){r.r(t),r.d(t,"EXT_TIMESTAMP",function(){return o}),r.d(t,"encodeTimeSpecToTimestamp",function(){return u}),r.d(t,"encodeDateToTimeSpec",function(){return _}),r.d(t,"encodeTimestampExtension",function(){return g}),r.d(t,"decodeTimestampToTimeSpec",function(){return a}),r.d(t,"decodeTimestampExtension",function(){return m}),r.d(t,"timestampExtension",function(){return b});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),o=-1,l=4294967296-1,f=17179869184-1;function u(v){var c=v.sec,w=v.nsec;if(c>=0&&w>=0&&c<=f)if(w===0&&c<=l){var k=new Uint8Array(4),x=new DataView(k.buffer);return x.setUint32(0,c),k}else{var E=c/4294967296,O=c&4294967295,k=new Uint8Array(8),x=new DataView(k.buffer);return x.setUint32(0,w<<2|E&3),x.setUint32(4,O),k}else{var k=new Uint8Array(12),x=new DataView(k.buffer);return x.setUint32(0,w),Object(s.setInt64)(x,4,c),k}}function _(v){var c=v.getTime(),w=Math.floor(c/1e3),k=(c-w*1e3)*1e6,x=Math.floor(k/1e9);return{sec:w+x,nsec:k-x*1e9}}function g(v){if(v instanceof Date){var c=_(v);return u(c)}else return null}function a(v){var c=new DataView(v.buffer,v.byteOffset,v.byteLength);switch(v.byteLength){case 4:{var w=c.getUint32(0),k=0;return{sec:w,nsec:k}}case 8:{var x=c.getUint32(0),E=c.getUint32(4),w=(x&3)*4294967296+E,k=x>>>2;return{sec:w,nsec:k}}case 12:{var w=Object(s.getInt64)(c,4),k=c.getUint32(0);return{sec:w,nsec:k}}default:throw new i.DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): "+v.length)}}function m(v){var c=a(v);return new Date(c.sec*1e3+c.nsec/1e6)}var b={type:o,encode:g,decode:m}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs":function(n,t,r){r.r(t),r.d(t,"UINT32_MAX",function(){return i}),r.d(t,"setUint64",function(){return s}),r.d(t,"setInt64",function(){return o}),r.d(t,"getInt64",function(){return l}),r.d(t,"getUint64",function(){return f});var i=4294967295;function s(u,_,g){var a=g/4294967296,m=g;u.setUint32(_,a),u.setUint32(_+4,m)}function o(u,_,g){var a=Math.floor(g/4294967296),m=g;u.setUint32(_,a),u.setUint32(_+4,m)}function l(u,_){var g=u.getInt32(_),a=u.getUint32(_+4);return g*4294967296+a}function f(u,_){var g=u.getUint32(_),a=u.getUint32(_+4);return g*4294967296+a}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs":function(n,t,r){r.r(t),r.d(t,"prettyByte",function(){return i});function i(s){return(s<0?"-":"")+"0x"+Math.abs(s).toString(16).padStart(2,"0")}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs":function(n,t,r){r.r(t),r.d(t,"isAsyncIterable",function(){return l}),r.d(t,"asyncIterableFromStream",function(){return u}),r.d(t,"ensureAsyncIterable",function(){return _});var i=function(g,a){var m={label:0,sent:function(){if(c[0]&1)throw c[1];return c[1]},trys:[],ops:[]},b,v,c,w;return w={next:k(0),throw:k(1),return:k(2)},typeof Symbol=="function"&&(w[Symbol.iterator]=function(){return this}),w;function k(E){return function(O){return x([E,O])}}function x(E){if(b)throw new TypeError("Generator is already executing.");for(;m;)try{if(b=1,v&&(c=E[0]&2?v.return:E[0]?v.throw||((c=v.return)&&c.call(v),0):v.next)&&!(c=c.call(v,E[1])).done)return c;switch(v=0,c&&(E=[E[0]&2,c.value]),E[0]){case 0:case 1:c=E;break;case 4:return m.label++,{value:E[1],done:!1};case 5:m.label++,v=E[1],E=[0];continue;case 7:E=m.ops.pop(),m.trys.pop();continue;default:if(c=m.trys,!(c=c.length>0&&c[c.length-1])&&(E[0]===6||E[0]===2)){m=0;continue}if(E[0]===3&&(!c||E[1]>c[0]&&E[1]<c[3])){m.label=E[1];break}if(E[0]===6&&m.label<c[1]){m.label=c[1],c=E;break}if(c&&m.label<c[2]){m.label=c[2],m.ops.push(E);break}c[2]&&m.ops.pop(),m.trys.pop();continue}E=a.call(g,m)}catch(O){E=[6,O],v=0}finally{b=c=0}if(E[0]&5)throw E[1];return{value:E[0]?E[1]:void 0,done:!0}}},s=function(g){return this instanceof s?(this.v=g,this):new s(g)},o=function(g,a,m){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var b=m.apply(g,a||[]),v,c=[];return v={},w("next"),w("throw"),w("return"),v[Symbol.asyncIterator]=function(){return this},v;function w(T){b[T]&&(v[T]=function(j){return new Promise(function(I,D){c.push([T,j,I,D])>1||k(T,j)})})}function k(T,j){try{x(b[T](j))}catch(I){A(c[0][3],I)}}function x(T){T.value instanceof s?Promise.resolve(T.value.v).then(E,O):A(c[0][2],T)}function E(T){k("next",T)}function O(T){k("throw",T)}function A(T,j){T(j),c.shift(),c.length&&k(c[0][0],c[0][1])}};function l(g){return g[Symbol.asyncIterator]!=null}function f(g){if(g==null)throw new Error("Assertion Failure: value must not be null nor undefined")}function u(g){return o(this,arguments,function(){var m,b,v,c;return i(this,function(w){switch(w.label){case 0:m=g.getReader(),w.label=1;case 1:w.trys.push([1,,9,10]),w.label=2;case 2:return[4,s(m.read())];case 3:return b=w.sent(),v=b.done,c=b.value,v?[4,s(void 0)]:[3,5];case 4:return[2,w.sent()];case 5:return f(c),[4,s(c)];case 6:return[4,w.sent()];case 7:return w.sent(),[3,2];case 8:return[3,10];case 9:return m.releaseLock(),[7];case 10:return[2]}})})}function _(g){return l(g)?g:u(g)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs":function(n,t,r){r.r(t),r.d(t,"ensureUint8Array",function(){return i}),r.d(t,"createDataView",function(){return s});function i(o){return o instanceof Uint8Array?o:ArrayBuffer.isView(o)?new Uint8Array(o.buffer,o.byteOffset,o.byteLength):o instanceof ArrayBuffer?new Uint8Array(o):Uint8Array.from(o)}function s(o){if(o instanceof ArrayBuffer)return new DataView(o);var l=i(o);return new DataView(l.buffer,l.byteOffset,l.byteLength)}},"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs":function(n,t,r){r.r(t),r.d(t,"utf8Count",function(){return o}),r.d(t,"utf8EncodeJs",function(){return l}),r.d(t,"TEXT_ENCODER_THRESHOLD",function(){return u}),r.d(t,"utf8EncodeTE",function(){return a}),r.d(t,"utf8DecodeJs",function(){return b}),r.d(t,"TEXT_DECODER_THRESHOLD",function(){return c}),r.d(t,"utf8DecodeTD",function(){return w});var i=r("./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"),s=(typeof process>"u"||define_process_env_default.TEXT_ENCODING!=="never")&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function o(k){for(var x=k.length,E=0,O=0;O<x;){var A=k.charCodeAt(O++);if(A&4294967168)if(!(A&4294965248))E+=2;else{if(A>=55296&&A<=56319&&O<x){var T=k.charCodeAt(O);(T&64512)===56320&&(++O,A=((A&1023)<<10)+(T&1023)+65536)}A&4294901760?E+=4:E+=3}else{E++;continue}}return E}function l(k,x,E){for(var O=k.length,A=E,T=0;T<O;){var j=k.charCodeAt(T++);if(j&4294967168)if(!(j&4294965248))x[A++]=j>>6&31|192;else{if(j>=55296&&j<=56319&&T<O){var I=k.charCodeAt(T);(I&64512)===56320&&(++T,j=((j&1023)<<10)+(I&1023)+65536)}j&4294901760?(x[A++]=j>>18&7|240,x[A++]=j>>12&63|128,x[A++]=j>>6&63|128):(x[A++]=j>>12&15|224,x[A++]=j>>6&63|128)}else{x[A++]=j;continue}x[A++]=j&63|128}}var f=s?new TextEncoder:void 0,u=s?typeof process<"u"&&define_process_env_default.TEXT_ENCODING!=="force"?200:0:i.UINT32_MAX;function _(k,x,E){x.set(f.encode(k),E)}function g(k,x,E){f.encodeInto(k,x.subarray(E))}var a=f!=null&&f.encodeInto?g:_,m=4096;function b(k,x,E){for(var O=x,A=O+E,T=[],j="";O<A;){var I=k[O++];if(!(I&128))T.push(I);else if((I&224)===192){var D=k[O++]&63;T.push((I&31)<<6|D)}else if((I&240)===224){var D=k[O++]&63,$=k[O++]&63;T.push((I&31)<<12|D<<6|$)}else if((I&248)===240){var D=k[O++]&63,$=k[O++]&63,N=k[O++]&63,M=(I&7)<<18|D<<12|$<<6|N;M>65535&&(M-=65536,T.push(M>>>10&1023|55296),M=56320|M&1023),T.push(M)}else T.push(I);T.length>=m&&(j+=String.fromCharCode.apply(String,T),T.length=0)}return T.length>0&&(j+=String.fromCharCode.apply(String,T)),j}var v=s?new TextDecoder:null,c=s?typeof process<"u"&&define_process_env_default.TEXT_DECODER!=="force"?200:0:i.UINT32_MAX;function w(k,x,E){var O=k.subarray(x,x+E);return v.decode(O)}},"./package.json":function(n){n.exports=JSON.parse('{"name":"imjoy-rpc","version":"0.5.46","description":"Remote procedure calls for ImJoy.","module":"index.js","types":"index.d.ts","scripts":{"build":"rm -rf dist && npm run build-umd","build-umd":"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map ","watch":"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map","publish-npm":"npm install && npm run build && npm publish","serve":"webpack-dev-server","stats":"webpack --profile --json > stats.json","stats-prod":"webpack --profile --json --mode production > stats-prod.json","analyze":"webpack-bundle-analyzer -p 9999 stats.json","analyze-prod":"webpack-bundle-analyzer -p 9999 stats-prod.json","clean":"rimraf dist/*","deploy":"npm run build && node deploy-site.js","format":"prettier --write \\"{src,tests}/**/**\\"","check-format":"prettier --check \\"{src,tests}/**/**\\"","test":"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js","test-watch":"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug"},"repository":{"type":"git","url":"git+https://github.com/imjoy-team/imjoy-rpc.git"},"keywords":["imjoy","rpc"],"author":"imjoy-team <imjoy.team@gmail.com>","license":"MIT","bugs":{"url":"https://github.com/imjoy-team/imjoy-rpc/issues"},"homepage":"https://github.com/imjoy-team/imjoy-rpc","dependencies":{"@msgpack/msgpack":"^2.7.1","socket.io-client":"^4.6.2"},"devDependencies":{"@babel/core":"^7.16.12","@babel/plugin-syntax-dynamic-import":"^7.8.3","@babel/polyfill":"^7.12.1","@babel/preset-env":"^7.16.11","@types/requirejs":"^2.1.34","babel-core":"^6.26.0","babel-eslint":"^10.1.0","babel-loader":"^8.2.3","babel-runtime":"^6.26.0","chai":"^4.3.6","clean-webpack-plugin":"^0.1.19","copy-webpack-plugin":"^5.1.2","eslint":"^6.8.0","eslint-config-prettier":"^4.2.0","eslint-loader":"^4.0.2","file-loader":"^0.11.2","fs-extra":"^0.30.0","gh-pages":"^2.0.1","html-loader":"^0.5.5","html-webpack-plugin":"^3.2.0","json-loader":"^0.5.4","karma":"^6.3.12","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^1.3.0","karma-mocha":"^2.0.1","karma-sourcemap-loader":"^0.3.8","karma-spec-reporter":"0.0.32","karma-webpack":"^4.0.2","lerna":"^6.0.3","lodash.debounce":"^4.0.8","mocha":"^10.1.0","postcss":"^7.0.36","prettier":"^1.6.1","rimraf":"^2.6.2","schema-utils":"^0.4.3","style-loader":"^0.18.1","ts-loader":"^9.4.3","url-loader":"^0.5.9","webpack":"^4.46.0","webpack-bundle-analyzer":"^4.7.0","webpack-cli":"^3.3.12","webpack-dev-server":"^3.11.3","webpack-merge":"^4.1.1","workbox-webpack-plugin":"^4.3.1","worker-loader":"^2.0.0","write-file-webpack-plugin":"^4.5.1"},"eslintConfig":{"globals":{"document":true,"window":true}}}')},"./src/hypha/rpc.js":function(n,t,r){r.r(t),r.d(t,"API_VERSION",function(){return o}),r.d(t,"RPC",function(){return b});var i=r("./src/hypha/utils.js"),s=r("./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs");const o="0.3.0",l=1024*500,f=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor;function u(v,c){const w=new Uint8Array(v.byteLength+c.byteLength);return w.set(new Uint8Array(v),0),w.set(new Uint8Array(c),v.byteLength),w.buffer}function _(v,c){if(!c)throw new Error("undefined index");return typeof c=="string"?_(v,c.split(".")):c.length===0?v:_(v[c[0]],c.slice(1))}function g(v){const c=v.toString(),w=c.match(/function\s*(\w*)/),k=w&&w[1]||"",x=c.match(/\(([^)]*)\)/);let E="";x&&(E=x[1].split(",").map(I=>I.replace(/\/\*.*?\*\//g,"").replace(/\/\/.*$/g,"")).filter(I=>I.trim().length>0).map(I=>I.trim()).join(", "));let O=c.match(/\)\s*\{\s*\/\*([\s\S]*?)\*\//);const A=O&&O[1].trim()||"";O=c.match(/\)\s*\{\s*(\/\/[\s\S]*?)\n\s*[^\s\/]/);const T=O&&O[1].split(`
`).map(I=>I.replace(/^\/\/\s*/,"").trim()).join(`
`)||"",j=A||T;return k&&E.length>0&&{name:k,sig:E,doc:j}}function a(v){var c=v.map(function(x){return x.byteLength}),w=c.reduce(function(x,E){return x+E},0),k=new Uint8Array(w);return c.reduce(function(x,E,O){return k.set(new Uint8Array(v[O]),x),x+E},0),k.buffer}class m{constructor(c,w,k,x){this._timeout=c,this._callback=w,this._args=k,this._label=x||"timer",this._task=null,this.started=!1}start(){this.started?this.reset():(this._task=setTimeout(()=>{this._callback.apply(this,this._args)},this._timeout*1e3),this.started=!0)}clear(){this._task?(clearTimeout(this._task),this._task=null,this.started=!1):console.warn(`Clearing a timer (${this._label}) which is not started`)}reset(){this._task&&clearTimeout(this._task),this._task=setTimeout(()=>{this._callback.apply(this,this._args)},this._timeout*1e3),this.started=!0}}class b extends i.MessageEmitter{constructor(c,{client_id:w=null,manager_id:k=null,default_context:x=null,name:E=null,codecs:O=null,method_timeout:A=null,max_message_buffer_size:T=0,debug:j=!1,workspace:I=null}){super(j),this._codecs=O||{},Object(i.assert)(w&&typeof w=="string"),Object(i.assert)(w,"client_id is required"),this._client_id=w,this._name=E,this._connection_info=null,this._workspace=null,this._local_workspace=I,this.manager_id=k,this.default_context=x||{},this._method_annotations=new WeakMap,this._manager_service=null,this._max_message_buffer_size=T,this._chunk_store={},this._method_timeout=A||30,this._services={},this._object_store={services:this._services},c?(this.add_service({id:"built-in",type:"built-in",name:"RPC built-in services",config:{require_context:!0,visibility:"public"},ping:this._ping.bind(this),get_service:this.get_local_service.bind(this),register_service:this.register_service.bind(this),message_cache:{create:this._create_message.bind(this),append:this._append_message.bind(this),process:this._process_message.bind(this),remove:this._remove_message.bind(this)}}),this.on("method",this._handle_method.bind(this)),Object(i.assert)(c.emit_message&&c.on_message),this._emit_message=c.emit_message.bind(c),c.on_message(this._on_message.bind(this)),this._connection=c,this._get_connection_info()):this._emit_message=function(){console.log("No connection to emit message")}}async _get_connection_info(){if(this.manager_id)try{if(await this.get_manager_service(30),Object(i.assert)(this._manager_service),this._connection_info=await this._manager_service.get_connection_info(),this._connection_info.reconnection_token&&this._connection.set_reconnection_token){this._connection.set_reconnection_token(this._connection_info.reconnection_token);const c=this._connection_info.reconnection_expires_in*.8;this._get_connection_info_task=setTimeout(this._get_connection_info.bind(this),c*1e3)}}catch(c){console.warn("Failed to fetch user info from ",this.manager_id,c)}}register_codec(c){if(!c.name||!c.encoder&&!c.decoder)throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");if(c.type)for(let w of Object.keys(this._codecs))(this._codecs[w].type===c.type||w===c.name)&&(delete this._codecs[w],console.warn("Remove duplicated codec: "+w));this._codecs[c.name]=c}async _ping(c,w){return Object(i.assert)(c=="ping"),"pong"}async ping(c,w){let k=this._generate_remote_method({_rtarget:c,_rmethod:"services.built-in.ping",_rpromise:!0,_rdoc:"Ping a remote client",_rsig:"ping(msg)"});Object(i.assert)(await k("ping",w)=="pong")}_create_message(c,w,k,x){if(w){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}if(this._object_store.message_cache||(this._object_store.message_cache={}),!k&&this._object_store.message_cache[c])throw new Error(`Message with the same key (${c}) already exists in the cache store, please use overwrite=true or remove it first.`);this._object_store.message_cache[c]=[]}_append_message(c,w,k,x){if(k){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}const E=this._object_store.message_cache;if(!E[c])throw new Error(`Message with key ${c} does not exists.`);Object(i.assert)(w instanceof f),E[c].push(w)}_remove_message(c,w){const k=this._object_store.message_cache;if(!k[c])throw new Error(`Message with key ${c} does not exists.`);delete k[c]}_process_message(c,w,k){if(w){if(!this._object_store[c])throw new Error(`session does not exist anymore: ${c}`);this._object_store[c].timer.reset()}const x=this._object_store.message_cache;if(Object(i.assert)(!!k,"Context is required"),!x[c])throw new Error(`Message with key ${c} does not exists.`);x[c]=a(x[c]),console.debug(`Processing message ${c} (size=${x[c].length})`);let E=Object(s.decodeMulti)(x[c]);const{done:O,value:A}=E.next(),T=A;if(Object.assign(T,{from:k.from,to:k.to,user:k.user}),T.ctx=JSON.parse(JSON.stringify(T)),Object.assign(T.ctx,this.default_context),!O){let j=E.next();Object.assign(T,j.value)}this._fire(T.type,T),delete x[c]}_on_message(c){try{Object(i.assert)(c instanceof ArrayBuffer);let w=Object(s.decodeMulti)(c);const{done:k,value:x}=w.next(),E=x;if(E.ctx=JSON.parse(JSON.stringify(E)),Object.assign(E.ctx,this.default_context),!k){let O=w.next();Object.assign(E,O.value)}this._fire(E.type,E)}catch{console.error(e)}}reset(){this._event_handlers={},this._services={}}async disconnect(){this._get_connection_info_task&&(clearTimeout(this._get_connection_info_task),this._get_connection_info_task=null),this._fire("disconnect")}async get_manager_service(c){this.manager_id&&!this._manager_service&&(this._manager_service=await this.get_remote_service(`${this.manager_id}:default`,c))}get_all_local_services(){return this._services}get_local_service(c,w){Object(i.assert)(c);const[k,x]=w.to.split("/");Object(i.assert)(x===this._client_id,"Services can only be accessed locally");const E=this._services[c];if(!E)throw new Error("Service not found: "+c);if(E.config.visibility=="public"||w.from.startsWith(k+"/"))return E;throw new Error("Permission denied for service: "+c)}async get_remote_service(c,w){w=w===void 0?this._method_timeout:w,!c&&this.manager_id?c=this.manager_id:c.includes(":")||(c=this._client_id+":"+c);const k=c.split(":")[0];Object(i.assert)(k);try{const x=this._generate_remote_method({_rtarget:k,_rmethod:"services.built-in.get_service",_rpromise:!0,_rdoc:"Get a remote service",_rsig:"get_service(service_id)"}),E=await Object(i.waitFor)(x(c.split(":")[1]),w,"Timeout Error: Failed to get remote service: "+c);return E.id=c,E}catch(x){throw console.error("Failed to get remote service: "+c,x),x}}_annotate_service_methods(c,w,k,x,E){if(typeof c=="function"){let O=w.split(".")[1];this._method_annotations.set(c,{require_context:Array.isArray(k)?k.includes(O):!!k,run_in_executor:x,method_id:"services."+w,visibility:E})}else if(c instanceof Array||c instanceof Object)for(let O of Object.keys(c)){let A=c[O];if(typeof A=="function"&&A.__rpc_object__){let T=A.__rpc_object__._rtarget;if(T.includes("/")&&(T=T.split("/")[1]),this._client_id===T)c instanceof Array&&(c=c.slice()),c[O]=_(this._object_store,A.__rpc_object__._rmethod),A=c[O];else throw new Error(`Local method not found: ${A.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${T}`)}this._annotate_service_methods(A,w+"."+O,k,x,E)}}add_service(c,w){if(!c||Array.isArray(c))throw new Error("Invalid service object");if(c.constructor===Object)c=Object.assign({},c);else{const O={},A=Object.getOwnPropertyNames(c).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(c)));for(let T of A)T!=="constructor"&&(typeof c[T]=="function"?O[T]=c[T].bind(c):O[T]=c[T]);c.id=c.id||"default",c=O}Object(i.assert)(c.id&&typeof c.id=="string",`Service id not found: ${c}`),c.name||(c.name=c.id),c.config||(c.config={}),c.type||(c.type="generic");let k=!1,x=!1;c.config.require_context&&(k=c.config.require_context),c.config.run_in_executor&&(x=!0);const E=c.config.visibility||"protected";if(Object(i.assert)(["protected","public"].includes(E)),this._annotate_service_methods(c,c.id,k,x,E),this._services[c.id])if(w)delete this._services[c.id];else throw new Error(`Service already exists: ${c.id}, please specify a different id (not ${c.id}) or overwrite=true`);return this._services[c.id]=c,c}async register_service(c,w,k,x){if(k===void 0&&(k=!0),x){const[O,A]=x.to.split("/");Object(i.assert)(A===this._client_id),Object(i.assert)(O===x.from.split("/")[0],"Services can only be registered from the same workspace")}const E=this.add_service(c,w);return k&&(this._fire("service-updated",{service_id:E.id,api:E,type:"add"}),await this._notify_service_update()),{id:`${this._client_id}:${E.id}`,type:E.type,name:E.name,description:E.description||"",config:E.config}}async unregister_service(c,w){if(c instanceof Object&&(c=c.id),!this._services[c])throw new Error(`Service not found: ${c}`);const k=this._services[c];delete this._services[c],this._fire("service-updated",{service_id:c,api:k,type:"remove"}),await this._notify_service_update()}_ndarray(c,w,k){const x=Object(i.typedArrayToDtype)(c);if(k&&k!==x)throw"dtype doesn't match the type of the array: "+x+" != "+k;return w=w||[c.length],{_rtype:"ndarray",_rvalue:c.buffer,_rshape:w,_rdtype:x}}_encode_callback(c,w,k,x,E,O){let A=`${k}.${c}`,T={_rtype:"method",_rtarget:O?`${O}/${this._client_id}`:this._client_id,_rmethod:A,_rpromise:!1};const j=this;return[T,function(){try{w.apply(null,Array.prototype.slice.call(arguments))}catch(D){console.error("Error in callback:",A,D)}finally{x&&j._object_store[k]&&delete j._object_store[k],E&&E.started&&E.clear()}}]}async _encode_promise(c,w,k,x,E,O){let A=this._get_session_store(k,!0);Object(i.assert)(A,`Failed to create session store ${k} due to invalid parent`);let T={};return E&&w&&this._method_timeout?(T.heartbeat=await this._encode(E.reset.bind(E),k,O),T.interval=this._method_timeout/2,A.timer=E):E=null,[T.resolve,A.resolve]=this._encode_callback("resolve",c,k,x,E,O),[T.reject,A.reject]=this._encode_callback("reject",w,k,x,E,O),T}async _send_chunks(c,w,k){let x=await this.get_remote_service(`${w}:built-in`);Object(i.assert)(x.message_cache,"Remote client does not support message caching for long message.");let E=x.message_cache,O=k||Object(i.randId)();await E.create(O,!!k);let A=c.length,T=Math.ceil(A/l);for(let j=0;j<T;j++){let I=j*l;await E.append(O,c.slice(I,I+l),!!k)}await E.process(O,!!k)}_generate_remote_method(c,w,k,x,E){let O=c._rtarget;x&&!O.includes("/")&&(O=x+"/"+O,c._rtarget=O);let A=c._rmethod,T=c._rpromise;const j=this;function I(){return new Promise(async($,N)=>{let M=Object(i.randId)();k&&(M=k+"."+M);let W=j._get_session_store(M,!0);if(!W){N(new Error(`Runtime Error: Failed to get session store ${M}`));return}W.target_id=O;const F=await j._encode(Array.prototype.slice.call(arguments),M,E),H=F.length,q=H>0&&typeof F[H-1]=="object"&&F[H-1]!==null&&F[H-1]._rkwargs;q&&delete F[H-1]._rkwargs;let Y={type:"method",from:j._local_workspace?j._local_workspace+"/"+j._client_id:j._client_id,to:O,method:A},X={};F&&(X.args=F),q&&(X.with_kwargs=q),w&&(Y.parent=w);let J=null;if(T){Y.session=M;let de=`${O}:${A}`;J=new m(j._method_timeout,N,[`Method call time out: ${de}`],de),X.promise=await j._encode_promise($,N,M,!0,J,E)}let te=Object(s.encode)(Y);if(X){const de=Object(s.encode)(X);te=new Uint8Array([...te,...de])}te.length<=l+1024?j._emit_message(te).then(function(){J&&J.start()}):j._send_chunks(te,O,w).then(function(){J&&J.start()})})}I.__rpc_object__=c;const D=A.split(".");return I.__name__=D[D.length-1],I.__doc__=c._rdoc,I.__sig__=c._rsig,I}async _notify_service_update(){if(this.manager_id)try{await this.get_manager_service(30),Object(i.assert)(this._manager_service),await this._manager_service.update_client_info(this.get_client_info())}catch(c){console.warn("Failed to notify service update to",this.manager_id,c)}}get_client_info(){const c=[];for(let w of Object.values(this._services))c.push({id:`${this._client_id}:${w.id}`,type:w.type,name:w.name,description:w.description||"",config:w.config});return{id:this._client_id,services:c}}async _handle_method(c){let w=null;try{Object(i.assert)(c.method&&c.ctx&&c.from);const k=c.from+":"+c.method,x=c.from.split("/")[0];c.to=c.to.includes("/")?c.to:x+"/"+c.to,c.ctx.to=c.to;const E=c.to.split("/")[0],O=c.parent;let A,T;if(c.promise){const D=await this._decode(c.promise,c.session,O,x,E);if(A=D.resolve,T=D.reject,D.heartbeat&&D.interval){async function $(){try{await D.heartbeat()}catch(N){console.error(N)}}w=setInterval($,D.interval*1e3)}}let j;try{j=_(this._object_store,c.method)}catch(D){throw console.debug("Failed to find method",k,D),new Error(`Method not found: ${k}`)}if(Object(i.assert)(j&&typeof j=="function","Invalid method: "+k),this._method_annotations.has(j)){if(this._method_annotations.get(j).visibility==="protected"&&E!==x)throw new Error("Permission denied for protected method "+k+", workspace mismatch: "+E+" != "+x)}else{let D=this._object_store[c.method.split(".")[0]].target_id;if(E===x&&D&&D.indexOf("/")===-1&&(D=E+"/"+D),D!==c.from)throw new Error("Access denied for method call ("+k+") from "+c.from)}O&&Object(i.assert)(this._get_session_store(O,!0)!==null,"Parent session was closed: "+O);let I;if(c.args?I=await this._decode(c.args,c.session,null,x,null):I=[],this._method_annotations.has(j)&&this._method_annotations.get(j).require_context&&I.push(c.ctx),c.promise){const D=j.apply(null,I);D instanceof Promise?D.then($=>{A($),clearInterval(w)}).catch($=>{T($),clearInterval(w)}):(A(D),clearInterval(w))}else j.apply(null,I),clearInterval(w)}catch(k){console.error("Error during calling method: ",k),clearInterval(w)}}encode(c,w){return this._encode(c,w)}_get_session_store(c,w){let k=this._object_store;const x=c.split(".");if(w){const E=x.length-1;for(let O of x.slice(0,E)){if(!k[O])return null;k=k[O]}return k[x[E]]||(k[x[E]]={}),k[x[E]]}else{for(let E of x){if(!k[E])return null;k=k[E]}return k}}async _encode(c,w,k){const x=typeof c;if(x==="number"||x==="string"||x==="boolean"||c===null||c===void 0||c instanceof Uint8Array)return c;if(c instanceof ArrayBuffer)return{_rtype:"memoryview",_rvalue:new Uint8Array(c)};if(c.__rpc_object__)return c.__rpc_object__;let E;if(c.constructor instanceof Object&&c._rtype){const A=c._rtype;return delete c._rtype,E=await this._encode(c,w,k),E._rtype=A,E}if(typeof c=="function"){if(this._method_annotations.has(c)){let A=this._method_annotations.get(c);E={_rtype:"method",_rtarget:this._client_id,_rmethod:A.method_id,_rpromise:!0}}else{Object(i.assert)(typeof w=="string");let A;c.__name__?A=`${Object(i.randId)()}-${c.__name__}`:A=Object(i.randId)(),E={_rtype:"method",_rtarget:this._client_id,_rmethod:`${w}.${A}`,_rpromise:!0};let T=this._get_session_store(w,!0);Object(i.assert)(T!==null,`Failed to create session store ${w} due to invalid parent`),T[A]=c}if(E._rdoc=c.__doc__,E._rsig=c.__sig__,!E._rdoc||!E._rsig)try{const A=g(c);A&&!E._rdoc&&(E._rdoc=`${A.doc}`),A&&!E._rsig&&(E._rsig=`${A.name}(${A.sig})`)}catch{console.error("Failed to extract function docstring:",c)}return E}const O=Array.isArray(c);for(let A of Object.keys(this._codecs)){const T=this._codecs[A];if(T.encoder&&c instanceof T.type){let j=await Promise.resolve(T.encoder(c));if(j&&!j._rtype&&(j._rtype=T.name),typeof j=="object"){const I=j._rtype;delete j._rtype,j=await this._encode(j,w,k),j._rtype=I}return E=j,E}}if(typeof tf<"u"&&tf.Tensor&&c instanceof tf.Tensor){const A=c.dataSync();E={_rtype:"ndarray",_rvalue:new Uint8Array(A.buffer),_rshape:c.shape,_rdtype:c.dtype}}else if(typeof nj<"u"&&nj.NdArray&&c instanceof nj.NdArray){const A=Object(i.typedArrayToDtype)(c.selection.data);E={_rtype:"ndarray",_rvalue:new Uint8Array(c.selection.data.buffer),_rshape:c.shape,_rdtype:A}}else if(c instanceof Error)console.error(c),E={_rtype:"error",_rvalue:c.toString()};else if(c!==Object(c)||c instanceof Boolean||c instanceof String||c instanceof Date||c instanceof RegExp||c instanceof ImageData||typeof FileList<"u"&&c instanceof FileList||typeof FileSystemDirectoryHandle<"u"&&c instanceof FileSystemDirectoryHandle||typeof FileSystemFileHandle<"u"&&c instanceof FileSystemFileHandle||typeof FileSystemHandle<"u"&&c instanceof FileSystemHandle||typeof FileSystemWritableFileStream<"u"&&c instanceof FileSystemWritableFileStream)E=c;else if(c instanceof Blob){let A=function(I){T=I},T=0;async function j(I){let D;I?D=c.slice(T,T+I):D=c.slice(T);const $=new Uint8Array(await D.arrayBuffer());return T=T+$.byteLength,$}E={_rtype:"iostream",_rnative:"js:blob",type:c.type,name:c.name,size:c.size,path:c._path||c.webkitRelativePath,read:await this._encode(j,w,k),seek:await this._encode(A,w,k)}}else if(c instanceof f){const A=Object(i.typedArrayToDtype)(c);E={_rtype:"typedarray",_rvalue:new Uint8Array(c.buffer),_rdtype:A}}else if(c instanceof DataView)E={_rtype:"memoryview",_rvalue:new Uint8Array(c.buffer)};else if(c instanceof Set)E={_rtype:"set",_rvalue:await this._encode(Array.from(c),w,k)};else if(c instanceof Map)E={_rtype:"orderedmap",_rvalue:await this._encode(Array.from(c),w,k)};else if(c.constructor instanceof Object||Array.isArray(c)){E=O?[]:{};const A=Object.keys(c);for(let T of A)E[T]=await this._encode(c[T],w,k)}else throw`imjoy-rpc: Unsupported data type: ${c}, you can register a custom codec to encode/decode the object.`;if(!E)throw new Error("Failed to encode object");return E}async decode(c){return await this._decode(c)}async _decode(c,w,k,x,E){if(!c)return c;let O;if(c._rtype)if(this._codecs[c._rtype]&&this._codecs[c._rtype].decoder){const A=c._rtype;delete c._rtype,c=await this._decode(c,w,k,x,E),c._rtype=A,O=await Promise.resolve(this._codecs[c._rtype].decoder(c))}else if(c._rtype==="method")O=this._generate_remote_method(c,w,k,x,E);else if(c._rtype==="ndarray")if(typeof nj<"u"&&nj.array)Array.isArray(c._rvalue)&&(c._rvalue=c._rvalue.reduce(u)),O=nj.array(new Uint8(c._rvalue),c._rdtype).reshape(c._rshape);else if(typeof tf<"u"&&tf.Tensor){Array.isArray(c._rvalue)&&(c._rvalue=c._rvalue.reduce(u));const A=i.dtypeToTypedArray[c._rdtype];O=tf.tensor(new A(c._rvalue),c._rshape,c._rdtype)}else O=c;else if(c._rtype==="error")O=new Error(c._rvalue);else if(c._rtype==="typedarray"){const A=i.dtypeToTypedArray[c._rdtype];if(!A)throw new Error("unsupported dtype: "+c._rdtype);const T=c._rvalue.buffer.slice(c._rvalue.byteOffset,c._rvalue.byteOffset+c._rvalue.byteLength);O=new A(T)}else if(c._rtype==="memoryview")O=c._rvalue.buffer.slice(c._rvalue.byteOffset,c._rvalue.byteOffset+c._rvalue.byteLength);else if(c._rtype==="iostream"){if(c._rnative==="js:blob"){const T=await(await this._generate_remote_method(c.read,w,k,x,E))();O=new Blob([T],{type:c.type,name:c.name})}else{O={};for(let A of Object.keys(c))A.startsWith("_")||(O[A]=await this._decode(c[A],w,k,x,E))}O.__rpc_object__=c}else if(c._rtype==="orderedmap")O=new Map(await this._decode(c._rvalue,w,k,x,E));else if(c._rtype==="set")O=new Set(await this._decode(c._rvalue,w,k,x,E));else{const A=c._rtype;delete c._rtype,O=await this._decode(c,w,k,x,E),O._rtype=A}else if(c.constructor===Object||Array.isArray(c)){const A=Array.isArray(c);O=A?[]:{};for(let T of Object.keys(c))if(A||c.hasOwnProperty(T)){const j=c[T];O[T]=await this._decode(j,w,k,x,E)}}else O=c;if(O===void 0)throw new Error("Failed to decode object");return O}}},"./src/hypha/sse-client.js":function(n,t,r){r.r(t),r.d(t,"login",function(){return g}),r.d(t,"connectToServer",function(){return a});var i=r("./src/hypha/rpc.js");r.d(t,"RPC",function(){return i.RPC}),r.d(t,"API_VERSION",function(){return i.API_VERSION});var s=r("./src/hypha/utils.js");r.d(t,"loadRequirements",function(){return s.loadRequirements});var o=r("./src/hypha/webrtc-client.js");r.d(t,"getRTCService",function(){return o.getRTCService}),r.d(t,"registerRTCService",function(){return o.registerRTCService});var l=r("./package.json");r.d(t,"VERSION",function(){return l.version});function f(m,b="application/octet-stream"){return fetch(`data:${b};base64,${m}`).then(v=>v.arrayBuffer())}class u{constructor(b,v,c,w,k=120){Object(s.assert)(b&&v,"server_url and client_id are required"),b=b+"?client_id="+v,c&&(b+="&workspace="+c),w&&(b+="&token="+w),b+="&session_id="+Object(s.randId)(),this._events=null,this._handle_message=null,this._reconnection_token=null,this._server_url=b,this._timeout=k*1e3,this._opening=!1,this._retry_count=0,this._closing=!1}set_reconnection_token(b){this._reconnection_token=b}on_message(b){Object(s.assert)(b,"handler is required"),this._handle_message=b}open(){return this._opening?this._opening:(this._opening=new Promise((b,v)=>{const c=this._reconnection_token?`${this._server_url}&reconnection_token=${this._reconnection_token}`:this._server_url;console.info("Creating a new connection to ",c.split("?")[0]),this._events=new EventSource(c),this._events.onmessage=async w=>{const k=await f(w.data);this._handle_message(k)},this._events.onclose=w=>{console.log("eventsource closed"),this._closing||(console.log("Connection interrupted, retrying..."),this._retry_count++,setTimeout(()=>this.open(),this._timeout)),this._events=null,this._opening=!1,v("closed")},this._events.onerror=w=>{console.trace(),console.log("Error occurred in eventsource connection: ",w.message);debugger;v(w.toString())},this._events.onopen=w=>{b(!0)}}),this._opening)}async _send(b){await fetch(this._server_url,{method:"POST",mode:"cors",cache:"no-cache",credentials:"same-origin",headers:{"Content-Type":"octet-stream"},redirect:"follow",referrerPolicy:"no-referrer",body:b})}async emit_message(b){Object(s.assert)(this._handle_message,"No handler for message"),(!this._events||this._events.readyState===EventSource.CLOSED)&&await this.open(),await this._send(b)}disconnect(b){this._closing=!0;const v=this._events;this._events=null,v&&v.readyState===EventSource.OPEN&&v.close(),console.info(`EventSource connection disconnected (${b})`)}}function _(m){if(!m)throw new Error("server_url is required");return m=m.replace(/\/$/,"")+"/sse",m}async function g(m){const b=m.login_service_id||"public/*:hypha-login",v=m.login_timeout||120,c=m.login_callback,w=await a({name:"initial login client",server_url:m.server_url,method_timeout:v});try{const k=await w.get_service(b),x=await k.start();return c?await c(x):console.log(`Please open your browser and login at ${x.login_url}`),await k.check(x.key,v)}catch(k){throw k}finally{await w.disconnect()}}async function a(m){let b=m.client_id;b||(b=Object(s.randId)());let v=_(m.server_url),c=new u(v,b,m.workspace,m.token,m.method_timeout||120);await c.open();const w=new i.RPC(c,{client_id:b,manager_id:"workspace-manager",default_context:{connection_type:"eventsource"},name:m.name,method_timeout:m.method_timeout}),k=await w.get_remote_service("workspace-manager:default",m.method_timeout);k.rpc=w;async function x(A){A.id="default",A.name=m.name||A.id,await w.register_service(A,!0)}async function E(A){return await k.get_service(A+":default")}async function O(){await w.disconnect(),await c.disconnect()}if(k.export=x,k.getPlugin=E,k.listPlugins=k.listServices,k.disconnect=O,k.registerCodec=w.register_codec.bind(w),m.webrtc&&await Object(o.registerRTCService)(k,b+"-rtc",m.webrtc_config),k.get_service||k.getService){const A=k.get_service||k.getService;k.get_service=async function(T,j,I){Object(s.assert)([void 0,!0,!1,"auto"].includes(j),"webrtc must be true, false or 'auto'");const D=await A(T);if(j===!0||j==="auto"){if(D.id.includes(":")&&D.id.includes("/")){const $=D.id.split(":")[0];try{const N=await Object(o.getRTCService)(k,$+":"+$.split("/")[1]+"-rtc",I),M=await N.get_service(D.id.split(":")[1]);return M._webrtc=!0,M._peer=N,M._service=D,M}catch(N){console.warn("Failed to get webrtc service, using eventsource connection",N)}}if(j===!0)throw new Error("Failed to get the service via webrtc")}return D},k.getService=k.get_service}return k}},"./src/hypha/utils.js":function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"randId",function(){return randId}),__webpack_require__.d(__webpack_exports__,"dtypeToTypedArray",function(){return dtypeToTypedArray}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWindow",function(){return loadRequirementsInWindow}),__webpack_require__.d(__webpack_exports__,"loadRequirementsInWebworker",function(){return loadRequirementsInWebworker}),__webpack_require__.d(__webpack_exports__,"loadRequirements",function(){return loadRequirements}),__webpack_require__.d(__webpack_exports__,"normalizeConfig",function(){return normalizeConfig}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtypeMapping",function(){return typedArrayToDtypeMapping}),__webpack_require__.d(__webpack_exports__,"typedArrayToDtype",function(){return typedArrayToDtype}),__webpack_require__.d(__webpack_exports__,"cacheRequirements",function(){return cacheRequirements}),__webpack_require__.d(__webpack_exports__,"setupServiceWorker",function(){return setupServiceWorker}),__webpack_require__.d(__webpack_exports__,"assert",function(){return assert}),__webpack_require__.d(__webpack_exports__,"urlJoin",function(){return urlJoin}),__webpack_require__.d(__webpack_exports__,"waitFor",function(){return waitFor}),__webpack_require__.d(__webpack_exports__,"MessageEmitter",function(){return MessageEmitter});function randId(){return Math.random().toString(36).substr(2,10)+new Date().getTime()}const dtypeToTypedArray={int8:Int8Array,int16:Int16Array,int32:Int32Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,float32:Float32Array,float64:Float64Array,array:Array};async function loadRequirementsInWindow(n){function t(o){return new Promise((l,f)=>{var u=document.createElement("script");u.src=o,u.type="text/javascript",u.onload=l,u.onreadystatechange=function(){(this.readyState==="loaded"||this.readyState==="complete")&&l()},u.onerror=f,document.head.appendChild(u)})}async function r(){for(var o=Array.prototype.slice.call(arguments),l=o.length,f=0;f<l;f++)await t(o[f])}if(n&&(Array.isArray(n)||typeof n=="string"))try{var i;if(n=typeof n=="string"?[n]:n,Array.isArray(n))for(var s=0;s<n.length;s++)n[s].toLowerCase().endsWith(".css")||n[s].startsWith("css:")?(n[s].startsWith("css:")&&(n[s]=n[s].slice(4)),i=document.createElement("link"),i.rel="stylesheet",i.href=n[s],document.head.appendChild(i)):n[s].toLowerCase().endsWith(".mjs")||n[s].startsWith("mjs:")?(n[s].startsWith("mjs:")&&(n[s]=n[s].slice(4)),await __vitePreload(()=>import(n[s]),__vite__mapDeps([]))):n[s].toLowerCase().endsWith(".js")||n[s].startsWith("js:")?(n[s].startsWith("js:")&&(n[s]=n[s].slice(3)),await r(n[s])):n[s].startsWith("http")?await r(n[s]):n[s].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[s]);else throw"unsupported requirements definition"}catch{throw"failed to import required scripts: "+n.toString()}}async function loadRequirementsInWebworker(n){if(n&&(Array.isArray(n)||typeof n=="string"))try{Array.isArray(n)||(n=[n]);for(var t=0;t<n.length;t++){if(n[t].toLowerCase().endsWith(".css")||n[t].startsWith("css:"))throw"unable to import css in a webworker";n[t].toLowerCase().endsWith(".js")||n[t].startsWith("js:")?(n[t].startsWith("js:")&&(n[t]=n[t].slice(3)),importScripts(n[t])):n[t].startsWith("http")?importScripts(n[t]):n[t].startsWith("cache:")||console.log("Unprocessed requirements url: "+n[t])}}catch{throw"failed to import required scripts: "+n.toString()}}function loadRequirements(n){return typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope?loadRequirementsInWebworker(n):loadRequirementsInWindow(n)}function normalizeConfig(n){return n.version=n.version||"0.1.0",n.description=n.description||`[TODO: add description for ${n.name} ]`,n.type=n.type||"rpc-window",n.id=n.id||randId(),n.target_origin=n.target_origin||"*",n.allow_execution=n.allow_execution||!1,n=Object.keys(n).reduce((t,r)=>(typeof n[r]!="function"&&(t[r]=n[r]),t),{}),n}const typedArrayToDtypeMapping={Int8Array:"int8",Int16Array:"int16",Int32Array:"int32",Uint8Array:"uint8",Uint16Array:"uint16",Uint32Array:"uint32",Float32Array:"float32",Float64Array:"float64",Array:"array"},typedArrayToDtypeKeys=[];for(const arrType of Object.keys(typedArrayToDtypeMapping))typedArrayToDtypeKeys.push(eval(arrType));function typedArrayToDtype(n){let t=typedArrayToDtypeMapping[n.constructor.name];if(!t){const r=Object.getPrototypeOf(n);for(const i of typedArrayToDtypeKeys)if(r instanceof i){t=typedArrayToDtypeMapping[i.name];break}}return t}function cacheUrlInServiceWorker(n){return new Promise(function(t,r){const i={command:"add",url:n};if(!navigator.serviceWorker||!navigator.serviceWorker.register){r("Service worker is not supported.");return}const s=new MessageChannel;s.port1.onmessage=function(o){o.data&&o.data.error?r(o.data.error):t(o.data&&o.data.result)},navigator.serviceWorker&&navigator.serviceWorker.controller?navigator.serviceWorker.controller.postMessage(i,[s.port2]):r("Service worker controller is not available")})}async function cacheRequirements(n){n=n||[],Array.isArray(n)||(n=[n]);for(let t of n)t.startsWith("js:")&&(t=t.slice(3)),t.startsWith("css:")&&(t=t.slice(4)),t.startsWith("cache:")&&(t=t.slice(6)),t.startsWith("http")&&await cacheUrlInServiceWorker(t).catch(r=>{console.error(r)})}function setupServiceWorker(n,t,r){if("serviceWorker"in navigator){if(n=n||"/",navigator.serviceWorker.register(n+"plugin-service-worker.js").then(function(i){console.log("ServiceWorker registration successful with scope: ",i.scope)},function(i){console.log("ServiceWorker registration failed: ",i)}),t=t||"*",r=r||cacheRequirements,r&&typeof r!="function")throw new Error("config.cache_requirements must be a function");window.addEventListener("message",function(i){if(t==="*"||i.origin===t){const s=i.data;s.type==="cacheRequirements"&&r(s.requirements)}})}}function assert(n,t){if(!n)throw new Error(t||"Assertion failed")}function urlJoin(...n){return n.join("/").replace(/[\/]+/g,"/").replace(/^(.+):\//,"$1://").replace(/^file:/,"file:/").replace(/\/(\?|&|#[^!])/g,"$1").replace(/\?/g,"&").replace("&","?")}function waitFor(n,t,r){let i;return Promise.race([n,new Promise((s,o)=>i=setTimeout(()=>{o(r||"Timeout Error")},t*1e3))]).finally(()=>clearTimeout(i))}class MessageEmitter{constructor(t){this._event_handlers={},this._once_handlers={},this._debug=t}emit(){throw new Error("emit is not implemented")}on(t,r){this._event_handlers[t]||(this._event_handlers[t]=[]),this._event_handlers[t].push(r)}once(t,r){r.___event_run_once=!0,this.on(t,r)}off(t,r){if(!t&&!r)this._event_handlers={};else if(t&&!r)this._event_handlers[t]&&(this._event_handlers[t]=[]);else if(this._event_handlers[t]){const i=this._event_handlers[t].indexOf(r);i>=0&&this._event_handlers[t].splice(i,1)}}_fire(t,r){if(this._event_handlers[t])for(var i=this._event_handlers[t].length;i--;){const s=this._event_handlers[t][i];try{s(r)}catch(o){console.error(o)}finally{s.___event_run_once&&this._event_handlers[t].splice(i,1)}}else this._debug&&console.warn("unhandled event",t,r)}}},"./src/hypha/webrtc-client.js":function(n,t,r){r.r(t),r.d(t,"getRTCService",function(){return u}),r.d(t,"registerRTCService",function(){return _});var i=r("./src/hypha/rpc.js"),s=r("./src/hypha/utils.js");class o{constructor(a){this._data_channel=a,this._handle_message=null,this._reconnection_token=null,this._data_channel.onmessage=async b=>{let v=b.data;v instanceof Blob&&(v=await v.arrayBuffer()),this._handle_message(v)};const m=this;this._data_channel.onclose=function(){console.log("websocket closed"),m._data_channel=null}}set_reconnection_token(a){this._reconnection_token=a}on_message(a){Object(s.assert)(a,"handler is required"),this._handle_message=a}async emit_message(a){Object(s.assert)(this._handle_message,"No handler for message");try{this._data_channel.send(a)}catch(m){throw console.error(`Failed to send data, error: ${m}`),m}}async disconnect(a){this._data_channel=null,console.info(`data channel connection disconnected (${a})`)}}async function l(g){Object(s.assert)(g.channel,"No channel provided"),Object(s.assert)(g.workspace,"No workspace provided");const a=g.channel,m=g.client_id||Object(s.randId)(),b=new o(a);return g.context=g.context||{},g.context.connection_type="webrtc",new i.RPC(b,{client_id:m,manager_id:null,default_context:g.context,name:g.name,method_timeout:g.method_timeout||10,workspace:g.workspace})}async function f(g,a,m,b,v){m=m||{};let c=new RTCSessionDescription({sdp:g.sdp,type:g.type}),w=new RTCPeerConnection({iceServers:m.ice_servers||[{urls:["stun:stun.l.google.com:19302"]}],sdpSemantics:"unified-plan"});a&&w.addEventListener("datachannel",async x=>{const E=x.channel;let O=null;v&&v.user&&(O={user:v.user});const A=await l({channel:E,client_id:E.label,workspace:a.config.workspace,context:O});A._services=a.rpc._services}),b&&await b(w),await w.setRemoteDescription(c);let k=await w.createAnswer();return await w.setLocalDescription(k),{sdp:w.localDescription.sdp,type:w.localDescription.type,workspace:a.config.workspace}}async function u(g,a,m){m=m||{},m.peer_id=m.peer_id||Object(s.randId)();const b=new RTCPeerConnection({iceServers:m.ice_servers||[{urls:["stun:stun.l.google.com:19302"]}],sdpSemantics:"unified-plan"});return new Promise(async(v,c)=>{try{b.addEventListener("connectionstatechange",()=>{b.connectionState==="failed"&&(b.close(),c(new Error("Connection failed")))},!1),m.on_init&&(await m.on_init(b),delete m.on_init);let w=b.createDataChannel(m.peer_id,{ordered:!0});w.binaryType="arraybuffer";const k=await b.createOffer();await b.setLocalDescription(k);const E=await(await g.getService(a)).offer({sdp:b.localDescription.sdp,type:b.localDescription.type});w.onopen=()=>{m.channel=w,m.workspace=E.workspace,setTimeout(async()=>{const O=await l(m);b.rpc=O;async function A(j){return await O.get_remote_service(m.peer_id+":"+j)}async function T(){await O.disconnect(),b.close()}b.get_service=A,b.getService=A,b.disconnect=T,b.register_codec=O.register_codec,b.registerCodec=O.register_codec,v(b)},500)},w.onclose=()=>c(new Error("Data channel closed")),await b.setRemoteDescription(new RTCSessionDescription({sdp:E.sdp,type:E.type}))}catch(w){c(w)}})}async function _(g,a,m){m=m||{visibility:"protected",require_context:!0};const b=m.on_init;delete m.on_init,await g.registerService({id:a,config:m,offer:(v,c)=>f(v,g,m,b,c)})}}})})})(hyphaRpcSse);var hyphaRpcSseExports=hyphaRpcSse.exports,imjoyRpc={imjoyRPC:imjoyRpcExports,imjoyRPCSocketIO:imjoyRpcSocketioExports,hyphaRPC:hyphaRpcExports,hyphaWebsocketClient:hyphaRpcWebsocketExports,hyphaSSEClient:hyphaRpcSseExports};class TritonExecutor{constructor(t){this.serverUrl=t}async init(){const t=await imjoyRpc.hyphaWebsocketClient.connectToServer({server_url:this.serverUrl,method_timeout:30,name:"client"});this.triton=await t.get_service("triton-client")}async loadModelConfig(t){const r=`${this.serverUrl}/triton/v2/models/${t}/config`;return await fetch(r).then(s=>s.json())}async loadModelRdf(t){let r;try{r=await this.execute(t,void 0,!0)}catch(s){throw alert("Failed to load the model, see console for details."),this.setInfoPanel("Failed to load the model.",!1,!0),s}return r.result.rdf}async execute(t,r=null,i=!1,s=null){return await this.triton.execute({_rkwargs:!0,inputs:[{model_id:t,inputs:r,return_rdf:i,weight_format:s}],model_name:"bioengine-model-runner",serialization:"imjoy"})}}class ModelRunner{constructor(t="https://ai.imjoy.io"){this.tritonExecutor=new TritonExecutor(t),this.rdf=null,this.modelTritonConfig=null,this.inputEndianness=null,this.modelId=null}async init(){await this.tritonExecutor.init()}fixedTileSize(){if(this.rdf&&this.modelTritonConfig){const t=this.rdf.inputs[0],r=this.modelTritonConfig.input[0].dims;return r!==void 0&&!r.includes(-1)?r:t.shape instanceof Array?t.shape:!1}else return!1}getInputMinShape(){const t=this.rdf.inputs[0].axes;let r;const i=this.fixedTileSize();return i===!1?r=this.rdf.inputs[0].shape.min:r=i,t.split("").reduce((o,l,f)=>(o[l]=r[f],o),{})}getInputMaxShape(){const t=this.rdf.inputs[0].axes;let r;const i=this.fixedTileSize();return i!==!1?r=i:r=this.rdf.inputs[0].shape.min.map(()=>{}),t.split("").reduce((s,o,l)=>(s[o]=r[l],s),{})}getDefaultTileSizes(){const t=this.getInputMinShape(),r=Object.assign({},t),i=this.rdf.inputs[0].axes,s=this.fixedTileSize();return s===!1?(r.x=4*t.x,r.y=4*t.y):i.split("").map((o,l)=>{r[o]=s[l]}),r}getDefaultTileOverlaps(){const t=this.rdf.inputs[0],r=this.rdf.outputs[0],i=t.axes;let s={};return r.halo&&this.fixedTileSize===!1?i.split("").map((o,l)=>{r.axes.includes(o)&&o!=="z"?s[o]=2*r.halo[l]:s[o]=0}):s=i.split("").reduce((o,l)=>(o[l]=0,o),{}),s}isImg2Img(){const t=this.rdf.outputs[0];return t.axes.includes("x")&&t.axes.includes("y")}async detectInputEndianness(){const t=this.rdf.test_inputs[0];t&&(this.inputEndianness=await getNpyEndianness(t)),console.log("Input endianness: "+this.inputEndianness)}async loadModel(t){this.modelId=t,this.rdf=await this.tritonExecutor.loadModelRdf(t);const r=this.rdf.config.bioimageio.nickname;this.modelTritonConfig=await this.tritonExecutor.loadModelConfig(r),this.detectInputEndianness()}async submitTensor(t){const r=this.inputEndianness==="<",i=tfjsToImJoy(t,r),s=this.modelId,o=await this.tritonExecutor.execute(s,[i]);if(!o.result.success)throw new Error(o.result.error);return o.result.outputs[0]}async runOneTensor(t,r){console.log("Input tile shape: "+t.shape);const[i,s]=r.pad(t);console.log("Padded tile shape: "+i.shape);let o=await this.submitTensor(i);console.log("Output tile shape: "+o._rshape);const l=imjoyToTfjs(o),f=this.rdf.outputs[0].axes.includes("x")&&this.rdf.outputs[0].axes.includes("y");let u=l;return f&&(u=r.crop(l,s)),u}async runTiles(t,r,i,s,o,l=void 0){l||(l=x=>{console.log(x)});let f;const u=this.fixedTileSize();u===!1?f=new ImgPadder(void 0,r.shape.min,r.shape.step,0):f=new ImgPadder(u,void 0,void 0,0);const _=r.axes.split("").map(x=>s[x]),g=r.axes.split("").map(x=>o[x]);console.log("tile size:",_,"overlap:",g);const a=new ImgTiler(t.shape,_,g),m=a.getNTiles();console.log("Number of tiles in each dimension: "+m);const b=a.getTiles();console.log("Number of tiles: "+b.length);const v=[];for(let x=0;x<b.length;x++){l(`Running the model... (${x+1}/${b.length})`);const E=b[x];console.log(E),E.slice(t);const O=await this.runOneTensor(E.data,f),A=new ImgTile(E.starts,E.ends,E.indexes);A.data=O,v.push(A)}const c=i.axes.includes("x")&&i.axes.includes("y");let w;c?w=new TileMerger(t.shape):w=new MeanTileMerger(t.shape);const k=w.mergeTiles(v).data;return console.log("Output image shape after merging: "+k.shape),k}}var browserPonyfill={exports:{}};(function(n,t){var r=typeof self<"u"?self:commonjsGlobal,i=function(){function o(){this.fetch=!1,this.DOMException=r.DOMException}return o.prototype=r,new o}();(function(o){(function(l){var f={searchParams:"URLSearchParams"in o,iterable:"Symbol"in o&&"iterator"in Symbol,blob:"FileReader"in o&&"Blob"in o&&function(){try{return new Blob,!0}catch{return!1}}(),formData:"FormData"in o,arrayBuffer:"ArrayBuffer"in o};function u(F){return F&&DataView.prototype.isPrototypeOf(F)}if(f.arrayBuffer)var _=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],g=ArrayBuffer.isView||function(F){return F&&_.indexOf(Object.prototype.toString.call(F))>-1};function a(F){if(typeof F!="string"&&(F=String(F)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(F))throw new TypeError("Invalid character in header field name");return F.toLowerCase()}function m(F){return typeof F!="string"&&(F=String(F)),F}function b(F){var H={next:function(){var q=F.shift();return{done:q===void 0,value:q}}};return f.iterable&&(H[Symbol.iterator]=function(){return H}),H}function v(F){this.map={},F instanceof v?F.forEach(function(H,q){this.append(q,H)},this):Array.isArray(F)?F.forEach(function(H){this.append(H[0],H[1])},this):F&&Object.getOwnPropertyNames(F).forEach(function(H){this.append(H,F[H])},this)}v.prototype.append=function(F,H){F=a(F),H=m(H);var q=this.map[F];this.map[F]=q?q+", "+H:H},v.prototype.delete=function(F){delete this.map[a(F)]},v.prototype.get=function(F){return F=a(F),this.has(F)?this.map[F]:null},v.prototype.has=function(F){return this.map.hasOwnProperty(a(F))},v.prototype.set=function(F,H){this.map[a(F)]=m(H)},v.prototype.forEach=function(F,H){for(var q in this.map)this.map.hasOwnProperty(q)&&F.call(H,this.map[q],q,this)},v.prototype.keys=function(){var F=[];return this.forEach(function(H,q){F.push(q)}),b(F)},v.prototype.values=function(){var F=[];return this.forEach(function(H){F.push(H)}),b(F)},v.prototype.entries=function(){var F=[];return this.forEach(function(H,q){F.push([q,H])}),b(F)},f.iterable&&(v.prototype[Symbol.iterator]=v.prototype.entries);function c(F){if(F.bodyUsed)return Promise.reject(new TypeError("Already read"));F.bodyUsed=!0}function w(F){return new Promise(function(H,q){F.onload=function(){H(F.result)},F.onerror=function(){q(F.error)}})}function k(F){var H=new FileReader,q=w(H);return H.readAsArrayBuffer(F),q}function x(F){var H=new FileReader,q=w(H);return H.readAsText(F),q}function E(F){for(var H=new Uint8Array(F),q=new Array(H.length),Y=0;Y<H.length;Y++)q[Y]=String.fromCharCode(H[Y]);return q.join("")}function O(F){if(F.slice)return F.slice(0);var H=new Uint8Array(F.byteLength);return H.set(new Uint8Array(F)),H.buffer}function A(){return this.bodyUsed=!1,this._initBody=function(F){this._bodyInit=F,F?typeof F=="string"?this._bodyText=F:f.blob&&Blob.prototype.isPrototypeOf(F)?this._bodyBlob=F:f.formData&&FormData.prototype.isPrototypeOf(F)?this._bodyFormData=F:f.searchParams&&URLSearchParams.prototype.isPrototypeOf(F)?this._bodyText=F.toString():f.arrayBuffer&&f.blob&&u(F)?(this._bodyArrayBuffer=O(F.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):f.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(F)||g(F))?this._bodyArrayBuffer=O(F):this._bodyText=F=Object.prototype.toString.call(F):this._bodyText="",this.headers.get("content-type")||(typeof F=="string"?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):f.searchParams&&URLSearchParams.prototype.isPrototypeOf(F)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},f.blob&&(this.blob=function(){var F=c(this);if(F)return F;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?c(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(k)}),this.text=function(){var F=c(this);if(F)return F;if(this._bodyBlob)return x(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(E(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},f.formData&&(this.formData=function(){return this.text().then(D)}),this.json=function(){return this.text().then(JSON.parse)},this}var T=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function j(F){var H=F.toUpperCase();return T.indexOf(H)>-1?H:F}function I(F,H){H=H||{};var q=H.body;if(F instanceof I){if(F.bodyUsed)throw new TypeError("Already read");this.url=F.url,this.credentials=F.credentials,H.headers||(this.headers=new v(F.headers)),this.method=F.method,this.mode=F.mode,this.signal=F.signal,!q&&F._bodyInit!=null&&(q=F._bodyInit,F.bodyUsed=!0)}else this.url=String(F);if(this.credentials=H.credentials||this.credentials||"same-origin",(H.headers||!this.headers)&&(this.headers=new v(H.headers)),this.method=j(H.method||this.method||"GET"),this.mode=H.mode||this.mode||null,this.signal=H.signal||this.signal,this.referrer=null,(this.method==="GET"||this.method==="HEAD")&&q)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(q)}I.prototype.clone=function(){return new I(this,{body:this._bodyInit})};function D(F){var H=new FormData;return F.trim().split("&").forEach(function(q){if(q){var Y=q.split("="),X=Y.shift().replace(/\+/g," "),J=Y.join("=").replace(/\+/g," ");H.append(decodeURIComponent(X),decodeURIComponent(J))}}),H}function $(F){var H=new v,q=F.replace(/\r?\n[\t ]+/g," ");return q.split(/\r?\n/).forEach(function(Y){var X=Y.split(":"),J=X.shift().trim();if(J){var te=X.join(":").trim();H.append(J,te)}}),H}A.call(I.prototype);function N(F,H){H||(H={}),this.type="default",this.status=H.status===void 0?200:H.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in H?H.statusText:"OK",this.headers=new v(H.headers),this.url=H.url||"",this._initBody(F)}A.call(N.prototype),N.prototype.clone=function(){return new N(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new v(this.headers),url:this.url})},N.error=function(){var F=new N(null,{status:0,statusText:""});return F.type="error",F};var M=[301,302,303,307,308];N.redirect=function(F,H){if(M.indexOf(H)===-1)throw new RangeError("Invalid status code");return new N(null,{status:H,headers:{location:F}})},l.DOMException=o.DOMException;try{new l.DOMException}catch{l.DOMException=function(H,q){this.message=H,this.name=q;var Y=Error(H);this.stack=Y.stack},l.DOMException.prototype=Object.create(Error.prototype),l.DOMException.prototype.constructor=l.DOMException}function W(F,H){return new Promise(function(q,Y){var X=new I(F,H);if(X.signal&&X.signal.aborted)return Y(new l.DOMException("Aborted","AbortError"));var J=new XMLHttpRequest;function te(){J.abort()}J.onload=function(){var ie={status:J.status,statusText:J.statusText,headers:$(J.getAllResponseHeaders()||"")};ie.url="responseURL"in J?J.responseURL:ie.headers.get("X-Request-URL");var de="response"in J?J.response:J.responseText;q(new N(de,ie))},J.onerror=function(){Y(new TypeError("Network request failed"))},J.ontimeout=function(){Y(new TypeError("Network request failed"))},J.onabort=function(){Y(new l.DOMException("Aborted","AbortError"))},J.open(X.method,X.url,!0),X.credentials==="include"?J.withCredentials=!0:X.credentials==="omit"&&(J.withCredentials=!1),"responseType"in J&&f.blob&&(J.responseType="blob"),X.headers.forEach(function(ie,de){J.setRequestHeader(de,ie)}),X.signal&&(X.signal.addEventListener("abort",te),J.onreadystatechange=function(){J.readyState===4&&X.signal.removeEventListener("abort",te)}),J.send(typeof X._bodyInit>"u"?null:X._bodyInit)})}return W.polyfill=!0,o.fetch||(o.fetch=W,o.Headers=v,o.Request=I,o.Response=N),l.Headers=v,l.Request=I,l.Response=N,l.fetch=W,Object.defineProperty(l,"__esModule",{value:!0}),l})({})})(i),i.fetch.ponyfill=!0,delete i.fetch.polyfill;var s=i;t=s.fetch,t.default=s.fetch,t.fetch=s.fetch,t.Headers=s.Headers,t.Request=s.Request,t.Response=s.Response,n.exports=t})(browserPonyfill,browserPonyfill.exports);var browserPonyfillExports=browserPonyfill.exports;const fetch$1=getDefaultExportFromCjs(browserPonyfillExports);class npyjs{constructor(t){t&&console.error(["No arguments accepted to npyjs constructor.","For usage, go to https://github.com/jhuapl-boss/npyjs."].join(" ")),this.dtypes={"<u1":{name:"uint8",size:8,arrayConstructor:Uint8Array},"|u1":{name:"uint8",size:8,arrayConstructor:Uint8Array},"<u2":{name:"uint16",size:16,arrayConstructor:Uint16Array},"|i1":{name:"int8",size:8,arrayConstructor:Int8Array},"<i2":{name:"int16",size:16,arrayConstructor:Int16Array},"<u4":{name:"uint32",size:32,arrayConstructor:Int32Array},"<i4":{name:"int32",size:32,arrayConstructor:Int32Array},"<u8":{name:"uint64",size:64,arrayConstructor:BigUint64Array},"<i8":{name:"int64",size:64,arrayConstructor:BigInt64Array},"<f4":{name:"float32",size:32,arrayConstructor:Float32Array},"<f8":{name:"float64",size:64,arrayConstructor:Float64Array}}}parse(t){const r=new DataView(t.slice(8,10)).getUint8(0),i=10+r,s=new TextDecoder("utf-8").decode(new Uint8Array(t.slice(10,10+r))),o=JSON.parse(s.toLowerCase().replace(/'/g,'"').replace("(","[").replace(/,*\),*/g,"]")),l=o.shape,f=this.dtypes[o.descr],u=new f.arrayConstructor(t,i);return{dtype:f.name,data:u,shape:l,fortranOrder:o.fortran_order}}async load(t,r,i){i=i||{};let s;t instanceof ArrayBuffer?s=t:s=await(await fetch$1(t,{...i})).arrayBuffer();const o=this.parse(s);return r?r(o):o}}class ImagejJsController{constructor(t){this.ij=t}async getImage(){return await this.ij.getImage({format:"ndarray",all:!0})}async viewFromUrl(t,r,i,s="input"){console.log("View image from url: "+t);let o;if(t.endsWith("/content")?o=t.split("/")[t.split("/").length-2]:o=t.split("/")[t.split("/").length-1],o.endsWith(".npy")){let l=new npyjs;const f=await fetch(t).then(v=>v.arrayBuffer()),u=await l.load(f),_=new Uint8Array(u.data.buffer.slice(u.data.byteOffset)),g={_rtype:"ndarray",_rdtype:u.dtype,_rshape:u.shape,_rvalue:_},a=inferImgAxesViaSpec(g._rshape,r.axes),m=imjoyToTfjs(g);if(s==="output"&&!(i.axes.includes("x")&&i.axes.includes("y"))){await this.showTableFromTensor(m,o);return}const b=processForShow(m,a);await this.showImgs(b,o)}else{const l=await fetch(t);if(!l.ok)throw new Error("Failed to load the image.");const f=await l.arrayBuffer();this.ij.viewImage(f,{name:o}).catch(u=>{throw new Error("Failed to view the image.")})}}async showTableFromTensor(t,r){t.arraySync().map(async s=>{await this.showTable(s,"Probability",r)})}async showTable(t,r,i){const s=t.map((l,f)=>f),o=`
Table.create("${i}")
Table.setColumn("Index", newArray(${s.join(",")}))
Table.setColumn("${r}", newArray(${t.join(",")}))
`;this.ij.runMacro(o)}async showImgs(t,r="output"){for(let i=0;i<t.length;i++){const s=t[i];console.log("Output image shape after processing: "+s._rshape);try{await this.ij.viewImage(s,{name:r})}catch{throw new Error("Failed to view the image.")}}}}function rdfHas(n,t){return n[t]!==void 0&&n[t].length>0}const _sfc_main$1={props:{ij:{type:Object,default:null}},data:()=>({waiting:!1,error:!1,info:"",ij:null,api:null,buttonEnabledRun:!1,buttonEnabledInput:!1,buttonEnabledOutput:!1,tileSizes:{x:0,y:0,z:0},tileOverlaps:{x:0,y:0,z:0},runner:null,serverUrl:"https://hypha.bioimage.io"}),computed:{infoColor(){return this.error?"red":"black"},tritonConfig(){return this.runner?this.runner.modelTritonConfig:{}},inputMinShape(){return this.runner?this.runner.getInputMinShape():{}},inputMaxShape(){return this.runner?this.runner.getInputMaxShape():{}},inputSpec(){return this.runner?this.runner.rdf.inputs[0]:{}},outputSpec(){return this.runner?this.runner.rdf.outputs[0]:{}}},watch:{tileSizes:{handler(n,t){t.y!==t.x&&(this.tileSizes.y=t.x),console.log(n,t)},deep:!0},tileOverlaps:{handler(n,t){t.y!==t.x&&(this.tileOverlaps.y=t.x),console.log(n,t)},deep:!0}},mounted(){this.init()},methods:{async init(){this.setInfoPanel("Initializing...",!0),await this.initImJoy();const n=new ModelRunner(this.serverUrl);await n.init(),this.runner=n;const t="10.5281/zenodo.5764892";await this.initModel(t),this.turnButtons(!1),this.$props.ij?this.ij=props.ij:(this.setInfoPanel("Initializing ImageJ.JS ...",!0),await this.initImageJ()),this.viewerControl=new ImagejJsController(this.ij),this.setInfoPanel(""),this.turnButtons(!0)},async initModel(n,t=void 0){this.setInfoPanel(`Initializing model ${n}...`,!0),this.turnButtons(!1),t===void 0&&(t=this.runner),await t.loadModel(n),this.tileSizes=this.runner.getDefaultTileSizes(),this.tileOverlaps=this.runner.getDefaultTileOverlaps(),this.turnButtons(!0),this.setInfoPanel("")},turnButtons(n){this.buttonEnabledRun=n,this.buttonEnabledInput=n&&(rdfHas(this.runner.rdf,"test_inputs")||rdfHas(this.runner.rdf,"sample_inputs")),this.buttonEnabledOutput=n&&(rdfHas(this.runner.rdf,"test_outputs")||rdfHas(this.runner.rdf,"sample_outputs"))},handleModelChange(n){this.initModel(n.id)},async handleServerUrlChange(n){this.serverUrl=n;const t=this.runner.modelId;this.setInfoPanel("Initializing server...",!0),this.turnButtons(!1);try{const r=new ModelRunner(this.serverUrl);await r.init(),await this.initModel(t,r),this.runner=r,this.turnButtons(!0),this.setInfoPanel("")}catch(r){this.setInfoPanel("Failed to initialize the server.",!1,!0),this.turnButtons(!1),console.error(r)}},async initImJoy(){function n(i=1e4){return new Promise((s,o)=>{const l=setInterval(()=>{window.app&&window.app.imjoy!==void 0&&(clearInterval(l),s(window.app.imjoy))},100);setTimeout(()=>{clearInterval(l),o(new Error("Timeout waiting for window.app.imjoy"))},i)})}const t=await n();console.log("ImJoy is ready:",t);const r=window.app.imjoy.api;this.api=r},async initImageJ(){console.log("Initializing IJ..."),this.ij=await this.api.createWindow({src:"https://ij.imjoy.io/",name:"ImageJ.JS",fullscreen:!1,window_id:"ij-container"})},setInfoPanel(n,t=!1,r=!1){this.info=n,this.waiting=t,this.error=r},async runModel(){this.setInfoPanel("Running the model...",!0),this.buttonEnabledRun=!1,console.log("Spec input axes: "+this.inputSpec.axes),console.log("Spec output axes: "+this.outputSpec.axes);try{const n=await this.viewerControl.getImage();let t=inferImgAxesViaSpec(n._rshape,this.inputSpec.axes,!0);console.log("Input image axes: "+t),console.log("Reshape image to match the input spec.");const r=imjoyToTfjs(n),i=mapAxes(r,t,this.inputSpec.axes),s=await this.runner.runTiles(i,this.inputSpec,this.outputSpec,this.tileSizes,this.tileOverlaps,o=>{this.setInfoPanel(o,!0)});if(this.runner.isImg2Img()){const o=processForShow(s,this.outputSpec.axes);await this.viewerControl.showImgs(o,"output")}else await this.viewerControl.showTableFromTensor(s,"output")}catch(n){alert("Failed to run the model, see console for details."),this.setInfoPanel("Failed to run the model, see console for details.",!1,!0),this.buttonEnabledRun=!0,console.error(n);debugger;return}this.setInfoPanel(""),this.buttonEnabledRun=!0},async loadTestInput(){if(this.setInfoPanel("Loading test input...",!0),rdfHas(this.runner.rdf,"test_inputs"))try{await this.viewerControl.viewFromUrl(this.runner.rdf.test_inputs[0],this.inputSpec,this.outputSpec)}catch(n){console.log("Failed to load the test input, see console for details."),console.error(n),console.log("Loading sample input instead..."),await this.viewerControl.viewFromUrl(this.runner.rdf.sample_inputs[0],this.inputSpec,this.outputSpec)}else rdfHas(this.runner.rdf,"sample_inputs")?await this.viewerControl.viewFromUrl(this.runner.rdf.sample_inputs[0],this.inputSpec,this.outputSpec):alert("No test input found.");this.setInfoPanel("")},async loadTestOutput(){if(this.setInfoPanel("Loading test output...",!0),rdfHas(this.runner.rdf,"test_outputs"))try{await this.viewerControl.viewFromUrl(this.runner.rdf.test_outputs[0],this.inputSpec,this.outputSpec,"output")}catch(n){console.log("Failed to load the test output."),console.error(n),console.log("Loading sample output instead..."),await this.viewerControl.viewFromUrl(this.runner.rdf.sample_outputs[0],this.inputSpec,this.outputSpec,"output")}else rdfHas(this.runner.rdf,"sample_outputs")?await this.viewerControl.viewFromUrl(this.runner.rdf.sample_outputs[0],this.inputSpec,this.outputSpec,"output"):await alert("No test output found.");this.setInfoPanel("")}},components:{HideContainer,OverlayContainer,AdvanceSetting,LoadingAnimation,ModelSelect}},_withScopeId=n=>(pushScopeId("data-v-5d1299b2"),n=n(),popScopeId(),n),_hoisted_1$a={id:"test-run-body"},_hoisted_2$7={class:"model-selection"},_hoisted_3$3={class:"model-selection-line"},_hoisted_4$3=_withScopeId(()=>createBaseVNode("div",{class:"model-selection-label"},"Model",-1)),_hoisted_5$3=_withScopeId(()=>createBaseVNode("div",{class:"model-selection-tips"},[createTextVNode("ℹ️ Please visit "),createBaseVNode("a",{href:"https://bioimage.io/#/",target:"_blank"},"bioimage.io"),createTextVNode(" to view detailed information about the model.")],-1)),_hoisted_6$3={id:"buttons"},_hoisted_7$1={id:"info"},_hoisted_8={key:1},_hoisted_9=_withScopeId(()=>createBaseVNode("span",null,"💡Tip: Drag and drop your own image file below to try out the model. We support formats like .tiff, .png, and .jpg",-1)),_hoisted_10=[_hoisted_9],_hoisted_11={key:0,id:"ij-container"};function _sfc_render(n,t,r,i,s,o){const l=resolveComponent("ModelSelect"),f=resolveComponent("Button"),u=resolveComponent("AdvanceSetting"),_=resolveComponent("OverlayContainer"),g=resolveComponent("HideContainer"),a=resolveComponent("LoadingAnimation");return openBlock(),createElementBlock("div",_hoisted_1$a,[createBaseVNode("div",_hoisted_2$7,[createBaseVNode("div",_hoisted_3$3,[_hoisted_4$3,createVNode(l,{onModelSelected:o.handleModelChange},null,8,["onModelSelected"])]),_hoisted_5$3]),createBaseVNode("div",_hoisted_6$3,[createVNode(f,{disabled:!this.buttonEnabledInput,onClick:this.loadTestInput},{default:withCtx(()=>[createTextVNode(" Load sample image ")]),_:1},8,["disabled","onClick"]),createVNode(f,{class:"is-primary",disabled:!this.buttonEnabledRun,onClick:this.runModel},{default:withCtx(()=>[createTextVNode(" Run model ")]),_:1},8,["disabled","onClick"]),createVNode(f,{disabled:!this.buttonEnabledOutput,onClick:this.loadTestOutput},{default:withCtx(()=>[createTextVNode(" Show reference output ")]),_:1},8,["disabled","onClick"])]),createVNode(g,{summary:"Advanced settings"},{default:withCtx(()=>[createVNode(_,{open:n.waiting},{default:withCtx(()=>[createVNode(u,{tritonConfig:this.tritonConfig,inputMinShape:this.inputMinShape,inputMaxShape:this.inputMaxShape,tileSizes:this.tileSizes,tileOverlaps:this.tileOverlaps,serverUrl:this.serverUrl,onServerUrlChanged:this.handleServerUrlChange},null,8,["tritonConfig","inputMinShape","inputMaxShape","tileSizes","tileOverlaps","serverUrl","onServerUrlChanged"])]),_:1},8,["open"])]),_:1}),createBaseVNode("div",_hoisted_7$1,[this.waiting?(openBlock(),createBlock(a,{key:0})):n.$props.ij===null?(openBlock(),createElementBlock("div",_hoisted_8,_hoisted_10)):createCommentVNode("",!0),createBaseVNode("div",{id:"info-panel",style:normalizeStyle({color:o.infoColor})},toDisplayString(this.info),5)]),n.$props.ij===null?(openBlock(),createElementBlock("div",_hoisted_11)):createCommentVNode("",!0)])}const RunPanel=_export_sfc(_sfc_main$1,[["render",_sfc_render],["__scopeId","data-v-5d1299b2"]]),_sfc_main={__name:"App",setup(n){return(t,r)=>(openBlock(),createBlock(RunPanel))}};var imjoyCore$1={exports:{}};(function(module,exports){(function(t,r){module.exports=r()})(window,function(){return function(n){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i,l:!1,exports:{}};return n[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=n,r.c=t,r.d=function(i,s,o){r.o(i,s)||Object.defineProperty(i,s,{enumerable:!0,get:o})},r.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},r.t=function(i,s){if(s&1&&(i=r(i)),s&8||s&4&&typeof i=="object"&&i&&i.__esModule)return i;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:i}),s&2&&typeof i!="string")for(var l in i)r.d(o,l,(function(f){return i[f]}).bind(null,l));return o},r.n=function(i){var s=i&&i.__esModule?function(){return i.default}:function(){return i};return r.d(s,"a",s),s},r.o=function(i,s){return Object.prototype.hasOwnProperty.call(i,s)},r.p="",r(r.s="./src/imjoyCore.js")}({"./node_modules/ajv/lib/ajv.js":function(module,exports,__webpack_require__){eval(`

var compileSchema = __webpack_require__(/*! ./compile */ "./node_modules/ajv/lib/compile/index.js")
  , resolve = __webpack_require__(/*! ./compile/resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , Cache = __webpack_require__(/*! ./cache */ "./node_modules/ajv/lib/cache.js")
  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js")
  , formats = __webpack_require__(/*! ./compile/formats */ "./node_modules/ajv/lib/compile/formats.js")
  , rules = __webpack_require__(/*! ./compile/rules */ "./node_modules/ajv/lib/compile/rules.js")
  , $dataMetaSchema = __webpack_require__(/*! ./data */ "./node_modules/ajv/lib/data.js")
  , util = __webpack_require__(/*! ./compile/util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ "./node_modules/ajv/lib/compile/async.js");
var customKeyword = __webpack_require__(/*! ./keyword */ "./node_modules/ajv/lib/keyword.js");
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;

var errorClasses = __webpack_require__(/*! ./compile/error_classes */ "./node_modules/ajv/lib/compile/error_classes.js");
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: \`Ajv(opts)\`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in \`ajv.errors\` (and also in compiled schema: \`schema.errors\`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, \`key\` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to \`validate\` method instead of schema object or id/ref. One schema per instance can have empty \`id\` and \`key\`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by \`key\` or \`ref\`.
 * @this   Ajv
 * @param  {String} keyRef \`key\` that was passed to \`addSchema\` or full schema reference (\`schema.id\` or resolved id).
 * @return {Function} schema validating function (with property \`schema\`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties \`separator\` and \`dataVar\`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = __webpack_require__(/*! ./refs/data.json */ "./node_modules/ajv/lib/refs/data.json");
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/ajv.js?`)},"./node_modules/ajv/lib/cache.js":function(module,exports,__webpack_require__){eval(`


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/cache.js?`)},"./node_modules/ajv/lib/compile/async.js":function(module,exports,__webpack_require__){eval(`

var MissingRefError = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js").MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * \`loadSchema\` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/async.js?`)},"./node_modules/ajv/lib/compile/error_classes.js":function(module,exports,__webpack_require__){eval(`

var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js");

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/error_classes.js?`)},"./node_modules/ajv/lib/compile/formats.js":function(module,exports,__webpack_require__){eval(`

var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

var DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\\x00-\\x20"'<>%\\\\^\`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;
var URL = /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,
  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\\/?\\/)?[^\\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_\`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_\`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,
  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\\\]\\\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/formats.js?`)},"./node_modules/ajv/lib/compile/index.js":function(module,exports,__webpack_require__){eval(`

var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , errorClasses = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");

var validateGenerator = __webpack_require__(/*! ../dotjs/validate */ "./node_modules/ajv/lib/dotjs/validate.js");

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\\n\\n\\n *** \\n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/index.js?`)},"./node_modules/ajv/lib/compile/resolve.js":function(module,exports,__webpack_require__){eval(`

var URI = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js")
  , equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , SchemaObject = __webpack_require__(/*! ./schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , traverse = __webpack_require__(/*! json-schema-traverse */ "./node_modules/json-schema-traverse/index.js");

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/resolve.js?`)},"./node_modules/ajv/lib/compile/rules.js":function(module,exports,__webpack_require__){eval(`

var ruleModules = __webpack_require__(/*! ../dotjs */ "./node_modules/ajv/lib/dotjs/index.js")
  , toHash = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js").toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/rules.js?`)},"./node_modules/ajv/lib/compile/schema_obj.js":function(module,exports,__webpack_require__){eval(`

var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/schema_obj.js?`)},"./node_modules/ajv/lib/compile/ucs2length.js":function(module,exports,__webpack_require__){eval(`

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/ucs2length.js?`)},"./node_modules/ajv/lib/compile/util.js":function(module,exports,__webpack_require__){eval(`


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js"),
  ucs2length: __webpack_require__(/*! ./ucs2length */ "./node_modules/ajv/lib/compile/ucs2length.js"),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\\\$&')
            .replace(/\\n/g, '\\\\n')
            .replace(/\\r/g, '\\\\r')
            .replace(/\\f/g, '\\\\f')
            .replace(/\\t/g, '\\\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\\s*{\\s*}/g
  , EMPTY_IF_NO_ELSE = /if\\s*\\([^)]+\\)\\s*\\{\\s*\\}(?!\\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\\s*\\(([^)]+)\\)\\s*\\{\\s*\\}\\s*else(?!\\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \\(errors === 0\\) return data;\\s*else throw new ValidationError\\(vErrors\\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \\(rootData === undefined\\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) {
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  }

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\\'' + escapeQuotes(str) + '\\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')
              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \\+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/util.js?`)},"./node_modules/ajv/lib/data.js":function(module,exports,__webpack_require__){eval(`

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/data.js?`)},"./node_modules/ajv/lib/definition_schema.js":function(module,exports,__webpack_require__){eval(`

var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");

module.exports = {
  $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/definition_schema.js?`)},"./node_modules/ajv/lib/dotjs/_limit.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\\' + ' + $opExpr + ' + \\'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \\'boolean\\' && ' + ($exclType) + ' != \\'undefined\\' && ' + ($exclType) + ' != \\'number\\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ($errorKeyword || '_exclusiveLimit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'' + ($exclusiveKeyword) + ' should be boolean\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
    }
    out += ' ' + ($exclType) + ' == \\'number\\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \\'' + ($op) + '\\' : \\'' + ($op) + '=\\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\\'' + $opStr + '\\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\\'' + $opStr + '\\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limit.js?`)},"./node_modules/ajv/lib/dotjs/_limitItems.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limitItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limitItems.js?`)},"./node_modules/ajv/lib/dotjs/_limitLength.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limitLength') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limitLength.js?`)},"./node_modules/ajv/lib/dotjs/_limitProperties.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limitProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limitProperties.js?`)},"./node_modules/ajv/lib/dotjs/allOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/allOf.js?`)},"./node_modules/ajv/lib/dotjs/anyOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('anyOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should match some schema in anyOf\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/anyOf.js?`)},"./node_modules/ajv/lib/dotjs/comment.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/comment.js?`)},"./node_modules/ajv/lib/dotjs/const.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('const') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be equal to constant\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/const.js?`)},"./node_modules/ajv/lib/dotjs/contains.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('contains') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should contain a valid item\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/contains.js?`)},"./node_modules/ajv/lib/dotjs/custom.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\\'' + ($keyword) + '\\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \\'\\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should pass "' + ($rule.keyword) + '" keyword validation\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \\'should pass "' + ($rule.keyword) + '" keyword validation\\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/custom.js?`)},"./node_modules/ajv/lib/dotjs/dependencies.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \\'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/dependencies.js?`)},"./node_modules/ajv/lib/dotjs/enum.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('enum') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be equal to one of the allowed values\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/enum.js?`)},"./node_modules/ajv/lib/dotjs/format.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \\'object\\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \\'string\\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \\'' + ($ruleType) + '\\' && !(typeof ' + ($format) + ' == \\'function\\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('format') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should match format "';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/format.js?`)},"./node_modules/ajv/lib/dotjs/if.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \\'then\\'; ';
      } else {
        $ifClause = '\\'then\\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \\'else\\'; ';
      } else {
        $ifClause = '\\'else\\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('if') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should match "\\' + ' + ($ifClause) + ' + \\'" schema\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/if.js?`)},"./node_modules/ajv/lib/dotjs/index.js":function(module,exports,__webpack_require__){eval(`

//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': __webpack_require__(/*! ./ref */ "./node_modules/ajv/lib/dotjs/ref.js"),
  allOf: __webpack_require__(/*! ./allOf */ "./node_modules/ajv/lib/dotjs/allOf.js"),
  anyOf: __webpack_require__(/*! ./anyOf */ "./node_modules/ajv/lib/dotjs/anyOf.js"),
  '$comment': __webpack_require__(/*! ./comment */ "./node_modules/ajv/lib/dotjs/comment.js"),
  const: __webpack_require__(/*! ./const */ "./node_modules/ajv/lib/dotjs/const.js"),
  contains: __webpack_require__(/*! ./contains */ "./node_modules/ajv/lib/dotjs/contains.js"),
  dependencies: __webpack_require__(/*! ./dependencies */ "./node_modules/ajv/lib/dotjs/dependencies.js"),
  'enum': __webpack_require__(/*! ./enum */ "./node_modules/ajv/lib/dotjs/enum.js"),
  format: __webpack_require__(/*! ./format */ "./node_modules/ajv/lib/dotjs/format.js"),
  'if': __webpack_require__(/*! ./if */ "./node_modules/ajv/lib/dotjs/if.js"),
  items: __webpack_require__(/*! ./items */ "./node_modules/ajv/lib/dotjs/items.js"),
  maximum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  minimum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  maxItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  minItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  maxLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  minLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  maxProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  minProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  multipleOf: __webpack_require__(/*! ./multipleOf */ "./node_modules/ajv/lib/dotjs/multipleOf.js"),
  not: __webpack_require__(/*! ./not */ "./node_modules/ajv/lib/dotjs/not.js"),
  oneOf: __webpack_require__(/*! ./oneOf */ "./node_modules/ajv/lib/dotjs/oneOf.js"),
  pattern: __webpack_require__(/*! ./pattern */ "./node_modules/ajv/lib/dotjs/pattern.js"),
  properties: __webpack_require__(/*! ./properties */ "./node_modules/ajv/lib/dotjs/properties.js"),
  propertyNames: __webpack_require__(/*! ./propertyNames */ "./node_modules/ajv/lib/dotjs/propertyNames.js"),
  required: __webpack_require__(/*! ./required */ "./node_modules/ajv/lib/dotjs/required.js"),
  uniqueItems: __webpack_require__(/*! ./uniqueItems */ "./node_modules/ajv/lib/dotjs/uniqueItems.js"),
  validate: __webpack_require__(/*! ./validate */ "./node_modules/ajv/lib/dotjs/validate.js")
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/index.js?`)},"./node_modules/ajv/lib/dotjs/items.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \\'' + ('additionalItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/items.js?`)},"./node_modules/ajv/lib/dotjs/multipleOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \\'number\\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('multipleOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be multiple of ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/multipleOf.js?`)},"./node_modules/ajv/lib/dotjs/not.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should NOT be valid\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should NOT be valid\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/not.js?`)},"./node_modules/ajv/lib/dotjs/oneOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('oneOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should match exactly one schema in oneOf\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/oneOf.js?`)},"./node_modules/ajv/lib/dotjs/pattern.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('pattern') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should match pattern "';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/pattern.js?`)},"./node_modules/ajv/lib/dotjs/properties.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\\' + ' + $key + ' + \\'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \\'' + ('additionalProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \\'' + ($additionalProperty) + '\\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \\'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \\'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
                  }
                  out += '\\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/properties.js?`)},"./node_modules/ajv/lib/dotjs/propertyNames.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\\' + ' + $key + ' + \\'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('propertyNames') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \\'' + ($invalidName) + '\\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'property name \\\\\\'' + ($invalidName) + '\\\\\\' is invalid\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/propertyNames.js?`)},"./node_modules/ajv/lib/dotjs/ref.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('$ref') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \\'' + (it.util.escapeQuotes($schema)) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \\'\\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/ref.js?`)},"./node_modules/ajv/lib/dotjs/required.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \\'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
              }
              out += '\\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \\'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
                }
                out += '\\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/required.js?`)},"./node_modules/ajv/lib/dotjs/uniqueItems.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \\'boolean\\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \\'string\\') item = \\'"\\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \\'number\\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('uniqueItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/uniqueItems.js?`)},"./node_modules/ajv/lib/dotjs/validate.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \\'use strict\\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \\'' + ($errorKeyword || 'false schema') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \\'boolean schema is false\\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \\'object\\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \\'array\\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \\'array\\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\') ' + ($coerced) + ' = \\'\\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \\'\\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \\'string\\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \\'false\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \\'true\\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \\'\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \\'string\\' || ' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \\'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top) {
    out = it.util.finalCleanUpCode(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/validate.js?`)},"./node_modules/ajv/lib/keyword.js":function(module,exports,__webpack_require__){eval(`

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = __webpack_require__(/*! ./dotjs/custom */ "./node_modules/ajv/lib/dotjs/custom.js");
var definitionSchema = __webpack_require__(/*! ./definition_schema */ "./node_modules/ajv/lib/definition_schema.js");

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties \`type\` (type(s) which the keyword applies to), \`validate\` or \`compile\`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, \`true\` if it is a predefined keyword, \`false\` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/keyword.js?`)},"./node_modules/ajv/lib/refs/data.json":function(module){eval(`module.exports = JSON.parse("{\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"$id\\":\\"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#\\",\\"description\\":\\"Meta-schema for $data reference (JSON Schema extension proposal)\\",\\"type\\":\\"object\\",\\"required\\":[\\"$data\\"],\\"properties\\":{\\"$data\\":{\\"type\\":\\"string\\",\\"anyOf\\":[{\\"format\\":\\"relative-json-pointer\\"},{\\"format\\":\\"json-pointer\\"}]}},\\"additionalProperties\\":false}");

//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/refs/data.json?`)},"./node_modules/ajv/lib/refs/json-schema-draft-07.json":function(module){eval(`module.exports = JSON.parse("{\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"$id\\":\\"http://json-schema.org/draft-07/schema#\\",\\"title\\":\\"Core schema meta-schema\\",\\"definitions\\":{\\"schemaArray\\":{\\"type\\":\\"array\\",\\"minItems\\":1,\\"items\\":{\\"$ref\\":\\"#\\"}},\\"nonNegativeInteger\\":{\\"type\\":\\"integer\\",\\"minimum\\":0},\\"nonNegativeIntegerDefault0\\":{\\"allOf\\":[{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},{\\"default\\":0}]},\\"simpleTypes\\":{\\"enum\\":[\\"array\\",\\"boolean\\",\\"integer\\",\\"null\\",\\"number\\",\\"object\\",\\"string\\"]},\\"stringArray\\":{\\"type\\":\\"array\\",\\"items\\":{\\"type\\":\\"string\\"},\\"uniqueItems\\":true,\\"default\\":[]}},\\"type\\":[\\"object\\",\\"boolean\\"],\\"properties\\":{\\"$id\\":{\\"type\\":\\"string\\",\\"format\\":\\"uri-reference\\"},\\"$schema\\":{\\"type\\":\\"string\\",\\"format\\":\\"uri\\"},\\"$ref\\":{\\"type\\":\\"string\\",\\"format\\":\\"uri-reference\\"},\\"$comment\\":{\\"type\\":\\"string\\"},\\"title\\":{\\"type\\":\\"string\\"},\\"description\\":{\\"type\\":\\"string\\"},\\"default\\":true,\\"readOnly\\":{\\"type\\":\\"boolean\\",\\"default\\":false},\\"examples\\":{\\"type\\":\\"array\\",\\"items\\":true},\\"multipleOf\\":{\\"type\\":\\"number\\",\\"exclusiveMinimum\\":0},\\"maximum\\":{\\"type\\":\\"number\\"},\\"exclusiveMaximum\\":{\\"type\\":\\"number\\"},\\"minimum\\":{\\"type\\":\\"number\\"},\\"exclusiveMinimum\\":{\\"type\\":\\"number\\"},\\"maxLength\\":{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},\\"minLength\\":{\\"$ref\\":\\"#/definitions/nonNegativeIntegerDefault0\\"},\\"pattern\\":{\\"type\\":\\"string\\",\\"format\\":\\"regex\\"},\\"additionalItems\\":{\\"$ref\\":\\"#\\"},\\"items\\":{\\"anyOf\\":[{\\"$ref\\":\\"#\\"},{\\"$ref\\":\\"#/definitions/schemaArray\\"}],\\"default\\":true},\\"maxItems\\":{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},\\"minItems\\":{\\"$ref\\":\\"#/definitions/nonNegativeIntegerDefault0\\"},\\"uniqueItems\\":{\\"type\\":\\"boolean\\",\\"default\\":false},\\"contains\\":{\\"$ref\\":\\"#\\"},\\"maxProperties\\":{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},\\"minProperties\\":{\\"$ref\\":\\"#/definitions/nonNegativeIntegerDefault0\\"},\\"required\\":{\\"$ref\\":\\"#/definitions/stringArray\\"},\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"definitions\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"default\\":{}},\\"properties\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"default\\":{}},\\"patternProperties\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"propertyNames\\":{\\"format\\":\\"regex\\"},\\"default\\":{}},\\"dependencies\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"anyOf\\":[{\\"$ref\\":\\"#\\"},{\\"$ref\\":\\"#/definitions/stringArray\\"}]}},\\"propertyNames\\":{\\"$ref\\":\\"#\\"},\\"const\\":true,\\"enum\\":{\\"type\\":\\"array\\",\\"items\\":true,\\"minItems\\":1,\\"uniqueItems\\":true},\\"type\\":{\\"anyOf\\":[{\\"$ref\\":\\"#/definitions/simpleTypes\\"},{\\"type\\":\\"array\\",\\"items\\":{\\"$ref\\":\\"#/definitions/simpleTypes\\"},\\"minItems\\":1,\\"uniqueItems\\":true}]},\\"format\\":{\\"type\\":\\"string\\"},\\"contentMediaType\\":{\\"type\\":\\"string\\"},\\"contentEncoding\\":{\\"type\\":\\"string\\"},\\"if\\":{\\"$ref\\":\\"#\\"},\\"then\\":{\\"$ref\\":\\"#\\"},\\"else\\":{\\"$ref\\":\\"#\\"},\\"allOf\\":{\\"$ref\\":\\"#/definitions/schemaArray\\"},\\"anyOf\\":{\\"$ref\\":\\"#/definitions/schemaArray\\"},\\"oneOf\\":{\\"$ref\\":\\"#/definitions/schemaArray\\"},\\"not\\":{\\"$ref\\":\\"#\\"}},\\"default\\":true}");

//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/refs/json-schema-draft-07.json?`)},"./node_modules/argsarray/index.js":function(module,exports,__webpack_require__){eval(`

module.exports = argsArray;

function argsArray(fun) {
  return function () {
    var len = arguments.length;
    if (len) {
      var args = [];
      var i = -1;
      while (++i < len) {
        args[i] = arguments[i];
      }
      return fun.call(this, args);
    } else {
      return fun.call(this, []);
    }
  };
}

//# sourceURL=webpack://%5Bname%5D/./node_modules/argsarray/index.js?`)},"./node_modules/axios/index.js":function(module,exports,__webpack_require__){eval(`module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/index.js?`)},"./node_modules/axios/lib/adapters/xhr.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/adapters/xhr.js?`)},"./node_modules/axios/lib/axios.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/axios.js?`)},"./node_modules/axios/lib/cancel/Cancel.js":function(module,exports,__webpack_require__){eval(`

/**
 * A \`Cancel\` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/cancel/Cancel.js?`)},"./node_modules/axios/lib/cancel/CancelToken.js":function(module,exports,__webpack_require__){eval(`

var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A \`CancelToken\` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a \`Cancel\` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new \`CancelToken\` and a function that, when called,
 * cancels the \`CancelToken\`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/cancel/CancelToken.js?`)},"./node_modules/axios/lib/cancel/isCancel.js":function(module,exports,__webpack_require__){eval(`

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/cancel/isCancel.js?`)},"./node_modules/axios/lib/core/Axios.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/Axios.js?`)},"./node_modules/axios/lib/core/InterceptorManager.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle \`then\` for a \`Promise\`
 * @param {Function} rejected The function to handle \`reject\` for a \`Promise\`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by \`use\`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become \`null\` calling \`eject\`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/InterceptorManager.js?`)},"./node_modules/axios/lib/core/buildFullPath.js":function(module,exports,__webpack_require__){eval(`

var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/buildFullPath.js?`)},"./node_modules/axios/lib/core/createError.js":function(module,exports,__webpack_require__){eval(`

var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/createError.js?`)},"./node_modules/axios/lib/core/dispatchRequest.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a \`Cancel\` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/dispatchRequest.js?`)},"./node_modules/axios/lib/core/enhanceError.js":function(module,exports,__webpack_require__){eval(`

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/enhanceError.js?`)},"./node_modules/axios/lib/core/mergeConfig.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/mergeConfig.js?`)},"./node_modules/axios/lib/core/settle.js":function(module,exports,__webpack_require__){eval(`

var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/settle.js?`)},"./node_modules/axios/lib/core/transformData.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/transformData.js?`)},"./node_modules/axios/lib/defaults.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/defaults.js?`)},"./node_modules/axios/lib/helpers/bind.js":function(module,exports,__webpack_require__){eval(`

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/bind.js?`)},"./node_modules/axios/lib/helpers/buildURL.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/buildURL.js?`)},"./node_modules/axios/lib/helpers/combineURLs.js":function(module,exports,__webpack_require__){eval(`

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')
    : baseURL;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/combineURLs.js?`)},"./node_modules/axios/lib/helpers/cookies.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/cookies.js?`)},"./node_modules/axios/lib/helpers/isAbsoluteURL.js":function(module,exports,__webpack_require__){eval(`

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/isAbsoluteURL.js?`)},"./node_modules/axios/lib/helpers/isAxiosError.js":function(module,exports,__webpack_require__){eval(`

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/isAxiosError.js?`)},"./node_modules/axios/lib/helpers/isURLSameOrigin.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/isURLSameOrigin.js?`)},"./node_modules/axios/lib/helpers/normalizeHeaderName.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/normalizeHeaderName.js?`)},"./node_modules/axios/lib/helpers/parseHeaders.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * \`\`\`
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * \`\`\`
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/parseHeaders.js?`)},"./node_modules/axios/lib/helpers/spread.js":function(module,exports,__webpack_require__){eval(`

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use \`Function.prototype.apply\`.
 *
 *  \`\`\`js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  \`\`\`
 *
 * With \`spread\` this example can be re-written.
 *
 *  \`\`\`js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  \`\`\`
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/spread.js?`)},"./node_modules/axios/lib/utils.js":function(module,exports,__webpack_require__){eval(`

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If \`obj\` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * \`\`\`js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * \`\`\`
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/utils.js?`)},"./node_modules/base64-js/index.js":function(module,exports,__webpack_require__){eval(`

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/base64-js/index.js?`)},"./node_modules/buffer/index.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If \`Buffer.TYPED_ARRAY_SUPPORT\`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to \`Uint8Array\` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the \`TypedArray.prototype.subarray\` function.
 *
 *   - IE10 has a broken \`TypedArray.prototype.subarray\` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set \`Buffer.TYPED_ARRAY_SUPPORT\` to \`false\` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack \`subarray\`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken \`subarray\`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of \`Uint8Array\` that have their
 * prototype changed to \`Buffer.prototype\`. Furthermore, \`Buffer\` is a subclass of
 * \`Uint8Array\`, so the returned instances will have all the node \`Buffer\` methods
 * and the \`Uint8Array\` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The \`Uint8Array\` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if \`array\` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\\'offset\\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\\'length\\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use \`length < kMaxLength()\` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by \`Buffer.isBuffer\` and \`is-buffer\` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of \`val\` in \`buffer\` at offset >= \`byteOffset\`,
// OR the last index of \`val\` in \`buffer\` at offset <= \`byteOffset\`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into \`buffer\`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\\s+|\\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/buffer/index.js?`)},"./node_modules/dompurify/dist/purify.js":function(module,exports,__webpack_require__){eval(`/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.0.8/LICENSE */

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, function () { 'use strict';

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      objectKeys = Object.keys;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayIndexOf = unapply(Array.prototype.indexOf);
  var arrayJoin = unapply(Array.prototype.join);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var arraySlice = unapply(Array.prototype.slice);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);
  var regExpCreate = unconstruct(RegExp);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create(null);

    var property = void 0;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  var text = freeze(['#text']);

  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex
  );

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.0.17';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;
    var removeTitle = false;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        Text = window.Text,
        Comment = window.Comment,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.

    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        getElementsByTagName = _document.getElementsByTagName,
        createDocumentFragment = _document.createDocumentFragment;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for jQuery's $() factory? */
    var SAFE_FOR_JQUERY = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM \`HTMLBodyElement\` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If \`WHOLE_DOCUMENT\` is enabled a \`HTMLHtmlElement\` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM \`DocumentFragment\` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* If \`RETURN_DOM\` or \`RETURN_DOM_FRAGMENT\` is enabled, decide if the returned DOM
     * \`Node\` is imported into the current \`Document\`. If this flag is not enabled the
     * \`Node\` will belong (its ownerDocument) to a fresh \`HTMLDocument\`, created by
     * DOMPurify. */
    var RETURN_DOM_IMPORT = false;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a \`Node\` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html);
          addToSet(ALLOWED_ATTR, html$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        node.parentNode.removeChild(node);
      } catch (_) {
        node.outerHTML = emptyHTML;
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /* Use the DOMParser API by default, fallback later if needs be */
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
      } catch (_) {}

      /* Remove title to fix a mXSS bug in older MS Edge */
      if (removeTitle) {
        addToSet(FORBID_TAGS, ['title']);
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createHTMLDocument('');
        var _doc = doc,
            body = _doc.body;

        body.parentNode.removeChild(body.parentNode.firstElementChild);
        body.outerHTML = dirtyPayload;
      }

      if (dirty && leadingWhitespace) {
        doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    };

    /* Here we test for a broken feature in Edge that might cause mXSS */
    if (DOMPurify.isSupported) {
      (function () {
        try {
          var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');
          if (regExpTest(/<\\/title/, doc.querySelector('title').innerHTML)) {
            removeTitle = true;
          }
        } catch (_) {}
      })();
    }

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
        return NodeFilter.FILTER_ACCEPT;
      }, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false;
      }

      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string') {
        return true;
      }

      return false;
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    // eslint-disable-next-line complexity
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = stringToLowerCase(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Take care of an mXSS pattern using p, br inside svg, math */
      if ((tagName === 'svg' || tagName === 'math') && currentNode.querySelectorAll('p, br, form, table').length !== 0) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
          try {
            var htmlToInsert = currentNode.innerHTML;
            currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);
          } catch (_) {}
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Remove in case a noscript/noembed XSS is suspected */
      if (tagName === 'noscript' && regExpTest(/<\\/noscript/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      if (tagName === 'noembed' && regExpTest(/<\\/noembed/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Convert markup to cover jQuery behavior */
      if (SAFE_FOR_JQUERY && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/</g, currentNode.textContent)) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        if (currentNode.innerHTML) {
          currentNode.innerHTML = stringReplace(currentNode.innerHTML, /</g, '&lt;');
        } else {
          currentNode.innerHTML = stringReplace(currentNode.textContent, /</g, '&lt;');
        }
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if \`value\` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        return false;

        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    // eslint-disable-next-line complexity
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var idAttr = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim(attr.value);
        lcName = stringToLowerCase(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
        // remove a "name" attribute from an <img> tag that has an "id"
        // attribute at the time.
        if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {
          idAttr = attributes.id;
          attributes = arraySlice(attributes, []);
          _removeAttribute('id', currentNode);
          _removeAttribute(name, currentNode);
          if (arrayIndexOf(attributes, idAttr) > l) {
            currentNode.setAttribute('id', idAttr.value);
          }
        } else if (
        // This works around a bug in Safari, where input[type=file]
        // cannot be dynamically set after type has been removed
        currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
          continue;
        } else {
          // This avoids a crash in Safari v9.0 with double-ids.
          // The trick is to first set the id to be empty and then to
          // remove the attribute
          if (name === 'id') {
            currentNode.setAttribute(name, '');
          }

          _removeAttribute(name, currentNode);
        }

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (SAFE_FOR_JQUERY && regExpTest(/\\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Take care of an mXSS pattern using namespace switches */
        if (regExpTest(/svg|math/i, currentNode.namespaceURI) && regExpTest(regExpCreate('</(' + arrayJoin(objectKeys(FORBID_CONTENTS), '|') + ')', 'i'), value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is \`value\` valid for this attribute? */
        var lcTag = currentNode.nodeName.toLowerCase();
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      if (!dirty) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) ; else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!-->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : emptyHTML;
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized \`dirty\` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (RETURN_DOM_IMPORT) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if \`value\` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = stringToLowerCase(tag);
      var lcName = stringToLowerCase(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
//# sourceMappingURL=purify.js.map


//# sourceURL=webpack://%5Bname%5D/./node_modules/dompurify/dist/purify.js?`)},"./node_modules/esprima/dist/esprima.js":function(module,exports,__webpack_require__){eval(`(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  \`function a() {/** comments **\\/}\`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // \`
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\\r' && this.scanner.source[this.scanner.index] === '\\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with \`new\`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \\'use strict\\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \\'%1\\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \\'%0\\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // \`<!--\`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \\0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\\n';
	                            break;
	                        case 'r':
	                            str += '\\r';
	                            break;
	                        case 't':
	                            str += '\\t';
	                            break;
	                        case 'b':
	                            str += '\\b';
	                            break;
	                        case 'f':
	                            str += '\\f';
	                            break;
	                        case 'v':
	                            str += '\\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\\r' && this.source[this.index] === '\\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '\`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '\`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('\${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\\n';
	                            break;
	                        case 'r':
	                            cooked += '\\r';
	                            break;
	                        case 't':
	                            cooked += '\\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\\b';
	                            break;
	                        case 'f':
	                            cooked += '\\f';
	                            break;
	                        case 'v':
	                            cooked += '\\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \\01 \\02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \\1 \\2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\\r' && this.source[this.index] === '\\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\\r' && this.source[this.index] === '\\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\\uFFFF' enables false positives in unlikely
	        // scenarios. For example, \`[\\u{1044f}-\\u{10440}]\` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // \`null\` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with \` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '\${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\\u0022',
	    amp: '\\u0026',
	    apos: '\\u0027',
	    gt: '\\u003E',
	    nbsp: '\\u00A0',
	    iexcl: '\\u00A1',
	    cent: '\\u00A2',
	    pound: '\\u00A3',
	    curren: '\\u00A4',
	    yen: '\\u00A5',
	    brvbar: '\\u00A6',
	    sect: '\\u00A7',
	    uml: '\\u00A8',
	    copy: '\\u00A9',
	    ordf: '\\u00AA',
	    laquo: '\\u00AB',
	    not: '\\u00AC',
	    shy: '\\u00AD',
	    reg: '\\u00AE',
	    macr: '\\u00AF',
	    deg: '\\u00B0',
	    plusmn: '\\u00B1',
	    sup2: '\\u00B2',
	    sup3: '\\u00B3',
	    acute: '\\u00B4',
	    micro: '\\u00B5',
	    para: '\\u00B6',
	    middot: '\\u00B7',
	    cedil: '\\u00B8',
	    sup1: '\\u00B9',
	    ordm: '\\u00BA',
	    raquo: '\\u00BB',
	    frac14: '\\u00BC',
	    frac12: '\\u00BD',
	    frac34: '\\u00BE',
	    iquest: '\\u00BF',
	    Agrave: '\\u00C0',
	    Aacute: '\\u00C1',
	    Acirc: '\\u00C2',
	    Atilde: '\\u00C3',
	    Auml: '\\u00C4',
	    Aring: '\\u00C5',
	    AElig: '\\u00C6',
	    Ccedil: '\\u00C7',
	    Egrave: '\\u00C8',
	    Eacute: '\\u00C9',
	    Ecirc: '\\u00CA',
	    Euml: '\\u00CB',
	    Igrave: '\\u00CC',
	    Iacute: '\\u00CD',
	    Icirc: '\\u00CE',
	    Iuml: '\\u00CF',
	    ETH: '\\u00D0',
	    Ntilde: '\\u00D1',
	    Ograve: '\\u00D2',
	    Oacute: '\\u00D3',
	    Ocirc: '\\u00D4',
	    Otilde: '\\u00D5',
	    Ouml: '\\u00D6',
	    times: '\\u00D7',
	    Oslash: '\\u00D8',
	    Ugrave: '\\u00D9',
	    Uacute: '\\u00DA',
	    Ucirc: '\\u00DB',
	    Uuml: '\\u00DC',
	    Yacute: '\\u00DD',
	    THORN: '\\u00DE',
	    szlig: '\\u00DF',
	    agrave: '\\u00E0',
	    aacute: '\\u00E1',
	    acirc: '\\u00E2',
	    atilde: '\\u00E3',
	    auml: '\\u00E4',
	    aring: '\\u00E5',
	    aelig: '\\u00E6',
	    ccedil: '\\u00E7',
	    egrave: '\\u00E8',
	    eacute: '\\u00E9',
	    ecirc: '\\u00EA',
	    euml: '\\u00EB',
	    igrave: '\\u00EC',
	    iacute: '\\u00ED',
	    icirc: '\\u00EE',
	    iuml: '\\u00EF',
	    eth: '\\u00F0',
	    ntilde: '\\u00F1',
	    ograve: '\\u00F2',
	    oacute: '\\u00F3',
	    ocirc: '\\u00F4',
	    otilde: '\\u00F5',
	    ouml: '\\u00F6',
	    divide: '\\u00F7',
	    oslash: '\\u00F8',
	    ugrave: '\\u00F9',
	    uacute: '\\u00FA',
	    ucirc: '\\u00FB',
	    uuml: '\\u00FC',
	    yacute: '\\u00FD',
	    thorn: '\\u00FE',
	    yuml: '\\u00FF',
	    OElig: '\\u0152',
	    oelig: '\\u0153',
	    Scaron: '\\u0160',
	    scaron: '\\u0161',
	    Yuml: '\\u0178',
	    fnof: '\\u0192',
	    circ: '\\u02C6',
	    tilde: '\\u02DC',
	    Alpha: '\\u0391',
	    Beta: '\\u0392',
	    Gamma: '\\u0393',
	    Delta: '\\u0394',
	    Epsilon: '\\u0395',
	    Zeta: '\\u0396',
	    Eta: '\\u0397',
	    Theta: '\\u0398',
	    Iota: '\\u0399',
	    Kappa: '\\u039A',
	    Lambda: '\\u039B',
	    Mu: '\\u039C',
	    Nu: '\\u039D',
	    Xi: '\\u039E',
	    Omicron: '\\u039F',
	    Pi: '\\u03A0',
	    Rho: '\\u03A1',
	    Sigma: '\\u03A3',
	    Tau: '\\u03A4',
	    Upsilon: '\\u03A5',
	    Phi: '\\u03A6',
	    Chi: '\\u03A7',
	    Psi: '\\u03A8',
	    Omega: '\\u03A9',
	    alpha: '\\u03B1',
	    beta: '\\u03B2',
	    gamma: '\\u03B3',
	    delta: '\\u03B4',
	    epsilon: '\\u03B5',
	    zeta: '\\u03B6',
	    eta: '\\u03B7',
	    theta: '\\u03B8',
	    iota: '\\u03B9',
	    kappa: '\\u03BA',
	    lambda: '\\u03BB',
	    mu: '\\u03BC',
	    nu: '\\u03BD',
	    xi: '\\u03BE',
	    omicron: '\\u03BF',
	    pi: '\\u03C0',
	    rho: '\\u03C1',
	    sigmaf: '\\u03C2',
	    sigma: '\\u03C3',
	    tau: '\\u03C4',
	    upsilon: '\\u03C5',
	    phi: '\\u03C6',
	    chi: '\\u03C7',
	    psi: '\\u03C8',
	    omega: '\\u03C9',
	    thetasym: '\\u03D1',
	    upsih: '\\u03D2',
	    piv: '\\u03D6',
	    ensp: '\\u2002',
	    emsp: '\\u2003',
	    thinsp: '\\u2009',
	    zwnj: '\\u200C',
	    zwj: '\\u200D',
	    lrm: '\\u200E',
	    rlm: '\\u200F',
	    ndash: '\\u2013',
	    mdash: '\\u2014',
	    lsquo: '\\u2018',
	    rsquo: '\\u2019',
	    sbquo: '\\u201A',
	    ldquo: '\\u201C',
	    rdquo: '\\u201D',
	    bdquo: '\\u201E',
	    dagger: '\\u2020',
	    Dagger: '\\u2021',
	    bull: '\\u2022',
	    hellip: '\\u2026',
	    permil: '\\u2030',
	    prime: '\\u2032',
	    Prime: '\\u2033',
	    lsaquo: '\\u2039',
	    rsaquo: '\\u203A',
	    oline: '\\u203E',
	    frasl: '\\u2044',
	    euro: '\\u20AC',
	    image: '\\u2111',
	    weierp: '\\u2118',
	    real: '\\u211C',
	    trade: '\\u2122',
	    alefsym: '\\u2135',
	    larr: '\\u2190',
	    uarr: '\\u2191',
	    rarr: '\\u2192',
	    darr: '\\u2193',
	    harr: '\\u2194',
	    crarr: '\\u21B5',
	    lArr: '\\u21D0',
	    uArr: '\\u21D1',
	    rArr: '\\u21D2',
	    dArr: '\\u21D3',
	    hArr: '\\u21D4',
	    forall: '\\u2200',
	    part: '\\u2202',
	    exist: '\\u2203',
	    empty: '\\u2205',
	    nabla: '\\u2207',
	    isin: '\\u2208',
	    notin: '\\u2209',
	    ni: '\\u220B',
	    prod: '\\u220F',
	    sum: '\\u2211',
	    minus: '\\u2212',
	    lowast: '\\u2217',
	    radic: '\\u221A',
	    prop: '\\u221D',
	    infin: '\\u221E',
	    ang: '\\u2220',
	    and: '\\u2227',
	    or: '\\u2228',
	    cap: '\\u2229',
	    cup: '\\u222A',
	    int: '\\u222B',
	    there4: '\\u2234',
	    sim: '\\u223C',
	    cong: '\\u2245',
	    asymp: '\\u2248',
	    ne: '\\u2260',
	    equiv: '\\u2261',
	    le: '\\u2264',
	    ge: '\\u2265',
	    sub: '\\u2282',
	    sup: '\\u2283',
	    nsub: '\\u2284',
	    sube: '\\u2286',
	    supe: '\\u2287',
	    oplus: '\\u2295',
	    otimes: '\\u2297',
	    perp: '\\u22A5',
	    sdot: '\\u22C5',
	    lceil: '\\u2308',
	    rceil: '\\u2309',
	    lfloor: '\\u230A',
	    rfloor: '\\u230B',
	    loz: '\\u25CA',
	    spades: '\\u2660',
	    clubs: '\\u2663',
	    hearts: '\\u2665',
	    diams: '\\u2666',
	    lang: '\\u27E8',
	    rang: '\\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;

//# sourceURL=webpack://%5Bname%5D/./node_modules/esprima/dist/esprima.js?`)},"./node_modules/events/events.js":function(module,exports,__webpack_require__){eval(`// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the \`throw\` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign \`events\` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/events/events.js?`)},"./node_modules/fast-deep-equal/index.js":function(module,exports,__webpack_require__){eval(`

// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/fast-deep-equal/index.js?`)},"./node_modules/fast-json-stable-stringify/index.js":function(module,exports,__webpack_require__){eval(`

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/fast-json-stable-stringify/index.js?`)},"./node_modules/file-saver/FileSaver.js":function(module,exports,__webpack_require__){eval(`var __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// \`self\` is undefined in Firefox for Android content script context
// while \`this\` is nsIContentFrameMessageManager
// with an attribute \`content\` that corresponds to the window

if ( true && module.exports) {
  module.exports.saveAs = saveAs;
} else if (( true && __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") !== null) && (__webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") !== null)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return saveAs;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/file-saver/FileSaver.js?`)},"./node_modules/ieee754/index.js":function(module,exports){eval(`exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ieee754/index.js?`)},"./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js":function(module,exports,__webpack_require__){eval(`(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/socketIOMain.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js":
/*!***********************************************************************************!*\\
  !*** ./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!
  \\***********************************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/*
 * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
var encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
var decode = function (base64) {
    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};


//# sourceMappingURL=base64-arraybuffer.es5.js.map


/***/ }),

/***/ "./node_modules/@socket.io/component-emitter/index.js":
/*!************************************************************!*\\
  !*** ./node_modules/@socket.io/component-emitter/index.js ***!
  \\************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose \`Emitter\`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new \`Emitter\`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given \`event\` with \`fn\`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an \`event\` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for \`event\` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit \`event\` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for \`event\`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has \`event\` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\\
  !*** ./node_modules/backo2/index.js ***!
  \\**************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose \`Backoff\`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with \`opts\`.
 *
 * - \`min\` initial timeout in milliseconds [100]
 * - \`max\` max timeout [10000]
 * - \`jitter\` [0]
 * - \`factor\` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\\
  !*** ./node_modules/base64-js/index.js ***!
  \\*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\\
  !*** ./node_modules/buffer/index.js ***!
  \\**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If \`Buffer.TYPED_ARRAY_SUPPORT\`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to \`Uint8Array\` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the \`TypedArray.prototype.subarray\` function.
 *
 *   - IE10 has a broken \`TypedArray.prototype.subarray\` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set \`Buffer.TYPED_ARRAY_SUPPORT\` to \`false\` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack \`subarray\`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken \`subarray\`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of \`Uint8Array\` that have their
 * prototype changed to \`Buffer.prototype\`. Furthermore, \`Buffer\` is a subclass of
 * \`Uint8Array\`, so the returned instances will have all the node \`Buffer\` methods
 * and the \`Uint8Array\` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The \`Uint8Array\` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if \`array\` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\\'offset\\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\\'length\\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use \`length < kMaxLength()\` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by \`Buffer.isBuffer\` and \`is-buffer\` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of \`val\` in \`buffer\` at offset >= \`byteOffset\`,
// OR the last index of \`val\` in \`buffer\` at offset <= \`byteOffset\`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into \`buffer\`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\\s+|\\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/globalThis.browser.js":
/*!***********************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/globalThis.browser.js ***!
  \\***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ((() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})());


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/index.js":
/*!**********************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/index.js ***!
  \\**********************************************************/
/*! exports provided: Socket, protocol, Transport, transports, installTimerFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return protocol; });
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./socket.js */ "./node_modules/engine.io-client/build/esm/socket.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return _socket_js__WEBPACK_IMPORTED_MODULE_0__["Socket"]; });

/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transport.js */ "./node_modules/engine.io-client/build/esm/transport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transport", function() { return _transport_js__WEBPACK_IMPORTED_MODULE_1__["Transport"]; });

/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transports/index.js */ "./node_modules/engine.io-client/build/esm/transports/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transports", function() { return _transports_index_js__WEBPACK_IMPORTED_MODULE_2__["transports"]; });

/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "installTimerFunctions", function() { return _util_js__WEBPACK_IMPORTED_MODULE_3__["installTimerFunctions"]; });



const protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__["Socket"].protocol;





/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/socket.js":
/*!***********************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/socket.js ***!
  \\***********************************************************/
/*! exports provided: Socket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return Socket; });
/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transports/index.js */ "./node_modules/engine.io-client/build/esm/transports/index.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(parseqs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(parseuri__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");






class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__["Emitter"] {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri or options
     * @param {Object} opts - options
     * @api public
     */
    constructor(uri, opts = {}) {
        super();
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            uri = parseuri__WEBPACK_IMPORTED_MODULE_3___default()(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol === "https" || uri.protocol === "wss";
            opts.port = uri.port;
            if (uri.query)
                opts.query = uri.query;
        }
        else if (opts.host) {
            opts.hostname = parseuri__WEBPACK_IMPORTED_MODULE_3___default()(opts.host).host;
        }
        Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["installTimerFunctions"])(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
            opts.port ||
                (typeof location !== "undefined" && location.port
                    ? location.port
                    : this.secure
                        ? "443"
                        : "80");
        this.transports = opts.transports || ["polling", "websocket"];
        this.readyState = "";
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: true
        }, opts);
        this.opts.path = this.opts.path.replace(/\\/$/, "") + "/";
        if (typeof this.opts.query === "string") {
            this.opts.query = parseqs__WEBPACK_IMPORTED_MODULE_2___default.a.decode(this.opts.query);
        }
        // set on handshake
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        // set on heartbeat
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                addEventListener("beforeunload", () => {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                }, false);
            }
            if (this.hostname !== "localhost") {
                this.offlineEventListener = () => {
                    this.onClose("transport close");
                };
                addEventListener("offline", this.offlineEventListener, false);
            }
        }
        this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} transport name
     * @return {Transport}
     * @api private
     */
    createTransport(name) {
        const query = clone(this.opts.query);
        // append engine.io protocol identifier
        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__["protocol"];
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        });
        return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__["transports"][name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @api private
     */
    open() {
        let transport;
        if (this.opts.rememberUpgrade &&
            Socket.priorWebsocketSuccess &&
            this.transports.indexOf("websocket") !== -1) {
            transport = "websocket";
        }
        else if (0 === this.transports.length) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        else {
            transport = this.transports[0];
        }
        this.readyState = "opening";
        // Retry with the next transport if the transport is disabled (jsonp: false)
        try {
            transport = this.createTransport(transport);
        }
        catch (e) {
            this.transports.shift();
            this.open();
            return;
        }
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @api private
     */
    setTransport(transport) {
        if (this.transport) {
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on("drain", this.onDrain.bind(this))
            .on("packet", this.onPacket.bind(this))
            .on("error", this.onError.bind(this))
            .on("close", () => {
            this.onClose("transport close");
        });
    }
    /**
     * Probes a transport.
     *
     * @param {String} transport name
     * @api private
     */
    probe(name) {
        let transport = this.createTransport(name);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
            if (failed)
                return;
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", msg => {
                if (failed)
                    return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport)
                        return;
                    Socket.priorWebsocketSuccess = "websocket" === transport.name;
                    this.transport.pause(() => {
                        if (failed)
                            return;
                        if ("closed" === this.readyState)
                            return;
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: "upgrade" }]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = err => {
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
    }
    /**
     * Called when connection is deemed open.
     *
     * @api private
     */
    onOpen() {
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
        // we check for \`readyState\` in case an \`open\`
        // listener already closed the socket
        if ("open" === this.readyState &&
            this.opts.upgrade &&
            this.transport.pause) {
            let i = 0;
            const l = this.upgrades.length;
            for (; i < l; i++) {
                this.probe(this.upgrades[i]);
            }
        }
    }
    /**
     * Handles a packet.
     *
     * @api private
     */
    onPacket(packet) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            switch (packet.type) {
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this.resetPingTimeout();
                    this.sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this.onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
        else {
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @api private
     */
    onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState)
            return;
        this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @api private
     */
    resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
            this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
            this.pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on \`drain\` event
     *
     * @api private
     */
    onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on \`drain\`
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @api private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length) {
            this.transport.send(this.writeBuffer);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on \`drain\`
            this.prevBufferLen = this.writeBuffer.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Sends a message.
     *
     * @param {String} message.
     * @param {Function} callback function.
     * @param {Object} options.
     * @return {Socket} for chaining.
     * @api public
     */
    write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} callback function.
     * @api private
     */
    sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     *
     * @api public
     */
    close() {
        const close = () => {
            this.onClose("forced close");
            this.transport.close();
        };
        const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = () => {
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", () => {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @api private
     */
    onError(err) {
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @api private
     */
    onClose(reason, desc) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            // clear timers
            this.clearTimeoutFn(this.pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (typeof removeEventListener === "function") {
                removeEventListener("offline", this.offlineEventListener, false);
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, desc);
            // clean buffers after, so users can still
            // grab the buffers on \`close\` event
            this.writeBuffer = [];
            this.prevBufferLen = 0;
        }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} server upgrades
     * @api private
     *
     */
    filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
Socket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__["protocol"];
function clone(obj) {
    const o = {};
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            o[i] = obj[i];
        }
    }
    return o;
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transport.js":
/*!**************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transport.js ***!
  \\**************************************************************/
/*! exports provided: Transport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transport", function() { return Transport; });
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/engine.io-client/build/esm/util.js");



class Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__["Emitter"] {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */
    constructor(opts) {
        super();
        this.writable = false;
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["installTimerFunctions"])(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.readyState = "";
        this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} str
     * @return {Transport} for chaining
     * @api protected
     */
    onError(msg, desc) {
        const err = new Error(msg);
        // @ts-ignore
        err.type = "TransportError";
        // @ts-ignore
        err.description = desc;
        super.emit("error", err);
        return this;
    }
    /**
     * Opens the transport.
     *
     * @api public
     */
    open() {
        if ("closed" === this.readyState || "" === this.readyState) {
            this.readyState = "opening";
            this.doOpen();
        }
        return this;
    }
    /**
     * Closes the transport.
     *
     * @api public
     */
    close() {
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api public
     */
    send(packets) {
        if ("open" === this.readyState) {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
        }
    }
    /**
     * Called upon open
     *
     * @api protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emit("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @api protected
     */
    onData(data) {
        const packet = Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_0__["decodePacket"])(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @api protected
     */
    onPacket(packet) {
        super.emit("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @api protected
     */
    onClose() {
        this.readyState = "closed";
        super.emit("close");
    }
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/index.js":
/*!*********************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/index.js ***!
  \\*********************************************************************/
/*! exports provided: transports */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transports", function() { return transports; });
/* harmony import */ var _polling_xhr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling-xhr.js */ "./node_modules/engine.io-client/build/esm/transports/polling-xhr.js");
/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket.js */ "./node_modules/engine.io-client/build/esm/transports/websocket.js");


const transports = {
    websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__["WS"],
    polling: _polling_xhr_js__WEBPACK_IMPORTED_MODULE_0__["XHR"]
};


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/polling-xhr.js":
/*!***************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/polling-xhr.js ***!
  \\***************************************************************************/
/*! exports provided: XHR, Request */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHR", function() { return XHR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony import */ var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xmlhttprequest.js */ "./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js");
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polling.js */ "./node_modules/engine.io-client/build/esm/transports/polling.js");
/* global attachEvent */





/**
 * Empty function
 */
function empty() { }
const hasXHR2 = (function () {
    const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
        xdomain: false
    });
    return null != xhr.responseType;
})();
class XHR extends _polling_js__WEBPACK_IMPORTED_MODULE_4__["Polling"] {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @api public
     */
    constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty \`location.port\`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
            this.xs = opts.secure !== isSSL;
        }
        /**
         * XHR supports binary
         */
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @api private
     */
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @api private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data
        });
        req.on("success", fn);
        req.on("error", err => {
            this.onError("xhr post error", err);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @api private
     */
    doPoll() {
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", err => {
            this.onError("xhr poll error", err);
        });
        this.pollXhr = req;
    }
}
class Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3__["Emitter"] {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @api public
     */
    constructor(uri, opts) {
        super();
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["installTimerFunctions"])(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = false !== opts.async;
        this.data = undefined !== opts.data ? opts.data : null;
        this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @api private
     */
    create() {
        const opts = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["pick"])(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        const xhr = (this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_0__["default"](opts));
        try {
            xhr.open(this.method, this.uri, this.async);
            try {
                if (this.opts.extraHeaders) {
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this.opts.extraHeaders) {
                        if (this.opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this.method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this.opts.withCredentials;
            }
            if (this.opts.requestTimeout) {
                xhr.timeout = this.opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this.onLoad();
                }
                else {
                    // make sure the \`error\` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            xhr.send(this.data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this.onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
        }
    }
    /**
     * Called upon successful response.
     *
     * @api private
     */
    onSuccess() {
        this.emit("success");
        this.cleanup();
    }
    /**
     * Called if we have data.
     *
     * @api private
     */
    onData(data) {
        this.emit("data", data);
        this.onSuccess();
    }
    /**
     * Called upon error.
     *
     * @api private
     */
    onError(err) {
        this.emit("error", err);
        this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @api private
     */
    cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
            return;
        }
        this.xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this.xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this.index];
        }
        this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @api private
     */
    onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
            this.onData(data);
        }
    }
    /**
     * Aborts the request.
     *
     * @api public
     */
    abort() {
        this.cleanup();
    }
}
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in _globalThis_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/polling.js":
/*!***********************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/polling.js ***!
  \\***********************************************************************/
/*! exports provided: Polling */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polling", function() { return Polling; });
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ "./node_modules/engine.io-client/build/esm/transport.js");
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(yeast__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(parseqs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");




class Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__["Transport"] {
    constructor() {
        super(...arguments);
        this.polling = false;
    }
    /**
     * Transport name.
     */
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */
    doOpen() {
        this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            this.readyState = "paused";
            onPause();
        };
        if (this.polling || !this.writable) {
            let total = 0;
            if (this.polling) {
                total++;
                this.once("pollComplete", function () {
                    --total || pause();
                });
            }
            if (!this.writable) {
                total++;
                this.once("drain", function () {
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @api public
     */
    poll() {
        this.polling = true;
        this.doPoll();
        this.emit("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @api private
     */
    onData(data) {
        const callback = packet => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose();
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__["decodePayload"])(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this.polling = false;
            this.emit("pollComplete");
            if ("open" === this.readyState) {
                this.poll();
            }
            else {
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @api private
     */
    doClose() {
        const close = () => {
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */
    write(packets) {
        this.writable = false;
        Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__["encodePayload"])(packets, data => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emit("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */
    uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = yeast__WEBPACK_IMPORTED_MODULE_1___default()();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        // avoid port if default for schema
        if (this.opts.port &&
            (("https" === schema && Number(this.opts.port) !== 443) ||
                ("http" === schema && Number(this.opts.port) !== 80))) {
            port = ":" + this.opts.port;
        }
        const encodedQuery = parseqs__WEBPACK_IMPORTED_MODULE_2___default.a.encode(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (schema +
            "://" +
            (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
            port +
            this.opts.path +
            (encodedQuery.length ? "?" + encodedQuery : ""));
    }
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js":
/*!*********************************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js ***!
  \\*********************************************************************************************/
/*! exports provided: nextTick, WebSocket, usingBrowserWebSocket, defaultBinaryType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextTick", function() { return nextTick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocket", function() { return WebSocket; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "usingBrowserWebSocket", function() { return usingBrowserWebSocket; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultBinaryType", function() { return defaultBinaryType; });
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");

const nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return cb => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
const WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"].WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"].MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/websocket.js":
/*!*************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/websocket.js ***!
  \\*************************************************************************/
/*! exports provided: WS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WS", function() { return WS; });
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ "./node_modules/engine.io-client/build/esm/transport.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(parseqs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(yeast__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./websocket-constructor.js */ "./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js");
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");






// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__["Transport"] {
    /**
     * WebSocket transport constructor.
     *
     * @api {Object} connection options
     * @api public
     */
    constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Transport name.
     *
     * @api public
     */
    get name() {
        return "websocket";
    }
    /**
     * Opens socket.
     *
     * @api private
     */
    doOpen() {
        if (!this.check()) {
            // let probe timeout
            return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : Object(_util_js__WEBPACK_IMPORTED_MODULE_3__["pick"])(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws =
                _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["usingBrowserWebSocket"] && !isReactNative
                    ? protocols
                        ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"](uri, protocols)
                        : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"](uri)
                    : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"](uri, protocols, opts);
        }
        catch (err) {
            return this.emit("error", err);
        }
        this.ws.binaryType = this.socket.binaryType || _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["defaultBinaryType"];
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @api private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = this.onClose.bind(this);
        this.ws.onmessage = ev => this.onData(ev.data);
        this.ws.onerror = e => this.onError("websocket error", e);
    }
    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_5__["encodePacket"])(packet, this.supportsBinary, data => {
                // always create a new object (GH-437)
                const opts = {};
                if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["usingBrowserWebSocket"]) {
                    if (packet.options) {
                        opts.compress = packet.options.compress;
                    }
                    if (this.opts.perMessageDeflate) {
                        const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
                        if (len < this.opts.perMessageDeflate.threshold) {
                            opts.compress = false;
                        }
                    }
                }
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["usingBrowserWebSocket"]) {
                        // TypeError is thrown when passing the second argument on Safari
                        this.ws.send(data);
                    }
                    else {
                        this.ws.send(data, opts);
                    }
                }
                catch (e) {
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    Object(_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["nextTick"])(() => {
                        this.writable = true;
                        this.emit("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    /**
     * Closes socket.
     *
     * @api private
     */
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */
    uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";
        // avoid port if default for schema
        if (this.opts.port &&
            (("wss" === schema && Number(this.opts.port) !== 443) ||
                ("ws" === schema && Number(this.opts.port) !== 80))) {
            port = ":" + this.opts.port;
        }
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = yeast__WEBPACK_IMPORTED_MODULE_2___default()();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        const encodedQuery = parseqs__WEBPACK_IMPORTED_MODULE_1___default.a.encode(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (schema +
            "://" +
            (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
            port +
            this.opts.path +
            (encodedQuery.length ? "?" + encodedQuery : ""));
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */
    check() {
        return (!!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"] &&
            !("__initialize" in _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"] && this.name === WS.prototype.name));
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js":
/*!**************************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js ***!
  \\**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var has_cors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! has-cors */ "./node_modules/has-cors/index.js");
/* harmony import */ var has_cors__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(has_cors__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");
// browser shim for xmlhttprequest module


/* harmony default export */ __webpack_exports__["default"] = (function (opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors__WEBPACK_IMPORTED_MODULE_0___default.a)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__["default"][["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
});


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/util.js":
/*!*********************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/util.js ***!
  \\*********************************************************/
/*! exports provided: pick, installTimerFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return pick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "installTimerFunctions", function() { return installTimerFunctions; });
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");

function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = setTimeout;
const NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
    else {
        obj.setTimeoutFn = setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
        obj.clearTimeoutFn = clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
}


/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/commons.js":
/*!************************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/commons.js ***!
  \\************************************************************/
/*! exports provided: PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PACKET_TYPES", function() { return PACKET_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PACKET_TYPES_REVERSE", function() { return PACKET_TYPES_REVERSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR_PACKET", function() { return ERROR_PACKET; });
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach(key => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };



/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/decodePacket.browser.js":
/*!*************************************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/decodePacket.browser.js ***!
  \\*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/esm/commons.js");
/* harmony import */ var _socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/base64-arraybuffer */ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js");


const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType)
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
    }
    const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES_REVERSE"][type];
    if (!packetType) {
        return _commons_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_PACKET"];
    }
    return encodedPacket.length > 1
        ? {
            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES_REVERSE"][type],
            data: encodedPacket.substring(1)
        }
        : {
            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES_REVERSE"][type]
        };
};
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = Object(_socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__["decode"])(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
            return data; // assuming the data is already an ArrayBuffer
    }
};
/* harmony default export */ __webpack_exports__["default"] = (decodePacket);


/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/encodePacket.browser.js":
/*!*************************************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/encodePacket.browser.js ***!
  \\*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/esm/commons.js");

const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = obj => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES"][type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + content);
    };
    return fileReader.readAsDataURL(data);
};
/* harmony default export */ __webpack_exports__["default"] = (encodePacket);


/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/index.js":
/*!**********************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/index.js ***!
  \\**********************************************************/
/*! exports provided: protocol, encodePacket, encodePayload, decodePacket, decodePayload */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return protocol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodePayload", function() { return encodePayload; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePayload", function() { return decodePayload; });
/* harmony import */ var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encodePacket.js */ "./node_modules/engine.io-parser/build/esm/encodePacket.browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodePacket", function() { return _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decodePacket.js */ "./node_modules/engine.io-parser/build/esm/decodePacket.browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodePacket", function() { return _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });



const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        Object(_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__["default"])(packet, false, encodedPacket => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = Object(_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__["default"])(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
const protocol = 4;



/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\\
  !*** ./node_modules/has-cors/index.js ***!
  \\****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\\
  !*** ./node_modules/ieee754/index.js ***!
  \\***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\\
  !*** ./node_modules/isarray/index.js ***!
  \\***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\\
  !*** ./node_modules/parseqs/index.js ***!
  \\***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\\
  !*** ./node_modules/parseuri/index.js ***!
  \\****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/index.js":
/*!**********************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/index.js ***!
  \\**********************************************************/
/*! exports provided: protocol, Manager, Socket, io, connect, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return lookup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connect", function() { return lookup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lookup; });
/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.js */ "./node_modules/socket.io-client/build/esm/url.js");
/* harmony import */ var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./manager.js */ "./node_modules/socket.io-client/build/esm/manager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Manager", function() { return _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"]; });

/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./socket.js */ "./node_modules/socket.io-client/build/esm/socket.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return _socket_js__WEBPACK_IMPORTED_MODULE_2__["Socket"]; });

/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return socket_io_parser__WEBPACK_IMPORTED_MODULE_3__["protocol"]; });




/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = Object(_url_js__WEBPACK_IMPORTED_MODULE_0__["url"])(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"](source, opts);
    }
    else {
        if (!cache[id]) {
            cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"](source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. \`io(...)\`) and as a
// namespace (e.g. \`io.connect(...)\`), for backward compatibility
Object.assign(lookup, {
    Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"],
    Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__["Socket"],
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */

/**
 * Expose constructors for standalone build.
 *
 * @public
 */



/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/manager.js":
/*!************************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/manager.js ***!
  \\************************************************************/
/*! exports provided: Manager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Manager", function() { return Manager; });
/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-client */ "./node_modules/engine.io-client/build/esm/index.js");
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./socket.js */ "./node_modules/socket.io-client/build/esm/socket.js");
/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./on.js */ "./node_modules/socket.io-client/build/esm/on.js");
/* harmony import */ var backo2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");
/* harmony import */ var backo2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(backo2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__);






class Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__["Emitter"] {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__["installTimerFunctions"])(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2__WEBPACK_IMPORTED_MODULE_4___default.a({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport \`socket\`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__["Socket"](this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit \`open\`
        const openSubDestroy = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        // emit \`error\`
        const errorSub = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "error", (err) => {
            self.cleanup();
            self._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                self.maybeReconnectOnOpen();
            }
        });
        if (false !== this._timeout) {
            const timeout = this._timeout;
            if (timeout === 0) {
                openSubDestroy(); // prevents a race condition with the 'open' event
            }
            // set timer
            const timer = this.setTimeoutFn(() => {
                openSubDestroy();
                socket.close();
                // @ts-ignore
                socket.emit("error", new Error("timeout"));
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(function subDestroy() {
                clearTimeout(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push(Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "ping", this.onping.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "data", this.ondata.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "error", this.onerror.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "close", this.onclose.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        this.decoder.add(data);
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        this.emitReserved("packet", packet);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given \`nsp\`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__["Socket"](this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine)
            this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason) {
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(function subDestroy() {
                clearTimeout(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/on.js":
/*!*******************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/on.js ***!
  \\*******************************************************/
/*! exports provided: on */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/socket.js":
/*!***********************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/socket.js ***!
  \\***********************************************************/
/*! exports provided: Socket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return Socket; });
/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./on.js */ "./node_modules/socket.io-client/build/esm/on.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__);



/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__["Emitter"] {
    /**
     * \`Socket\` constructor.
     *
     * @public
     */
    constructor(io, nsp, opts) {
        super();
        this.connected = false;
        this.disconnected = true;
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "open", this.onopen.bind(this)),
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "packet", this.onpacket.bind(this)),
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "error", this.onerror.bind(this)),
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @public
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for connect()
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a \`message\` event.
     *
     * @return self
     * @public
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override \`emit\`.
     * If the event is in \`events\`, it's emitted normally.
     *
     * @return self
     * @public
     */
    emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev + '" is a reserved event name');
        }
        args.unshift(ev);
        const packet = {
            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = this.io.engine &&
            this.io.engine.transport &&
            this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
        }
        else if (this.connected) {
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    this.sendBuffer.splice(i, 1);
                }
            }
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks[id] = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, [null, ...args]);
        };
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine \`open\`.
     *
     * @private
     */
    onopen() {
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT, data });
            });
        }
        else {
            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT, data: this.auth });
        }
    }
    /**
     * Called upon engine or manager \`error\`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine \`close\`.
     *
     * @param reason
     * @private
     */
    onclose(reason) {
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emitReserved("disconnect", reason);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT:
                if (packet.data && packet.data.sid) {
                    const id = packet.data.sid;
                    this.onconnect(id);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].ACK:
                this.onack(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        if (null != packet.id) {
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            self.packet({
                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if ("function" === typeof ack) {
            ack.apply(this, packet.data);
            delete this.acks[packet.id];
        }
        else {
        }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id) {
        this.id = id;
        this.connected = true;
        this.disconnected = false;
        this.emitBuffered();
        this.emitReserved("connect");
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => this.packet(packet));
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually.
     *
     * @return self
     * @public
     */
    disconnect() {
        if (this.connected) {
            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for disconnect()
     *
     * @return self
     * @public
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if \`true\`, compresses the sending data
     * @return self
     * @public
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @returns self
     * @public
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * \`\`\`
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     * \`\`\`
     *
     * @returns self
     * @public
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */
    listenersAny() {
        return this._anyListeners || [];
    }
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/url.js":
/*!********************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/url.js ***!
  \\********************************************************/
/*! exports provided: url */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "url", function() { return url; });
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(parseuri__WEBPACK_IMPORTED_MODULE_0__);

/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\\/\\//.test(uri)) {
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        obj = parseuri__WEBPACK_IMPORTED_MODULE_0___default()(uri);
    }
    // make sure we treat \`localhost:80\` and \`localhost\` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/binary.js":
/*!*****************************************************************************************!*\\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/binary.js ***!
  \\*****************************************************************************************/
/*! exports provided: deconstructPacket, reconstructPacket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deconstructPacket", function() { return deconstructPacket; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reconstructPacket", function() { return reconstructPacket; });
/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-binary.js */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js");

/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_0__["isBinary"])(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    packet.attachments = undefined; // no longer useful
    return packet;
}
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder) {
        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js":
/*!****************************************************************************************!*\\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js ***!
  \\****************************************************************************************/
/*! exports provided: protocol, PacketType, Encoder, Decoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return protocol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PacketType", function() { return PacketType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Encoder", function() { return Encoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Decoder", function() { return Decoder; });
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/binary.js");
/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-binary.js */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js");



/**
 * Protocol version.
 *
 * @public
 */
const protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__["hasBinary"])(obj)) {
                obj.type =
                    obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK;
                return this.encodeAsBinary(obj);
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than \`/\`
        // we append it followed by a comma \`,\`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data);
        }
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__["deconstructPacket"])(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__["Emitter"] {
    constructor() {
        super();
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            packet = this.decodeString(obj);
            if (packet.type === PacketType.BINARY_EVENT ||
                packet.type === PacketType.BINARY_ACK) {
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__["isBinary"])(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        return p;
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return typeof payload === "object";
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || typeof payload === "object";
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return Array.isArray(payload) && payload.length > 0;
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
        }
    }
}
function tryParse(str) {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        return false;
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__["reconstructPacket"])(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js":
/*!********************************************************************************************!*\\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js ***!
  \\********************************************************************************************/
/*! exports provided: isBinary, hasBinary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBinary", function() { return isBinary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasBinary", function() { return hasBinary; });
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\\
  !*** (webpack)/buildin/global.js ***!
  \\***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \\*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\\
  !*** ./node_modules/yeast/index.js ***!
  \\*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the \`yeast\`, \`encode\` and \`decode\` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ "./package.json":
/*!**********************!*\\
  !*** ./package.json ***!
  \\**********************/
/*! exports provided: name, version, description, module, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */
/***/ (function(module) {

module.exports = JSON.parse("{\\"name\\":\\"imjoy-rpc\\",\\"version\\":\\"0.5.9\\",\\"description\\":\\"Remote procedure calls for ImJoy.\\",\\"module\\":\\"index.js\\",\\"scripts\\":{\\"build\\":\\"rm -rf dist && npm run build-umd\\",\\"build-umd\\":\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\",\\"watch\\":\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\",\\"publish-npm\\":\\"npm install && npm run build && npm publish\\",\\"serve\\":\\"webpack-dev-server\\",\\"stats\\":\\"webpack --profile --json > stats.json\\",\\"stats-prod\\":\\"webpack --profile --json --mode production > stats-prod.json\\",\\"analyze\\":\\"webpack-bundle-analyzer -p 9999 stats.json\\",\\"analyze-prod\\":\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\",\\"clean\\":\\"rimraf dist/*\\",\\"deploy\\":\\"npm run build && node deploy-site.js\\",\\"format\\":\\"prettier --write \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"check-format\\":\\"prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"test\\":\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\",\\"test-watch\\":\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\"},\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\"},\\"keywords\\":[\\"imjoy\\",\\"rpc\\"],\\"author\\":\\"imjoy-team <imjoy.team@gmail.com>\\",\\"license\\":\\"MIT\\",\\"bugs\\":{\\"url\\":\\"https://github.com/imjoy-team/imjoy-rpc/issues\\"},\\"homepage\\":\\"https://github.com/imjoy-team/imjoy-rpc\\",\\"dependencies\\":{\\"@msgpack/msgpack\\":\\"^2.7.1\\",\\"socket.io-client\\":\\"^4.4.1\\"},\\"devDependencies\\":{\\"@babel/core\\":\\"^7.16.12\\",\\"@babel/plugin-syntax-dynamic-import\\":\\"^7.8.3\\",\\"@babel/polyfill\\":\\"^7.12.1\\",\\"@babel/preset-env\\":\\"^7.16.11\\",\\"@types/requirejs\\":\\"^2.1.34\\",\\"babel-core\\":\\"^6.26.0\\",\\"babel-eslint\\":\\"^10.1.0\\",\\"babel-loader\\":\\"^8.2.3\\",\\"babel-runtime\\":\\"^6.26.0\\",\\"chai\\":\\"^4.3.6\\",\\"clean-webpack-plugin\\":\\"^0.1.19\\",\\"copy-webpack-plugin\\":\\"^5.1.2\\",\\"eslint\\":\\"^6.8.0\\",\\"eslint-config-prettier\\":\\"^4.2.0\\",\\"eslint-loader\\":\\"^4.0.2\\",\\"file-loader\\":\\"^0.11.2\\",\\"fs-extra\\":\\"^0.30.0\\",\\"gh-pages\\":\\"^2.0.1\\",\\"html-loader\\":\\"^0.5.5\\",\\"html-webpack-plugin\\":\\"^3.2.0\\",\\"json-loader\\":\\"^0.5.4\\",\\"karma\\":\\"^6.3.12\\",\\"karma-chrome-launcher\\":\\"^3.1.0\\",\\"karma-firefox-launcher\\":\\"^1.3.0\\",\\"karma-mocha\\":\\"^1.3.0\\",\\"karma-sourcemap-loader\\":\\"^0.3.8\\",\\"karma-spec-reporter\\":\\"0.0.32\\",\\"karma-webpack\\":\\"^4.0.2\\",\\"lerna\\":\\"^3.22.1\\",\\"lodash.debounce\\":\\"^4.0.8\\",\\"mocha\\":\\"^7.2.0\\",\\"postcss\\":\\"^7.0.36\\",\\"prettier\\":\\"^1.6.1\\",\\"rimraf\\":\\"^2.6.2\\",\\"schema-utils\\":\\"^0.4.3\\",\\"style-loader\\":\\"^0.18.1\\",\\"url-loader\\":\\"^0.5.9\\",\\"webpack\\":\\"^4.46.0\\",\\"webpack-bundle-analyzer\\":\\"^3.9.0\\",\\"webpack-cli\\":\\"^3.3.12\\",\\"webpack-dev-server\\":\\"^3.11.3\\",\\"webpack-merge\\":\\"^4.1.1\\",\\"workbox-webpack-plugin\\":\\"^4.3.1\\",\\"worker-loader\\":\\"^2.0.0\\",\\"write-file-webpack-plugin\\":\\"^4.5.1\\"},\\"eslintConfig\\":{\\"globals\\":{\\"document\\":true,\\"window\\":true}}}");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\\
  !*** ./src/main.js ***!
  \\*********************/
/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitForInitialization", function() { return waitForInitialization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupRPC", function() { return setupRPC; });
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.webworker.js */ "./src/plugin.webworker.js");
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginIframe.js */ "./src/pluginIframe.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirements"]; });

/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["RPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["API_VERSION"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_4__["version"]; });

/**
 * Contains the code executed in the sandboxed frame under web-browser
 *
 * Tries to create a Web-Worker inside the frame and set up the
 * communication between the worker and the parent window. Some
 * browsers restrict creating a worker inside a sandboxed iframe - if
 * this happens, the plugin initialized right inside the frame (in the
 * same thread)
 */







function _inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

function _inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
/**
 * Initializes the plugin inside a web worker. May throw an exception
 * in case this was not permitted by the browser.
 */


function setupWebWorker(config) {
  if (!config.allow_execution) throw new Error("web-worker plugin can only work with allow_execution=true");
  let broadcastChannel = null;

  if (config.broadcastChannel) {
    broadcastChannel = new BroadcastChannel(config.broadcastChannel);
  }

  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker
  // initialization without exception, handling this with timeout

  const fallbackTimeout = setTimeout(function () {
    worker.terminate();
    console.warn(\`Plugin failed to start as a web-worker, running in an iframe instead.\`);
    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
  }, 2000);
  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])(); // forwarding messages between the worker and parent window

  worker.addEventListener("message", function (e) {
    let transferables = undefined;
    const m = e.data;

    if (m.type === "worker-ready") {
      // send config to the worker
      worker.postMessage({
        type: "connectRPC",
        config: config
      });
      clearTimeout(fallbackTimeout);
      return;
    } else if (m.type === "initialized") {
      // complete the missing fields
      m.config = Object.assign({}, config, m.config);
      m.origin = window.location.origin;
      m.peer_id = peer_id;
    } else if (m.type === "imjoy_remote_api_ready") {
      // if it's a webworker, there will be no api object returned
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: null
      }));
    } else if (m.type === "cacheRequirements" && typeof cache_requirements === "function") {
      cache_requirements(m.requirements);
    } else if (m.type === "disconnect") {
      worker.terminate();
    } else {
      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }
    }

    if (broadcastChannel) broadcastChannel.postMessage(m);else parent.postMessage(m, config.target_origin || "*", transferables);
  });
  (broadcastChannel || window).addEventListener("message", function (e) {
    if (e.type === "message" && (broadcastChannel || config.target_origin === "*" || e.origin === config.target_origin)) {
      let transferables = undefined;
      const m = e.data;

      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }

      if (m.peer_id === peer_id) {
        worker.postMessage(m, transferables);
      } else if (config.debug) {
        console.log(\`connection peer id mismatch \${m.peer_id} !== \${peer_id}\`);
      }
    }
  });
}

function waitForInitialization(config) {
  if (_inWebWorker()) {
    globalThis.parent = self;
  }

  config = config || {};

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
    config.enable_service_worker = false;
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  const targetOrigin = config.target_origin || "*";

  if (config.credential_required && typeof config.verify_credential !== "function") {
    throw new Error("Please also provide the \`verify_credential\` function with \`credential_required\`.");
  }

  if (config.credential_required && targetOrigin === "*") {
    throw new Error("\`target_origin\` was set to \`*\` with \`credential_required=true\`, there is a security risk that you may leak the credential to website from other origin. Please specify the \`target_origin\` explicitly.");
  }

  const done = () => {
    globalThis.removeEventListener("message", handleEvent);
  };

  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();

  const handleEvent = e => {
    if (e.type === "message" && (!e.origin || targetOrigin === "*" || e.origin === targetOrigin)) {
      if (e.data.type === "initialize") {
        done();

        if (e.data.peer_id !== peer_id) {
          // TODO: throw an error when we are sure all the peers will send the peer_id
          console.warn(\`\${e.data.config && e.data.config.name}: connection peer id mismatch \${e.data.peer_id} !== \${peer_id}\`);
        }

        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client
        // otherwise take the setting from the core

        if (targetOrigin !== "*") {
          cfg.target_origin = targetOrigin;
        }

        if (config.credential_required) {
          config.verify_credential(cfg.credential).then(result => {
            if (result && result.auth && !result.error) {
              // pass the authentication information with tokens
              cfg.auth = result.auth;
              setupRPC(cfg).then(() => {
                console.log("ImJoy RPC loaded successfully!");
              });
            } else {
              throw new Error("Failed to verify the credentail:" + (result && result.error));
            }
          });
        } else {
          setupRPC(cfg).then(() => {
            console.log("ImJoy RPC loaded successfully!");
          });
        }
      } else {
        throw new Error(\`unrecognized message: \${e.data}\`);
      }
    }
  };

  globalThis.addEventListener("message", handleEvent);

  if (_inWebWorker()) {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    });
  } else {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    }, "*");
  }
}
function setupRPC(config) {
  config = config || {};
  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["normalizeConfig"])(config);

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  return new Promise((resolve, reject) => {
    const handleEvent = e => {
      const api = e.detail;

      if (config.expose_api_globally) {
        globalThis.api = api;
      } // imjoy plugin api


      resolve(api);
      globalThis.removeEventListener("imjoy_remote_api_ready", handleEvent);
    };

    if (_inIframe()) {
      if (config.type === "web-worker") {
        try {
          setupWebWorker(config);
        } catch (e) {
          // fallback to iframe
          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
        }
      } else if (["rpc-window", "rpc-worker", "iframe", "window"].includes(config.type)) {
        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
      } else {
        console.error("Unsupported plugin type: " + config.type);
        reject("Unsupported plugin type: " + config.type);
        return;
      }

      globalThis.addEventListener("imjoy_remote_api_ready", handleEvent);
    } else if (_inWebWorker()) {
      // inside a webworker
      Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
    } else {
      reject(new Error("imjoy-rpc should only run inside an iframe or a webworker."));
    }
  });
}

/***/ }),

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\\
  !*** ./src/plugin.webworker.js ***!
  \\*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\"\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\"./src/plugin.webworker.js\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\"./src/plugin.webworker.js\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\"./src/pluginCore.js\\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \\"undefined\\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\\"This script can only loaded in a webworker\\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \\"data:text/javascript;charset=utf-8,\\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"MessageEmitter\\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\\"message\\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \\"initialized\\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\\"beforeDisconnect\\");\\n    self.close();\\n    this._fire(\\"disconnected\\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \\"requirements\\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"loadRequirementsInWebworker\\"])(code.requirements);\\n    } else if (code.type === \\"script\\") {\\n      try {\\n        if (code.attrs.type === \\"module\\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \\"unsupported code type.\\";\\n    }\\n    if (code.type === \\"requirements\\") {\\n      self.postMessage({\\n        type: \\"cacheRequirements\\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \\"web-worker\\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \\"javascript\\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\"API_VERSION\\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\\"connectRPC\\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\"connectRPC\\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \\"worker-ready\\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \\"./src/pluginCore.js\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"connectRPC\\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\"RPC\\"](connection, config, codecs);\\n  rpc.on(\\"getInterface\\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\\"remoteReady\\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\\"name\\"] || !config[\\"encoder\\"] && !config[\\"decoder\\"]) {\\n        throw new Error(\\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\\"Remove duplicated codec: \\" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\\"name\\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \\"imjoy_remote_api_ready\\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \\"function\\") {\\n      const msg = \\"A function may only be subsribed to the event, \\" + type + \\" was provided instead\\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/rpc.js\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"API_VERSION\\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"RPC\\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \\"0.2.3\\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\\"undefined index\\");\\n  if (typeof is === \\"string\\") return indexObject(obj, is.split(\\".\\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"MessageEmitter\\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(\`connection.execute not implemented (in \\"\${name}\\")\`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\\"remoteIdle\\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\\"remoteBusy\\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \\"initialized\\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\\"interfaceAvailable\\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\\"interfaceSetAsRemote\\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\\"interface is not set.\\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \\"setInterface\\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(\`Object (id=\${objectId}) not found.\`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\\"disposed\\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \\"disposeObject\\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\\"Invalid object\\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\\"init\\", this.init);\\n\\n    this._connection.on(\\"execute\\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \\"executed\\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"executed\\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\\"method\\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\\".\\")) {\\n          const tmp = data.name.split(\\".\\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\\".\\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"callback\\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"disposeObject\\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"setInterface\\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\\"getInterface\\", () => {\\n      this._fire(\\"getInterface\\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\\"interfaceAvailable\\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"interfaceSetAsRemote\\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\\"interfaceSetAsRemote\\");\\n    });\\n\\n    this._connection.on(\\"disconnect\\", () => {\\n      this._fire(\\"beforeDisconnect\\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\\"disconnected\\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \\"getInterface\\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \\"dtype doesn't match the type of the array: \\" + _dtype + \\" != \\" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \\"ndarray\\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\\"remoteReady\\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \\"/\\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \\"register\\" || name === \\"registerService\\" || name === \\"register_service\\" || name === \\"export\\" || name === \\"on\\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \\"method\\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \\"interfaceSetAsRemote\\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \\"number\\" || aType === \\"string\\" || aType === \\"boolean\\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \\"function\\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\\"objectId is not specified.\\");\\n        bObject = {\\n          _rtype: \\"interface\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \\"callback\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \\"undefined\\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \\"undefined\\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \\"error\\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \\"undefined\\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \\"undefined\\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \\"undefined\\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \\"undefined\\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \\"undefined\\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \\"blob\\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject);\\n      bObject = {\\n        _rtype: \\"typedarray\\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"memoryview\\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \\"set\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \\"orderedmap\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\\"Please instantiate the class before exportting it.\\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\\"Unsupported interface type\\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \\"string\\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \\"constructor\\") continue;\\n\\n          if (k.startsWith(\\"_\\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \\"string\\" ? asInterface + \\".\\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \\"function\\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \\"function\\") {\\n          aObject.on(\\"close\\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \\"object\\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n\\n      for (let k of keys) {\\n        if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \\"imjoy-rpc: Unsupported data type:\\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\\"Failed to encode object\\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\\"_rtype\\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \\"callback\\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \\"interface\\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \\"ndarray\\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \\"undefined\\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \\"undefined\\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \\"error\\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \\"file\\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \\"typedarray\\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\\"unsupported dtype: \\" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \\"memoryview\\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \\"blob\\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \\"orderedmap\\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \\"set\\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\\"Failed to decode object\\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \\"callback\\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \\"callback\\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \\"disconnect\\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/utils.js\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"randId\\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"dtypeToTypedArray\\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWindow\\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWebworker\\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirements\\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"normalizeConfig\\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtypeMapping\\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtype\\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"cacheRequirements\\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"setupServiceWorker\\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"urlJoin\\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"MessageEmitter\\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\\"script\\");\\n      scriptTag.src = url;\\n      scriptTag.type = \\"text/javascript\\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \\"loaded\\" || this.readyState === \\"complete\\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \\"string\\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n            if (requirements[i].startsWith(\\"css:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\\"link\\");\\n            link_node.rel = \\"stylesheet\\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".mjs\\") || requirements[i].startsWith(\\"mjs:\\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\\"mjs:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n            if (requirements[i].startsWith(\\"js:\\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"http\\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n          } else {\\n            console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \\"unsupported requirements definition\\";\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n          throw \\"unable to import css in a webworker\\";\\n        } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n          if (requirements[i].startsWith(\\"js:\\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"http\\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n        } else {\\n          console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \\"0.1.0\\";\\n  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;\\n  config.type = config.type || \\"rpc-window\\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \\"*\\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \\"function\\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \\"int8\\",\\n  Int16Array: \\"int16\\",\\n  Int32Array: \\"int32\\",\\n  Uint8Array: \\"uint8\\",\\n  Uint16Array: \\"uint16\\",\\n  Uint32Array: \\"uint32\\",\\n  Float32Array: \\"float32\\",\\n  Float64Array: \\"float64\\",\\n  Array: \\"array\\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \\"add\\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\\"Service worker is not supported.\\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\\"Service worker controller is not available\\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\\"js:\\")) req = req.slice(3);\\n    if (req.startsWith(\\"css:\\")) req = req.slice(4);\\n    if (req.startsWith(\\"cache:\\")) req = req.slice(6);\\n    if (!req.startsWith(\\"http\\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\\"serviceWorker\\" in navigator) {\\n    baseUrl = baseUrl || \\"/\\";\\n    navigator.serviceWorker.register(baseUrl + \\"plugin-service-worker.js\\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\\"ServiceWorker registration successful with scope: \\", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\\"ServiceWorker registration failed: \\", err);\\n    });\\n    targetOrigin = targetOrigin || \\"*\\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \\"function\\") {\\n      throw new Error(\\"config.cache_requirements must be a function\\");\\n    }\\n\\n    window.addEventListener(\\"message\\", function (e) {\\n      if (targetOrigin === \\"*\\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \\"cacheRequirements\\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\\"/\\").replace(/[\\\\/]+/g, \\"/\\").replace(/^(.+):\\\\//, \\"$1://\\").replace(/^file:/, \\"file:/\\").replace(/\\\\/(\\\\?|&|#[^!])/g, \\"$1\\").replace(/\\\\?/g, \\"&\\").replace(\\"&\\", \\"?\\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\\"emit is not implemented\\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\\"unhandled event\\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map", null);
};

/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\\
  !*** ./src/pluginCore.js ***!
  \\***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectRPC", function() { return connectRPC; });
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/**
 * Core plugin script loaded into the plugin process/thread.
 *
 * Initializes the plugin-site API global methods.
 */

function connectRPC(connection, config) {
  config = config || {};
  const codecs = {};
  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__["RPC"](connection, config, codecs);
  rpc.on("getInterface", function () {
    launchConnected();
  });
  rpc.on("remoteReady", function () {
    const api = rpc.getRemote() || {};

    api.registerCodec = function (config) {
      if (!config["name"] || !config["encoder"] && !config["decoder"]) {
        throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");
      } else {
        if (config.type) {
          for (let k of Object.keys(codecs)) {
            if (codecs[k].type === config.type || k === config.name) {
              delete codecs[k];
              console.warn("Remove duplicated codec: " + k);
            }
          }
        }

        codecs[config["name"]] = config;
      }
    };

    api.init = function (config) {
      // register a minimal plugin api
      rpc.setInterface({
        setup() {}

      }, config);
    };

    api.disposeObject = function (obj) {
      rpc.disposeObject(obj);
    };

    api.export = function (_interface, config) {
      rpc.setInterface(_interface, config);
    };

    api.onLoad = function (handler) {
      handler = checkHandler(handler);

      if (connected) {
        handler();
      } else {
        connectedHandlers.push(handler);
      }
    };

    api.dispose = function (_interface) {
      rpc.disconnect();
    };

    api._rpc = rpc;

    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
      self.api = api;
      self.postMessage({
        type: "imjoy_remote_api_ready"
      });
      self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    } else if (typeof window) {
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    }
  });
  let connected = false;
  const connectedHandlers = [];

  const launchConnected = function () {
    if (!connected) {
      connected = true;
      let handler;

      while (handler = connectedHandlers.pop()) {
        handler();
      }
    }
  };

  const checkHandler = function (handler) {
    const type = typeof handler;

    if (type !== "function") {
      const msg = "A function may only be subsribed to the event, " + type + " was provided instead";
      throw new Error(msg);
    }

    return handler;
  };

  return rpc;
}

/***/ }),

/***/ "./src/pluginIframe.js":
/*!*****************************!*\\
  !*** ./src/pluginIframe.js ***!
  \\*****************************/
/*! exports provided: Connection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return setupIframe; });
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the routines loaded by the plugin iframe under web-browser
 * in case when worker failed to initialize
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */


 // Create a new, plain <span> element

function _htmlToElement(html) {
  var template = document.createElement("template");
  html = html.trim(); // Never return a text node of whitespace as the result

  template.innerHTML = html;
  return template.content.firstChild;
}

const _inWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;

async function executeEsModule(content) {
  const dataUri = "data:text/javascript;charset=utf-8," + encodeURIComponent(content);
  await import(
  /* webpackIgnore: true */
  dataUri);
}

class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  }

  connect() {
    this.config.target_origin = this.config.target_origin || "*"; // this will call handleEvent function

    if (this.config.broadcastChannel) {
      this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);
    } else {
      this.broadcastChannel = null;
    }

    if (this.broadcastChannel) this.broadcastChannel.addEventListener("message", this);else globalThis.addEventListener("message", this);
    this.emit({
      type: "initialized",
      config: this.config,
      origin: globalThis.location.origin,
      peer_id: this.peer_id
    });

    this._fire("connected");
  }

  handleEvent(e) {
    if (e.type === "message" && (this.broadcastChannel || this.config.target_origin === "*" || !e.origin || e.origin === this.config.target_origin)) {
      if (e.data.peer_id === this.peer_id) {
        this._fire(e.data.type, e.data);
      } else if (this.config.debug) {
        console.log(\`connection peer id mismatch \${e.data.peer_id} !== \${this.peer_id}\`);
      }
    }
  }

  disconnect() {
    this._fire("beforeDisconnect");

    globalThis.removeEventListener("message", this);

    this._fire("disconnected");
  }

  emit(data) {
    let transferables;
    if (this.broadcastChannel) this.broadcastChannel.postMessage(data);else {
      if (data.__transferables__) {
        transferables = data.__transferables__;
        delete data.__transferables__;
      } else if (_inWebWorker) self.postMessage(data, transferables);else parent.postMessage(data, this.config.target_origin, transferables);
    }
  }

  async execute(code) {
    try {
      if (code.type === "requirements") {
        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirementsInWindow"])(code.requirements);
      } else if (code.type === "script") {
        if (code.src) {
          var script_node = document.createElement("script");
          script_node.setAttribute("type", code.attrs.type);
          script_node.setAttribute("src", code.src);
          document.head.appendChild(script_node);
        } else {
          if (code.content && code.attrs.lang === "javascript") {
            // document.addEventListener("DOMContentLoaded", function(){
            if (code.attrs.type === "module") {
              await executeEsModule(code.content);
            } else {
              eval(code.content);
            } // });

          } else {
            var node = document.createElement("script");

            for (let k in code.attrs) {
              node.setAttribute(k, code.attrs[k]);
            }

            node.appendChild(document.createTextNode(code.content));
            document.body.appendChild(node);
          }
        }
      } else if (code.type === "style") {
        const style_node = document.createElement("style");

        if (code.src) {
          style_node.src = code.src;
        }

        style_node.innerHTML = code.content;
        document.head.appendChild(style_node);
      } else if (code.type === "link") {
        const link_node_ = document.createElement("link");

        if (code.rel) {
          link_node_.rel = code.rel;
        }

        if (code.href) {
          link_node_.href = code.href;
        }

        if (code.attrs && code.attrs.type) {
          link_node_.type = code.attrs.type;
        }

        document.head.appendChild(link_node_);
      } else if (code.type === "html") {
        document.body.appendChild(_htmlToElement(code.content));
      } else {
        throw "unsupported code type.";
      }

      if (_inWebWorker) self.postMessage({
        type: "executed"
      });else parent.postMessage({
        type: "executed"
      }, this.config.target_origin);
    } catch (e) {
      console.error("failed to execute scripts: ", code, e);
      if (_inWebWorker) self.postMessage({
        type: "executed",
        error: e.stack || String(e)
      });else parent.postMessage({
        type: "executed",
        error: e.stack || String(e)
      }, this.config.target_origin);
    }
  }

}
function setupIframe(config) {
  config = config || {};
  config.dedicated_thread = false;
  config.lang = "javascript";
  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"];
  const conn = new Connection(config);
  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(conn, config);
  conn.connect();
}

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\\
  !*** ./src/rpc.js ***!
  \\********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return API_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return RPC; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the RPC object used both by the application
 * site, and by each plugin
 */

const API_VERSION = "0.2.3";
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;

function _appendBuffer(buffer1, buffer2) {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
}

function indexObject(obj, is) {
  if (!is) throw new Error("undefined index");
  if (typeof is === "string") return indexObject(obj, is.split("."));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));
}
/**
 * RPC object represents a single site in the
 * communication protocol between the application and the plugin
 *
 * @param {Object} connection a special object allowing to send
 * and receive messages from the opposite site (basically it
 * should only provide send() and onMessage() methods)
 */


class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(connection, config, codecs) {
    super(config && config.debug);
    this._connection = connection;
    this.config = config || {};
    this._codecs = codecs || {};
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._remote_set = false; // make sure there is an execute function

    const name = this.config.name;

    this._connection.execute = this._connection.execute || function () {
      throw new Error(\`connection.execute not implemented (in "\${name}")\`);
    };

    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();

    this._method_refs.onReady(() => {
      this._fire("remoteIdle");
    });

    this._method_refs.onBusy(() => {
      this._fire("remoteBusy");
    });

    this._setupMessageHanlders();
  }

  init() {
    this._connection.emit({
      type: "initialized",
      config: this.config,
      peer_id: this._connection.peer_id
    });
  }

  setConfig(config) {
    if (config) for (const k of Object.keys(config)) {
      this.config[k] = config[k];
    }
  }
  /**
   * Set a handler to be called when received a responce from the
   * remote site reporting that the previously provided interface
   * has been successfully set as remote for that site
   *
   * @param {Function} handler
   */


  getRemoteCallStack() {
    return this._method_refs.getStack();
  }
  /**
   * @returns {Object} set of remote interface methods
   */


  getRemote() {
    return this._remote_interface;
  }
  /**
   * Sets the interface of this site making it available to the
   * remote site by sending a message with a set of methods names
   *
   * @param {Object} _interface to set
   */


  setInterface(_interface, config) {
    config = config || {};
    this.config.name = config.name || this.config.name;
    this.config.description = config.description || this.config.description;

    if (this.config.forwarding_functions) {
      for (let func_name of this.config.forwarding_functions) {
        const _remote = this._remote_interface;

        if (_remote[func_name]) {
          if (_interface.constructor === Object) {
            if (!_interface[func_name]) {
              _interface[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          } else if (_interface.constructor.constructor === Function) {
            if (!_interface.constructor.prototype[func_name]) {
              _interface.constructor.prototype[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          }
        }
      }
    }

    this._local_api = _interface;
    if (!this._remote_set) this._fire("interfaceAvailable");else this.sendInterface();
    return new Promise(resolve => {
      this.once("interfaceSetAsRemote", resolve);
    });
  }
  /**
   * Sends the actual interface to the remote site upon it was
   * updated or by a special request of the remote site
   */


  sendInterface() {
    if (!this._local_api) {
      throw new Error("interface is not set.");
    }

    this._encode(this._local_api, true).then(api => {
      this._connection.emit({
        type: "setInterface",
        api: api
      });
    });
  }

  _disposeObject(objectId) {
    if (this._object_store[objectId]) {
      delete this._object_store[objectId];
    } else {
      throw new Error(\`Object (id=\${objectId}) not found.\`);
    }
  }

  disposeObject(obj) {
    return new Promise((resolve, reject) => {
      if (this._object_weakmap.has(obj)) {
        const objectId = this._object_weakmap.get(obj);

        this._connection.once("disposed", data => {
          if (data.error) reject(new Error(data.error));else resolve();
        });

        this._connection.emit({
          type: "disposeObject",
          object_id: objectId
        });
      } else {
        throw new Error("Invalid object");
      }
    });
  }
  /**
   * Handles a message from the remote site
   */


  _setupMessageHanlders() {
    this._connection.on("init", this.init);

    this._connection.on("execute", data => {
      Promise.resolve(this._connection.execute(data.code)).then(() => {
        this._connection.emit({
          type: "executed"
        });
      }).catch(e => {
        console.error(e);

        this._connection.emit({
          type: "executed",
          error: String(e)
        });
      });
    });

    this._connection.on("method", async data => {
      let resolve, reject, method, method_this, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        const _interface = this._object_store[data.object_id];
        method = indexObject(_interface, data.name);

        if (data.name.includes(".")) {
          const tmp = data.name.split(".");
          const intf_index = tmp.slice(0, tmp.length - 1).join(".");
          method_this = indexObject(_interface, intf_index);
        } else {
          method_this = _interface;
        }

        args = await this._unwrap(data.args, true);

        if (data.promise) {
          result = method.apply(method_this, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method.apply(method_this, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("callback", async data => {
      let resolve, reject, method, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        if (data.promise) {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          result = method.apply(null, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          method.apply(null, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("disposeObject", data => {
      try {
        this._disposeObject(data.object_id);

        this._connection.emit({
          type: "disposed"
        });
      } catch (e) {
        console.error(e);

        this._connection.emit({
          type: "disposed",
          error: String(e)
        });
      }
    });

    this._connection.on("setInterface", data => {
      this._setRemoteInterface(data.api);
    });

    this._connection.on("getInterface", () => {
      this._fire("getInterface");

      if (this._local_api) {
        this.sendInterface();
      } else {
        this.once("interfaceAvailable", () => {
          this.sendInterface();
        });
      }
    });

    this._connection.on("interfaceSetAsRemote", () => {
      this._remote_set = true;

      this._fire("interfaceSetAsRemote");
    });

    this._connection.on("disconnect", () => {
      this._fire("beforeDisconnect");

      this._connection.disconnect();

      this._fire("disconnected");
    });
  }
  /**
   * Sends a requests to the remote site asking it to provide its
   * current interface
   */


  requestRemote() {
    this._connection.emit({
      type: "getInterface"
    });
  }

  _ndarray(typedArray, shape, dtype) {
    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(typedArray);

    if (dtype && dtype !== _dtype) {
      throw "dtype doesn't match the type of the array: " + _dtype + " != " + dtype;
    }

    shape = shape || [typedArray.length];
    return {
      _rtype: "ndarray",
      _rvalue: typedArray.buffer,
      _rshape: shape,
      _rdtype: _dtype
    };
  }
  /**
   * Sets the new remote interface provided by the other site
   *
   * @param {Array} names list of function names
   */


  _setRemoteInterface(api) {
    this._decode(api).then(intf => {
      // update existing interface instead of recreating it
      // this will preserve the object reference
      if (this._remote_interface) {
        // clear the interface
        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces


        Object.assign(this._remote_interface, intf);
      } else this._remote_interface = intf;

      this._fire("remoteReady");

      this._reportRemoteSet();
    });
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * method. When the generated function is called, it will send the
   * corresponding message to the remote site asking it to execute
   * the particular method of its interface
   *
   * @param {String} name of the remote method
   *
   * @returns {Function} wrapped remote method
   */


  _genRemoteMethod(targetId, name, objectId) {
    const me = this;

    const remoteMethod = function () {
      return new Promise(async (resolve, reject) => {
        let id = null;

        try {
          id = me._method_refs.put(objectId ? objectId + "/" + name : name);

          const wrapped_resolve = function () {
            if (id !== null) me._method_refs.fetch(id);
            return resolve.apply(this, arguments);
          };

          const wrapped_reject = function () {
            if (id !== null) me._method_refs.fetch(id);
            return reject.apply(this, arguments);
          };

          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together

          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;
          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;
          let args = Array.prototype.slice.call(arguments);
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;

          if (name === "register" || name === "registerService" || name === "register_service" || name === "export" || name === "on") {
            args = await me._wrap(args, true);
          } else {
            args = await me._wrap(args);
          }

          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;

          me._connection.emit({
            type: "method",
            target_id: targetId,
            name: name,
            object_id: objectId,
            args: args,
            promise: encodedPromise,
            with_kwargs: withKwargs
          }, transferables);
        } catch (e) {
          if (id) me._method_refs.fetch(id);
          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);
        }
      });
    };

    remoteMethod.__remote_method = true;
    return remoteMethod;
  }
  /**
   * Sends a responce reporting that interface just provided by the
   * remote site was successfully set by this site as remote
   */


  _reportRemoteSet() {
    this._connection.emit({
      type: "interfaceSetAsRemote"
    });
  }
  /**
   * Prepares the provided set of remote method arguments for
   * sending to the remote site, replaces all the callbacks with
   * identifiers
   *
   * @param {Array} args to wrap
   *
   * @returns {Array} wrapped arguments
   */


  async _encode(aObject, asInterface, objectId) {
    const aType = typeof aObject;

    if (aType === "number" || aType === "string" || aType === "boolean" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {
      return aObject;
    }

    let bObject;

    if (typeof aObject === "function") {
      if (asInterface) {
        if (!objectId) throw new Error("objectId is not specified.");
        bObject = {
          _rtype: "interface",
          _rtarget_id: this._connection.peer_id,
          _rintf: objectId,
          _rvalue: asInterface
        };

        this._method_weakmap.set(aObject, bObject);
      } else if (this._method_weakmap.has(aObject)) {
        bObject = this._method_weakmap.get(aObject);
      } else {
        const cid = this._store.put(aObject);

        bObject = {
          _rtype: "callback",
          _rtarget_id: this._connection.peer_id,
          _rname: aObject.constructor && aObject.constructor.name || cid,
          _rvalue: cid
        };
      }

      return bObject;
    } // skip if already encoded


    if (aObject.constructor instanceof Object && aObject._rtype) {
      // make sure the interface functions are encoded
      if (aObject._rintf) {
        const temp = aObject._rtype;
        delete aObject._rtype;
        bObject = await this._encode(aObject, asInterface, objectId);
        bObject._rtype = temp;
      } else {
        bObject = aObject;
      }

      return bObject;
    }

    const transferables = [];
    const _transfer = aObject._transfer;
    const isarray = Array.isArray(aObject);

    for (let tp of Object.keys(this._codecs)) {
      const codec = this._codecs[tp];

      if (codec.encoder && aObject instanceof codec.type) {
        // TODO: what if multiple encoders found
        let encodedObj = await Promise.resolve(codec.encoder(aObject));
        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object

        if (encodedObj && encodedObj._rintf) {
          const temp = encodedObj._rtype;
          delete encodedObj._rtype;
          encodedObj = await this._encode(encodedObj, asInterface, objectId);
          encodedObj._rtype = temp;
        }

        bObject = encodedObj;
        return bObject;
      }
    }

    if (
    /*global tf*/
    typeof tf !== "undefined" && tf.Tensor && aObject instanceof tf.Tensor) {
      const v_buffer = aObject.dataSync();

      if (aObject._transfer || _transfer) {
        transferables.push(v_buffer.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: v_buffer.buffer,
        _rshape: aObject.shape,
        _rdtype: aObject.dtype
      };
    } else if (
    /*global nj*/
    typeof nj !== "undefined" && nj.NdArray && aObject instanceof nj.NdArray) {
      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject.selection.data);

      if (aObject._transfer || _transfer) {
        transferables.push(aObject.selection.data.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: aObject.selection.data.buffer,
        _rshape: aObject.shape,
        _rdtype: dtype
      };
    } else if (aObject instanceof Error) {
      console.error(aObject);
      bObject = {
        _rtype: "error",
        _rvalue: aObject.toString()
      };
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } // send objects supported by structure clone algorithm
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== "undefined" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== "undefined" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== "undefined" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== "undefined" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== "undefined" && aObject instanceof FileSystemWritableFileStream) {
      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rname: aObject.name,
        _rmime: aObject.type,
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } else if (aObject instanceof Blob) {
      bObject = {
        _rtype: "blob",
        _rvalue: aObject
      };
    } else if (aObject instanceof ArrayBufferView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject);
      bObject = {
        _rtype: "typedarray",
        _rvalue: aObject.buffer,
        _rdtype: dtype
      };
    } else if (aObject instanceof DataView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "memoryview",
        _rvalue: aObject.buffer
      };
    } else if (aObject instanceof Set) {
      bObject = {
        _rtype: "set",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject instanceof Map) {
      bObject = {
        _rtype: "orderedmap",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {
      bObject = isarray ? [] : {};
      let keys; // an object/array

      if (aObject.constructor === Object || Array.isArray(aObject)) {
        keys = Object.keys(aObject);
      } // a class
      else if (aObject.constructor === Function) {
        throw new Error("Please instantiate the class before exportting it.");
      } // instance of a class
      else if (aObject.constructor.constructor === Function) {
        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object
        // always encode class instance as interface

        asInterface = true;
      } else {
        throw Error("Unsupported interface type");
      }

      let hasFunction = false; // encode interfaces

      if (aObject._rintf || asInterface) {
        if (!objectId) {
          if (typeof aObject._rintf === "string" && aObject._rintf.length > 0) {
            objectId = aObject._rintf; // enable custom object id
          } else {
            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
          } // Note: object with the same id will be overwritten


          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);
          this._object_store[objectId] = aObject;
        }

        for (let k of keys) {
          if (k === "constructor") continue;

          if (k.startsWith("_")) {
            continue;
          }

          bObject[k] = await this._encode(aObject[k], typeof asInterface === "string" ? asInterface + "." + k : k, objectId);

          if (typeof aObject[k] === "function") {
            hasFunction = true;
          }
        } // object id for dispose the object remotely


        if (hasFunction) bObject._rintf = objectId; // remove interface when closed

        if (aObject.on && typeof aObject.on === "function") {
          aObject.on("close", () => {
            delete this._object_store[objectId];
          });
        }
      } else {
        for (let k of keys) {
          if (["hasOwnProperty", "constructor"].includes(k)) continue;
          bObject[k] = await this._encode(aObject[k]);
        }
      } // for example, browserFS object

    } else if (typeof aObject === "object") {
      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));
      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();

      for (let k of keys) {
        if (["hasOwnProperty", "constructor"].includes(k)) continue; // encode as interface

        bObject[k] = await this._encode(aObject[k], k, bObject);
      } // object id, used for dispose the object


      bObject._rintf = objectId;
    } else {
      throw "imjoy-rpc: Unsupported data type:" + aObject;
    }

    if (transferables.length > 0) {
      bObject.__transferables__ = transferables;
    }

    if (!bObject) {
      throw new Error("Failed to encode object");
    }

    return bObject;
  }

  async _decode(aObject, withPromise) {
    if (!aObject) {
      return aObject;
    }

    let bObject;

    if (aObject["_rtype"]) {
      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          aObject = await this._decode(aObject, withPromise);
          aObject._rtype = temp;
        }

        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));
      } else if (aObject._rtype === "callback") {
        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);
      } else if (aObject._rtype === "interface") {
        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);
      } else if (aObject._rtype === "ndarray") {
        /*global nj tf*/
        //create build array/tensor if used in the plugin
        if (typeof nj !== "undefined" && nj.array) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);
        } else if (typeof tf !== "undefined" && tf.Tensor) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);
        } else {
          //keep it as regular if transfered to the main app
          bObject = aObject;
        }
      } else if (aObject._rtype === "error") {
        bObject = new Error(aObject._rvalue);
      } else if (aObject._rtype === "file") {
        if (aObject._rvalue instanceof File) {
          bObject = aObject._rvalue; //patch _path

          bObject._path = aObject._rpath;
        } else {
          bObject = new File([aObject._rvalue], aObject._rname, {
            type: aObject._rmime
          });
          bObject._path = aObject._rpath;
        }
      } else if (aObject._rtype === "typedarray") {
        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
        if (!arraytype) throw new Error("unsupported dtype: " + aObject._rdtype);
        bObject = new arraytype(aObject._rvalue);
      } else if (aObject._rtype === "memoryview") {
        bObject = new DataView(aObject._rvalue);
      } else if (aObject._rtype === "blob") {
        if (aObject._rvalue instanceof Blob) {
          bObject = aObject._rvalue;
        } else {
          bObject = new Blob([aObject._rvalue], {
            type: aObject._rmime
          });
        }
      } else if (aObject._rtype === "orderedmap") {
        bObject = new Map(await this._decode(aObject._rvalue, withPromise));
      } else if (aObject._rtype === "set") {
        bObject = new Set(await this._decode(aObject._rvalue, withPromise));
      } else {
        // make sure all the interface functions are decoded
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          bObject = await this._decode(aObject, withPromise);
          bObject._rtype = temp;
        } else bObject = aObject;
      }
    } else if (aObject.constructor === Object || Array.isArray(aObject)) {
      const isarray = Array.isArray(aObject);
      bObject = isarray ? [] : {};

      for (let k of Object.keys(aObject)) {
        if (isarray || aObject.hasOwnProperty(k)) {
          const v = aObject[k];
          bObject[k] = await this._decode(v, withPromise);
        }
      }
    } else {
      bObject = aObject;
    }

    if (bObject === undefined) {
      throw new Error("Failed to decode object");
    } // store the object id for dispose


    if (aObject._rintf) {
      this._object_weakmap.set(bObject, aObject._rintf);
    }

    return bObject;
  }

  async _wrap(args, asInterface) {
    return await this._encode(args, asInterface);
  }
  /**
   * Unwraps the set of arguments delivered from the remote site,
   * replaces all callback identifiers with a function which will
   * initiate sending that callback identifier back to other site
   *
   * @param {Object} args to unwrap
   *
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Array} unwrapped args
   */


  async _unwrap(args, withPromise) {
    return await this._decode(args, withPromise);
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * callback. When the generated function is called, it will send
   * the corresponding message to the remote site asking it to
   * execute the particular callback previously saved during a call
   * by the remote site a method from the interface of this site
   *
   * @param {Number} id of the remote callback to execute
   * @param {Number} argNum argument index of the callback
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Function} wrapped remote callback
   */


  _genRemoteCallback(targetId, cid, withPromise) {
    const me = this;
    let remoteCallback;

    if (withPromise) {
      remoteCallback = function () {
        return new Promise(async (resolve, reject) => {
          const args = await me._wrap(Array.prototype.slice.call(arguments));
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;
          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;
          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together

          resolve.__promise_pair = encodedPromise[1]._rvalue;
          reject.__promise_pair = encodedPromise[0]._rvalue;

          try {
            me._connection.emit({
              type: "callback",
              target_id: targetId,
              id: cid,
              args: args,
              promise: encodedPromise,
              with_kwargs: withKwargs
            }, transferables);
          } catch (e) {
            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);
          }
        });
      };

      return remoteCallback;
    } else {
      remoteCallback = async function () {
        const args = await me._wrap(Array.prototype.slice.call(arguments));
        const argLength = args.length; // if the last argument is an object, mark it as kwargs

        const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
        if (withKwargs) delete args[argLength - 1]._rkwargs;
        const transferables = args.__transferables__;
        if (transferables) delete args.__transferables__;
        return me._connection.emit({
          type: "callback",
          target_id: targetId,
          id: cid,
          args: args,
          with_kwargs: withKwargs
        }, transferables);
      };

      return remoteCallback;
    }
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
    this._remote_interface = null;
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();
  }
  /**
   * Sends the notification message and breaks the connection
   */


  disconnect() {
    this._connection.emit({
      type: "disconnect"
    });

    this.reset();
    setTimeout(() => {
      this._connection.disconnect();
    }, 2000);
  }

}
/**
 * ReferenceStore is a special object which stores other objects
 * and provides the references (number) instead. This reference
 * may then be sent over a json-based communication channel (IPC
 * to another Node.js process or a message to the Worker). Other
 * site may then provide the reference in the responce message
 * implying the given object should be activated.
 *
 * Primary usage for the ReferenceStore is a storage for the
 * callbacks, which therefore makes it possible to initiate a
 * callback execution by the opposite site (which normally cannot
 * directly execute functions over the communication channel).
 *
 * Each stored object can only be fetched once and is not
 * available for the second time. Each stored object must be
 * fetched, since otherwise it will remain stored forever and
 * consume memory.
 *
 * Stored object indeces are simply the numbers, which are however
 * released along with the objects, and are later reused again (in
 * order to postpone the overflow, which should not likely happen,
 * but anyway).
 */

class ReferenceStore {
  constructor() {
    this._store = {}; // stored object

    this._indices = [0]; // smallest available indices

    this._readyHandler = function () {};

    this._busyHandler = function () {};

    this._readyHandler();
  }
  /**
   * call handler when the store is empty
   *
   * @param {FUNCTION} id of a handler
   */


  onReady(readyHandler) {
    this._readyHandler = readyHandler || function () {};
  }
  /**
   * call handler when the store is not empty
   *
   * @param {FUNCTION} id of a handler
   */


  onBusy(busyHandler) {
    this._busyHandler = busyHandler || function () {};
  }
  /**
   * get the length of the store
   *
   */


  getStack() {
    return Object.keys(this._store).length;
  }
  /**
   * @function _genId() generates the new reference id
   *
   * @returns {Number} smallest available id and reserves it
   */


  _genId() {
    let id;

    if (this._indices.length === 1) {
      id = this._indices[0]++;
    } else {
      id = this._indices.shift();
    }

    return id;
  }
  /**
   * Releases the given reference id so that it will be available by
   * another object stored
   *
   * @param {Number} id to release
   */


  _releaseId(id) {
    for (let i = 0; i < this._indices.length; i++) {
      if (id < this._indices[i]) {
        this._indices.splice(i, 0, id);

        break;
      }
    } // cleaning-up the sequence tail


    for (let i = this._indices.length - 1; i >= 0; i--) {
      if (this._indices[i] - 1 === this._indices[i - 1]) {
        this._indices.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Stores the given object and returns the refernce id instead
   *
   * @param {Object} obj to store
   *
   * @returns {Number} reference id of the stored object
   */


  put(obj) {
    if (this._busyHandler && Object.keys(this._store).length === 0) {
      this._busyHandler();
    }

    const id = this._genId();

    this._store[id] = obj;
    return id;
  }
  /**
   * Retrieves previously stored object and releases its reference
   *
   * @param {Number} id of an object to retrieve
   */


  fetch(id) {
    const obj = this._store[id];

    if (obj && !obj.__remote_method) {
      delete this._store[id];

      this._releaseId(id);

      if (this._readyHandler && Object.keys(this._store).length === 0) {
        this._readyHandler();
      }
    }

    if (obj && obj.__promise_pair) {
      this.fetch(obj.__promise_pair);
    }

    return obj;
  }

}

/***/ }),

/***/ "./src/socketIOMain.js":
/*!*****************************!*\\
  !*** ./src/socketIOMain.js ***!
  \\*****************************/
/*! exports provided: setupRPC, waitForInitialization, VERSION, RPC, API_VERSION, loadRequirements, Connection, connectToServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectToServer", function() { return connectToServer; });
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_1__["RPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"]; });

/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirements"]; });

/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-client */ "./node_modules/socket.io-client/build/esm/index.js");
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main.js */ "./src/main.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setupRPC", function() { return _main_js__WEBPACK_IMPORTED_MODULE_4__["setupRPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "waitForInitialization", function() { return _main_js__WEBPACK_IMPORTED_MODULE_4__["waitForInitialization"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_5__["version"]; });

/**
 * Contains the routines loaded by the plugin iframe under web-browser
 * in case when worker failed to initialize
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */








class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  }

  init() {
    return new Promise((resolve, reject) => {
      const config = this.config;
      const url = config.server_url;
      const extraHeaders = {};

      if (config.token) {
        extraHeaders.Authorization = "Bearer " + config.token;
      }

      const basePath = new URL(url).pathname; // Note: extraHeaders only works for polling transport (the default)
      // If we switch to websocket only, the headers won't be respected

      const socket = Object(socket_io_client__WEBPACK_IMPORTED_MODULE_3__["default"])(url, {
        withCredentials: true,
        extraHeaders,
        path: (basePath.endsWith("/") ? basePath.slice(0, -1) : basePath) + "/socket.io"
      });
      let connected = false;
      socket.on("connect", () => {
        if (connected) {
          console.warn("Skipping reconnect to the server");
          return;
        }

        socket.emit("register_plugin", config, result => {
          if (!result.success) {
            console.error(result.detail);
            reject(result.detail);
            return;
          }

          connected = true;
          this.plugin_id = result.plugin_id;
          socket.on("plugin_message", data => {
            if (data.peer_id === this.peer_id) {
              this._fire(data.type, data);
            } else if (this.config.debug) {
              console.log(\`connection peer id mismatch \${data.peer_id} !== \${this.peer_id}\`);
            }
          });
          this.once("initialize", () => {
            if (!this.rpc) {
              this.rpc = Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(this, config);
            } else {
              this.rpc.once("remoteReady", () => {
                this.rpc.sendInterface();
              });
            }

            this.connect();
            resolve();
          });
          this.emit({
            type: "imjoyRPCReady",
            config: config,
            peer_id: this.peer_id
          });
        });
        this._disconnected = false;
      });
      socket.on("connect_error", () => {
        reject("connection error");

        this._fire("connectFailure");
      });
      socket.on("disconnect", () => {
        reject("disconnected");
        this.disconnect();

        this._fire("disconnected");
      });
      this.socket = socket;
    });
  }

  connect() {
    this.emit({
      type: "initialized",
      config: this.config,
      origin: globalThis.location.origin,
      peer_id: this.peer_id
    });

    this._fire("connected");
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
  }

  execute() {
    throw new Error("Execution is not allowed for socketio connection");
  }

  disconnect() {
    this._fire("beforeDisconnect");

    this.socket.disconnect();
    this.init();

    this._fire("disconnected");
  }

  emit(data) {
    data.plugin_id = this.plugin_id;
    this.socket.emit("plugin_message", data, result => {
      if (!result.success) this._fire("error", data.detail);
    });
  }

}
function connectToServer(config) {
  config = config || {};
  if (!config.server_url) throw new Error("Server URL is not specified.");
  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["normalizeConfig"])(config);
  return new Promise((resolve, reject) => {
    const handleEvent = e => {
      const api = e.detail;

      if (config.expose_api_globally) {
        globalThis.api = api;
      } // imjoy plugin api


      resolve(api);
      globalThis.removeEventListener("imjoy_remote_api_ready", handleEvent);
    };

    globalThis.addEventListener("imjoy_remote_api_ready", handleEvent);
    config = config || {};
    config.dedicated_thread = false;
    config.lang = "javascript";
    config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"];
    const conn = new Connection(config);
    conn.init().catch(reject);
  });
}

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\\
  !*** ./src/utils.js ***!
  \\**********************/
/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dtypeToTypedArray", function() { return dtypeToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWindow", function() { return loadRequirementsInWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWebworker", function() { return loadRequirementsInWebworker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return loadRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeConfig", function() { return normalizeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtypeMapping", function() { return typedArrayToDtypeMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtype", function() { return typedArrayToDtype; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheRequirements", function() { return cacheRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupServiceWorker", function() { return setupServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlJoin", function() { return urlJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
function randId() {
  return Math.random().toString(36).substr(2, 10) + new Date().getTime();
}
const dtypeToTypedArray = {
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  float32: Float32Array,
  float64: Float64Array,
  array: Array
};
async function loadRequirementsInWindow(requirements) {
  function _importScript(url) {
    //url is URL of external file, implementationCode is the code
    //to be called from the file, location is the location to
    //insert the <script> element
    return new Promise((resolve, reject) => {
      var scriptTag = document.createElement("script");
      scriptTag.src = url;
      scriptTag.type = "text/javascript";
      scriptTag.onload = resolve;

      scriptTag.onreadystatechange = function () {
        if (this.readyState === "loaded" || this.readyState === "complete") {
          resolve();
        }
      };

      scriptTag.onerror = reject;
      document.head.appendChild(scriptTag);
    });
  } // support importScripts outside web worker


  async function importScripts() {
    var args = Array.prototype.slice.call(arguments),
        len = args.length,
        i = 0;

    for (; i < len; i++) {
      await _importScript(args[i]);
    }
  }

  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      var link_node;
      requirements = typeof requirements === "string" ? [requirements] : requirements;

      if (Array.isArray(requirements)) {
        for (var i = 0; i < requirements.length; i++) {
          if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
            if (requirements[i].startsWith("css:")) {
              requirements[i] = requirements[i].slice(4);
            }

            link_node = document.createElement("link");
            link_node.rel = "stylesheet";
            link_node.href = requirements[i];
            document.head.appendChild(link_node);
          } else if (requirements[i].toLowerCase().endsWith(".mjs") || requirements[i].startsWith("mjs:")) {
            // import esmodule
            if (requirements[i].startsWith("mjs:")) {
              requirements[i] = requirements[i].slice(4);
            }

            await import(
            /* webpackIgnore: true */
            requirements[i]);
          } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
            if (requirements[i].startsWith("js:")) {
              requirements[i] = requirements[i].slice(3);
            }

            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("http")) {
            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("cache:")) {//ignore cache
          } else {
            console.log("Unprocessed requirements url: " + requirements[i]);
          }
        }
      } else {
        throw "unsupported requirements definition";
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
async function loadRequirementsInWebworker(requirements) {
  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      if (!Array.isArray(requirements)) {
        requirements = [requirements];
      }

      for (var i = 0; i < requirements.length; i++) {
        if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
          throw "unable to import css in a webworker";
        } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
          if (requirements[i].startsWith("js:")) {
            requirements[i] = requirements[i].slice(3);
          }

          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("http")) {
          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("cache:")) {//ignore cache
        } else {
          console.log("Unprocessed requirements url: " + requirements[i]);
        }
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
function loadRequirements(requirements) {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return loadRequirementsInWebworker(requirements);
  } else {
    return loadRequirementsInWindow(requirements);
  }
}
function normalizeConfig(config) {
  config.version = config.version || "0.1.0";
  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;
  config.type = config.type || "rpc-window";
  config.id = config.id || randId();
  config.target_origin = config.target_origin || "*";
  config.allow_execution = config.allow_execution || false; // remove functions

  config = Object.keys(config).reduce((p, c) => {
    if (typeof config[c] !== "function") p[c] = config[c];
    return p;
  }, {});
  return config;
}
const typedArrayToDtypeMapping = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};
const typedArrayToDtypeKeys = [];

for (const arrType of Object.keys(typedArrayToDtypeMapping)) {
  typedArrayToDtypeKeys.push(eval(arrType));
}

function typedArrayToDtype(obj) {
  let dtype = typedArrayToDtypeMapping[obj.constructor.name];

  if (!dtype) {
    const pt = Object.getPrototypeOf(obj);

    for (const arrType of typedArrayToDtypeKeys) {
      if (pt instanceof arrType) {
        dtype = typedArrayToDtypeMapping[arrType.name];
        break;
      }
    }
  }

  return dtype;
}

function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}

async function cacheRequirements(requirements) {
  requirements = requirements || [];

  if (!Array.isArray(requirements)) {
    requirements = [requirements];
  }

  for (let req of requirements) {
    //remove prefix
    if (req.startsWith("js:")) req = req.slice(3);
    if (req.startsWith("css:")) req = req.slice(4);
    if (req.startsWith("cache:")) req = req.slice(6);
    if (!req.startsWith("http")) continue;
    await cacheUrlInServiceWorker(req).catch(e => {
      console.error(e);
    });
  }
}
function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {
  // register service worker for offline access
  if ("serviceWorker" in navigator) {
    baseUrl = baseUrl || "/";
    navigator.serviceWorker.register(baseUrl + "plugin-service-worker.js").then(function (registration) {
      // Registration was successful
      console.log("ServiceWorker registration successful with scope: ", registration.scope);
    }, function (err) {
      // registration failed :(
      console.log("ServiceWorker registration failed: ", err);
    });
    targetOrigin = targetOrigin || "*";
    cacheCallback = cacheCallback || cacheRequirements;

    if (cacheCallback && typeof cacheCallback !== "function") {
      throw new Error("config.cache_requirements must be a function");
    }

    window.addEventListener("message", function (e) {
      if (targetOrigin === "*" || e.origin === targetOrigin) {
        const m = e.data;

        if (m.type === "cacheRequirements") {
          cacheCallback(m.requirements);
        }
      }
    });
  }
} //#Source https://bit.ly/2neWfJ2

function urlJoin(...args) {
  return args.join("/").replace(/[\\/]+/g, "/").replace(/^(.+):\\//, "$1://").replace(/^file:/, "file:/").replace(/\\/(\\?|&|#[^!])/g, "$1").replace(/\\?/g, "&").replace("&", "?");
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}

/***/ })

/******/ });
});
//# sourceMappingURL=imjoy-rpc-socketio.js.map

//# sourceURL=webpack://%5Bname%5D/./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js?`)},"./node_modules/imjoy-rpc/dist/imjoy-rpc.js":function(module,exports,__webpack_require__){eval(`(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \\*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./package.json":
/*!**********************!*\\
  !*** ./package.json ***!
  \\**********************/
/*! exports provided: name, version, description, module, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */
/***/ (function(module) {

module.exports = JSON.parse("{\\"name\\":\\"imjoy-rpc\\",\\"version\\":\\"0.5.9\\",\\"description\\":\\"Remote procedure calls for ImJoy.\\",\\"module\\":\\"index.js\\",\\"scripts\\":{\\"build\\":\\"rm -rf dist && npm run build-umd\\",\\"build-umd\\":\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\",\\"watch\\":\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\",\\"publish-npm\\":\\"npm install && npm run build && npm publish\\",\\"serve\\":\\"webpack-dev-server\\",\\"stats\\":\\"webpack --profile --json > stats.json\\",\\"stats-prod\\":\\"webpack --profile --json --mode production > stats-prod.json\\",\\"analyze\\":\\"webpack-bundle-analyzer -p 9999 stats.json\\",\\"analyze-prod\\":\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\",\\"clean\\":\\"rimraf dist/*\\",\\"deploy\\":\\"npm run build && node deploy-site.js\\",\\"format\\":\\"prettier --write \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"check-format\\":\\"prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"test\\":\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\",\\"test-watch\\":\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\"},\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\"},\\"keywords\\":[\\"imjoy\\",\\"rpc\\"],\\"author\\":\\"imjoy-team <imjoy.team@gmail.com>\\",\\"license\\":\\"MIT\\",\\"bugs\\":{\\"url\\":\\"https://github.com/imjoy-team/imjoy-rpc/issues\\"},\\"homepage\\":\\"https://github.com/imjoy-team/imjoy-rpc\\",\\"dependencies\\":{\\"@msgpack/msgpack\\":\\"^2.7.1\\",\\"socket.io-client\\":\\"^4.4.1\\"},\\"devDependencies\\":{\\"@babel/core\\":\\"^7.16.12\\",\\"@babel/plugin-syntax-dynamic-import\\":\\"^7.8.3\\",\\"@babel/polyfill\\":\\"^7.12.1\\",\\"@babel/preset-env\\":\\"^7.16.11\\",\\"@types/requirejs\\":\\"^2.1.34\\",\\"babel-core\\":\\"^6.26.0\\",\\"babel-eslint\\":\\"^10.1.0\\",\\"babel-loader\\":\\"^8.2.3\\",\\"babel-runtime\\":\\"^6.26.0\\",\\"chai\\":\\"^4.3.6\\",\\"clean-webpack-plugin\\":\\"^0.1.19\\",\\"copy-webpack-plugin\\":\\"^5.1.2\\",\\"eslint\\":\\"^6.8.0\\",\\"eslint-config-prettier\\":\\"^4.2.0\\",\\"eslint-loader\\":\\"^4.0.2\\",\\"file-loader\\":\\"^0.11.2\\",\\"fs-extra\\":\\"^0.30.0\\",\\"gh-pages\\":\\"^2.0.1\\",\\"html-loader\\":\\"^0.5.5\\",\\"html-webpack-plugin\\":\\"^3.2.0\\",\\"json-loader\\":\\"^0.5.4\\",\\"karma\\":\\"^6.3.12\\",\\"karma-chrome-launcher\\":\\"^3.1.0\\",\\"karma-firefox-launcher\\":\\"^1.3.0\\",\\"karma-mocha\\":\\"^1.3.0\\",\\"karma-sourcemap-loader\\":\\"^0.3.8\\",\\"karma-spec-reporter\\":\\"0.0.32\\",\\"karma-webpack\\":\\"^4.0.2\\",\\"lerna\\":\\"^3.22.1\\",\\"lodash.debounce\\":\\"^4.0.8\\",\\"mocha\\":\\"^7.2.0\\",\\"postcss\\":\\"^7.0.36\\",\\"prettier\\":\\"^1.6.1\\",\\"rimraf\\":\\"^2.6.2\\",\\"schema-utils\\":\\"^0.4.3\\",\\"style-loader\\":\\"^0.18.1\\",\\"url-loader\\":\\"^0.5.9\\",\\"webpack\\":\\"^4.46.0\\",\\"webpack-bundle-analyzer\\":\\"^3.9.0\\",\\"webpack-cli\\":\\"^3.3.12\\",\\"webpack-dev-server\\":\\"^3.11.3\\",\\"webpack-merge\\":\\"^4.1.1\\",\\"workbox-webpack-plugin\\":\\"^4.3.1\\",\\"worker-loader\\":\\"^2.0.0\\",\\"write-file-webpack-plugin\\":\\"^4.5.1\\"},\\"eslintConfig\\":{\\"globals\\":{\\"document\\":true,\\"window\\":true}}}");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\\
  !*** ./src/main.js ***!
  \\*********************/
/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitForInitialization", function() { return waitForInitialization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupRPC", function() { return setupRPC; });
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.webworker.js */ "./src/plugin.webworker.js");
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginIframe.js */ "./src/pluginIframe.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirements"]; });

/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["RPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["API_VERSION"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_4__["version"]; });

/**
 * Contains the code executed in the sandboxed frame under web-browser
 *
 * Tries to create a Web-Worker inside the frame and set up the
 * communication between the worker and the parent window. Some
 * browsers restrict creating a worker inside a sandboxed iframe - if
 * this happens, the plugin initialized right inside the frame (in the
 * same thread)
 */







function _inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

function _inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
/**
 * Initializes the plugin inside a web worker. May throw an exception
 * in case this was not permitted by the browser.
 */


function setupWebWorker(config) {
  if (!config.allow_execution) throw new Error("web-worker plugin can only work with allow_execution=true");
  let broadcastChannel = null;

  if (config.broadcastChannel) {
    broadcastChannel = new BroadcastChannel(config.broadcastChannel);
  }

  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker
  // initialization without exception, handling this with timeout

  const fallbackTimeout = setTimeout(function () {
    worker.terminate();
    console.warn(\`Plugin failed to start as a web-worker, running in an iframe instead.\`);
    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
  }, 2000);
  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])(); // forwarding messages between the worker and parent window

  worker.addEventListener("message", function (e) {
    let transferables = undefined;
    const m = e.data;

    if (m.type === "worker-ready") {
      // send config to the worker
      worker.postMessage({
        type: "connectRPC",
        config: config
      });
      clearTimeout(fallbackTimeout);
      return;
    } else if (m.type === "initialized") {
      // complete the missing fields
      m.config = Object.assign({}, config, m.config);
      m.origin = window.location.origin;
      m.peer_id = peer_id;
    } else if (m.type === "imjoy_remote_api_ready") {
      // if it's a webworker, there will be no api object returned
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: null
      }));
    } else if (m.type === "cacheRequirements" && typeof cache_requirements === "function") {
      cache_requirements(m.requirements);
    } else if (m.type === "disconnect") {
      worker.terminate();
    } else {
      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }
    }

    if (broadcastChannel) broadcastChannel.postMessage(m);else parent.postMessage(m, config.target_origin || "*", transferables);
  });
  (broadcastChannel || window).addEventListener("message", function (e) {
    if (e.type === "message" && (broadcastChannel || config.target_origin === "*" || e.origin === config.target_origin)) {
      let transferables = undefined;
      const m = e.data;

      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }

      if (m.peer_id === peer_id) {
        worker.postMessage(m, transferables);
      } else if (config.debug) {
        console.log(\`connection peer id mismatch \${m.peer_id} !== \${peer_id}\`);
      }
    }
  });
}

function waitForInitialization(config) {
  if (_inWebWorker()) {
    globalThis.parent = self;
  }

  config = config || {};

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
    config.enable_service_worker = false;
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  const targetOrigin = config.target_origin || "*";

  if (config.credential_required && typeof config.verify_credential !== "function") {
    throw new Error("Please also provide the \`verify_credential\` function with \`credential_required\`.");
  }

  if (config.credential_required && targetOrigin === "*") {
    throw new Error("\`target_origin\` was set to \`*\` with \`credential_required=true\`, there is a security risk that you may leak the credential to website from other origin. Please specify the \`target_origin\` explicitly.");
  }

  const done = () => {
    globalThis.removeEventListener("message", handleEvent);
  };

  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();

  const handleEvent = e => {
    if (e.type === "message" && (!e.origin || targetOrigin === "*" || e.origin === targetOrigin)) {
      if (e.data.type === "initialize") {
        done();

        if (e.data.peer_id !== peer_id) {
          // TODO: throw an error when we are sure all the peers will send the peer_id
          console.warn(\`\${e.data.config && e.data.config.name}: connection peer id mismatch \${e.data.peer_id} !== \${peer_id}\`);
        }

        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client
        // otherwise take the setting from the core

        if (targetOrigin !== "*") {
          cfg.target_origin = targetOrigin;
        }

        if (config.credential_required) {
          config.verify_credential(cfg.credential).then(result => {
            if (result && result.auth && !result.error) {
              // pass the authentication information with tokens
              cfg.auth = result.auth;
              setupRPC(cfg).then(() => {
                console.log("ImJoy RPC loaded successfully!");
              });
            } else {
              throw new Error("Failed to verify the credentail:" + (result && result.error));
            }
          });
        } else {
          setupRPC(cfg).then(() => {
            console.log("ImJoy RPC loaded successfully!");
          });
        }
      } else {
        throw new Error(\`unrecognized message: \${e.data}\`);
      }
    }
  };

  globalThis.addEventListener("message", handleEvent);

  if (_inWebWorker()) {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    });
  } else {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    }, "*");
  }
}
function setupRPC(config) {
  config = config || {};
  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["normalizeConfig"])(config);

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  return new Promise((resolve, reject) => {
    const handleEvent = e => {
      const api = e.detail;

      if (config.expose_api_globally) {
        globalThis.api = api;
      } // imjoy plugin api


      resolve(api);
      globalThis.removeEventListener("imjoy_remote_api_ready", handleEvent);
    };

    if (_inIframe()) {
      if (config.type === "web-worker") {
        try {
          setupWebWorker(config);
        } catch (e) {
          // fallback to iframe
          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
        }
      } else if (["rpc-window", "rpc-worker", "iframe", "window"].includes(config.type)) {
        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
      } else {
        console.error("Unsupported plugin type: " + config.type);
        reject("Unsupported plugin type: " + config.type);
        return;
      }

      globalThis.addEventListener("imjoy_remote_api_ready", handleEvent);
    } else if (_inWebWorker()) {
      // inside a webworker
      Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
    } else {
      reject(new Error("imjoy-rpc should only run inside an iframe or a webworker."));
    }
  });
}

/***/ }),

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\\
  !*** ./src/plugin.webworker.js ***!
  \\*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\"\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\"./src/plugin.webworker.js\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\"./src/plugin.webworker.js\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\"./src/pluginCore.js\\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \\"undefined\\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\\"This script can only loaded in a webworker\\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \\"data:text/javascript;charset=utf-8,\\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"MessageEmitter\\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\\"message\\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \\"initialized\\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\\"beforeDisconnect\\");\\n    self.close();\\n    this._fire(\\"disconnected\\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \\"requirements\\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"loadRequirementsInWebworker\\"])(code.requirements);\\n    } else if (code.type === \\"script\\") {\\n      try {\\n        if (code.attrs.type === \\"module\\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \\"unsupported code type.\\";\\n    }\\n    if (code.type === \\"requirements\\") {\\n      self.postMessage({\\n        type: \\"cacheRequirements\\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \\"web-worker\\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \\"javascript\\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\"API_VERSION\\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\\"connectRPC\\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\"connectRPC\\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \\"worker-ready\\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \\"./src/pluginCore.js\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"connectRPC\\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\"RPC\\"](connection, config, codecs);\\n  rpc.on(\\"getInterface\\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\\"remoteReady\\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\\"name\\"] || !config[\\"encoder\\"] && !config[\\"decoder\\"]) {\\n        throw new Error(\\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\\"Remove duplicated codec: \\" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\\"name\\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \\"imjoy_remote_api_ready\\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \\"function\\") {\\n      const msg = \\"A function may only be subsribed to the event, \\" + type + \\" was provided instead\\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/rpc.js\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"API_VERSION\\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"RPC\\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \\"0.2.3\\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\\"undefined index\\");\\n  if (typeof is === \\"string\\") return indexObject(obj, is.split(\\".\\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"MessageEmitter\\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(\`connection.execute not implemented (in \\"\${name}\\")\`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\\"remoteIdle\\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\\"remoteBusy\\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \\"initialized\\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\\"interfaceAvailable\\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\\"interfaceSetAsRemote\\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\\"interface is not set.\\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \\"setInterface\\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(\`Object (id=\${objectId}) not found.\`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\\"disposed\\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \\"disposeObject\\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\\"Invalid object\\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\\"init\\", this.init);\\n\\n    this._connection.on(\\"execute\\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \\"executed\\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"executed\\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\\"method\\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\\".\\")) {\\n          const tmp = data.name.split(\\".\\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\\".\\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"callback\\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"disposeObject\\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"setInterface\\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\\"getInterface\\", () => {\\n      this._fire(\\"getInterface\\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\\"interfaceAvailable\\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"interfaceSetAsRemote\\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\\"interfaceSetAsRemote\\");\\n    });\\n\\n    this._connection.on(\\"disconnect\\", () => {\\n      this._fire(\\"beforeDisconnect\\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\\"disconnected\\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \\"getInterface\\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \\"dtype doesn't match the type of the array: \\" + _dtype + \\" != \\" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \\"ndarray\\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\\"remoteReady\\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \\"/\\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \\"register\\" || name === \\"registerService\\" || name === \\"register_service\\" || name === \\"export\\" || name === \\"on\\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \\"method\\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \\"interfaceSetAsRemote\\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \\"number\\" || aType === \\"string\\" || aType === \\"boolean\\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \\"function\\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\\"objectId is not specified.\\");\\n        bObject = {\\n          _rtype: \\"interface\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \\"callback\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \\"undefined\\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \\"undefined\\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \\"error\\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \\"undefined\\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \\"undefined\\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \\"undefined\\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \\"undefined\\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \\"undefined\\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \\"blob\\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject);\\n      bObject = {\\n        _rtype: \\"typedarray\\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"memoryview\\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \\"set\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \\"orderedmap\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\\"Please instantiate the class before exportting it.\\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\\"Unsupported interface type\\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \\"string\\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \\"constructor\\") continue;\\n\\n          if (k.startsWith(\\"_\\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \\"string\\" ? asInterface + \\".\\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \\"function\\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \\"function\\") {\\n          aObject.on(\\"close\\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \\"object\\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n\\n      for (let k of keys) {\\n        if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \\"imjoy-rpc: Unsupported data type:\\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\\"Failed to encode object\\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\\"_rtype\\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \\"callback\\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \\"interface\\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \\"ndarray\\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \\"undefined\\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \\"undefined\\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \\"error\\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \\"file\\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \\"typedarray\\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\\"unsupported dtype: \\" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \\"memoryview\\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \\"blob\\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \\"orderedmap\\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \\"set\\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\\"Failed to decode object\\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \\"callback\\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \\"callback\\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \\"disconnect\\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/utils.js\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"randId\\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"dtypeToTypedArray\\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWindow\\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWebworker\\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirements\\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"normalizeConfig\\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtypeMapping\\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtype\\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"cacheRequirements\\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"setupServiceWorker\\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"urlJoin\\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"MessageEmitter\\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\\"script\\");\\n      scriptTag.src = url;\\n      scriptTag.type = \\"text/javascript\\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \\"loaded\\" || this.readyState === \\"complete\\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \\"string\\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n            if (requirements[i].startsWith(\\"css:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\\"link\\");\\n            link_node.rel = \\"stylesheet\\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".mjs\\") || requirements[i].startsWith(\\"mjs:\\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\\"mjs:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n            if (requirements[i].startsWith(\\"js:\\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"http\\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n          } else {\\n            console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \\"unsupported requirements definition\\";\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n          throw \\"unable to import css in a webworker\\";\\n        } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n          if (requirements[i].startsWith(\\"js:\\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"http\\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n        } else {\\n          console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \\"0.1.0\\";\\n  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;\\n  config.type = config.type || \\"rpc-window\\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \\"*\\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \\"function\\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \\"int8\\",\\n  Int16Array: \\"int16\\",\\n  Int32Array: \\"int32\\",\\n  Uint8Array: \\"uint8\\",\\n  Uint16Array: \\"uint16\\",\\n  Uint32Array: \\"uint32\\",\\n  Float32Array: \\"float32\\",\\n  Float64Array: \\"float64\\",\\n  Array: \\"array\\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \\"add\\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\\"Service worker is not supported.\\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\\"Service worker controller is not available\\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\\"js:\\")) req = req.slice(3);\\n    if (req.startsWith(\\"css:\\")) req = req.slice(4);\\n    if (req.startsWith(\\"cache:\\")) req = req.slice(6);\\n    if (!req.startsWith(\\"http\\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\\"serviceWorker\\" in navigator) {\\n    baseUrl = baseUrl || \\"/\\";\\n    navigator.serviceWorker.register(baseUrl + \\"plugin-service-worker.js\\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\\"ServiceWorker registration successful with scope: \\", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\\"ServiceWorker registration failed: \\", err);\\n    });\\n    targetOrigin = targetOrigin || \\"*\\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \\"function\\") {\\n      throw new Error(\\"config.cache_requirements must be a function\\");\\n    }\\n\\n    window.addEventListener(\\"message\\", function (e) {\\n      if (targetOrigin === \\"*\\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \\"cacheRequirements\\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\\"/\\").replace(/[\\\\/]+/g, \\"/\\").replace(/^(.+):\\\\//, \\"$1://\\").replace(/^file:/, \\"file:/\\").replace(/\\\\/(\\\\?|&|#[^!])/g, \\"$1\\").replace(/\\\\?/g, \\"&\\").replace(\\"&\\", \\"?\\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\\"emit is not implemented\\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\\"unhandled event\\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map", null);
};

/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\\
  !*** ./src/pluginCore.js ***!
  \\***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectRPC", function() { return connectRPC; });
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/**
 * Core plugin script loaded into the plugin process/thread.
 *
 * Initializes the plugin-site API global methods.
 */

function connectRPC(connection, config) {
  config = config || {};
  const codecs = {};
  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__["RPC"](connection, config, codecs);
  rpc.on("getInterface", function () {
    launchConnected();
  });
  rpc.on("remoteReady", function () {
    const api = rpc.getRemote() || {};

    api.registerCodec = function (config) {
      if (!config["name"] || !config["encoder"] && !config["decoder"]) {
        throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");
      } else {
        if (config.type) {
          for (let k of Object.keys(codecs)) {
            if (codecs[k].type === config.type || k === config.name) {
              delete codecs[k];
              console.warn("Remove duplicated codec: " + k);
            }
          }
        }

        codecs[config["name"]] = config;
      }
    };

    api.init = function (config) {
      // register a minimal plugin api
      rpc.setInterface({
        setup() {}

      }, config);
    };

    api.disposeObject = function (obj) {
      rpc.disposeObject(obj);
    };

    api.export = function (_interface, config) {
      rpc.setInterface(_interface, config);
    };

    api.onLoad = function (handler) {
      handler = checkHandler(handler);

      if (connected) {
        handler();
      } else {
        connectedHandlers.push(handler);
      }
    };

    api.dispose = function (_interface) {
      rpc.disconnect();
    };

    api._rpc = rpc;

    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
      self.api = api;
      self.postMessage({
        type: "imjoy_remote_api_ready"
      });
      self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    } else if (typeof window) {
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    }
  });
  let connected = false;
  const connectedHandlers = [];

  const launchConnected = function () {
    if (!connected) {
      connected = true;
      let handler;

      while (handler = connectedHandlers.pop()) {
        handler();
      }
    }
  };

  const checkHandler = function (handler) {
    const type = typeof handler;

    if (type !== "function") {
      const msg = "A function may only be subsribed to the event, " + type + " was provided instead";
      throw new Error(msg);
    }

    return handler;
  };

  return rpc;
}

/***/ }),

/***/ "./src/pluginIframe.js":
/*!*****************************!*\\
  !*** ./src/pluginIframe.js ***!
  \\*****************************/
/*! exports provided: Connection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return setupIframe; });
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the routines loaded by the plugin iframe under web-browser
 * in case when worker failed to initialize
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */


 // Create a new, plain <span> element

function _htmlToElement(html) {
  var template = document.createElement("template");
  html = html.trim(); // Never return a text node of whitespace as the result

  template.innerHTML = html;
  return template.content.firstChild;
}

const _inWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;

async function executeEsModule(content) {
  const dataUri = "data:text/javascript;charset=utf-8," + encodeURIComponent(content);
  await import(
  /* webpackIgnore: true */
  dataUri);
}

class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  }

  connect() {
    this.config.target_origin = this.config.target_origin || "*"; // this will call handleEvent function

    if (this.config.broadcastChannel) {
      this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);
    } else {
      this.broadcastChannel = null;
    }

    if (this.broadcastChannel) this.broadcastChannel.addEventListener("message", this);else globalThis.addEventListener("message", this);
    this.emit({
      type: "initialized",
      config: this.config,
      origin: globalThis.location.origin,
      peer_id: this.peer_id
    });

    this._fire("connected");
  }

  handleEvent(e) {
    if (e.type === "message" && (this.broadcastChannel || this.config.target_origin === "*" || !e.origin || e.origin === this.config.target_origin)) {
      if (e.data.peer_id === this.peer_id) {
        this._fire(e.data.type, e.data);
      } else if (this.config.debug) {
        console.log(\`connection peer id mismatch \${e.data.peer_id} !== \${this.peer_id}\`);
      }
    }
  }

  disconnect() {
    this._fire("beforeDisconnect");

    globalThis.removeEventListener("message", this);

    this._fire("disconnected");
  }

  emit(data) {
    let transferables;
    if (this.broadcastChannel) this.broadcastChannel.postMessage(data);else {
      if (data.__transferables__) {
        transferables = data.__transferables__;
        delete data.__transferables__;
      } else if (_inWebWorker) self.postMessage(data, transferables);else parent.postMessage(data, this.config.target_origin, transferables);
    }
  }

  async execute(code) {
    try {
      if (code.type === "requirements") {
        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirementsInWindow"])(code.requirements);
      } else if (code.type === "script") {
        if (code.src) {
          var script_node = document.createElement("script");
          script_node.setAttribute("type", code.attrs.type);
          script_node.setAttribute("src", code.src);
          document.head.appendChild(script_node);
        } else {
          if (code.content && code.attrs.lang === "javascript") {
            // document.addEventListener("DOMContentLoaded", function(){
            if (code.attrs.type === "module") {
              await executeEsModule(code.content);
            } else {
              eval(code.content);
            } // });

          } else {
            var node = document.createElement("script");

            for (let k in code.attrs) {
              node.setAttribute(k, code.attrs[k]);
            }

            node.appendChild(document.createTextNode(code.content));
            document.body.appendChild(node);
          }
        }
      } else if (code.type === "style") {
        const style_node = document.createElement("style");

        if (code.src) {
          style_node.src = code.src;
        }

        style_node.innerHTML = code.content;
        document.head.appendChild(style_node);
      } else if (code.type === "link") {
        const link_node_ = document.createElement("link");

        if (code.rel) {
          link_node_.rel = code.rel;
        }

        if (code.href) {
          link_node_.href = code.href;
        }

        if (code.attrs && code.attrs.type) {
          link_node_.type = code.attrs.type;
        }

        document.head.appendChild(link_node_);
      } else if (code.type === "html") {
        document.body.appendChild(_htmlToElement(code.content));
      } else {
        throw "unsupported code type.";
      }

      if (_inWebWorker) self.postMessage({
        type: "executed"
      });else parent.postMessage({
        type: "executed"
      }, this.config.target_origin);
    } catch (e) {
      console.error("failed to execute scripts: ", code, e);
      if (_inWebWorker) self.postMessage({
        type: "executed",
        error: e.stack || String(e)
      });else parent.postMessage({
        type: "executed",
        error: e.stack || String(e)
      }, this.config.target_origin);
    }
  }

}
function setupIframe(config) {
  config = config || {};
  config.dedicated_thread = false;
  config.lang = "javascript";
  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"];
  const conn = new Connection(config);
  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(conn, config);
  conn.connect();
}

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\\
  !*** ./src/rpc.js ***!
  \\********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return API_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return RPC; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the RPC object used both by the application
 * site, and by each plugin
 */

const API_VERSION = "0.2.3";
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;

function _appendBuffer(buffer1, buffer2) {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
}

function indexObject(obj, is) {
  if (!is) throw new Error("undefined index");
  if (typeof is === "string") return indexObject(obj, is.split("."));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));
}
/**
 * RPC object represents a single site in the
 * communication protocol between the application and the plugin
 *
 * @param {Object} connection a special object allowing to send
 * and receive messages from the opposite site (basically it
 * should only provide send() and onMessage() methods)
 */


class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(connection, config, codecs) {
    super(config && config.debug);
    this._connection = connection;
    this.config = config || {};
    this._codecs = codecs || {};
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._remote_set = false; // make sure there is an execute function

    const name = this.config.name;

    this._connection.execute = this._connection.execute || function () {
      throw new Error(\`connection.execute not implemented (in "\${name}")\`);
    };

    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();

    this._method_refs.onReady(() => {
      this._fire("remoteIdle");
    });

    this._method_refs.onBusy(() => {
      this._fire("remoteBusy");
    });

    this._setupMessageHanlders();
  }

  init() {
    this._connection.emit({
      type: "initialized",
      config: this.config,
      peer_id: this._connection.peer_id
    });
  }

  setConfig(config) {
    if (config) for (const k of Object.keys(config)) {
      this.config[k] = config[k];
    }
  }
  /**
   * Set a handler to be called when received a responce from the
   * remote site reporting that the previously provided interface
   * has been successfully set as remote for that site
   *
   * @param {Function} handler
   */


  getRemoteCallStack() {
    return this._method_refs.getStack();
  }
  /**
   * @returns {Object} set of remote interface methods
   */


  getRemote() {
    return this._remote_interface;
  }
  /**
   * Sets the interface of this site making it available to the
   * remote site by sending a message with a set of methods names
   *
   * @param {Object} _interface to set
   */


  setInterface(_interface, config) {
    config = config || {};
    this.config.name = config.name || this.config.name;
    this.config.description = config.description || this.config.description;

    if (this.config.forwarding_functions) {
      for (let func_name of this.config.forwarding_functions) {
        const _remote = this._remote_interface;

        if (_remote[func_name]) {
          if (_interface.constructor === Object) {
            if (!_interface[func_name]) {
              _interface[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          } else if (_interface.constructor.constructor === Function) {
            if (!_interface.constructor.prototype[func_name]) {
              _interface.constructor.prototype[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          }
        }
      }
    }

    this._local_api = _interface;
    if (!this._remote_set) this._fire("interfaceAvailable");else this.sendInterface();
    return new Promise(resolve => {
      this.once("interfaceSetAsRemote", resolve);
    });
  }
  /**
   * Sends the actual interface to the remote site upon it was
   * updated or by a special request of the remote site
   */


  sendInterface() {
    if (!this._local_api) {
      throw new Error("interface is not set.");
    }

    this._encode(this._local_api, true).then(api => {
      this._connection.emit({
        type: "setInterface",
        api: api
      });
    });
  }

  _disposeObject(objectId) {
    if (this._object_store[objectId]) {
      delete this._object_store[objectId];
    } else {
      throw new Error(\`Object (id=\${objectId}) not found.\`);
    }
  }

  disposeObject(obj) {
    return new Promise((resolve, reject) => {
      if (this._object_weakmap.has(obj)) {
        const objectId = this._object_weakmap.get(obj);

        this._connection.once("disposed", data => {
          if (data.error) reject(new Error(data.error));else resolve();
        });

        this._connection.emit({
          type: "disposeObject",
          object_id: objectId
        });
      } else {
        throw new Error("Invalid object");
      }
    });
  }
  /**
   * Handles a message from the remote site
   */


  _setupMessageHanlders() {
    this._connection.on("init", this.init);

    this._connection.on("execute", data => {
      Promise.resolve(this._connection.execute(data.code)).then(() => {
        this._connection.emit({
          type: "executed"
        });
      }).catch(e => {
        console.error(e);

        this._connection.emit({
          type: "executed",
          error: String(e)
        });
      });
    });

    this._connection.on("method", async data => {
      let resolve, reject, method, method_this, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        const _interface = this._object_store[data.object_id];
        method = indexObject(_interface, data.name);

        if (data.name.includes(".")) {
          const tmp = data.name.split(".");
          const intf_index = tmp.slice(0, tmp.length - 1).join(".");
          method_this = indexObject(_interface, intf_index);
        } else {
          method_this = _interface;
        }

        args = await this._unwrap(data.args, true);

        if (data.promise) {
          result = method.apply(method_this, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method.apply(method_this, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("callback", async data => {
      let resolve, reject, method, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        if (data.promise) {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          result = method.apply(null, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          method.apply(null, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("disposeObject", data => {
      try {
        this._disposeObject(data.object_id);

        this._connection.emit({
          type: "disposed"
        });
      } catch (e) {
        console.error(e);

        this._connection.emit({
          type: "disposed",
          error: String(e)
        });
      }
    });

    this._connection.on("setInterface", data => {
      this._setRemoteInterface(data.api);
    });

    this._connection.on("getInterface", () => {
      this._fire("getInterface");

      if (this._local_api) {
        this.sendInterface();
      } else {
        this.once("interfaceAvailable", () => {
          this.sendInterface();
        });
      }
    });

    this._connection.on("interfaceSetAsRemote", () => {
      this._remote_set = true;

      this._fire("interfaceSetAsRemote");
    });

    this._connection.on("disconnect", () => {
      this._fire("beforeDisconnect");

      this._connection.disconnect();

      this._fire("disconnected");
    });
  }
  /**
   * Sends a requests to the remote site asking it to provide its
   * current interface
   */


  requestRemote() {
    this._connection.emit({
      type: "getInterface"
    });
  }

  _ndarray(typedArray, shape, dtype) {
    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(typedArray);

    if (dtype && dtype !== _dtype) {
      throw "dtype doesn't match the type of the array: " + _dtype + " != " + dtype;
    }

    shape = shape || [typedArray.length];
    return {
      _rtype: "ndarray",
      _rvalue: typedArray.buffer,
      _rshape: shape,
      _rdtype: _dtype
    };
  }
  /**
   * Sets the new remote interface provided by the other site
   *
   * @param {Array} names list of function names
   */


  _setRemoteInterface(api) {
    this._decode(api).then(intf => {
      // update existing interface instead of recreating it
      // this will preserve the object reference
      if (this._remote_interface) {
        // clear the interface
        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces


        Object.assign(this._remote_interface, intf);
      } else this._remote_interface = intf;

      this._fire("remoteReady");

      this._reportRemoteSet();
    });
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * method. When the generated function is called, it will send the
   * corresponding message to the remote site asking it to execute
   * the particular method of its interface
   *
   * @param {String} name of the remote method
   *
   * @returns {Function} wrapped remote method
   */


  _genRemoteMethod(targetId, name, objectId) {
    const me = this;

    const remoteMethod = function () {
      return new Promise(async (resolve, reject) => {
        let id = null;

        try {
          id = me._method_refs.put(objectId ? objectId + "/" + name : name);

          const wrapped_resolve = function () {
            if (id !== null) me._method_refs.fetch(id);
            return resolve.apply(this, arguments);
          };

          const wrapped_reject = function () {
            if (id !== null) me._method_refs.fetch(id);
            return reject.apply(this, arguments);
          };

          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together

          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;
          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;
          let args = Array.prototype.slice.call(arguments);
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;

          if (name === "register" || name === "registerService" || name === "register_service" || name === "export" || name === "on") {
            args = await me._wrap(args, true);
          } else {
            args = await me._wrap(args);
          }

          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;

          me._connection.emit({
            type: "method",
            target_id: targetId,
            name: name,
            object_id: objectId,
            args: args,
            promise: encodedPromise,
            with_kwargs: withKwargs
          }, transferables);
        } catch (e) {
          if (id) me._method_refs.fetch(id);
          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);
        }
      });
    };

    remoteMethod.__remote_method = true;
    return remoteMethod;
  }
  /**
   * Sends a responce reporting that interface just provided by the
   * remote site was successfully set by this site as remote
   */


  _reportRemoteSet() {
    this._connection.emit({
      type: "interfaceSetAsRemote"
    });
  }
  /**
   * Prepares the provided set of remote method arguments for
   * sending to the remote site, replaces all the callbacks with
   * identifiers
   *
   * @param {Array} args to wrap
   *
   * @returns {Array} wrapped arguments
   */


  async _encode(aObject, asInterface, objectId) {
    const aType = typeof aObject;

    if (aType === "number" || aType === "string" || aType === "boolean" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {
      return aObject;
    }

    let bObject;

    if (typeof aObject === "function") {
      if (asInterface) {
        if (!objectId) throw new Error("objectId is not specified.");
        bObject = {
          _rtype: "interface",
          _rtarget_id: this._connection.peer_id,
          _rintf: objectId,
          _rvalue: asInterface
        };

        this._method_weakmap.set(aObject, bObject);
      } else if (this._method_weakmap.has(aObject)) {
        bObject = this._method_weakmap.get(aObject);
      } else {
        const cid = this._store.put(aObject);

        bObject = {
          _rtype: "callback",
          _rtarget_id: this._connection.peer_id,
          _rname: aObject.constructor && aObject.constructor.name || cid,
          _rvalue: cid
        };
      }

      return bObject;
    } // skip if already encoded


    if (aObject.constructor instanceof Object && aObject._rtype) {
      // make sure the interface functions are encoded
      if (aObject._rintf) {
        const temp = aObject._rtype;
        delete aObject._rtype;
        bObject = await this._encode(aObject, asInterface, objectId);
        bObject._rtype = temp;
      } else {
        bObject = aObject;
      }

      return bObject;
    }

    const transferables = [];
    const _transfer = aObject._transfer;
    const isarray = Array.isArray(aObject);

    for (let tp of Object.keys(this._codecs)) {
      const codec = this._codecs[tp];

      if (codec.encoder && aObject instanceof codec.type) {
        // TODO: what if multiple encoders found
        let encodedObj = await Promise.resolve(codec.encoder(aObject));
        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object

        if (encodedObj && encodedObj._rintf) {
          const temp = encodedObj._rtype;
          delete encodedObj._rtype;
          encodedObj = await this._encode(encodedObj, asInterface, objectId);
          encodedObj._rtype = temp;
        }

        bObject = encodedObj;
        return bObject;
      }
    }

    if (
    /*global tf*/
    typeof tf !== "undefined" && tf.Tensor && aObject instanceof tf.Tensor) {
      const v_buffer = aObject.dataSync();

      if (aObject._transfer || _transfer) {
        transferables.push(v_buffer.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: v_buffer.buffer,
        _rshape: aObject.shape,
        _rdtype: aObject.dtype
      };
    } else if (
    /*global nj*/
    typeof nj !== "undefined" && nj.NdArray && aObject instanceof nj.NdArray) {
      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject.selection.data);

      if (aObject._transfer || _transfer) {
        transferables.push(aObject.selection.data.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: aObject.selection.data.buffer,
        _rshape: aObject.shape,
        _rdtype: dtype
      };
    } else if (aObject instanceof Error) {
      console.error(aObject);
      bObject = {
        _rtype: "error",
        _rvalue: aObject.toString()
      };
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } // send objects supported by structure clone algorithm
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== "undefined" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== "undefined" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== "undefined" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== "undefined" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== "undefined" && aObject instanceof FileSystemWritableFileStream) {
      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rname: aObject.name,
        _rmime: aObject.type,
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } else if (aObject instanceof Blob) {
      bObject = {
        _rtype: "blob",
        _rvalue: aObject
      };
    } else if (aObject instanceof ArrayBufferView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject);
      bObject = {
        _rtype: "typedarray",
        _rvalue: aObject.buffer,
        _rdtype: dtype
      };
    } else if (aObject instanceof DataView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "memoryview",
        _rvalue: aObject.buffer
      };
    } else if (aObject instanceof Set) {
      bObject = {
        _rtype: "set",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject instanceof Map) {
      bObject = {
        _rtype: "orderedmap",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {
      bObject = isarray ? [] : {};
      let keys; // an object/array

      if (aObject.constructor === Object || Array.isArray(aObject)) {
        keys = Object.keys(aObject);
      } // a class
      else if (aObject.constructor === Function) {
        throw new Error("Please instantiate the class before exportting it.");
      } // instance of a class
      else if (aObject.constructor.constructor === Function) {
        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object
        // always encode class instance as interface

        asInterface = true;
      } else {
        throw Error("Unsupported interface type");
      }

      let hasFunction = false; // encode interfaces

      if (aObject._rintf || asInterface) {
        if (!objectId) {
          if (typeof aObject._rintf === "string" && aObject._rintf.length > 0) {
            objectId = aObject._rintf; // enable custom object id
          } else {
            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
          } // Note: object with the same id will be overwritten


          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);
          this._object_store[objectId] = aObject;
        }

        for (let k of keys) {
          if (k === "constructor") continue;

          if (k.startsWith("_")) {
            continue;
          }

          bObject[k] = await this._encode(aObject[k], typeof asInterface === "string" ? asInterface + "." + k : k, objectId);

          if (typeof aObject[k] === "function") {
            hasFunction = true;
          }
        } // object id for dispose the object remotely


        if (hasFunction) bObject._rintf = objectId; // remove interface when closed

        if (aObject.on && typeof aObject.on === "function") {
          aObject.on("close", () => {
            delete this._object_store[objectId];
          });
        }
      } else {
        for (let k of keys) {
          if (["hasOwnProperty", "constructor"].includes(k)) continue;
          bObject[k] = await this._encode(aObject[k]);
        }
      } // for example, browserFS object

    } else if (typeof aObject === "object") {
      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));
      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();

      for (let k of keys) {
        if (["hasOwnProperty", "constructor"].includes(k)) continue; // encode as interface

        bObject[k] = await this._encode(aObject[k], k, bObject);
      } // object id, used for dispose the object


      bObject._rintf = objectId;
    } else {
      throw "imjoy-rpc: Unsupported data type:" + aObject;
    }

    if (transferables.length > 0) {
      bObject.__transferables__ = transferables;
    }

    if (!bObject) {
      throw new Error("Failed to encode object");
    }

    return bObject;
  }

  async _decode(aObject, withPromise) {
    if (!aObject) {
      return aObject;
    }

    let bObject;

    if (aObject["_rtype"]) {
      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          aObject = await this._decode(aObject, withPromise);
          aObject._rtype = temp;
        }

        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));
      } else if (aObject._rtype === "callback") {
        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);
      } else if (aObject._rtype === "interface") {
        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);
      } else if (aObject._rtype === "ndarray") {
        /*global nj tf*/
        //create build array/tensor if used in the plugin
        if (typeof nj !== "undefined" && nj.array) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);
        } else if (typeof tf !== "undefined" && tf.Tensor) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);
        } else {
          //keep it as regular if transfered to the main app
          bObject = aObject;
        }
      } else if (aObject._rtype === "error") {
        bObject = new Error(aObject._rvalue);
      } else if (aObject._rtype === "file") {
        if (aObject._rvalue instanceof File) {
          bObject = aObject._rvalue; //patch _path

          bObject._path = aObject._rpath;
        } else {
          bObject = new File([aObject._rvalue], aObject._rname, {
            type: aObject._rmime
          });
          bObject._path = aObject._rpath;
        }
      } else if (aObject._rtype === "typedarray") {
        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
        if (!arraytype) throw new Error("unsupported dtype: " + aObject._rdtype);
        bObject = new arraytype(aObject._rvalue);
      } else if (aObject._rtype === "memoryview") {
        bObject = new DataView(aObject._rvalue);
      } else if (aObject._rtype === "blob") {
        if (aObject._rvalue instanceof Blob) {
          bObject = aObject._rvalue;
        } else {
          bObject = new Blob([aObject._rvalue], {
            type: aObject._rmime
          });
        }
      } else if (aObject._rtype === "orderedmap") {
        bObject = new Map(await this._decode(aObject._rvalue, withPromise));
      } else if (aObject._rtype === "set") {
        bObject = new Set(await this._decode(aObject._rvalue, withPromise));
      } else {
        // make sure all the interface functions are decoded
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          bObject = await this._decode(aObject, withPromise);
          bObject._rtype = temp;
        } else bObject = aObject;
      }
    } else if (aObject.constructor === Object || Array.isArray(aObject)) {
      const isarray = Array.isArray(aObject);
      bObject = isarray ? [] : {};

      for (let k of Object.keys(aObject)) {
        if (isarray || aObject.hasOwnProperty(k)) {
          const v = aObject[k];
          bObject[k] = await this._decode(v, withPromise);
        }
      }
    } else {
      bObject = aObject;
    }

    if (bObject === undefined) {
      throw new Error("Failed to decode object");
    } // store the object id for dispose


    if (aObject._rintf) {
      this._object_weakmap.set(bObject, aObject._rintf);
    }

    return bObject;
  }

  async _wrap(args, asInterface) {
    return await this._encode(args, asInterface);
  }
  /**
   * Unwraps the set of arguments delivered from the remote site,
   * replaces all callback identifiers with a function which will
   * initiate sending that callback identifier back to other site
   *
   * @param {Object} args to unwrap
   *
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Array} unwrapped args
   */


  async _unwrap(args, withPromise) {
    return await this._decode(args, withPromise);
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * callback. When the generated function is called, it will send
   * the corresponding message to the remote site asking it to
   * execute the particular callback previously saved during a call
   * by the remote site a method from the interface of this site
   *
   * @param {Number} id of the remote callback to execute
   * @param {Number} argNum argument index of the callback
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Function} wrapped remote callback
   */


  _genRemoteCallback(targetId, cid, withPromise) {
    const me = this;
    let remoteCallback;

    if (withPromise) {
      remoteCallback = function () {
        return new Promise(async (resolve, reject) => {
          const args = await me._wrap(Array.prototype.slice.call(arguments));
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;
          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;
          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together

          resolve.__promise_pair = encodedPromise[1]._rvalue;
          reject.__promise_pair = encodedPromise[0]._rvalue;

          try {
            me._connection.emit({
              type: "callback",
              target_id: targetId,
              id: cid,
              args: args,
              promise: encodedPromise,
              with_kwargs: withKwargs
            }, transferables);
          } catch (e) {
            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);
          }
        });
      };

      return remoteCallback;
    } else {
      remoteCallback = async function () {
        const args = await me._wrap(Array.prototype.slice.call(arguments));
        const argLength = args.length; // if the last argument is an object, mark it as kwargs

        const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
        if (withKwargs) delete args[argLength - 1]._rkwargs;
        const transferables = args.__transferables__;
        if (transferables) delete args.__transferables__;
        return me._connection.emit({
          type: "callback",
          target_id: targetId,
          id: cid,
          args: args,
          with_kwargs: withKwargs
        }, transferables);
      };

      return remoteCallback;
    }
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
    this._remote_interface = null;
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();
  }
  /**
   * Sends the notification message and breaks the connection
   */


  disconnect() {
    this._connection.emit({
      type: "disconnect"
    });

    this.reset();
    setTimeout(() => {
      this._connection.disconnect();
    }, 2000);
  }

}
/**
 * ReferenceStore is a special object which stores other objects
 * and provides the references (number) instead. This reference
 * may then be sent over a json-based communication channel (IPC
 * to another Node.js process or a message to the Worker). Other
 * site may then provide the reference in the responce message
 * implying the given object should be activated.
 *
 * Primary usage for the ReferenceStore is a storage for the
 * callbacks, which therefore makes it possible to initiate a
 * callback execution by the opposite site (which normally cannot
 * directly execute functions over the communication channel).
 *
 * Each stored object can only be fetched once and is not
 * available for the second time. Each stored object must be
 * fetched, since otherwise it will remain stored forever and
 * consume memory.
 *
 * Stored object indeces are simply the numbers, which are however
 * released along with the objects, and are later reused again (in
 * order to postpone the overflow, which should not likely happen,
 * but anyway).
 */

class ReferenceStore {
  constructor() {
    this._store = {}; // stored object

    this._indices = [0]; // smallest available indices

    this._readyHandler = function () {};

    this._busyHandler = function () {};

    this._readyHandler();
  }
  /**
   * call handler when the store is empty
   *
   * @param {FUNCTION} id of a handler
   */


  onReady(readyHandler) {
    this._readyHandler = readyHandler || function () {};
  }
  /**
   * call handler when the store is not empty
   *
   * @param {FUNCTION} id of a handler
   */


  onBusy(busyHandler) {
    this._busyHandler = busyHandler || function () {};
  }
  /**
   * get the length of the store
   *
   */


  getStack() {
    return Object.keys(this._store).length;
  }
  /**
   * @function _genId() generates the new reference id
   *
   * @returns {Number} smallest available id and reserves it
   */


  _genId() {
    let id;

    if (this._indices.length === 1) {
      id = this._indices[0]++;
    } else {
      id = this._indices.shift();
    }

    return id;
  }
  /**
   * Releases the given reference id so that it will be available by
   * another object stored
   *
   * @param {Number} id to release
   */


  _releaseId(id) {
    for (let i = 0; i < this._indices.length; i++) {
      if (id < this._indices[i]) {
        this._indices.splice(i, 0, id);

        break;
      }
    } // cleaning-up the sequence tail


    for (let i = this._indices.length - 1; i >= 0; i--) {
      if (this._indices[i] - 1 === this._indices[i - 1]) {
        this._indices.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Stores the given object and returns the refernce id instead
   *
   * @param {Object} obj to store
   *
   * @returns {Number} reference id of the stored object
   */


  put(obj) {
    if (this._busyHandler && Object.keys(this._store).length === 0) {
      this._busyHandler();
    }

    const id = this._genId();

    this._store[id] = obj;
    return id;
  }
  /**
   * Retrieves previously stored object and releases its reference
   *
   * @param {Number} id of an object to retrieve
   */


  fetch(id) {
    const obj = this._store[id];

    if (obj && !obj.__remote_method) {
      delete this._store[id];

      this._releaseId(id);

      if (this._readyHandler && Object.keys(this._store).length === 0) {
        this._readyHandler();
      }
    }

    if (obj && obj.__promise_pair) {
      this.fetch(obj.__promise_pair);
    }

    return obj;
  }

}

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\\
  !*** ./src/utils.js ***!
  \\**********************/
/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dtypeToTypedArray", function() { return dtypeToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWindow", function() { return loadRequirementsInWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWebworker", function() { return loadRequirementsInWebworker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return loadRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeConfig", function() { return normalizeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtypeMapping", function() { return typedArrayToDtypeMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtype", function() { return typedArrayToDtype; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheRequirements", function() { return cacheRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupServiceWorker", function() { return setupServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlJoin", function() { return urlJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
function randId() {
  return Math.random().toString(36).substr(2, 10) + new Date().getTime();
}
const dtypeToTypedArray = {
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  float32: Float32Array,
  float64: Float64Array,
  array: Array
};
async function loadRequirementsInWindow(requirements) {
  function _importScript(url) {
    //url is URL of external file, implementationCode is the code
    //to be called from the file, location is the location to
    //insert the <script> element
    return new Promise((resolve, reject) => {
      var scriptTag = document.createElement("script");
      scriptTag.src = url;
      scriptTag.type = "text/javascript";
      scriptTag.onload = resolve;

      scriptTag.onreadystatechange = function () {
        if (this.readyState === "loaded" || this.readyState === "complete") {
          resolve();
        }
      };

      scriptTag.onerror = reject;
      document.head.appendChild(scriptTag);
    });
  } // support importScripts outside web worker


  async function importScripts() {
    var args = Array.prototype.slice.call(arguments),
        len = args.length,
        i = 0;

    for (; i < len; i++) {
      await _importScript(args[i]);
    }
  }

  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      var link_node;
      requirements = typeof requirements === "string" ? [requirements] : requirements;

      if (Array.isArray(requirements)) {
        for (var i = 0; i < requirements.length; i++) {
          if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
            if (requirements[i].startsWith("css:")) {
              requirements[i] = requirements[i].slice(4);
            }

            link_node = document.createElement("link");
            link_node.rel = "stylesheet";
            link_node.href = requirements[i];
            document.head.appendChild(link_node);
          } else if (requirements[i].toLowerCase().endsWith(".mjs") || requirements[i].startsWith("mjs:")) {
            // import esmodule
            if (requirements[i].startsWith("mjs:")) {
              requirements[i] = requirements[i].slice(4);
            }

            await import(
            /* webpackIgnore: true */
            requirements[i]);
          } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
            if (requirements[i].startsWith("js:")) {
              requirements[i] = requirements[i].slice(3);
            }

            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("http")) {
            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("cache:")) {//ignore cache
          } else {
            console.log("Unprocessed requirements url: " + requirements[i]);
          }
        }
      } else {
        throw "unsupported requirements definition";
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
async function loadRequirementsInWebworker(requirements) {
  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      if (!Array.isArray(requirements)) {
        requirements = [requirements];
      }

      for (var i = 0; i < requirements.length; i++) {
        if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
          throw "unable to import css in a webworker";
        } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
          if (requirements[i].startsWith("js:")) {
            requirements[i] = requirements[i].slice(3);
          }

          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("http")) {
          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("cache:")) {//ignore cache
        } else {
          console.log("Unprocessed requirements url: " + requirements[i]);
        }
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
function loadRequirements(requirements) {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return loadRequirementsInWebworker(requirements);
  } else {
    return loadRequirementsInWindow(requirements);
  }
}
function normalizeConfig(config) {
  config.version = config.version || "0.1.0";
  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;
  config.type = config.type || "rpc-window";
  config.id = config.id || randId();
  config.target_origin = config.target_origin || "*";
  config.allow_execution = config.allow_execution || false; // remove functions

  config = Object.keys(config).reduce((p, c) => {
    if (typeof config[c] !== "function") p[c] = config[c];
    return p;
  }, {});
  return config;
}
const typedArrayToDtypeMapping = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};
const typedArrayToDtypeKeys = [];

for (const arrType of Object.keys(typedArrayToDtypeMapping)) {
  typedArrayToDtypeKeys.push(eval(arrType));
}

function typedArrayToDtype(obj) {
  let dtype = typedArrayToDtypeMapping[obj.constructor.name];

  if (!dtype) {
    const pt = Object.getPrototypeOf(obj);

    for (const arrType of typedArrayToDtypeKeys) {
      if (pt instanceof arrType) {
        dtype = typedArrayToDtypeMapping[arrType.name];
        break;
      }
    }
  }

  return dtype;
}

function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}

async function cacheRequirements(requirements) {
  requirements = requirements || [];

  if (!Array.isArray(requirements)) {
    requirements = [requirements];
  }

  for (let req of requirements) {
    //remove prefix
    if (req.startsWith("js:")) req = req.slice(3);
    if (req.startsWith("css:")) req = req.slice(4);
    if (req.startsWith("cache:")) req = req.slice(6);
    if (!req.startsWith("http")) continue;
    await cacheUrlInServiceWorker(req).catch(e => {
      console.error(e);
    });
  }
}
function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {
  // register service worker for offline access
  if ("serviceWorker" in navigator) {
    baseUrl = baseUrl || "/";
    navigator.serviceWorker.register(baseUrl + "plugin-service-worker.js").then(function (registration) {
      // Registration was successful
      console.log("ServiceWorker registration successful with scope: ", registration.scope);
    }, function (err) {
      // registration failed :(
      console.log("ServiceWorker registration failed: ", err);
    });
    targetOrigin = targetOrigin || "*";
    cacheCallback = cacheCallback || cacheRequirements;

    if (cacheCallback && typeof cacheCallback !== "function") {
      throw new Error("config.cache_requirements must be a function");
    }

    window.addEventListener("message", function (e) {
      if (targetOrigin === "*" || e.origin === targetOrigin) {
        const m = e.data;

        if (m.type === "cacheRequirements") {
          cacheCallback(m.requirements);
        }
      }
    });
  }
} //#Source https://bit.ly/2neWfJ2

function urlJoin(...args) {
  return args.join("/").replace(/[\\/]+/g, "/").replace(/^(.+):\\//, "$1://").replace(/^file:/, "file:/").replace(/\\/(\\?|&|#[^!])/g, "$1").replace(/\\?/g, "&").replace("&", "?");
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}

/***/ })

/******/ });
});
//# sourceMappingURL=imjoy-rpc.js.map

//# sourceURL=webpack://%5Bname%5D/./node_modules/imjoy-rpc/dist/imjoy-rpc.js?`)},"./node_modules/imjoy-rpc/index.js":function(module,exports,__webpack_require__){eval(`module.exports = {imjoyRPC: __webpack_require__(/*! ./dist/imjoy-rpc.js */ "./node_modules/imjoy-rpc/dist/imjoy-rpc.js"), imjoyRPCSocketIO: __webpack_require__(/*! ./dist/imjoy-rpc-socketio */ "./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js")};

//# sourceURL=webpack://%5Bname%5D/./node_modules/imjoy-rpc/index.js?`)},"./node_modules/immediate/lib/index.js":function(module,exports,__webpack_require__){eval(`
var types = [
  __webpack_require__(/*! ./nextTick */ 0),
  __webpack_require__(/*! ./queueMicrotask */ "./node_modules/immediate/lib/queueMicrotask.js"),
  __webpack_require__(/*! ./mutation.js */ "./node_modules/immediate/lib/mutation.js"),
  __webpack_require__(/*! ./messageChannel */ "./node_modules/immediate/lib/messageChannel.js"),
  __webpack_require__(/*! ./stateChange */ "./node_modules/immediate/lib/stateChange.js"),
  __webpack_require__(/*! ./timeout */ "./node_modules/immediate/lib/timeout.js")
];
var draining;
var currentQueue;
var queueIndex = -1;
var queue = [];
var scheduled = false;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    nextTick();
  }
}

//named nextTick for less confusing stack traces
function nextTick() {
  if (draining) {
    return;
  }
  scheduled = false;
  draining = true;
  var len = queue.length;
  var timeout = setTimeout(cleanUpNextTick);
  while (len) {
    currentQueue = queue;
    queue = [];
    while (currentQueue && ++queueIndex < len) {
      currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  queueIndex = -1;
  draining = false;
  clearTimeout(timeout);
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  var fun = this.fun;
  var array = this.array;
  switch (array.length) {
  case 0:
    return fun();
  case 1:
    return fun(array[0]);
  case 2:
    return fun(array[0], array[1]);
  case 3:
    return fun(array[0], array[1], array[2]);
  default:
    return fun.apply(null, array);
  }

};
module.exports = immediate;
function immediate(task) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(task, args));
  if (!scheduled && !draining) {
    scheduled = true;
    scheduleDrain();
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/index.js?`)},"./node_modules/immediate/lib/messageChannel.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/messageChannel.js?`)},"./node_modules/immediate/lib/mutation.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/mutation.js?`)},"./node_modules/immediate/lib/queueMicrotask.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {
exports.test = function () {
  return typeof global.queueMicrotask === 'function';
};

exports.install = function (func) {
  return function () {
    global.queueMicrotask(func);
  };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/queueMicrotask.js?`)},"./node_modules/immediate/lib/stateChange.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/stateChange.js?`)},"./node_modules/immediate/lib/timeout.js":function(module,exports,__webpack_require__){eval(`
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/timeout.js?`)},"./node_modules/isarray/index.js":function(module,exports){eval(`var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/isarray/index.js?`)},"./node_modules/js-yaml/index.js":function(module,exports,__webpack_require__){eval(`


var yaml = __webpack_require__(/*! ./lib/js-yaml.js */ "./node_modules/js-yaml/lib/js-yaml.js");


module.exports = yaml;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/index.js?`)},"./node_modules/js-yaml/lib/js-yaml.js":function(module,exports,__webpack_require__){eval(`


var loader = __webpack_require__(/*! ./js-yaml/loader */ "./node_modules/js-yaml/lib/js-yaml/loader.js");
var dumper = __webpack_require__(/*! ./js-yaml/dumper */ "./node_modules/js-yaml/lib/js-yaml/dumper.js");


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = __webpack_require__(/*! ./js-yaml/type */ "./node_modules/js-yaml/lib/js-yaml/type.js");
module.exports.Schema              = __webpack_require__(/*! ./js-yaml/schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");
module.exports.FAILSAFE_SCHEMA     = __webpack_require__(/*! ./js-yaml/schema/failsafe */ "./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js");
module.exports.JSON_SCHEMA         = __webpack_require__(/*! ./js-yaml/schema/json */ "./node_modules/js-yaml/lib/js-yaml/schema/json.js");
module.exports.CORE_SCHEMA         = __webpack_require__(/*! ./js-yaml/schema/core */ "./node_modules/js-yaml/lib/js-yaml/schema/core.js");
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = __webpack_require__(/*! ./js-yaml/exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/failsafe */ "./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js");
module.exports.SAFE_SCHEMA    = __webpack_require__(/*! ./js-yaml/schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
module.exports.DEFAULT_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml.js?`)},"./node_modules/js-yaml/lib/js-yaml/common.js":function(module,exports,__webpack_require__){eval(`


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/common.js?`)},"./node_modules/js-yaml/lib/js-yaml/dumper.js":function(module,exports,__webpack_require__){eval(`

/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");
var DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");
var DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* \` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\\\0';
ESCAPE_SEQUENCES[0x07]   = '\\\\a';
ESCAPE_SEQUENCES[0x08]   = '\\\\b';
ESCAPE_SEQUENCES[0x09]   = '\\\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\\\e';
ESCAPE_SEQUENCES[0x22]   = '\\\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\\\_';
ESCAPE_SEQUENCES[0x2028] = '\\\\L';
ESCAPE_SEQUENCES[0x2029] = '\\\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “\`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \\n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \\n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\\n';
  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\\n+)([^\\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \\n.
  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \\n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\\n' + line.slice(start, end);
      // skip the space that was output as \\n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \\n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes \`object\` and writes it to global \`result\`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/dumper.js?`)},"./node_modules/js-yaml/lib/js-yaml/exception.js":function(module,exports,__webpack_require__){eval(`// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/exception.js?`)},"./node_modules/js-yaml/lib/js-yaml/loader.js":function(module,exports,__webpack_require__){eval(`

/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");
var Mark                = __webpack_require__(/*! ./mark */ "./node_modules/js-yaml/lib/js-yaml/mark.js");
var DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
var DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\\x00' :
        (c === 0x61/* a */) ? '\\x07' :
        (c === 0x62/* b */) ? '\\x08' :
        (c === 0x74/* t */) ? '\\x09' :
        (c === 0x09/* Tab */) ? '\\x09' :
        (c === 0x6E/* n */) ? '\\x0A' :
        (c === 0x76/* v */) ? '\\x0B' :
        (c === 0x66/* f */) ? '\\x0C' :
        (c === 0x72/* r */) ? '\\x0D' :
        (c === 0x65/* e */) ? '\\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \\ */) ? '\\x5C' :
        (c === 0x4E/* N */) ? '\\x85' :
        (c === 0x5F/* _ */) ? '\\xA0' :
        (c === 0x4C/* L */) ? '\\u2028' :
        (c === 0x50/* P */) ? '\\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* \` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \\ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\\n';
        }
      }

      // Break this \`while\` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of \`composeNode\`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of \`composeNode\`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // \`state.result\` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // \`state.result\` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing \`\\n\` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/loader.js?`)},"./node_modules/js-yaml/lib/js-yaml/mark.js":function(module,exports,__webpack_require__){eval(`


var common = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/mark.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema.js":function(module,exports,__webpack_require__){eval(`

/*eslint-disable max-len*/

var common        = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");
var Type          = __webpack_require__(/*! ./type */ "./node_modules/js-yaml/lib/js-yaml/type.js");


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/core.js":function(module,exports,__webpack_require__){eval(`// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./json */ "./node_modules/js-yaml/lib/js-yaml/schema/json.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/core.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/default_full.js":function(module,exports,__webpack_require__){eval(`// JS-YAML's default schema for \`load\` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at \`Schema.create\` function.





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __webpack_require__(/*! ./default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js")
  ],
  explicit: [
    __webpack_require__(/*! ../type/js/undefined */ "./node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"),
    __webpack_require__(/*! ../type/js/regexp */ "./node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"),
    __webpack_require__(/*! ../type/js/function */ "./node_modules/js-yaml/lib/js-yaml/type/js/function.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/default_full.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js":function(module,exports,__webpack_require__){eval(`// JS-YAML's default schema for \`safeLoad\` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./core */ "./node_modules/js-yaml/lib/js-yaml/schema/core.js")
  ],
  implicit: [
    __webpack_require__(/*! ../type/timestamp */ "./node_modules/js-yaml/lib/js-yaml/type/timestamp.js"),
    __webpack_require__(/*! ../type/merge */ "./node_modules/js-yaml/lib/js-yaml/type/merge.js")
  ],
  explicit: [
    __webpack_require__(/*! ../type/binary */ "./node_modules/js-yaml/lib/js-yaml/type/binary.js"),
    __webpack_require__(/*! ../type/omap */ "./node_modules/js-yaml/lib/js-yaml/type/omap.js"),
    __webpack_require__(/*! ../type/pairs */ "./node_modules/js-yaml/lib/js-yaml/type/pairs.js"),
    __webpack_require__(/*! ../type/set */ "./node_modules/js-yaml/lib/js-yaml/type/set.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js":function(module,exports,__webpack_require__){eval(`// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  explicit: [
    __webpack_require__(/*! ../type/str */ "./node_modules/js-yaml/lib/js-yaml/type/str.js"),
    __webpack_require__(/*! ../type/seq */ "./node_modules/js-yaml/lib/js-yaml/type/seq.js"),
    __webpack_require__(/*! ../type/map */ "./node_modules/js-yaml/lib/js-yaml/type/map.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/json.js":function(module,exports,__webpack_require__){eval(`// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use \`Null\` and \`NULL\` as \`null\`, etc.





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./failsafe */ "./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js")
  ],
  implicit: [
    __webpack_require__(/*! ../type/null */ "./node_modules/js-yaml/lib/js-yaml/type/null.js"),
    __webpack_require__(/*! ../type/bool */ "./node_modules/js-yaml/lib/js-yaml/type/bool.js"),
    __webpack_require__(/*! ../type/int */ "./node_modules/js-yaml/lib/js-yaml/type/int.js"),
    __webpack_require__(/*! ../type/float */ "./node_modules/js-yaml/lib/js-yaml/type/float.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/json.js?`)},"./node_modules/js-yaml/lib/js-yaml/type.js":function(module,exports,__webpack_require__){eval(`

var YAMLException = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/binary.js":function(module,exports,__webpack_require__){eval(`var require;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include \`Buffer\` shim
  var _require = require;
  NodeBuffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
} catch (__) {}

var Type       = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/binary.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/bool.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/bool.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/float.js":function(module,exports,__webpack_require__){eval(`

var common = __webpack_require__(/*! ../common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var Type   = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +
  // .inf
  '|[-+]?\\\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with \`_\`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/float.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/int.js":function(module,exports,__webpack_require__){eval(`

var common = __webpack_require__(/*! ../common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var Type   = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with \`_\`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with \`_\`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/int.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/js/function.js":function(module,exports,__webpack_require__){eval(`var require;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = __webpack_require__(/*! esprima */ "./node_modules/esprima/dist/esprima.js");
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(/*! ../../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/js/function.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/js/regexp.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // \`/foo/gim\` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\\/([gim]*)$/.exec(data),
      modifiers = '';

  // \`/foo/gim\` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/js/regexp.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/js/undefined.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/js/undefined.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/map.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/map.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/merge.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/merge.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/null.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/null.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/omap.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/omap.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/pairs.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/pairs.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/seq.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/seq.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/set.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/set.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/str.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/str.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/timestamp.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\\\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/timestamp.js?`)},"./node_modules/json-schema-traverse/index.js":function(module,exports,__webpack_require__){eval(`

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\\//g, '~1');
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/json-schema-traverse/index.js?`)},"./node_modules/lodash/_Symbol.js":function(module,exports,__webpack_require__){eval(`var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_Symbol.js?`)},"./node_modules/lodash/_apply.js":function(module,exports){eval(`/**
 * A faster alternative to \`Function#apply\`, this function invokes \`func\`
 * with the \`this\` binding of \`thisArg\` and the arguments of \`args\`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The \`this\` binding of \`func\`.
 * @param {Array} args The arguments to invoke \`func\` with.
 * @returns {*} Returns the result of \`func\`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_apply.js?`)},"./node_modules/lodash/_arrayLikeKeys.js":function(module,exports,__webpack_require__){eval(`var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like \`value\`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable \`arguments.length\` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_arrayLikeKeys.js?`)},"./node_modules/lodash/_arrayMap.js":function(module,exports){eval(`/**
 * A specialized version of \`_.map\` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_arrayMap.js?`)},"./node_modules/lodash/_asciiToArray.js":function(module,exports){eval(`/**
 * Converts an ASCII \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_asciiToArray.js?`)},"./node_modules/lodash/_assignValue.js":function(module,exports,__webpack_require__){eval(`var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns \`value\` to \`key\` of \`object\` if the existing value is not equivalent
 * using [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_assignValue.js?`)},"./node_modules/lodash/_baseAssignValue.js":function(module,exports,__webpack_require__){eval(`var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of \`assignValue\` and \`assignMergeValue\` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseAssignValue.js?`)},"./node_modules/lodash/_baseFindIndex.js":function(module,exports){eval(`/**
 * The base implementation of \`_.findIndex\` and \`_.findLastIndex\` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseFindIndex.js?`)},"./node_modules/lodash/_baseGetTag.js":function(module,exports,__webpack_require__){eval(`var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** \`Object#toString\` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of \`getTag\` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the \`toStringTag\`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseGetTag.js?`)},"./node_modules/lodash/_baseIndexOf.js":function(module,exports,__webpack_require__){eval(`var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of \`_.indexOf\` without \`fromIndex\` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIndexOf.js?`)},"./node_modules/lodash/_baseIsArguments.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** \`Object#toString\` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of \`_.isArguments\`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an \`arguments\` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsArguments.js?`)},"./node_modules/lodash/_baseIsNaN.js":function(module,exports){eval(`/**
 * The base implementation of \`_.isNaN\` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is \`NaN\`, else \`false\`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsNaN.js?`)},"./node_modules/lodash/_baseIsNative.js":function(module,exports,__webpack_require__){eval(`var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match \`RegExp\`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\\[object .+?Constructor\\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of \`_.isNative\` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a native function,
 *  else \`false\`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsNative.js?`)},"./node_modules/lodash/_baseIsTypedArray.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** \`Object#toString\` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify \`toStringTag\` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of \`_.isTypedArray\` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a typed array, else \`false\`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsTypedArray.js?`)},"./node_modules/lodash/_baseKeys.js":function(module,exports,__webpack_require__){eval(`var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of \`_.keys\` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseKeys.js?`)},"./node_modules/lodash/_baseRest.js":function(module,exports,__webpack_require__){eval(`var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of \`_.rest\` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseRest.js?`)},"./node_modules/lodash/_baseSetToString.js":function(module,exports,__webpack_require__){eval(`var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of \`setToString\` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The \`toString\` result.
 * @returns {Function} Returns \`func\`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseSetToString.js?`)},"./node_modules/lodash/_baseSlice.js":function(module,exports){eval(`/**
 * The base implementation of \`_.slice\` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of \`array\`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseSlice.js?`)},"./node_modules/lodash/_baseTimes.js":function(module,exports){eval(`/**
 * The base implementation of \`_.times\` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke \`iteratee\`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseTimes.js?`)},"./node_modules/lodash/_baseToString.js":function(module,exports,__webpack_require__){eval(`var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various \`Number\` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of \`_.toString\` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseToString.js?`)},"./node_modules/lodash/_baseTrim.js":function(module,exports,__webpack_require__){eval(`var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\\s+/;

/**
 * The base implementation of \`_.trim\`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseTrim.js?`)},"./node_modules/lodash/_baseUnary.js":function(module,exports){eval(`/**
 * The base implementation of \`_.unary\` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseUnary.js?`)},"./node_modules/lodash/_castSlice.js":function(module,exports,__webpack_require__){eval(`var baseSlice = __webpack_require__(/*! ./_baseSlice */ "./node_modules/lodash/_baseSlice.js");

/**
 * Casts \`array\` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_castSlice.js?`)},"./node_modules/lodash/_charsEndIndex.js":function(module,exports,__webpack_require__){eval(`var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * Used by \`_.trim\` and \`_.trimEnd\` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsEndIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_charsEndIndex.js?`)},"./node_modules/lodash/_charsStartIndex.js":function(module,exports,__webpack_require__){eval(`var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * Used by \`_.trim\` and \`_.trimStart\` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsStartIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_charsStartIndex.js?`)},"./node_modules/lodash/_copyObject.js":function(module,exports,__webpack_require__){eval(`var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of \`source\` to \`object\`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns \`object\`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_copyObject.js?`)},"./node_modules/lodash/_coreJsData.js":function(module,exports,__webpack_require__){eval(`var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_coreJsData.js?`)},"./node_modules/lodash/_createAssigner.js":function(module,exports,__webpack_require__){eval(`var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like \`_.assign\`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_createAssigner.js?`)},"./node_modules/lodash/_defineProperty.js":function(module,exports,__webpack_require__){eval(`var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_defineProperty.js?`)},"./node_modules/lodash/_freeGlobal.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable \`global\` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_freeGlobal.js?`)},"./node_modules/lodash/_getNative.js":function(module,exports,__webpack_require__){eval(`var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at \`key\` of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else \`undefined\`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_getNative.js?`)},"./node_modules/lodash/_getRawTag.js":function(module,exports,__webpack_require__){eval(`var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [\`toStringTag\`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of \`baseGetTag\` which ignores \`Symbol.toStringTag\` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw \`toStringTag\`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_getRawTag.js?`)},"./node_modules/lodash/_getValue.js":function(module,exports){eval(`/**
 * Gets the value at \`key\` of \`object\`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_getValue.js?`)},"./node_modules/lodash/_hasUnicode.js":function(module,exports){eval(`/** Used to compose unicode character classes. */
var rsAstralRange = '\\\\ud800-\\\\udfff',
    rsComboMarksRange = '\\\\u0300-\\\\u036f',
    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',
    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\\\ufe0e\\\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if \`string\` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns \`true\` if a symbol is found, else \`false\`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_hasUnicode.js?`)},"./node_modules/lodash/_isIndex.js":function(module,exports){eval(`/** Used as references for various \`Number\` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\\d*)$/;

/**
 * Checks if \`value\` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid index, else \`false\`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isIndex.js?`)},"./node_modules/lodash/_isIterateeCall.js":function(module,exports,__webpack_require__){eval(`var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns \`true\` if the arguments are from an iteratee call,
 *  else \`false\`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isIterateeCall.js?`)},"./node_modules/lodash/_isMasked.js":function(module,exports,__webpack_require__){eval(`var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if \`func\` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns \`true\` if \`func\` is masked, else \`false\`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isMasked.js?`)},"./node_modules/lodash/_isPrototype.js":function(module,exports){eval(`/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if \`value\` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a prototype, else \`false\`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isPrototype.js?`)},"./node_modules/lodash/_nativeKeys.js":function(module,exports,__webpack_require__){eval(`var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_nativeKeys.js?`)},"./node_modules/lodash/_nodeUtil.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable \`exports\`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable \`module\`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension \`module.exports\`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable \`process\` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use \`util.types\` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy \`process.binding('util')\` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_nodeUtil.js?`)},"./node_modules/lodash/_objectToString.js":function(module,exports){eval(`/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [\`toStringTag\`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts \`value\` to a string using \`Object.prototype.toString\`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_objectToString.js?`)},"./node_modules/lodash/_overArg.js":function(module,exports){eval(`/**
 * Creates a unary function that invokes \`func\` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_overArg.js?`)},"./node_modules/lodash/_overRest.js":function(module,exports,__webpack_require__){eval(`var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of \`baseRest\` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_overRest.js?`)},"./node_modules/lodash/_root.js":function(module,exports,__webpack_require__){eval(`var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable \`self\`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_root.js?`)},"./node_modules/lodash/_setToString.js":function(module,exports,__webpack_require__){eval(`var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the \`toString\` method of \`func\` to return \`string\`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The \`toString\` result.
 * @returns {Function} Returns \`func\`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_setToString.js?`)},"./node_modules/lodash/_shortOut.js":function(module,exports){eval(`/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke \`identity\` instead
 * of \`func\` when it's called \`HOT_COUNT\` or more times in \`HOT_SPAN\`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_shortOut.js?`)},"./node_modules/lodash/_strictIndexOf.js":function(module,exports){eval(`/**
 * A specialized version of \`_.indexOf\` which performs strict equality
 * comparisons of values, i.e. \`===\`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_strictIndexOf.js?`)},"./node_modules/lodash/_stringToArray.js":function(module,exports,__webpack_require__){eval(`var asciiToArray = __webpack_require__(/*! ./_asciiToArray */ "./node_modules/lodash/_asciiToArray.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeToArray = __webpack_require__(/*! ./_unicodeToArray */ "./node_modules/lodash/_unicodeToArray.js");

/**
 * Converts \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_stringToArray.js?`)},"./node_modules/lodash/_toSource.js":function(module,exports){eval(`/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts \`func\` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_toSource.js?`)},"./node_modules/lodash/_trimmedEndIndex.js":function(module,exports){eval(`/** Used to match a single whitespace character. */
var reWhitespace = /\\s/;

/**
 * Used by \`_.trim\` and \`_.trimEnd\` to get the index of the last non-whitespace
 * character of \`string\`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_trimmedEndIndex.js?`)},"./node_modules/lodash/_unicodeToArray.js":function(module,exports){eval(`/** Used to compose unicode character classes. */
var rsAstralRange = '\\\\ud800-\\\\udfff',
    rsComboMarksRange = '\\\\u0300-\\\\u036f',
    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',
    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\\\ufe0e\\\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',
    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',
    rsZWJ = '\\\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_unicodeToArray.js?`)},"./node_modules/lodash/assign.js":function(module,exports,__webpack_require__){eval(`var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates \`object\` and is loosely based on
 * [\`Object.assign\`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns \`object\`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/assign.js?`)},"./node_modules/lodash/constant.js":function(module,exports){eval(`/**
 * Creates a function that returns \`value\`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/constant.js?`)},"./node_modules/lodash/eq.js":function(module,exports){eval(`/**
 * Performs a
 * [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if the values are equivalent, else \`false\`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/eq.js?`)},"./node_modules/lodash/identity.js":function(module,exports){eval(`/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns \`value\`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/identity.js?`)},"./node_modules/lodash/isArguments.js":function(module,exports,__webpack_require__){eval(`var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if \`value\` is likely an \`arguments\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an \`arguments\` object,
 *  else \`false\`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isArguments.js?`)},"./node_modules/lodash/isArray.js":function(module,exports){eval(`/**
 * Checks if \`value\` is classified as an \`Array\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an array, else \`false\`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isArray.js?`)},"./node_modules/lodash/isArrayLike.js":function(module,exports,__webpack_require__){eval(`var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if \`value\` is array-like. A value is considered array-like if it's
 * not a function and has a \`value.length\` that's an integer greater than or
 * equal to \`0\` and less than or equal to \`Number.MAX_SAFE_INTEGER\`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is array-like, else \`false\`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isArrayLike.js?`)},"./node_modules/lodash/isBuffer.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable \`exports\`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable \`module\`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension \`module.exports\`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if \`value\` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a buffer, else \`false\`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isBuffer.js?`)},"./node_modules/lodash/isFunction.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** \`Object#toString\` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if \`value\` is classified as a \`Function\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a function, else \`false\`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of \`Object#toString\` avoids issues with the \`typeof\` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isFunction.js?`)},"./node_modules/lodash/isLength.js":function(module,exports){eval(`/** Used as references for various \`Number\` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if \`value\` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [\`ToLength\`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid length, else \`false\`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isLength.js?`)},"./node_modules/lodash/isObject.js":function(module,exports){eval(`/**
 * Checks if \`value\` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of \`Object\`. (e.g. arrays, functions, objects, regexes, \`new Number(0)\`, and \`new String('')\`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an object, else \`false\`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isObject.js?`)},"./node_modules/lodash/isObjectLike.js":function(module,exports){eval(`/**
 * Checks if \`value\` is object-like. A value is object-like if it's not \`null\`
 * and has a \`typeof\` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is object-like, else \`false\`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isObjectLike.js?`)},"./node_modules/lodash/isSymbol.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** \`Object#toString\` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if \`value\` is classified as a \`Symbol\` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a symbol, else \`false\`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isSymbol.js?`)},"./node_modules/lodash/isTypedArray.js":function(module,exports,__webpack_require__){eval(`var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if \`value\` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a typed array, else \`false\`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isTypedArray.js?`)},"./node_modules/lodash/keys.js":function(module,exports,__webpack_require__){eval(`var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of \`object\`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/keys.js?`)},"./node_modules/lodash/stubFalse.js":function(module,exports){eval(`/**
 * This method returns \`false\`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns \`false\`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/stubFalse.js?`)},"./node_modules/lodash/toString.js":function(module,exports,__webpack_require__){eval(`var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts \`value\` to a string. An empty string is returned for \`null\`
 * and \`undefined\` values. The sign of \`-0\` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/toString.js?`)},"./node_modules/lodash/trim.js":function(module,exports,__webpack_require__){eval(`var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js"),
    baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    castSlice = __webpack_require__(/*! ./_castSlice */ "./node_modules/lodash/_castSlice.js"),
    charsEndIndex = __webpack_require__(/*! ./_charsEndIndex */ "./node_modules/lodash/_charsEndIndex.js"),
    charsStartIndex = __webpack_require__(/*! ./_charsStartIndex */ "./node_modules/lodash/_charsStartIndex.js"),
    stringToArray = __webpack_require__(/*! ./_stringToArray */ "./node_modules/lodash/_stringToArray.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Removes leading and trailing whitespace or specified characters from \`string\`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like \`_.map\`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return baseTrim(string);
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

module.exports = trim;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/trim.js?`)},"./node_modules/lz-string/libs/lz-string.js":function(module,exports,__webpack_require__){eval(`var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


//# sourceURL=webpack://%5Bname%5D/./node_modules/lz-string/libs/lz-string.js?`)},"./node_modules/minibus/minibus.js":function(module,exports,__webpack_require__){eval(`var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! minibus - v3.1.0 - 2014-11-22
 * https://github.com/axelpale/minibus
 *
 * Copyright (c) 2014 Akseli Palen <akseli.palen@gmail.com>;
 * Licensed under the MIT license */

(function (root, factory) {
  'use strict';
  // UMD pattern commonjsStrict.js
  // https://github.com/umdjs/umd
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function (exports) {
  'use strict';

// Minibus

//**************
// Constructor *
//**************

var Bus = function () {
  // event string -> sub route map
  this.eventMap = {};

  // route string -> route object
  this.routeMap = {};

  // free namespace shared between the event handlers on the bus.
  this.busContext = {};
};

exports.create = function () {
  return new Bus();
};

// For extendability.
// Usage: Minibus.extension.myFunction = function (...) {...};
exports.extension = Bus.prototype;



//*******************
// Helper functions *
//*******************

var isArray = function (v) {
  return Object.prototype.toString.call(v) === '[object Array]';
};

var isEmpty = function (obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};



//*************
// Exceptions *
//*************

var InvalidEventStringError = function (eventString) {
  // Usage
  //   throw new InvalidEventStringError(eventString)
  this.name = 'InvalidEventStringError';
  this.message = 'Invalid event string given: ' + eventString;
};

var InvalidRouteStringError = function (routeString) {
  // Usage
  //   throw new InvalidRouteStringError(routeString)
  this.name = 'InvalidRouteStringError';
  this.message = 'Invalid route string given: ' + routeString;
};

var InvalidEventHandlerError = function (eventHandler) {
  // Usage
  //   throw new InvalidEventHandlerError(eventHandler)
  this.name = 'InvalidEventHandlerError';
  this.message = 'Invalid event handler function given: ' + eventHandler;
};



//*******************************************
// Member functions. They all are mutators. *
//*******************************************

var _emit = function (eventString) {
  // Emit an event to execute the bound event handler functions.
  // The event handlers are executed immediately.
  //
  // Parameter
  //   eventString
  //     Event string or array of event strings.
  //   arg1 (optional)
  //     Argument to be passed to the handler functions.
  //   arg2 (optional)
  //   ...
  //
  // Return
  //   nothing
  //
  // Throw
  //   InvalidEventStringError
  //     if given event string is not a string or array of strings.
  //
  var emitArgs, i, subRouteMap, routeString, eventHandlers, busContext;

  // Turn to array for more general code.
  if (!isArray(eventString)) {
    eventString = [eventString];
  }

  // Validate all eventStrings before mutating anything.
  // This makes the on call more atomic.
  for (i = 0; i < eventString.length; i += 1) {
    if (typeof eventString[i] !== 'string') {
      throw new InvalidEventStringError(eventString[i]);
    }
  }

  // Collect passed arguments after the eventString argument.
  emitArgs = [];
  for (i = 1; i < arguments.length; i += 1) {
    emitArgs.push(arguments[i]);
  }

  // Collect all the event handlers bound to the given eventString
  eventHandlers = [];
  for (i = 0; i < eventString.length; i += 1) {
    if (this.eventMap.hasOwnProperty(eventString[i])) {
      subRouteMap = this.eventMap[eventString[i]];
      for (routeString in subRouteMap) {
        if (subRouteMap.hasOwnProperty(routeString)) {
          eventHandlers.push(subRouteMap[routeString].eventHandler);
        }
      }
    }
  }

  // Apply the event handlers.
  // All event handlers on the bus share a same bus context.
  busContext = this.busContext;
  for (i = 0; i < eventHandlers.length; i += 1) {
    eventHandlers[i].apply(busContext, emitArgs);
  }
};

// See Node.js events.EventEmitter.emit
Bus.prototype.emit = _emit;

// See Backbone.js Events.trigger
Bus.prototype.trigger = _emit;

// See Mozilla Web API EventTarget.dispatchEvent
// See http://stackoverflow.com/a/10085161/638546
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.dispatchEvent = _emit;

// See http://stackoverflow.com/a/9672223/638546
// Uncomment to enable. Too rare to be included by default.
//Bus.prototype.fireEvent = _emit;



var _on = function (eventString, eventHandler) {
  // Bind an event string(s) to an event handler function.
  //
  // Parameter
  //   eventString
  //     Event string or array of event strings.
  //     Empty array is ok but does nothing.
  //   eventHandler
  //     Event handler function to be executed when the event is emitted.
  //
  // Throw
  //   InvalidEventStringError
  //   InvalidEventHandlerError
  //
  // Return
  //   a route string or an array of route strings
  //
  var wasArray, i, routeObject, routeString, routeStringArray;

  // Turn to array for more general code.
  // Store whether parameter was array to return right type of value.
  wasArray = isArray(eventString);
  if (!wasArray) {
    eventString = [eventString];
  }

  // Validate all eventStrings before mutating anything.
  // This makes the on call more atomic.
  for (i = 0; i < eventString.length; i += 1) {
    if (typeof eventString[i] !== 'string') {
      throw new InvalidEventStringError(eventString[i]);
    }
  }

  // Validate the eventHandler
  if (typeof eventHandler !== 'function') {
    throw new InvalidEventHandlerError(eventHandler);
  }

  routeStringArray = [];
  for (i = 0; i < eventString.length; i += 1) {
    routeObject = {
      eventString: eventString[i],
      eventHandler: eventHandler
    };

    routeString = Identity.create();
    routeStringArray.push(routeString);

    if (!this.eventMap.hasOwnProperty(eventString[i])) {
      this.eventMap[eventString[i]] = {};
    }
    this.eventMap[eventString[i]][routeString] = routeObject;
    this.routeMap[routeString] = routeObject;
  }

  if (wasArray) {
    return routeStringArray;
  } // else
  return routeStringArray[0];
};

// See Backbone.js Events.on
// See Node.js events.EventEmitter.on
Bus.prototype.on = _on;

// See http://stackoverflow.com/a/9672223/638546
Bus.prototype.listen = _on;

// See Node.js events.EventEmitter.addListener
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.addListener = _on;

// See Mozilla Web API EventTarget.addEventListener
// See http://stackoverflow.com/a/11237657/638546
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.addEventListener = _on;



var _once = function (eventString, eventHandler) {
  // Like _on but reacts to emit only once.
  //
  // Parameter
  //   See _on
  //
  // Return
  //   See _on
  //
  // Throw
  //   InvalidEventStringError
  //   InvalidEventHandlerError
  //
  var that, routeString, called;

  // Validate the eventHandler. On does the validation also.
  // Duplicate validation is required because a wrapper function
  // is feed into on instead the given eventHandler.
  if (typeof eventHandler !== 'function') {
    throw new InvalidEventHandlerError(eventHandler);
  }

  that = this;
  called = false;
  routeString = this.on(eventString, function () {
    if (!called) {
      called = true; // Required to prevent duplicate sync calls
      that.off(routeString);
      // Apply. Use the context given by emit to embrace code dryness.
      eventHandler.apply(this, arguments);
    }
  });
  return routeString;
};

// See Node.js events.EventEmitter.once
// See Backbone.js Events.once
Bus.prototype.once = _once;



var _off = function (routeString) {
  // Unbind one or many event handlers.
  //
  // Parameter
  //   routeString
  //     A route string or an array of route strings or
  //     an array of arrays of route strings.
  //     The route to be shut down.
  //
  // Parameter (Alternative)
  //   eventString
  //     An event string or an array of event strings or
  //     an array of arrays of event strings.
  //     Shut down all the routes with this event string.
  //
  // Parameter (Alternative)
  //   (nothing)
  //     Shut down all the routes i.e. unbind all the event handlers.
  //
  // Throws
  //   InvalidRouteStringError
  //
  // Return
  //   nothing
  //
  var noArgs, i, routeObject, eventString, subRouteMap, rs;

  noArgs = (typeof routeString === 'undefined');
  if (noArgs) {
    this.routeMap = {};
    this.eventMap = {};
    return;
  }

  // Turn to array for more general code.
  if (!isArray(routeString)) {
    routeString = [routeString];
  }

  // Flatten arrays to allow arrays of arrays of route strings.
  // This is needed if user wants to off an array of routes. Some routes
  // might be arrays or route strings because 'on' interface.
  // http://stackoverflow.com/a/10865042/638546
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/
  //   Reference/Global_Objects/Array/concat
  var flat = [];
  flat = flat.concat.apply(flat, routeString);
  routeString = flat;

  // Validate all routeStrings before mutating anything.
  // This makes the off call more atomic.
  for (i = 0; i < routeString.length; i += 1) {
    if (typeof routeString[i] !== 'string') {
      throw new InvalidRouteStringError(routeString[i]);
    }
  }

  for (i = 0; i < routeString.length; i += 1) {
    if (this.routeMap.hasOwnProperty(routeString[i])) {
      routeObject = this.routeMap[routeString[i]];
      delete this.routeMap[routeString[i]];
      delete this.eventMap[routeObject.eventString][routeString[i]];
      // Remove sub route map from the event map if it is empty.
      // This prevents outdated eventStrings piling up on the eventMap.
      if (isEmpty(this.eventMap[routeObject.eventString])) {
        delete this.eventMap[routeObject.eventString];
      }
    } else {
      // As eventString
      eventString = routeString[i];
      if (this.eventMap.hasOwnProperty(eventString)) {
        subRouteMap = this.eventMap[eventString];
        for (rs in subRouteMap) {
          if (subRouteMap.hasOwnProperty(rs)) {
            delete this.routeMap[rs];
          }
        }
        delete this.eventMap[eventString];
      }
    }
  }
  // Assert: event handlers and their routes removed.
};

// Backbone.js Events.off
Bus.prototype.off = _off;

// Node.js events.EventEmitter.removeListener
Bus.prototype.removeListener = _off;

// See Mozilla Web API EventTarget.removeEventListener
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.removeEventListener = _off;


var Identity = (function () {
  // A utility for creating unique strings for identification.
  // Abstracts how uniqueness is archieved.
  //
  // Usages
  //   >>> Identity.create();
  //   '532402059994638'
  //   >>> Identity.create();
  //   '544258285779506'
  //
  var exports = {};
  /////////////////

  exports.create = function () {
    return Math.random().toString().substring(2);
  };

  ///////////////
  return exports;
}());


  // Version
  exports.version = '3.1.0';


// End of intro
}));


//# sourceURL=webpack://%5Bname%5D/./node_modules/minibus/minibus.js?`)},"./node_modules/pouchdb-browser/lib/index.es.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var immediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immediate */ "./node_modules/immediate/lib/index.js");
/* harmony import */ var immediate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(immediate__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/index.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! spark-md5 */ "./node_modules/pouchdb-browser/node_modules/spark-md5/spark-md5.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(spark_md5__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vuvuzela__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vuvuzela */ "./node_modules/vuvuzela/index.js");
/* harmony import */ var vuvuzela__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vuvuzela__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var argsarray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! argsarray */ "./node_modules/argsarray/index.js");
/* harmony import */ var argsarray__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(argsarray__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! inherits */ "./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_6__);








function mangle(key) {
  return '$' + key;
}
function unmangle(key) {
  return key.substring(1);
}
function Map$1() {
  this._store = {};
}
Map$1.prototype.get = function (key) {
  var mangled = mangle(key);
  return this._store[mangled];
};
Map$1.prototype.set = function (key, value) {
  var mangled = mangle(key);
  this._store[mangled] = value;
  return true;
};
Map$1.prototype.has = function (key) {
  var mangled = mangle(key);
  return mangled in this._store;
};
Map$1.prototype.delete = function (key) {
  var mangled = mangle(key);
  var res = mangled in this._store;
  delete this._store[mangled];
  return res;
};
Map$1.prototype.forEach = function (cb) {
  var keys = Object.keys(this._store);
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    var value = this._store[key];
    key = unmangle(key);
    cb(value, key);
  }
};
Object.defineProperty(Map$1.prototype, 'size', {
  get: function () {
    return Object.keys(this._store).length;
  }
});

function Set$1(array) {
  this._store = new Map$1();

  // init with an array
  if (array && Array.isArray(array)) {
    for (var i = 0, len = array.length; i < len; i++) {
      this.add(array[i]);
    }
  }
}
Set$1.prototype.add = function (key) {
  return this._store.set(key, true);
};
Set$1.prototype.has = function (key) {
  return this._store.has(key);
};
Set$1.prototype.forEach = function (cb) {
  this._store.forEach(function (value, key) {
    cb(key);
  });
};
Object.defineProperty(Set$1.prototype, 'size', {
  get: function () {
    return this._store.size;
  }
});

/* global Map,Set,Symbol */
// Based on https://kangax.github.io/compat-table/es6/ we can sniff out
// incomplete Map/Set implementations which would otherwise cause our tests to fail.
// Notably they fail in IE11 and iOS 8.4, which this prevents.
function supportsMapAndSet() {
  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {
    return false;
  }
  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);
  return prop && 'get' in prop && Map[Symbol.species] === Map;
}

// based on https://github.com/montagejs/collections

var ExportedSet;
var ExportedMap;

{
  if (supportsMapAndSet()) { // prefer built-in Map/Set
    ExportedSet = Set;
    ExportedMap = Map;
  } else { // fall back to our polyfill
    ExportedSet = Set$1;
    ExportedMap = Map$1;
  }
}

function isBinaryObject(object) {
  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||
    (typeof Blob !== 'undefined' && object instanceof Blob);
}

function cloneArrayBuffer(buff) {
  if (typeof buff.slice === 'function') {
    return buff.slice(0);
  }
  // IE10-11 slice() polyfill
  var target = new ArrayBuffer(buff.byteLength);
  var targetArray = new Uint8Array(target);
  var sourceArray = new Uint8Array(buff);
  targetArray.set(sourceArray);
  return target;
}

function cloneBinaryObject(object) {
  if (object instanceof ArrayBuffer) {
    return cloneArrayBuffer(object);
  }
  var size = object.size;
  var type = object.type;
  // Blob
  if (typeof object.slice === 'function') {
    return object.slice(0, size, type);
  }
  // PhantomJS slice() replacement
  return object.webkitSlice(0, size, type);
}

// most of this is borrowed from lodash.isPlainObject:
// https://github.com/fis-components/lodash.isplainobject/
// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js

var funcToString = Function.prototype.toString;
var objectCtorString = funcToString.call(Object);

function isPlainObject(value) {
  var proto = Object.getPrototypeOf(value);
  /* istanbul ignore if */
  if (proto === null) { // not sure when this happens, but I guess it can
    return true;
  }
  var Ctor = proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

function clone(object) {
  var newObject;
  var i;
  var len;

  if (!object || typeof object !== 'object') {
    return object;
  }

  if (Array.isArray(object)) {
    newObject = [];
    for (i = 0, len = object.length; i < len; i++) {
      newObject[i] = clone(object[i]);
    }
    return newObject;
  }

  // special case: to avoid inconsistencies between IndexedDB
  // and other backends, we automatically stringify Dates
  if (object instanceof Date) {
    return object.toISOString();
  }

  if (isBinaryObject(object)) {
    return cloneBinaryObject(object);
  }

  if (!isPlainObject(object)) {
    return object; // don't clone objects like Workers
  }

  newObject = {};
  for (i in object) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(object, i)) {
      var value = clone(object[i]);
      if (typeof value !== 'undefined') {
        newObject[i] = value;
      }
    }
  }
  return newObject;
}

function once(fun) {
  var called = false;
  return argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    /* istanbul ignore if */
    if (called) {
      // this is a smoke test and should never actually happen
      throw new Error('once called more than once');
    } else {
      called = true;
      fun.apply(this, args);
    }
  });
}

function toPromise(func) {
  //create the function we will be returning
  return argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    // Clone arguments
    args = clone(args);
    var self = this;
    // if the last argument is a function, assume its a callback
    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
    var promise = new Promise(function (fulfill, reject) {
      var resp;
      try {
        var callback = once(function (err, mesg) {
          if (err) {
            reject(err);
          } else {
            fulfill(mesg);
          }
        });
        // create a callback for this invocation
        // apply the function in the orig context
        args.push(callback);
        resp = func.apply(self, args);
        if (resp && typeof resp.then === 'function') {
          fulfill(resp);
        }
      } catch (e) {
        reject(e);
      }
    });
    // if there is a callback, call it back
    if (usedCB) {
      promise.then(function (result) {
        usedCB(null, result);
      }, usedCB);
    }
    return promise;
  });
}

function logApiCall(self, name, args) {
  /* istanbul ignore if */
  if (self.constructor.listeners('debug').length) {
    var logArgs = ['api', self.name, name];
    for (var i = 0; i < args.length - 1; i++) {
      logArgs.push(args[i]);
    }
    self.constructor.emit('debug', logArgs);

    // override the callback itself to log the response
    var origCallback = args[args.length - 1];
    args[args.length - 1] = function (err, res) {
      var responseArgs = ['api', self.name, name];
      responseArgs = responseArgs.concat(
        err ? ['error', err] : ['success', res]
      );
      self.constructor.emit('debug', responseArgs);
      origCallback(err, res);
    };
  }
}

function adapterFun(name, callback) {
  return toPromise(argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    if (this._closed) {
      return Promise.reject(new Error('database is closed'));
    }
    if (this._destroyed) {
      return Promise.reject(new Error('database is destroyed'));
    }
    var self = this;
    logApiCall(self, name, args);
    if (!this.taskqueue.isReady) {
      return new Promise(function (fulfill, reject) {
        self.taskqueue.addTask(function (failed) {
          if (failed) {
            reject(failed);
          } else {
            fulfill(self[name].apply(self, args));
          }
        });
      });
    }
    return callback.apply(this, args);
  }));
}

// like underscore/lodash _.pick()
function pick(obj, arr) {
  var res = {};
  for (var i = 0, len = arr.length; i < len; i++) {
    var prop = arr[i];
    if (prop in obj) {
      res[prop] = obj[prop];
    }
  }
  return res;
}

// Most browsers throttle concurrent requests at 6, so it's silly
// to shim _bulk_get by trying to launch potentially hundreds of requests
// and then letting the majority time out. We can handle this ourselves.
var MAX_NUM_CONCURRENT_REQUESTS = 6;

function identityFunction(x) {
  return x;
}

function formatResultForOpenRevsGet(result) {
  return [{
    ok: result
  }];
}

// shim for P/CouchDB adapters that don't directly implement _bulk_get
function bulkGet(db, opts, callback) {
  var requests = opts.docs;

  // consolidate into one request per doc if possible
  var requestsById = new ExportedMap();
  requests.forEach(function (request) {
    if (requestsById.has(request.id)) {
      requestsById.get(request.id).push(request);
    } else {
      requestsById.set(request.id, [request]);
    }
  });

  var numDocs = requestsById.size;
  var numDone = 0;
  var perDocResults = new Array(numDocs);

  function collapseResultsAndFinish() {
    var results = [];
    perDocResults.forEach(function (res) {
      res.docs.forEach(function (info) {
        results.push({
          id: res.id,
          docs: [info]
        });
      });
    });
    callback(null, {results: results});
  }

  function checkDone() {
    if (++numDone === numDocs) {
      collapseResultsAndFinish();
    }
  }

  function gotResult(docIndex, id, docs) {
    perDocResults[docIndex] = {id: id, docs: docs};
    checkDone();
  }

  var allRequests = [];
  requestsById.forEach(function (value, key) {
    allRequests.push(key);
  });

  var i = 0;

  function nextBatch() {

    if (i >= allRequests.length) {
      return;
    }

    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);
    var batch = allRequests.slice(i, upTo);
    processBatch(batch, i);
    i += batch.length;
  }

  function processBatch(batch, offset) {
    batch.forEach(function (docId, j) {
      var docIdx = offset + j;
      var docRequests = requestsById.get(docId);

      // just use the first request as the "template"
      // TODO: The _bulk_get API allows for more subtle use cases than this,
      // but for now it is unlikely that there will be a mix of different
      // "atts_since" or "attachments" in the same request, since it's just
      // replicate.js that is using this for the moment.
      // Also, atts_since is aspirational, since we don't support it yet.
      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
      docOpts.open_revs = docRequests.map(function (request) {
        // rev is optional, open_revs disallowed
        return request.rev;
      });

      // remove falsey / undefined revisions
      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);

      var formatResult = identityFunction;

      if (docOpts.open_revs.length === 0) {
        delete docOpts.open_revs;

        // when fetching only the "winning" leaf,
        // transform the result so it looks like an open_revs
        // request
        formatResult = formatResultForOpenRevsGet;
      }

      // globally-supplied options
      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {
        if (param in opts) {
          docOpts[param] = opts[param];
        }
      });
      db.get(docId, docOpts, function (err, res) {
        var result;
        /* istanbul ignore if */
        if (err) {
          result = [{error: err}];
        } else {
          result = formatResult(res);
        }
        gotResult(docIdx, docId, result);
        nextBatch();
      });
    });
  }

  nextBatch();

}

var hasLocal;

try {
  localStorage.setItem('_pouch_check_localstorage', 1);
  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
} catch (e) {
  hasLocal = false;
}

function hasLocalStorage() {
  return hasLocal;
}

// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We

inherits__WEBPACK_IMPORTED_MODULE_5___default()(Changes, events__WEBPACK_IMPORTED_MODULE_6___default.a);

/* istanbul ignore next */
function attachBrowserEvents(self) {
  if (hasLocalStorage()) {
    addEventListener("storage", function (e) {
      self.emit(e.key);
    });
  }
}

function Changes() {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);
  this._listeners = {};

  attachBrowserEvents(this);
}
Changes.prototype.addListener = function (dbName, id, db, opts) {
  /* istanbul ignore if */
  if (this._listeners[id]) {
    return;
  }
  var self = this;
  var inprogress = false;
  function eventFunction() {
    /* istanbul ignore if */
    if (!self._listeners[id]) {
      return;
    }
    if (inprogress) {
      inprogress = 'waiting';
      return;
    }
    inprogress = true;
    var changesOpts = pick(opts, [
      'style', 'include_docs', 'attachments', 'conflicts', 'filter',
      'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'
    ]);

    /* istanbul ignore next */
    function onError() {
      inprogress = false;
    }

    db.changes(changesOpts).on('change', function (c) {
      if (c.seq > opts.since && !opts.cancelled) {
        opts.since = c.seq;
        opts.onChange(c);
      }
    }).on('complete', function () {
      if (inprogress === 'waiting') {
        immediate__WEBPACK_IMPORTED_MODULE_0___default()(eventFunction);
      }
      inprogress = false;
    }).on('error', onError);
  }
  this._listeners[id] = eventFunction;
  this.on(dbName, eventFunction);
};

Changes.prototype.removeListener = function (dbName, id) {
  /* istanbul ignore if */
  if (!(id in this._listeners)) {
    return;
  }
  events__WEBPACK_IMPORTED_MODULE_6___default.a.prototype.removeListener.call(this, dbName,
    this._listeners[id]);
  delete this._listeners[id];
};


/* istanbul ignore next */
Changes.prototype.notifyLocalWindows = function (dbName) {
  //do a useless change on a storage thing
  //in order to get other windows's listeners to activate
  if (hasLocalStorage()) {
    localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
  }
};

Changes.prototype.notify = function (dbName) {
  this.emit(dbName);
  this.notifyLocalWindows(dbName);
};

function guardedConsole(method) {
  /* istanbul ignore else */
  if (typeof console !== 'undefined' && typeof console[method] === 'function') {
    var args = Array.prototype.slice.call(arguments, 1);
    console[method].apply(console, args);
  }
}

function randomNumber(min, max) {
  var maxTimeout = 600000; // Hard-coded default of 10 minutes
  min = parseInt(min, 10) || 0;
  max = parseInt(max, 10);
  if (max !== max || max <= min) {
    max = (min || 1) << 1; //doubling
  } else {
    max = max + 1;
  }
  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout
  if (max > maxTimeout) {
    min = maxTimeout >> 1; // divide by two
    max = maxTimeout;
  }
  var ratio = Math.random();
  var range = max - min;

  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
}

function defaultBackOff(min) {
  var max = 0;
  if (!min) {
    max = 2000;
  }
  return randomNumber(min, max);
}

// designed to give info to browser users, who are disturbed
// when they see http errors in the console
function explainError(status, str) {
  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);
}

var assign;
{
  if (typeof Object.assign === 'function') {
    assign = Object.assign;
  } else {
    // lite Object.assign polyfill based on
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    assign = function (target) {
      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    };
  }
}

var $inject_Object_assign = assign;

inherits__WEBPACK_IMPORTED_MODULE_5___default()(PouchError, Error);

function PouchError(status, error, reason) {
  Error.call(this, reason);
  this.status = status;
  this.name = error;
  this.message = reason;
  this.error = true;
}

PouchError.prototype.toString = function () {
  return JSON.stringify({
    status: this.status,
    name: this.name,
    message: this.message,
    reason: this.reason
  });
};

var UNAUTHORIZED = new PouchError(401, 'unauthorized', "Name or password is incorrect.");
var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
var NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');
var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
var INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');
var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
var DB_MISSING = new PouchError(404, 'not_found', 'Database not found');
var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
var WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');
var LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');
var FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
var FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');
var INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');

function createError(error, reason) {
  function CustomPouchError(reason) {
    // inherit error properties from our parent error manually
    // so as to allow proper JSON parsing.
    /* jshint ignore:start */
    var names = Object.getOwnPropertyNames(error);
    for (var i = 0, len = names.length; i < len; i++) {
      if (typeof error[names[i]] !== 'function') {
        this[names[i]] = error[names[i]];
      }
    }
    /* jshint ignore:end */
    if (reason !== undefined) {
      this.reason = reason;
    }
  }
  CustomPouchError.prototype = PouchError.prototype;
  return new CustomPouchError(reason);
}

function generateErrorFromResponse(err) {

  if (typeof err !== 'object') {
    var data = err;
    err = UNKNOWN_ERROR;
    err.data = data;
  }

  if ('error' in err && err.error === 'conflict') {
    err.name = 'conflict';
    err.status = 409;
  }

  if (!('name' in err)) {
    err.name = err.error || 'unknown';
  }

  if (!('status' in err)) {
    err.status = 500;
  }

  if (!('message' in err)) {
    err.message = err.message || err.reason;
  }

  return err;
}

function tryFilter(filter, doc, req) {
  try {
    return !filter(doc, req);
  } catch (err) {
    var msg = 'Filter function threw: ' + err.toString();
    return createError(BAD_REQUEST, msg);
  }
}

function filterChange(opts) {
  var req = {};
  var hasFilter = opts.filter && typeof opts.filter === 'function';
  req.query = opts.query_params;

  return function filter(change) {
    if (!change.doc) {
      // CSG sends events on the changes feed that don't have documents,
      // this hack makes a whole lot of existing code robust.
      change.doc = {};
    }

    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);

    if (typeof filterReturn === 'object') {
      return filterReturn;
    }

    if (filterReturn) {
      return false;
    }

    if (!opts.include_docs) {
      delete change.doc;
    } else if (!opts.attachments) {
      for (var att in change.doc._attachments) {
        /* istanbul ignore else */
        if (change.doc._attachments.hasOwnProperty(att)) {
          change.doc._attachments[att].stub = true;
        }
      }
    }
    return true;
  };
}

function flatten(arrs) {
  var res = [];
  for (var i = 0, len = arrs.length; i < len; i++) {
    res = res.concat(arrs[i]);
  }
  return res;
}

// shim for Function.prototype.name,

// Determine id an ID is valid
//   - invalid IDs begin with an underescore that does not begin '_design' or
//     '_local'
//   - any other string value is a valid id
// Returns the specific error object for each case
function invalidIdError(id) {
  var err;
  if (!id) {
    err = createError(MISSING_ID);
  } else if (typeof id !== 'string') {
    err = createError(INVALID_ID);
  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
    err = createError(RESERVED_ID);
  }
  if (err) {
    throw err;
  }
}

// Checks if a PouchDB object is "remote" or not. This is

function isRemote(db) {
  if (typeof db._remote === 'boolean') {
    return db._remote;
  }
  /* istanbul ignore next */
  if (typeof db.type === 'function') {
    guardedConsole('warn',
      'db.type() is deprecated and will be removed in ' +
      'a future version of PouchDB');
    return db.type() === 'http';
  }
  /* istanbul ignore next */
  return false;
}

function listenerCount(ee, type) {
  return 'listenerCount' in ee ? ee.listenerCount(type) :
                                 events__WEBPACK_IMPORTED_MODULE_6___default.a.listenerCount(ee, type);
}

function parseDesignDocFunctionName(s) {
  if (!s) {
    return null;
  }
  var parts = s.split('/');
  if (parts.length === 2) {
    return parts;
  }
  if (parts.length === 1) {
    return [s, s];
  }
  return null;
}

function normalizeDesignDocFunctionName(s) {
  var normalized = parseDesignDocFunctionName(s);
  return normalized ? normalized.join('/') : null;
}

// originally parseUri 1.2.2, now patched by us
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
var keys = ["source", "protocol", "authority", "userInfo", "user", "password",
    "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
var qName ="queryKey";
var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;

// use the "loose" parser
/* eslint maxlen: 0, no-useless-escape: 0 */
var parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;

function parseUri(str) {
  var m = parser.exec(str);
  var uri = {};
  var i = 14;

  while (i--) {
    var key = keys[i];
    var value = m[i] || "";
    var encoded = ['user', 'password'].indexOf(key) !== -1;
    uri[key] = encoded ? decodeURIComponent(value) : value;
  }

  uri[qName] = {};
  uri[keys[12]].replace(qParser, function ($0, $1, $2) {
    if ($1) {
      uri[qName][$1] = $2;
    }
  });

  return uri;
}

// Based on https://github.com/alexdavid/scope-eval v0.0.3
// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)
// This is basically just a wrapper around new Function()

function scopeEval(source, scope) {
  var keys = [];
  var values = [];
  for (var key in scope) {
    if (scope.hasOwnProperty(key)) {
      keys.push(key);
      values.push(scope[key]);
    }
  }
  keys.push(source);
  return Function.apply(null, keys).apply(null, values);
}

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
function upsert(db, docId, diffFun) {
  return new Promise(function (fulfill, reject) {
    db.get(docId, function (err, doc) {
      if (err) {
        /* istanbul ignore next */
        if (err.status !== 404) {
          return reject(err);
        }
        doc = {};
      }

      // the user might change the _rev, so save it for posterity
      var docRev = doc._rev;
      var newDoc = diffFun(doc);

      if (!newDoc) {
        // if the diffFun returns falsy, we short-circuit as
        // an optimization
        return fulfill({updated: false, rev: docRev});
      }

      // users aren't allowed to modify these values,
      // so reset them here
      newDoc._id = docId;
      newDoc._rev = docRev;
      fulfill(tryAndPut(db, newDoc, diffFun));
    });
  });
}

function tryAndPut(db, doc, diffFun) {
  return db.put(doc).then(function (res) {
    return {
      updated: true,
      rev: res.rev
    };
  }, function (err) {
    /* istanbul ignore next */
    if (err.status !== 409) {
      throw err;
    }
    return upsert(db, doc._id, diffFun);
  });
}

var thisAtob = function (str) {
  return atob(str);
};

var thisBtoa = function (str) {
  return btoa(str);
};

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor (e.g.
// old QtWebKit versions, Android < 4.4).
function createBlob(parts, properties) {
  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
  parts = parts || [];
  properties = properties || {};
  try {
    return new Blob(parts, properties);
  } catch (e) {
    if (e.name !== "TypeError") {
      throw e;
    }
    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :
                  WebKitBlobBuilder;
    var builder = new Builder();
    for (var i = 0; i < parts.length; i += 1) {
      builder.append(parts[i]);
    }
    return builder.getBlob(properties.type);
  }
}

// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function binaryStringToArrayBuffer(bin) {
  var length = bin.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  for (var i = 0; i < length; i++) {
    arr[i] = bin.charCodeAt(i);
  }
  return buf;
}

function binStringToBluffer(binString, type) {
  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});
}

function b64ToBluffer(b64, type) {
  return binStringToBluffer(thisAtob(b64), type);
}

//Can't find original post, but this is close
//http://stackoverflow.com/questions/6965107/ (continues on next line)
//converting-between-strings-and-arraybuffers
function arrayBufferToBinaryString(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);
  var length = bytes.byteLength;
  for (var i = 0; i < length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return binary;
}

// shim for browsers that don't support it
function readAsBinaryString(blob, callback) {
  var reader = new FileReader();
  var hasBinaryString = typeof reader.readAsBinaryString === 'function';
  reader.onloadend = function (e) {
    var result = e.target.result || '';
    if (hasBinaryString) {
      return callback(result);
    }
    callback(arrayBufferToBinaryString(result));
  };
  if (hasBinaryString) {
    reader.readAsBinaryString(blob);
  } else {
    reader.readAsArrayBuffer(blob);
  }
}

function blobToBinaryString(blobOrBuffer, callback) {
  readAsBinaryString(blobOrBuffer, function (bin) {
    callback(bin);
  });
}

function blobToBase64(blobOrBuffer, callback) {
  blobToBinaryString(blobOrBuffer, function (base64) {
    callback(thisBtoa(base64));
  });
}

// simplified API. universal browser support is assumed
function readAsArrayBuffer(blob, callback) {
  var reader = new FileReader();
  reader.onloadend = function (e) {
    var result = e.target.result || new ArrayBuffer(0);
    callback(result);
  };
  reader.readAsArrayBuffer(blob);
}

// this is not used in the browser

var setImmediateShim = self.setImmediate || self.setTimeout;
var MD5_CHUNK_SIZE = 32768;

function rawToBase64(raw) {
  return thisBtoa(raw);
}

function sliceBlob(blob, start, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start, end);
  }
  return blob.slice(start, end);
}

function appendBlob(buffer, blob, start, end, callback) {
  if (start > 0 || end < blob.size) {
    // only slice blob if we really need to
    blob = sliceBlob(blob, start, end);
  }
  readAsArrayBuffer(blob, function (arrayBuffer) {
    buffer.append(arrayBuffer);
    callback();
  });
}

function appendString(buffer, string, start, end, callback) {
  if (start > 0 || end < string.length) {
    // only create a substring if we really need to
    string = string.substring(start, end);
  }
  buffer.appendBinary(string);
  callback();
}

function binaryMd5(data, callback) {
  var inputIsString = typeof data === 'string';
  var len = inputIsString ? data.length : data.size;
  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
  var chunks = Math.ceil(len / chunkSize);
  var currentChunk = 0;
  var buffer = inputIsString ? new spark_md5__WEBPACK_IMPORTED_MODULE_2___default.a() : new spark_md5__WEBPACK_IMPORTED_MODULE_2___default.a.ArrayBuffer();

  var append = inputIsString ? appendString : appendBlob;

  function next() {
    setImmediateShim(loadNextChunk);
  }

  function done() {
    var raw = buffer.end(true);
    var base64 = rawToBase64(raw);
    callback(base64);
    buffer.destroy();
  }

  function loadNextChunk() {
    var start = currentChunk * chunkSize;
    var end = start + chunkSize;
    currentChunk++;
    if (currentChunk < chunks) {
      append(buffer, data, start, end, next);
    } else {
      append(buffer, data, start, end, done);
    }
  }
  loadNextChunk();
}

function stringMd5(string) {
  return spark_md5__WEBPACK_IMPORTED_MODULE_2___default.a.hash(string);
}

function rev(doc, deterministic_revs) {
  var clonedDoc = clone(doc);
  if (!deterministic_revs) {
    return Object(uuid__WEBPACK_IMPORTED_MODULE_1__["v4"])().replace(/-/g, '').toLowerCase();
  }

  delete clonedDoc._rev_tree;
  return stringMd5(JSON.stringify(clonedDoc));
}

var uuid = uuid__WEBPACK_IMPORTED_MODULE_1__["v4"]; // mimic old import, only v4 is ever used elsewhere

// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// http://guide.couchdb.org/draft/conflicts.html
function winningRev(metadata) {
  var winningId;
  var winningPos;
  var winningDeleted;
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var tree = node.ids;
    var branches = tree[2];
    var pos = node.pos;
    if (branches.length) { // non-leaf
      for (var i = 0, len = branches.length; i < len; i++) {
        toVisit.push({pos: pos + 1, ids: branches[i]});
      }
      continue;
    }
    var deleted = !!tree[1].deleted;
    var id = tree[0];
    // sort by deleted, then pos, then id
    if (!winningId || (winningDeleted !== deleted ? winningDeleted :
        winningPos !== pos ? winningPos < pos : winningId < id)) {
      winningId = id;
      winningPos = pos;
      winningDeleted = deleted;
    }
  }

  return winningPos + '-' + winningId;
}

// Pretty much all below can be combined into a higher order function to
// traverse revisions
// The return value from the callback will be passed as context to all
// children of that node
function traverseRevTree(revs, callback) {
  var toVisit = revs.slice();

  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var branches = tree[2];
    var newCtx =
      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});
    }
  }
}

function sortByPos(a, b) {
  return a.pos - b.pos;
}

function collectLeaves(revs) {
  var leaves = [];
  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
    if (isLeaf) {
      leaves.push({rev: pos + "-" + id, pos: pos, opts: opts});
    }
  });
  leaves.sort(sortByPos).reverse();
  for (var i = 0, len = leaves.length; i < len; i++) {
    delete leaves[i].pos;
  }
  return leaves;
}

// returns revs of all conflicts that is leaves such that
// 1. are not deleted and
// 2. are different than winning revision
function collectConflicts(metadata) {
  var win = winningRev(metadata);
  var leaves = collectLeaves(metadata.rev_tree);
  var conflicts = [];
  for (var i = 0, len = leaves.length; i < len; i++) {
    var leaf = leaves[i];
    if (leaf.rev !== win && !leaf.opts.deleted) {
      conflicts.push(leaf.rev);
    }
  }
  return conflicts;
}

// compact a tree by marking its non-leafs as missing,
// and return a list of revs to delete
function compactTree(metadata) {
  var revs = [];
  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                               revHash, ctx, opts) {
    if (opts.status === 'available' && !isLeaf) {
      revs.push(pos + '-' + revHash);
      opts.status = 'missing';
    }
  });
  return revs;
}

// build up a list of all the paths to the leafs in this revision tree
function rootToLeaf(revs) {
  var paths = [];
  var toVisit = revs.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, opts: opts});
    if (isLeaf) {
      paths.push({pos: (pos + 1 - history.length), ids: history});
    }
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], history: history});
    }
  }
  return paths.reverse();
}

// for a better overview of what this is doing, read:

function sortByPos$1(a, b) {
  return a.pos - b.pos;
}

// classic binary search
function binarySearch(arr, item, comparator) {
  var low = 0;
  var high = arr.length;
  var mid;
  while (low < high) {
    mid = (low + high) >>> 1;
    if (comparator(arr[mid], item) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}

// assuming the arr is sorted, insert the item in the proper place
function insertSorted(arr, item, comparator) {
  var idx = binarySearch(arr, item, comparator);
  arr.splice(idx, 0, item);
}

// Turn a path as a flat array into a tree with a single branch.
// If any should be stemmed from the beginning of the array, that's passed
// in as the second argument
function pathToTree(path, numStemmed) {
  var root;
  var leaf;
  for (var i = numStemmed, len = path.length; i < len; i++) {
    var node = path[i];
    var currentLeaf = [node.id, node.opts, []];
    if (leaf) {
      leaf[2].push(currentLeaf);
      leaf = currentLeaf;
    } else {
      root = leaf = currentLeaf;
    }
  }
  return root;
}

// compare the IDs of two trees
function compareTree(a, b) {
  return a[0] < b[0] ? -1 : 1;
}

// Merge two trees together
// The roots of tree1 and tree2 must be the same revision
function mergeTree(in_tree1, in_tree2) {
  var queue = [{tree1: in_tree1, tree2: in_tree2}];
  var conflicts = false;
  while (queue.length > 0) {
    var item = queue.pop();
    var tree1 = item.tree1;
    var tree2 = item.tree2;

    if (tree1[1].status || tree2[1].status) {
      tree1[1].status =
        (tree1[1].status ===  'available' ||
        tree2[1].status === 'available') ? 'available' : 'missing';
    }

    for (var i = 0; i < tree2[2].length; i++) {
      if (!tree1[2][0]) {
        conflicts = 'new_leaf';
        tree1[2][0] = tree2[2][i];
        continue;
      }

      var merged = false;
      for (var j = 0; j < tree1[2].length; j++) {
        if (tree1[2][j][0] === tree2[2][i][0]) {
          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});
          merged = true;
        }
      }
      if (!merged) {
        conflicts = 'new_branch';
        insertSorted(tree1[2], tree2[2][i], compareTree);
      }
    }
  }
  return {conflicts: conflicts, tree: in_tree1};
}

function doMerge(tree, path, dontExpand) {
  var restree = [];
  var conflicts = false;
  var merged = false;
  var res;

  if (!tree.length) {
    return {tree: [path], conflicts: 'new_leaf'};
  }

  for (var i = 0, len = tree.length; i < len; i++) {
    var branch = tree[i];
    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
      // Paths start at the same position and have the same root, so they need
      // merged
      res = mergeTree(branch.ids, path.ids);
      restree.push({pos: branch.pos, ids: res.tree});
      conflicts = conflicts || res.conflicts;
      merged = true;
    } else if (dontExpand !== true) {
      // The paths start at a different position, take the earliest path and
      // traverse up until it as at the same point from root as the path we
      // want to merge.  If the keys match we return the longer path with the
      // other merged After stemming we dont want to expand the trees

      var t1 = branch.pos < path.pos ? branch : path;
      var t2 = branch.pos < path.pos ? path : branch;
      var diff = t2.pos - t1.pos;

      var candidateParents = [];

      var trees = [];
      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});
      while (trees.length > 0) {
        var item = trees.pop();
        if (item.diff === 0) {
          if (item.ids[0] === t2.ids[0]) {
            candidateParents.push(item);
          }
          continue;
        }
        var elements = item.ids[2];
        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
          trees.push({
            ids: elements[j],
            diff: item.diff - 1,
            parent: item.ids,
            parentIdx: j
          });
        }
      }

      var el = candidateParents[0];

      if (!el) {
        restree.push(branch);
      } else {
        res = mergeTree(el.ids, t2.ids);
        el.parent[2][el.parentIdx] = res.tree;
        restree.push({pos: t1.pos, ids: t1.ids});
        conflicts = conflicts || res.conflicts;
        merged = true;
      }
    } else {
      restree.push(branch);
    }
  }

  // We didnt find
  if (!merged) {
    restree.push(path);
  }

  restree.sort(sortByPos$1);

  return {
    tree: restree,
    conflicts: conflicts || 'internal_node'
  };
}

// To ensure we dont grow the revision tree infinitely, we stem old revisions
function stem(tree, depth) {
  // First we break out the tree into a complete list of root to leaf paths
  var paths = rootToLeaf(tree);
  var stemmedRevs;

  var result;
  for (var i = 0, len = paths.length; i < len; i++) {
    // Then for each path, we cut off the start of the path based on the
    // \`depth\` to stem to, and generate a new set of flat trees
    var path = paths[i];
    var stemmed = path.ids;
    var node;
    if (stemmed.length > depth) {
      // only do the stemming work if we actually need to stem
      if (!stemmedRevs) {
        stemmedRevs = {}; // avoid allocating this object unnecessarily
      }
      var numStemmed = stemmed.length - depth;
      node = {
        pos: path.pos + numStemmed,
        ids: pathToTree(stemmed, numStemmed)
      };

      for (var s = 0; s < numStemmed; s++) {
        var rev = (path.pos + s) + '-' + stemmed[s].id;
        stemmedRevs[rev] = true;
      }
    } else { // no need to actually stem
      node = {
        pos: path.pos,
        ids: pathToTree(stemmed, 0)
      };
    }

    // Then we remerge all those flat trees together, ensuring that we dont
    // connect trees that would go beyond the depth limit
    if (result) {
      result = doMerge(result, node, true).tree;
    } else {
      result = [node];
    }
  }

  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed
  if (stemmedRevs) {
    traverseRevTree(result, function (isLeaf, pos, revHash) {
      // some revisions may have been removed in a branch but not in another
      delete stemmedRevs[pos + '-' + revHash];
    });
  }

  return {
    tree: result,
    revs: stemmedRevs ? Object.keys(stemmedRevs) : []
  };
}

function merge(tree, path, depth) {
  var newTree = doMerge(tree, path);
  var stemmed = stem(newTree.tree, depth);
  return {
    tree: stemmed.tree,
    stemmedRevs: stemmed.revs,
    conflicts: newTree.conflicts
  };
}

// return true if a rev exists in the rev tree, false otherwise
function revExists(revs, rev) {
  var toVisit = revs.slice();
  var splitRev = rev.split('-');
  var targetPos = parseInt(splitRev[0], 10);
  var targetId = splitRev[1];

  var node;
  while ((node = toVisit.pop())) {
    if (node.pos === targetPos && node.ids[0] === targetId) {
      return true;
    }
    var branches = node.ids[2];
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: node.pos + 1, ids: branches[i]});
    }
  }
  return false;
}

function getTrees(node) {
  return node.ids;
}

// check if a specific revision of a doc has been deleted
//  - metadata: the metadata object from the doc store
//  - rev: (optional) the revision to check. defaults to winning revision
function isDeleted(metadata, rev) {
  if (!rev) {
    rev = winningRev(metadata);
  }
  var id = rev.substring(rev.indexOf('-') + 1);
  var toVisit = metadata.rev_tree.map(getTrees);

  var tree;
  while ((tree = toVisit.pop())) {
    if (tree[0] === id) {
      return !!tree[1].deleted;
    }
    toVisit = toVisit.concat(tree[2]);
  }
}

function isLocalId(id) {
  return (/^_local/).test(id);
}

// returns the current leaf node for a given revision
function latest(rev, metadata) {
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, pos: pos, opts: opts});

    if (isLeaf) {
      for (var i = 0, len = history.length; i < len; i++) {
        var historyNode = history[i];
        var historyRev = historyNode.pos + '-' + historyNode.id;

        if (historyRev === rev) {
          // return the rev of this leaf
          return pos + '-' + id;
        }
      }
    }

    for (var j = 0, l = branches.length; j < l; j++) {
      toVisit.push({pos: pos + 1, ids: branches[j], history: history});
    }
  }

  /* istanbul ignore next */
  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(Changes$1, events__WEBPACK_IMPORTED_MODULE_6___default.a);

function tryCatchInChangeListener(self, change, pending, lastSeq) {
  // isolate try/catches to avoid V8 deoptimizations
  try {
    self.emit('change', change, pending, lastSeq);
  } catch (e) {
    guardedConsole('error', 'Error in .on("change", function):', e);
  }
}

function Changes$1(db, opts, callback) {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);
  var self = this;
  this.db = db;
  opts = opts ? clone(opts) : {};
  var complete = opts.complete = once(function (err, resp) {
    if (err) {
      if (listenerCount(self, 'error') > 0) {
        self.emit('error', err);
      }
    } else {
      self.emit('complete', resp);
    }
    self.removeAllListeners();
    db.removeListener('destroyed', onDestroy);
  });
  if (callback) {
    self.on('complete', function (resp) {
      callback(null, resp);
    });
    self.on('error', callback);
  }
  function onDestroy() {
    self.cancel();
  }
  db.once('destroyed', onDestroy);

  opts.onChange = function (change, pending, lastSeq) {
    /* istanbul ignore if */
    if (self.isCancelled) {
      return;
    }
    tryCatchInChangeListener(self, change, pending, lastSeq);
  };

  var promise = new Promise(function (fulfill, reject) {
    opts.complete = function (err, res) {
      if (err) {
        reject(err);
      } else {
        fulfill(res);
      }
    };
  });
  self.once('cancel', function () {
    db.removeListener('destroyed', onDestroy);
    opts.complete(null, {status: 'cancelled'});
  });
  this.then = promise.then.bind(promise);
  this['catch'] = promise['catch'].bind(promise);
  this.then(function (result) {
    complete(null, result);
  }, complete);



  if (!db.taskqueue.isReady) {
    db.taskqueue.addTask(function (failed) {
      if (failed) {
        opts.complete(failed);
      } else if (self.isCancelled) {
        self.emit('cancel');
      } else {
        self.validateChanges(opts);
      }
    });
  } else {
    self.validateChanges(opts);
  }
}
Changes$1.prototype.cancel = function () {
  this.isCancelled = true;
  if (this.db.taskqueue.isReady) {
    this.emit('cancel');
  }
};
function processChange(doc, metadata, opts) {
  var changeList = [{rev: doc._rev}];
  if (opts.style === 'all_docs') {
    changeList = collectLeaves(metadata.rev_tree)
    .map(function (x) { return {rev: x.rev}; });
  }
  var change = {
    id: metadata.id,
    changes: changeList,
    doc: doc
  };

  if (isDeleted(metadata, doc._rev)) {
    change.deleted = true;
  }
  if (opts.conflicts) {
    change.doc._conflicts = collectConflicts(metadata);
    if (!change.doc._conflicts.length) {
      delete change.doc._conflicts;
    }
  }
  return change;
}

Changes$1.prototype.validateChanges = function (opts) {
  var callback = opts.complete;
  var self = this;

  /* istanbul ignore else */
  if (PouchDB._changesFilterPlugin) {
    PouchDB._changesFilterPlugin.validate(opts, function (err) {
      if (err) {
        return callback(err);
      }
      self.doChanges(opts);
    });
  } else {
    self.doChanges(opts);
  }
};

Changes$1.prototype.doChanges = function (opts) {
  var self = this;
  var callback = opts.complete;

  opts = clone(opts);
  if ('live' in opts && !('continuous' in opts)) {
    opts.continuous = opts.live;
  }
  opts.processChange = processChange;

  if (opts.since === 'latest') {
    opts.since = 'now';
  }
  if (!opts.since) {
    opts.since = 0;
  }
  if (opts.since === 'now') {
    this.db.info().then(function (info) {
      /* istanbul ignore if */
      if (self.isCancelled) {
        callback(null, {status: 'cancelled'});
        return;
      }
      opts.since = info.update_seq;
      self.doChanges(opts);
    }, callback);
    return;
  }

  /* istanbul ignore else */
  if (PouchDB._changesFilterPlugin) {
    PouchDB._changesFilterPlugin.normalize(opts);
    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {
      return PouchDB._changesFilterPlugin.filter(this, opts);
    }
  } else {
    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {
      if (key in opts) {
        guardedConsole('warn',
          'The "' + key + '" option was passed in to changes/replicate, ' +
          'but pouchdb-changes-filter plugin is not installed, so it ' +
          'was ignored. Please install the plugin to enable filtering.'
        );
      }
    });
  }

  if (!('descending' in opts)) {
    opts.descending = false;
  }

  // 0 and 1 should return 1 document
  opts.limit = opts.limit === 0 ? 1 : opts.limit;
  opts.complete = callback;
  var newPromise = this.db._changes(opts);
  /* istanbul ignore else */
  if (newPromise && typeof newPromise.cancel === 'function') {
    var cancel = self.cancel;
    self.cancel = argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
      newPromise.cancel();
      cancel.apply(this, args);
    });
  }
};

/*
 * A generic pouch adapter
 */

function compare(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Wrapper for functions that call the bulkdocs api with a single doc,
// if the first result is an error, return an error
function yankError(callback, docId) {
  return function (err, results) {
    if (err || (results[0] && results[0].error)) {
      err = err || results[0];
      err.docId = docId;
      callback(err);
    } else {
      callback(null, results.length ? results[0]  : results);
    }
  };
}

// clean docs given to us by the user
function cleanDocs(docs) {
  for (var i = 0; i < docs.length; i++) {
    var doc = docs[i];
    if (doc._deleted) {
      delete doc._attachments; // ignore atts for deleted docs
    } else if (doc._attachments) {
      // filter out extraneous keys from _attachments
      var atts = Object.keys(doc._attachments);
      for (var j = 0; j < atts.length; j++) {
        var att = atts[j];
        doc._attachments[att] = pick(doc._attachments[att],
          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);
      }
    }
  }
}

// compare two docs, first by _id then by _rev
function compareByIdThenRev(a, b) {
  var idCompare = compare(a._id, b._id);
  if (idCompare !== 0) {
    return idCompare;
  }
  var aStart = a._revisions ? a._revisions.start : 0;
  var bStart = b._revisions ? b._revisions.start : 0;
  return compare(aStart, bStart);
}

// for every node in a revision tree computes its distance from the closest
// leaf
function computeHeight(revs) {
  var height = {};
  var edges = [];
  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
    var rev$$1 = pos + "-" + id;
    if (isLeaf) {
      height[rev$$1] = 0;
    }
    if (prnt !== undefined) {
      edges.push({from: prnt, to: rev$$1});
    }
    return rev$$1;
  });

  edges.reverse();
  edges.forEach(function (edge) {
    if (height[edge.from] === undefined) {
      height[edge.from] = 1 + height[edge.to];
    } else {
      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
    }
  });
  return height;
}

function allDocsKeysParse(opts) {
  var keys =  ('limit' in opts) ?
    opts.keys.slice(opts.skip, opts.limit + opts.skip) :
    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;
  opts.keys = keys;
  opts.skip = 0;
  delete opts.limit;
  if (opts.descending) {
    keys.reverse();
    opts.descending = false;
  }
}

// all compaction is done in a queue, to avoid attaching
// too many listeners at once
function doNextCompaction(self) {
  var task = self._compactionQueue[0];
  var opts = task.opts;
  var callback = task.callback;
  self.get('_local/compaction').catch(function () {
    return false;
  }).then(function (doc) {
    if (doc && doc.last_seq) {
      opts.last_seq = doc.last_seq;
    }
    self._compact(opts, function (err, res) {
      /* istanbul ignore if */
      if (err) {
        callback(err);
      } else {
        callback(null, res);
      }
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
        self._compactionQueue.shift();
        if (self._compactionQueue.length) {
          doNextCompaction(self);
        }
      });
    });
  });
}

function attachmentNameError(name) {
  if (name.charAt(0) === '_') {
    return name + ' is not a valid attachment name, attachment ' +
      'names cannot start with \\'_\\'';
  }
  return false;
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(AbstractPouchDB, events__WEBPACK_IMPORTED_MODULE_6___default.a);

function AbstractPouchDB() {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);

  // re-bind prototyped methods
  for (var p in AbstractPouchDB.prototype) {
    if (typeof this[p] === 'function') {
      this[p] = this[p].bind(this);
    }
  }
}

AbstractPouchDB.prototype.post =
  adapterFun('post', function (doc, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return callback(createError(NOT_AN_OBJECT));
  }
  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));
});

AbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return cb(createError(NOT_AN_OBJECT));
  }
  invalidIdError(doc._id);
  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {
    if (doc._deleted) {
      return this._removeLocal(doc, cb);
    } else {
      return this._putLocal(doc, cb);
    }
  }
  var self = this;
  if (opts.force && doc._rev) {
    transformForceOptionToNewEditsOption();
    putDoc(function (err) {
      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};
      cb(err, result);
    });
  } else {
    putDoc(cb);
  }

  function transformForceOptionToNewEditsOption() {
    var parts = doc._rev.split('-');
    var oldRevId = parts[1];
    var oldRevNum = parseInt(parts[0], 10);

    var newRevNum = oldRevNum + 1;
    var newRevId = rev();

    doc._revisions = {
      start: newRevNum,
      ids: [newRevId, oldRevId]
    };
    doc._rev = newRevNum + '-' + newRevId;
    opts.new_edits = false;
  }
  function putDoc(next) {
    if (typeof self._put === 'function' && opts.new_edits !== false) {
      self._put(doc, opts, next);
    } else {
      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));
    }
  }
});

AbstractPouchDB.prototype.putAttachment =
  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,
                                              blob, type) {
  var api = this;
  if (typeof type === 'function') {
    type = blob;
    blob = rev$$1;
    rev$$1 = null;
  }
  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267
  /* istanbul ignore if */
  if (typeof type === 'undefined') {
    type = blob;
    blob = rev$$1;
    rev$$1 = null;
  }
  if (!type) {
    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');
  }

  function createAttachment(doc) {
    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;
    doc._attachments = doc._attachments || {};
    doc._attachments[attachmentId] = {
      content_type: type,
      data: blob,
      revpos: ++prevrevpos
    };
    return api.put(doc);
  }

  return api.get(docId).then(function (doc) {
    if (doc._rev !== rev$$1) {
      throw createError(REV_CONFLICT);
    }

    return createAttachment(doc);
  }, function (err) {
     // create new doc
    /* istanbul ignore else */
    if (err.reason === MISSING_DOC.message) {
      return createAttachment({_id: docId});
    } else {
      throw err;
    }
  });
});

AbstractPouchDB.prototype.removeAttachment =
  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,
                                                 callback) {
  var self = this;
  self.get(docId, function (err, obj) {
    /* istanbul ignore if */
    if (err) {
      callback(err);
      return;
    }
    if (obj._rev !== rev$$1) {
      callback(createError(REV_CONFLICT));
      return;
    }
    /* istanbul ignore if */
    if (!obj._attachments) {
      return callback();
    }
    delete obj._attachments[attachmentId];
    if (Object.keys(obj._attachments).length === 0) {
      delete obj._attachments;
    }
    self.put(obj, callback);
  });
});

AbstractPouchDB.prototype.remove =
  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
  var doc;
  if (typeof optsOrRev === 'string') {
    // id, rev, opts, callback style
    doc = {
      _id: docOrId,
      _rev: optsOrRev
    };
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
  } else {
    // doc, opts, callback style
    doc = docOrId;
    if (typeof optsOrRev === 'function') {
      callback = optsOrRev;
      opts = {};
    } else {
      callback = opts;
      opts = optsOrRev;
    }
  }
  opts = opts || {};
  opts.was_delete = true;
  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};
  newDoc._deleted = true;
  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
    return this._removeLocal(doc, callback);
  }
  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));
});

AbstractPouchDB.prototype.revsDiff =
  adapterFun('revsDiff', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  var ids = Object.keys(req);

  if (!ids.length) {
    return callback(null, {});
  }

  var count = 0;
  var missing = new ExportedMap();

  function addToMissing(id, revId) {
    if (!missing.has(id)) {
      missing.set(id, {missing: []});
    }
    missing.get(id).missing.push(revId);
  }

  function processDoc(id, rev_tree) {
    // Is this fast enough? Maybe we should switch to a set simulated by a map
    var missingForId = req[id].slice(0);
    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,
      opts) {
        var rev$$1 = pos + '-' + revHash;
        var idx = missingForId.indexOf(rev$$1);
        if (idx === -1) {
          return;
        }

        missingForId.splice(idx, 1);
        /* istanbul ignore if */
        if (opts.status !== 'available') {
          addToMissing(id, rev$$1);
        }
      });

    // Traversing the tree is synchronous, so now \`missingForId\` contains
    // revisions that were not found in the tree
    missingForId.forEach(function (rev$$1) {
      addToMissing(id, rev$$1);
    });
  }

  ids.map(function (id) {
    this._getRevisionTree(id, function (err, rev_tree) {
      if (err && err.status === 404 && err.message === 'missing') {
        missing.set(id, {missing: req[id]});
      } else if (err) {
        /* istanbul ignore next */
        return callback(err);
      } else {
        processDoc(id, rev_tree);
      }

      if (++count === ids.length) {
        // convert LazyMap to object
        var missingObj = {};
        missing.forEach(function (value, key) {
          missingObj[key] = value;
        });
        return callback(null, missingObj);
      }
    });
  }, this);
});

// _bulk_get API for faster replication, as described in
// https://github.com/apache/couchdb-chttpd/pull/33
// At the "abstract" level, it will just run multiple get()s in
// parallel, because this isn't much of a performance cost
// for local databases (except the cost of multiple transactions, which is
// small). The http adapter overrides this in order
// to do a more efficient single HTTP request.
AbstractPouchDB.prototype.bulkGet =
  adapterFun('bulkGet', function (opts, callback) {
  bulkGet(this, opts, callback);
});

// compact one document and fire callback
// by compacting we mean removing all revisions which
// are further from the leaf in revision tree than max_height
AbstractPouchDB.prototype.compactDocument =
  adapterFun('compactDocument', function (docId, maxHeight, callback) {
  var self = this;
  this._getRevisionTree(docId, function (err, revTree) {
    /* istanbul ignore if */
    if (err) {
      return callback(err);
    }
    var height = computeHeight(revTree);
    var candidates = [];
    var revs = [];
    Object.keys(height).forEach(function (rev$$1) {
      if (height[rev$$1] > maxHeight) {
        candidates.push(rev$$1);
      }
    });

    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
      var rev$$1 = pos + '-' + revHash;
      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {
        revs.push(rev$$1);
      }
    });
    self._doCompaction(docId, revs, callback);
  });
});

// compact the whole database using single document
// compaction
AbstractPouchDB.prototype.compact =
  adapterFun('compact', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  opts = opts || {};

  self._compactionQueue = self._compactionQueue || [];
  self._compactionQueue.push({opts: opts, callback: callback});
  if (self._compactionQueue.length === 1) {
    doNextCompaction(self);
  }
});
AbstractPouchDB.prototype._compact = function (opts, callback) {
  var self = this;
  var changesOpts = {
    return_docs: false,
    last_seq: opts.last_seq || 0
  };
  var promises = [];

  function onChange(row) {
    promises.push(self.compactDocument(row.id, 0));
  }
  function onComplete(resp) {
    var lastSeq = resp.last_seq;
    Promise.all(promises).then(function () {
      return upsert(self, '_local/compaction', function deltaFunc(doc) {
        if (!doc.last_seq || doc.last_seq < lastSeq) {
          doc.last_seq = lastSeq;
          return doc;
        }
        return false; // somebody else got here first, don't update
      });
    }).then(function () {
      callback(null, {ok: true});
    }).catch(callback);
  }
  self.changes(changesOpts)
    .on('change', onChange)
    .on('complete', onComplete)
    .on('error', callback);
};

/* Begin api wrappers. Specific functionality to storage belongs in the
   _[method] */
AbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof id !== 'string') {
    return cb(createError(INVALID_ID));
  }
  if (isLocalId(id) && typeof this._getLocal === 'function') {
    return this._getLocal(id, cb);
  }
  var leaves = [], self = this;

  function finishOpenRevs() {
    var result = [];
    var count = leaves.length;
    /* istanbul ignore if */
    if (!count) {
      return cb(null, result);
    }

    // order with open_revs is unspecified
    leaves.forEach(function (leaf) {
      self.get(id, {
        rev: leaf,
        revs: opts.revs,
        latest: opts.latest,
        attachments: opts.attachments,
        binary: opts.binary
      }, function (err, doc) {
        if (!err) {
          // using latest=true can produce duplicates
          var existing;
          for (var i = 0, l = result.length; i < l; i++) {
            if (result[i].ok && result[i].ok._rev === doc._rev) {
              existing = true;
              break;
            }
          }
          if (!existing) {
            result.push({ok: doc});
          }
        } else {
          result.push({missing: leaf});
        }
        count--;
        if (!count) {
          cb(null, result);
        }
      });
    });
  }

  if (opts.open_revs) {
    if (opts.open_revs === "all") {
      this._getRevisionTree(id, function (err, rev_tree) {
        /* istanbul ignore if */
        if (err) {
          return cb(err);
        }
        leaves = collectLeaves(rev_tree).map(function (leaf) {
          return leaf.rev;
        });
        finishOpenRevs();
      });
    } else {
      if (Array.isArray(opts.open_revs)) {
        leaves = opts.open_revs;
        for (var i = 0; i < leaves.length; i++) {
          var l = leaves[i];
          // looks like it's the only thing couchdb checks
          if (!(typeof (l) === "string" && /^\\d+-/.test(l))) {
            return cb(createError(INVALID_REV));
          }
        }
        finishOpenRevs();
      } else {
        return cb(createError(UNKNOWN_ERROR, 'function_clause'));
      }
    }
    return; // open_revs does not like other options
  }

  return this._get(id, opts, function (err, result) {
    if (err) {
      err.docId = id;
      return cb(err);
    }

    var doc = result.doc;
    var metadata = result.metadata;
    var ctx = result.ctx;

    if (opts.conflicts) {
      var conflicts = collectConflicts(metadata);
      if (conflicts.length) {
        doc._conflicts = conflicts;
      }
    }

    if (isDeleted(metadata, doc._rev)) {
      doc._deleted = true;
    }

    if (opts.revs || opts.revs_info) {
      var splittedRev = doc._rev.split('-');
      var revNo       = parseInt(splittedRev[0], 10);
      var revHash     = splittedRev[1];

      var paths = rootToLeaf(metadata.rev_tree);
      var path = null;

      for (var i = 0; i < paths.length; i++) {
        var currentPath = paths[i];
        var hashIndex = currentPath.ids.map(function (x) { return x.id; })
          .indexOf(revHash);
        var hashFoundAtRevPos = hashIndex === (revNo - 1);

        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {
          path = currentPath;
        }
      }

      /* istanbul ignore if */
      if (!path) {
        err = new Error('invalid rev tree');
        err.docId = id;
        return cb(err);
      }

      var indexOfRev = path.ids.map(function (x) { return x.id; })
        .indexOf(doc._rev.split('-')[1]) + 1;
      var howMany = path.ids.length - indexOfRev;
      path.ids.splice(indexOfRev, howMany);
      path.ids.reverse();

      if (opts.revs) {
        doc._revisions = {
          start: (path.pos + path.ids.length) - 1,
          ids: path.ids.map(function (rev$$1) {
            return rev$$1.id;
          })
        };
      }
      if (opts.revs_info) {
        var pos =  path.pos + path.ids.length;
        doc._revs_info = path.ids.map(function (rev$$1) {
          pos--;
          return {
            rev: pos + '-' + rev$$1.id,
            status: rev$$1.opts.status
          };
        });
      }
    }

    if (opts.attachments && doc._attachments) {
      var attachments = doc._attachments;
      var count = Object.keys(attachments).length;
      if (count === 0) {
        return cb(null, doc);
      }
      Object.keys(attachments).forEach(function (key) {
        this._getAttachment(doc._id, key, attachments[key], {
          // Previously the revision handling was done in adapter.js
          // getAttachment, however since idb-next doesnt we need to
          // pass the rev through
          rev: doc._rev,
          binary: opts.binary,
          ctx: ctx
        }, function (err, data) {
          var att = doc._attachments[key];
          att.data = data;
          delete att.stub;
          delete att.length;
          if (!--count) {
            cb(null, doc);
          }
        });
      }, self);
    } else {
      if (doc._attachments) {
        for (var key in doc._attachments) {
          /* istanbul ignore else */
          if (doc._attachments.hasOwnProperty(key)) {
            doc._attachments[key].stub = true;
          }
        }
      }
      cb(null, doc);
    }
  });
});

// TODO: I dont like this, it forces an extra read for every
// attachment read and enforces a confusing api between
// adapter.js and the adapter implementation
AbstractPouchDB.prototype.getAttachment =
  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {
  var self = this;
  if (opts instanceof Function) {
    callback = opts;
    opts = {};
  }
  this._get(docId, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (res.doc._attachments && res.doc._attachments[attachmentId]) {
      opts.ctx = res.ctx;
      opts.binary = true;
      self._getAttachment(docId, attachmentId,
                          res.doc._attachments[attachmentId], opts, callback);
    } else {
      return callback(createError(MISSING_DOC));
    }
  });
});

AbstractPouchDB.prototype.allDocs =
  adapterFun('allDocs', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
  if (opts.start_key) {
    opts.startkey = opts.start_key;
  }
  if (opts.end_key) {
    opts.endkey = opts.end_key;
  }
  if ('keys' in opts) {
    if (!Array.isArray(opts.keys)) {
      return callback(new TypeError('options.keys must be an array'));
    }
    var incompatibleOpt =
      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
      return incompatibleOpt in opts;
    })[0];
    if (incompatibleOpt) {
      callback(createError(QUERY_PARSE_ERROR,
        'Query parameter \`' + incompatibleOpt +
        '\` is not compatible with multi-get'
      ));
      return;
    }
    if (!isRemote(this)) {
      allDocsKeysParse(opts);
      if (opts.keys.length === 0) {
        return this._allDocs({limit: 0}, callback);
      }
    }
  }

  return this._allDocs(opts, callback);
});

AbstractPouchDB.prototype.changes = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = opts || {};

  // By default set return_docs to false if the caller has opts.live = true,
  // this will prevent us from collecting the set of changes indefinitely
  // resulting in growing memory
  opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;

  return new Changes$1(this, opts, callback);
};

AbstractPouchDB.prototype.close = adapterFun('close', function (callback) {
  this._closed = true;
  this.emit('closed');
  return this._close(callback);
});

AbstractPouchDB.prototype.info = adapterFun('info', function (callback) {
  var self = this;
  this._info(function (err, info) {
    if (err) {
      return callback(err);
    }
    // assume we know better than the adapter, unless it informs us
    info.db_name = info.db_name || self.name;
    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));
    info.adapter = self.adapter;
    callback(null, info);
  });
});

AbstractPouchDB.prototype.id = adapterFun('id', function (callback) {
  return this._id(callback);
});

/* istanbul ignore next */
AbstractPouchDB.prototype.type = function () {
  return (typeof this._type === 'function') ? this._type() : this.adapter;
};

AbstractPouchDB.prototype.bulkDocs =
  adapterFun('bulkDocs', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = opts || {};

  if (Array.isArray(req)) {
    req = {
      docs: req
    };
  }

  if (!req || !req.docs || !Array.isArray(req.docs)) {
    return callback(createError(MISSING_BULK_DOCS));
  }

  for (var i = 0; i < req.docs.length; ++i) {
    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
      return callback(createError(NOT_AN_OBJECT));
    }
  }

  var attachmentError;
  req.docs.forEach(function (doc) {
    if (doc._attachments) {
      Object.keys(doc._attachments).forEach(function (name) {
        attachmentError = attachmentError || attachmentNameError(name);
        if (!doc._attachments[name].content_type) {
          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');
        }
      });
    }
  });

  if (attachmentError) {
    return callback(createError(BAD_REQUEST, attachmentError));
  }

  if (!('new_edits' in opts)) {
    if ('new_edits' in req) {
      opts.new_edits = req.new_edits;
    } else {
      opts.new_edits = true;
    }
  }

  var adapter = this;
  if (!opts.new_edits && !isRemote(adapter)) {
    // ensure revisions of the same doc are sorted, so that
    // the local adapter processes them correctly (#2935)
    req.docs.sort(compareByIdThenRev);
  }

  cleanDocs(req.docs);

  // in the case of conflicts, we want to return the _ids to the user
  // however, the underlying adapter may destroy the docs array, so
  // create a copy here
  var ids = req.docs.map(function (doc) {
    return doc._id;
  });

  return this._bulkDocs(req, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (!opts.new_edits) {
      // this is what couch does when new_edits is false
      res = res.filter(function (x) {
        return x.error;
      });
    }
    // add ids for error/conflict responses (not required for CouchDB)
    if (!isRemote(adapter)) {
      for (var i = 0, l = res.length; i < l; i++) {
        res[i].id = res[i].id || ids[i];
      }
    }

    callback(null, res);
  });
});

AbstractPouchDB.prototype.registerDependentDatabase =
  adapterFun('registerDependentDatabase', function (dependentDb,
                                                          callback) {
  var depDB = new this.constructor(dependentDb, this.__opts);

  function diffFun(doc) {
    doc.dependentDbs = doc.dependentDbs || {};
    if (doc.dependentDbs[dependentDb]) {
      return false; // no update required
    }
    doc.dependentDbs[dependentDb] = true;
    return doc;
  }
  upsert(this, '_local/_pouch_dependentDbs', diffFun)
    .then(function () {
      callback(null, {db: depDB});
    }).catch(callback);
});

AbstractPouchDB.prototype.destroy =
  adapterFun('destroy', function (opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;

  function destroyDb() {
    // call destroy method of the particular adaptor
    self._destroy(opts, function (err, resp) {
      if (err) {
        return callback(err);
      }
      self._destroyed = true;
      self.emit('destroyed');
      callback(null, resp || { 'ok': true });
    });
  }

  if (isRemote(self)) {
    // no need to check for dependent DBs if it's a remote DB
    return destroyDb();
  }

  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {
    if (err) {
      /* istanbul ignore if */
      if (err.status !== 404) {
        return callback(err);
      } else { // no dependencies
        return destroyDb();
      }
    }
    var dependentDbs = localDoc.dependentDbs;
    var PouchDB = self.constructor;
    var deletedMap = Object.keys(dependentDbs).map(function (name) {
      // use_prefix is only false in the browser
      /* istanbul ignore next */
      var trueName = usePrefix ?
        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
      return new PouchDB(trueName, self.__opts).destroy();
    });
    Promise.all(deletedMap).then(destroyDb, callback);
  });
});

function TaskQueue() {
  this.isReady = false;
  this.failed = false;
  this.queue = [];
}

TaskQueue.prototype.execute = function () {
  var fun;
  if (this.failed) {
    while ((fun = this.queue.shift())) {
      fun(this.failed);
    }
  } else {
    while ((fun = this.queue.shift())) {
      fun();
    }
  }
};

TaskQueue.prototype.fail = function (err) {
  this.failed = err;
  this.execute();
};

TaskQueue.prototype.ready = function (db) {
  this.isReady = true;
  this.db = db;
  this.execute();
};

TaskQueue.prototype.addTask = function (fun) {
  this.queue.push(fun);
  if (this.failed) {
    this.execute();
  }
};

function parseAdapter(name, opts) {
  var match = name.match(/([a-z-]*):\\/\\/(.*)/);
  if (match) {
    // the http adapter expects the fully qualified name
    return {
      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],
      adapter: match[1]
    };
  }

  var adapters = PouchDB.adapters;
  var preferredAdapters = PouchDB.preferredAdapters;
  var prefix = PouchDB.prefix;
  var adapterName = opts.adapter;

  if (!adapterName) { // automatically determine adapter
    for (var i = 0; i < preferredAdapters.length; ++i) {
      adapterName = preferredAdapters[i];
      // check for browsers that have been upgraded from websql-only to websql+idb
      /* istanbul ignore if */
      if (adapterName === 'idb' && 'websql' in adapters &&
          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {
        // log it, because this can be confusing during development
        guardedConsole('log', 'PouchDB is downgrading "' + name + '" to WebSQL to' +
          ' avoid data loss, because it was already opened with WebSQL.');
        continue; // keep using websql to avoid user data loss
      }
      break;
    }
  }

  var adapter = adapters[adapterName];

  // if adapter is invalid, then an error will be thrown later
  var usePrefix = (adapter && 'use_prefix' in adapter) ?
    adapter.use_prefix : true;

  return {
    name: usePrefix ? (prefix + name) : name,
    adapter: adapterName
  };
}

// OK, so here's the deal. Consider this code:
//     var db1 = new PouchDB('foo');
//     var db2 = new PouchDB('foo');
//     db1.destroy();
// ^ these two both need to emit 'destroyed' events,
// as well as the PouchDB constructor itself.
// So we have one db object (whichever one got destroy() called on it)
// responsible for emitting the initial event, which then gets emitted
// by the constructor, which then broadcasts it to any other dbs
// that may have been created with the same name.
function prepareForDestruction(self) {

  function onDestroyed(from_constructor) {
    self.removeListener('closed', onClosed);
    if (!from_constructor) {
      self.constructor.emit('destroyed', self.name);
    }
  }

  function onClosed() {
    self.removeListener('destroyed', onDestroyed);
    self.constructor.emit('unref', self);
  }

  self.once('destroyed', onDestroyed);
  self.once('closed', onClosed);
  self.constructor.emit('ref', self);
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(PouchDB, AbstractPouchDB);
function PouchDB(name, opts) {
  // In Node our test suite only tests this for PouchAlt unfortunately
  /* istanbul ignore if */
  if (!(this instanceof PouchDB)) {
    return new PouchDB(name, opts);
  }

  var self = this;
  opts = opts || {};

  if (name && typeof name === 'object') {
    opts = name;
    name = opts.name;
    delete opts.name;
  }

  if (opts.deterministic_revs === undefined) {
    opts.deterministic_revs = true;
  }

  this.__opts = opts = clone(opts);

  self.auto_compaction = opts.auto_compaction;
  self.prefix = PouchDB.prefix;

  if (typeof name !== 'string') {
    throw new Error('Missing/invalid DB name');
  }

  var prefixedName = (opts.prefix || '') + name;
  var backend = parseAdapter(prefixedName, opts);

  opts.name = backend.name;
  opts.adapter = opts.adapter || backend.adapter;

  self.name = name;
  self._adapter = opts.adapter;
  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);

  if (!PouchDB.adapters[opts.adapter] ||
      !PouchDB.adapters[opts.adapter].valid()) {
    throw new Error('Invalid Adapter: ' + opts.adapter);
  }

  AbstractPouchDB.call(self);
  self.taskqueue = new TaskQueue();

  self.adapter = opts.adapter;

  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {
    if (err) {
      return self.taskqueue.fail(err);
    }
    prepareForDestruction(self);

    self.emit('created', self);
    PouchDB.emit('created', self.name);
    self.taskqueue.ready(self);
  });

}

// AbortController was introduced quite a while after fetch and
// isnt required for PouchDB to function so polyfill if needed
var a = (typeof AbortController !== 'undefined')
    ? AbortController
    : function () { return {abort: function () {}}; };

var f$1 = fetch;
var h = Headers;

PouchDB.adapters = {};
PouchDB.preferredAdapters = [];

PouchDB.prefix = '_pouch_';

var eventEmitter = new events__WEBPACK_IMPORTED_MODULE_6___default.a();

function setUpEventEmitter(Pouch) {
  Object.keys(events__WEBPACK_IMPORTED_MODULE_6___default.a.prototype).forEach(function (key) {
    if (typeof events__WEBPACK_IMPORTED_MODULE_6___default.a.prototype[key] === 'function') {
      Pouch[key] = eventEmitter[key].bind(eventEmitter);
    }
  });

  // these are created in constructor.js, and allow us to notify each DB with
  // the same name that it was destroyed, via the constructor object
  var destructListeners = Pouch._destructionListeners = new ExportedMap();

  Pouch.on('ref', function onConstructorRef(db) {
    if (!destructListeners.has(db.name)) {
      destructListeners.set(db.name, []);
    }
    destructListeners.get(db.name).push(db);
  });

  Pouch.on('unref', function onConstructorUnref(db) {
    if (!destructListeners.has(db.name)) {
      return;
    }
    var dbList = destructListeners.get(db.name);
    var pos = dbList.indexOf(db);
    if (pos < 0) {
      /* istanbul ignore next */
      return;
    }
    dbList.splice(pos, 1);
    if (dbList.length > 1) {
      /* istanbul ignore next */
      destructListeners.set(db.name, dbList);
    } else {
      destructListeners.delete(db.name);
    }
  });

  Pouch.on('destroyed', function onConstructorDestroyed(name) {
    if (!destructListeners.has(name)) {
      return;
    }
    var dbList = destructListeners.get(name);
    destructListeners.delete(name);
    dbList.forEach(function (db) {
      db.emit('destroyed',true);
    });
  });
}

setUpEventEmitter(PouchDB);

PouchDB.adapter = function (id, obj, addToPreferredAdapters) {
  /* istanbul ignore else */
  if (obj.valid()) {
    PouchDB.adapters[id] = obj;
    if (addToPreferredAdapters) {
      PouchDB.preferredAdapters.push(id);
    }
  }
};

PouchDB.plugin = function (obj) {
  if (typeof obj === 'function') { // function style for plugins
    obj(PouchDB);
  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {
    throw new Error('Invalid plugin: got "' + obj + '", expected an object or a function');
  } else {
    Object.keys(obj).forEach(function (id) { // object style for plugins
      PouchDB.prototype[id] = obj[id];
    });
  }
  if (this.__defaults) {
    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);
  }
  return PouchDB;
};

PouchDB.defaults = function (defaultOpts) {
  function PouchAlt(name, opts) {
    if (!(this instanceof PouchAlt)) {
      return new PouchAlt(name, opts);
    }

    opts = opts || {};

    if (name && typeof name === 'object') {
      opts = name;
      name = opts.name;
      delete opts.name;
    }

    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);
    PouchDB.call(this, name, opts);
  }

  inherits__WEBPACK_IMPORTED_MODULE_5___default()(PouchAlt, PouchDB);

  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();
  Object.keys(PouchDB).forEach(function (key) {
    if (!(key in PouchAlt)) {
      PouchAlt[key] = PouchDB[key];
    }
  });

  // make default options transitive
  // https://github.com/pouchdb/pouchdb/issues/5922
  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);

  return PouchAlt;
};

PouchDB.fetch = function (url, opts) {
  return f$1(url, opts);
};

// managed automatically by set-version.js
var version = "7.2.2";

// this would just be "return doc[field]", but fields
// can be "deep" due to dot notation
function getFieldFromDoc(doc, parsedField) {
  var value = doc;
  for (var i = 0, len = parsedField.length; i < len; i++) {
    var key = parsedField[i];
    value = value[key];
    if (!value) {
      break;
    }
  }
  return value;
}

function compare$1(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Converts a string in dot notation to an array of its components, with backslash escaping
function parseField(fieldName) {
  // fields may be deep (e.g. "foo.bar.baz"), so parse
  var fields = [];
  var current = '';
  for (var i = 0, len = fieldName.length; i < len; i++) {
    var ch = fieldName[i];
    if (ch === '.') {
      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter
        current = current.substring(0, current.length - 1) + '.';
      } else { // not escaped, so delimiter
        fields.push(current);
        current = '';
      }
    } else { // normal character
      current += ch;
    }
  }
  fields.push(current);
  return fields;
}

var combinationFields = ['$or', '$nor', '$not'];
function isCombinationalField(field) {
  return combinationFields.indexOf(field) > -1;
}

function getKey(obj) {
  return Object.keys(obj)[0];
}

function getValue(obj) {
  return obj[getKey(obj)];
}


// flatten an array of selectors joined by an $and operator
function mergeAndedSelectors(selectors) {

  // sort to ensure that e.g. if the user specified
  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into
  // just {$gt: 'b'}
  var res = {};

  selectors.forEach(function (selector) {
    Object.keys(selector).forEach(function (field) {
      var matcher = selector[field];
      if (typeof matcher !== 'object') {
        matcher = {$eq: matcher};
      }

      if (isCombinationalField(field)) {
        if (matcher instanceof Array) {
          res[field] = matcher.map(function (m) {
            return mergeAndedSelectors([m]);
          });
        } else {
          res[field] = mergeAndedSelectors([matcher]);
        }
      } else {
        var fieldMatchers = res[field] = res[field] || {};
        Object.keys(matcher).forEach(function (operator) {
          var value = matcher[operator];

          if (operator === '$gt' || operator === '$gte') {
            return mergeGtGte(operator, value, fieldMatchers);
          } else if (operator === '$lt' || operator === '$lte') {
            return mergeLtLte(operator, value, fieldMatchers);
          } else if (operator === '$ne') {
            return mergeNe(value, fieldMatchers);
          } else if (operator === '$eq') {
            return mergeEq(value, fieldMatchers);
          }
          fieldMatchers[operator] = value;
        });
      }
    });
  });

  return res;
}



// collapse logically equivalent gt/gte values
function mergeGtGte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$gte !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gte) { // more specificity
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value >= fieldMatchers.$gte) { // more specificity
        delete fieldMatchers.$gte;
        fieldMatchers.$gt = value;
      }
    }
  } else if (typeof fieldMatchers.$gt !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gt) { // more specificity
        delete fieldMatchers.$gt;
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value > fieldMatchers.$gt) { // more specificity
        fieldMatchers.$gt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// collapse logically equivalent lt/lte values
function mergeLtLte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$lte !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lte) { // more specificity
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value <= fieldMatchers.$lte) { // more specificity
        delete fieldMatchers.$lte;
        fieldMatchers.$lt = value;
      }
    }
  } else if (typeof fieldMatchers.$lt !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lt) { // more specificity
        delete fieldMatchers.$lt;
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value < fieldMatchers.$lt) { // more specificity
        fieldMatchers.$lt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// combine $ne values into one array
function mergeNe(value, fieldMatchers) {
  if ('$ne' in fieldMatchers) {
    // there are many things this could "not" be
    fieldMatchers.$ne.push(value);
  } else { // doesn't exist yet
    fieldMatchers.$ne = [value];
  }
}

// add $eq into the mix
function mergeEq(value, fieldMatchers) {
  // these all have less specificity than the $eq
  // TODO: check for user errors here
  delete fieldMatchers.$gt;
  delete fieldMatchers.$gte;
  delete fieldMatchers.$lt;
  delete fieldMatchers.$lte;
  delete fieldMatchers.$ne;
  fieldMatchers.$eq = value;
}

//#7458: execute function mergeAndedSelectors on nested $and
function mergeAndedSelectorsNested(obj) {
    for (var prop in obj) {
        if (Array.isArray(obj)) {
            for (var i in obj) {
                if (obj[i]['$and']) {
                    obj[i] = mergeAndedSelectors(obj[i]['$and']);
                }
            }
        }
        var value = obj[prop];
        if (typeof value === 'object') {
            mergeAndedSelectorsNested(value); // <- recursive call
        }
    }
    return obj;
}

//#7458: determine id $and is present in selector (at any level)
function isAndInSelector(obj, isAnd) {
    for (var prop in obj) {
        if (prop === '$and') {
            isAnd = true;
        }
        var value = obj[prop];
        if (typeof value === 'object') {
            isAnd = isAndInSelector(value, isAnd); // <- recursive call
        }
    }
    return isAnd;
}

//
// normalize the selector
//
function massageSelector(input) {
  var result = clone(input);
  var wasAnded = false;
    //#7458: if $and is present in selector (at any level) merge nested $and
    if (isAndInSelector(result, false)) {
        result = mergeAndedSelectorsNested(result);
        if ('$and' in result) {
            result = mergeAndedSelectors(result['$and']);
        }
        wasAnded = true;
    }

  ['$or', '$nor'].forEach(function (orOrNor) {
    if (orOrNor in result) {
      // message each individual selector
      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}
      result[orOrNor].forEach(function (subSelector) {
        var fields = Object.keys(subSelector);
        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];
          var matcher = subSelector[field];
          if (typeof matcher !== 'object' || matcher === null) {
            subSelector[field] = {$eq: matcher};
          }
        }
      });
    }
  });

  if ('$not' in result) {
    //This feels a little like forcing, but it will work for now,
    //I would like to come back to this and make the merging of selectors a little more generic
    result['$not'] = mergeAndedSelectors([result['$not']]);
  }

  var fields = Object.keys(result);

  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    var matcher = result[field];

    if (typeof matcher !== 'object' || matcher === null) {
      matcher = {$eq: matcher};
    } else if ('$ne' in matcher && !wasAnded) {
      // I put these in an array, since there may be more than one
      // but in the "mergeAnded" operation, I already take care of that
      matcher.$ne = [matcher.$ne];
    }
    result[field] = matcher;
  }

  return result;
}

function pad(str, padWith, upToLength) {
  var padding = '';
  var targetLength = upToLength - str.length;
  /* istanbul ignore next */
  while (padding.length < targetLength) {
    padding += padWith;
  }
  return padding;
}

function padLeft(str, padWith, upToLength) {
  var padding = pad(str, padWith, upToLength);
  return padding + str;
}

var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
var MAGNITUDE_DIGITS = 3; // ditto
var SEP = ''; // set to '_' for easier debugging 

function collate(a, b) {

  if (a === b) {
    return 0;
  }

  a = normalizeKey(a);
  b = normalizeKey(b);

  var ai = collationIndex(a);
  var bi = collationIndex(b);
  if ((ai - bi) !== 0) {
    return ai - bi;
  }
  switch (typeof a) {
    case 'number':
      return a - b;
    case 'boolean':
      return a < b ? -1 : 1;
    case 'string':
      return stringCollate(a, b);
  }
  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
}

// couch considers null/NaN/Infinity/-Infinity === undefined,
// for the purposes of mapreduce indexes. also, dates get stringified.
function normalizeKey(key) {
  switch (typeof key) {
    case 'undefined':
      return null;
    case 'number':
      if (key === Infinity || key === -Infinity || isNaN(key)) {
        return null;
      }
      return key;
    case 'object':
      var origKey = key;
      if (Array.isArray(key)) {
        var len = key.length;
        key = new Array(len);
        for (var i = 0; i < len; i++) {
          key[i] = normalizeKey(origKey[i]);
        }
      /* istanbul ignore next */
      } else if (key instanceof Date) {
        return key.toJSON();
      } else if (key !== null) { // generic object
        key = {};
        for (var k in origKey) {
          if (origKey.hasOwnProperty(k)) {
            var val = origKey[k];
            if (typeof val !== 'undefined') {
              key[k] = normalizeKey(val);
            }
          }
        }
      }
  }
  return key;
}

function indexify(key) {
  if (key !== null) {
    switch (typeof key) {
      case 'boolean':
        return key ? 1 : 0;
      case 'number':
        return numToIndexableString(key);
      case 'string':
        // We've to be sure that key does not contain \\u0000
        // Do order-preserving replacements:
        // 0 -> 1, 1
        // 1 -> 1, 2
        // 2 -> 2, 2
        /* eslint-disable no-control-regex */
        return key
          .replace(/\\u0002/g, '\\u0002\\u0002')
          .replace(/\\u0001/g, '\\u0001\\u0002')
          .replace(/\\u0000/g, '\\u0001\\u0001');
        /* eslint-enable no-control-regex */
      case 'object':
        var isArray = Array.isArray(key);
        var arr = isArray ? key : Object.keys(key);
        var i = -1;
        var len = arr.length;
        var result = '';
        if (isArray) {
          while (++i < len) {
            result += toIndexableString(arr[i]);
          }
        } else {
          while (++i < len) {
            var objKey = arr[i];
            result += toIndexableString(objKey) +
                toIndexableString(key[objKey]);
          }
        }
        return result;
    }
  }
  return '';
}

// convert the given key to a string that would be appropriate
// for lexical sorting, e.g. within a database, where the
// sorting is the same given by the collate() function.
function toIndexableString(key) {
  var zero = '\\u0000';
  key = normalizeKey(key);
  return collationIndex(key) + SEP + indexify(key) + zero;
}

function parseNumber(str, i) {
  var originalIdx = i;
  var num;
  var zero = str[i] === '1';
  if (zero) {
    num = 0;
    i++;
  } else {
    var neg = str[i] === '0';
    i++;
    var numAsString = '';
    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
    /* istanbul ignore next */
    if (neg) {
      magnitude = -magnitude;
    }
    i += MAGNITUDE_DIGITS;
    while (true) {
      var ch = str[i];
      if (ch === '\\u0000') {
        break;
      } else {
        numAsString += ch;
      }
      i++;
    }
    numAsString = numAsString.split('.');
    if (numAsString.length === 1) {
      num = parseInt(numAsString, 10);
    } else {
      /* istanbul ignore next */
      num = parseFloat(numAsString[0] + '.' + numAsString[1]);
    }
    /* istanbul ignore next */
    if (neg) {
      num = num - 10;
    }
    /* istanbul ignore next */
    if (magnitude !== 0) {
      // parseFloat is more reliable than pow due to rounding errors
      // e.g. Number.MAX_VALUE would return Infinity if we did
      // num * Math.pow(10, magnitude);
      num = parseFloat(num + 'e' + magnitude);
    }
  }
  return {num: num, length : i - originalIdx};
}

// move up the stack while parsing
// this function moved outside of parseIndexableString for performance
function pop(stack, metaStack) {
  var obj = stack.pop();

  if (metaStack.length) {
    var lastMetaElement = metaStack[metaStack.length - 1];
    if (obj === lastMetaElement.element) {
      // popping a meta-element, e.g. an object whose value is another object
      metaStack.pop();
      lastMetaElement = metaStack[metaStack.length - 1];
    }
    var element = lastMetaElement.element;
    var lastElementIndex = lastMetaElement.index;
    if (Array.isArray(element)) {
      element.push(obj);
    } else if (lastElementIndex === stack.length - 2) { // obj with key+value
      var key = stack.pop();
      element[key] = obj;
    } else {
      stack.push(obj); // obj with key only
    }
  }
}

function parseIndexableString(str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;

  /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
  while (true) {
    var collationIndex = str[i++];
    if (collationIndex === '\\u0000') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case '1':
        stack.push(null);
        break;
      case '2':
        stack.push(str[i] === '1');
        i++;
        break;
      case '3':
        var parsedNum = parseNumber(str, i);
        stack.push(parsedNum.num);
        i += parsedNum.length;
        break;
      case '4':
        var parsedStr = '';
        /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
        while (true) {
          var ch = str[i];
          if (ch === '\\u0000') {
            break;
          }
          parsedStr += ch;
          i++;
        }
        // perform the reverse of the order-preserving replacement
        // algorithm (see above)
        /* eslint-disable no-control-regex */
        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')
          .replace(/\\u0001\\u0002/g, '\\u0001')
          .replace(/\\u0002\\u0002/g, '\\u0002');
        /* eslint-enable no-control-regex */
        stack.push(parsedStr);
        break;
      case '5':
        var arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '6':
        var objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      /* istanbul ignore next */
      default:
        throw new Error(
          'bad collationIndex or unexpectedly reached end of input: ' +
            collationIndex);
    }
  }
}

function arrayCollate(a, b) {
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; i++) {
    var sort = collate(a[i], b[i]);
    if (sort !== 0) {
      return sort;
    }
  }
  return (a.length === b.length) ? 0 :
    (a.length > b.length) ? 1 : -1;
}
function stringCollate(a, b) {
  // See: https://github.com/daleharvey/pouchdb/issues/40
  // This is incompatible with the CouchDB implementation, but its the
  // best we can do for now
  return (a === b) ? 0 : ((a > b) ? 1 : -1);
}
function objectCollate(a, b) {
  var ak = Object.keys(a), bk = Object.keys(b);
  var len = Math.min(ak.length, bk.length);
  for (var i = 0; i < len; i++) {
    // First sort the keys
    var sort = collate(ak[i], bk[i]);
    if (sort !== 0) {
      return sort;
    }
    // if the keys are equal sort the values
    sort = collate(a[ak[i]], b[bk[i]]);
    if (sort !== 0) {
      return sort;
    }

  }
  return (ak.length === bk.length) ? 0 :
    (ak.length > bk.length) ? 1 : -1;
}
// The collation is defined by erlangs ordered terms
// the atoms null, true, false come first, then numbers, strings,
// arrays, then objects
// null/undefined/NaN/Infinity/-Infinity are all considered null
function collationIndex(x) {
  var id = ['boolean', 'number', 'string', 'object'];
  var idx = id.indexOf(typeof x);
  //false if -1 otherwise true, but fast!!!!1
  if (~idx) {
    if (x === null) {
      return 1;
    }
    if (Array.isArray(x)) {
      return 5;
    }
    return idx < 3 ? (idx + 2) : (idx + 3);
  }
  /* istanbul ignore next */
  if (Array.isArray(x)) {
    return 5;
  }
}

// conversion:
// x yyy zz...zz
// x = 0 for negative, 1 for 0, 2 for positive
// y = exponent (for negative numbers negated) moved so that it's >= 0
// z = mantisse
function numToIndexableString(num) {

  if (num === 0) {
    return '1';
  }

  // convert number to exponential format for easier and
  // more succinct string sorting
  var expFormat = num.toExponential().split(/e\\+?/);
  var magnitude = parseInt(expFormat[1], 10);

  var neg = num < 0;

  var result = neg ? '0' : '2';

  // first sort by magnitude
  // it's easier if all magnitudes are positive
  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

  result += SEP + magString;

  // then sort by the factor
  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
  /* istanbul ignore next */
  if (neg) { // for negative reverse ordering
    factor = 10 - factor;
  }

  var factorStr = factor.toFixed(20);

  // strip zeros from the end
  factorStr = factorStr.replace(/\\.?0+$/, '');

  result += SEP + factorStr;

  return result;
}

// create a comparator based on the sort object
function createFieldSorter(sort) {

  function getFieldValuesAsArray(doc) {
    return sort.map(function (sorting) {
      var fieldName = getKey(sorting);
      var parsedField = parseField(fieldName);
      var docFieldValue = getFieldFromDoc(doc, parsedField);
      return docFieldValue;
    });
  }

  return function (aRow, bRow) {
    var aFieldValues = getFieldValuesAsArray(aRow.doc);
    var bFieldValues = getFieldValuesAsArray(bRow.doc);
    var collation = collate(aFieldValues, bFieldValues);
    if (collation !== 0) {
      return collation;
    }
    // this is what mango seems to do
    return compare$1(aRow.doc._id, bRow.doc._id);
  };
}

function filterInMemoryFields(rows, requestDef, inMemoryFields) {
  rows = rows.filter(function (row) {
    return rowFilter(row.doc, requestDef.selector, inMemoryFields);
  });

  if (requestDef.sort) {
    // in-memory sort
    var fieldSorter = createFieldSorter(requestDef.sort);
    rows = rows.sort(fieldSorter);
    if (typeof requestDef.sort[0] !== 'string' &&
        getValue(requestDef.sort[0]) === 'desc') {
      rows = rows.reverse();
    }
  }

  if ('limit' in requestDef || 'skip' in requestDef) {
    // have to do the limit in-memory
    var skip = requestDef.skip || 0;
    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;
    rows = rows.slice(skip, limit);
  }
  return rows;
}

function rowFilter(doc, selector, inMemoryFields) {
  return inMemoryFields.every(function (field) {
    var matcher = selector[field];
    var parsedField = parseField(field);
    var docFieldValue = getFieldFromDoc(doc, parsedField);
    if (isCombinationalField(field)) {
      return matchCominationalSelector(field, matcher, doc);
    }

    return matchSelector(matcher, doc, parsedField, docFieldValue);
  });
}

function matchSelector(matcher, doc, parsedField, docFieldValue) {
  if (!matcher) {
    // no filtering necessary; this field is just needed for sorting
    return true;
  }

  // is matcher an object, if so continue recursion
  if (typeof matcher === 'object') {
    return Object.keys(matcher).every(function (userOperator) {
      var userValue = matcher[userOperator];
      return match(userOperator, doc, userValue, parsedField, docFieldValue);
    });
  }

  // no more depth, No need to recurse further
  return matcher === docFieldValue;
}

function matchCominationalSelector(field, matcher, doc) {

  if (field === '$or') {
    return matcher.some(function (orMatchers) {
      return rowFilter(doc, orMatchers, Object.keys(orMatchers));
    });
  }

  if (field === '$not') {
    return !rowFilter(doc, matcher, Object.keys(matcher));
  }

  //\`$nor\`
  return !matcher.find(function (orMatchers) {
    return rowFilter(doc, orMatchers, Object.keys(orMatchers));
  });

}

function match(userOperator, doc, userValue, parsedField, docFieldValue) {
  if (!matchers[userOperator]) {
    throw new Error('unknown operator "' + userOperator +
      '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +
      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
  }
  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);
}

function fieldExists(docFieldValue) {
  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;
}

function fieldIsNotUndefined(docFieldValue) {
  return typeof docFieldValue !== 'undefined';
}

function modField(docFieldValue, userValue) {
  var divisor = userValue[0];
  var mod = userValue[1];
  if (divisor === 0) {
    throw new Error('Bad divisor, cannot divide by zero');
  }

  if (parseInt(divisor, 10) !== divisor ) {
    throw new Error('Divisor is not an integer');
  }

  if (parseInt(mod, 10) !== mod ) {
    throw new Error('Modulus is not an integer');
  }

  if (parseInt(docFieldValue, 10) !== docFieldValue) {
    return false;
  }

  return docFieldValue % divisor === mod;
}

function arrayContainsValue(docFieldValue, userValue) {
  return userValue.some(function (val) {
    if (docFieldValue instanceof Array) {
      return docFieldValue.indexOf(val) > -1;
    }

    return docFieldValue === val;
  });
}

function arrayContainsAllValues(docFieldValue, userValue) {
  return userValue.every(function (val) {
    return docFieldValue.indexOf(val) > -1;
  });
}

function arraySize(docFieldValue, userValue) {
  return docFieldValue.length === userValue;
}

function regexMatch(docFieldValue, userValue) {
  var re = new RegExp(userValue);

  return re.test(docFieldValue);
}

function typeMatch(docFieldValue, userValue) {

  switch (userValue) {
    case 'null':
      return docFieldValue === null;
    case 'boolean':
      return typeof (docFieldValue) === 'boolean';
    case 'number':
      return typeof (docFieldValue) === 'number';
    case 'string':
      return typeof (docFieldValue) === 'string';
    case 'array':
      return docFieldValue instanceof Array;
    case 'object':
      return ({}).toString.call(docFieldValue) === '[object Object]';
  }

  throw new Error(userValue + ' not supported as a type.' +
                  'Please use one of object, string, array, number, boolean or null.');

}

var matchers = {

  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.some(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.some(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    /* istanbul ignore next */
    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.every(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.every(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$eq': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;
  },

  '$gte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;
  },

  '$gt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;
  },

  '$lte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;
  },

  '$lt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;
  },

  '$exists': function (doc, userValue, parsedField, docFieldValue) {
    //a field that is null is still considered to exist
    if (userValue) {
      return fieldIsNotUndefined(docFieldValue);
    }

    return !fieldIsNotUndefined(docFieldValue);
  },

  '$mod': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);
  },

  '$ne': function (doc, userValue, parsedField, docFieldValue) {
    return userValue.every(function (neValue) {
      return collate(docFieldValue, neValue) !== 0;
    });
  },
  '$in': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);
  },

  '$nin': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);
  },

  '$size': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);
  },

  '$all': function (doc, userValue, parsedField, docFieldValue) {
    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);
  },

  '$regex': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);
  },

  '$type': function (doc, userValue, parsedField, docFieldValue) {
    return typeMatch(docFieldValue, userValue);
  }
};

// return true if the given doc matches the supplied selector
function matchesSelector(doc, selector) {
  /* istanbul ignore if */
  if (typeof selector !== 'object') {
    // match the CouchDB error message
    throw new Error('Selector error: expected a JSON object');
  }

  selector = massageSelector(selector);
  var row = {
    'doc': doc
  };

  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));
  return rowsMatched && rowsMatched.length === 1;
}

function evalFilter(input) {
  return scopeEval('"use strict";\\nreturn ' + input + ';', {});
}

function evalView(input) {
  var code = [
    'return function(doc) {',
    '  "use strict";',
    '  var emitted = false;',
    '  var emit = function (a, b) {',
    '    emitted = true;',
    '  };',
    '  var view = ' + input + ';',
    '  view(doc);',
    '  if (emitted) {',
    '    return true;',
    '  }',
    '};'
  ].join('\\n');

  return scopeEval(code, {});
}

function validate(opts, callback) {
  if (opts.selector) {
    if (opts.filter && opts.filter !== '_selector') {
      var filterName = typeof opts.filter === 'string' ?
        opts.filter : 'function';
      return callback(new Error('selector invalid for filter "' + filterName + '"'));
    }
  }
  callback();
}

function normalize(opts) {
  if (opts.view && !opts.filter) {
    opts.filter = '_view';
  }

  if (opts.selector && !opts.filter) {
    opts.filter = '_selector';
  }

  if (opts.filter && typeof opts.filter === 'string') {
    if (opts.filter === '_view') {
      opts.view = normalizeDesignDocFunctionName(opts.view);
    } else {
      opts.filter = normalizeDesignDocFunctionName(opts.filter);
    }
  }
}

function shouldFilter(changesHandler, opts) {
  return opts.filter && typeof opts.filter === 'string' &&
    !opts.doc_ids && !isRemote(changesHandler.db);
}

function filter(changesHandler, opts) {
  var callback = opts.complete;
  if (opts.filter === '_view') {
    if (!opts.view || typeof opts.view !== 'string') {
      var err = createError(BAD_REQUEST,
        '\`view\` filter parameter not found or invalid.');
      return callback(err);
    }
    // fetch a view from a design doc, make it behave like a filter
    var viewName = parseDesignDocFunctionName(opts.view);
    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&
        ddoc.views[viewName[1]].map;
      if (!mapFun) {
        return callback(createError(MISSING_DOC,
          (ddoc.views ? 'missing json key: ' + viewName[1] :
            'missing json key: views')));
      }
      opts.filter = evalView(mapFun);
      changesHandler.doChanges(opts);
    });
  } else if (opts.selector) {
    opts.filter = function (doc) {
      return matchesSelector(doc, opts.selector);
    };
    changesHandler.doChanges(opts);
  } else {
    // fetch a filter from a design doc
    var filterName = parseDesignDocFunctionName(opts.filter);
    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];
      if (!filterFun) {
        return callback(createError(MISSING_DOC,
          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]
            : 'missing json key: filters')));
      }
      opts.filter = evalFilter(filterFun);
      changesHandler.doChanges(opts);
    });
  }
}

function applyChangesFilterPlugin(PouchDB) {
  PouchDB._changesFilterPlugin = {
    validate: validate,
    normalize: normalize,
    shouldFilter: shouldFilter,
    filter: filter
  };
}

// TODO: remove from pouchdb-core (breaking)
PouchDB.plugin(applyChangesFilterPlugin);

PouchDB.version = version;

function toObject(array) {
  return array.reduce(function (obj, item) {
    obj[item] = true;
    return obj;
  }, {});
}
// List of top level reserved words for doc
var reservedWords = toObject([
  '_id',
  '_rev',
  '_attachments',
  '_deleted',
  '_revisions',
  '_revs_info',
  '_conflicts',
  '_deleted_conflicts',
  '_local_seq',
  '_rev_tree',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats',
  // Specific to Couchbase Sync Gateway
  '_removed'
]);

// List of reserved words that should end up the document
var dataWords = toObject([
  '_attachments',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats'
]);

function parseRevisionInfo(rev$$1) {
  if (!/^\\d+-/.test(rev$$1)) {
    return createError(INVALID_REV);
  }
  var idx = rev$$1.indexOf('-');
  var left = rev$$1.substring(0, idx);
  var right = rev$$1.substring(idx + 1);
  return {
    prefix: parseInt(left, 10),
    id: right
  };
}

function makeRevTreeFromRevisions(revisions, opts) {
  var pos = revisions.start - revisions.ids.length + 1;

  var revisionIds = revisions.ids;
  var ids = [revisionIds[0], opts, []];

  for (var i = 1, len = revisionIds.length; i < len; i++) {
    ids = [revisionIds[i], {status: 'missing'}, [ids]];
  }

  return [{
    pos: pos,
    ids: ids
  }];
}

// Preprocess documents, parse their revisions, assign an id and a
// revision for new writes that are missing them, etc
function parseDoc(doc, newEdits, dbOpts) {
  if (!dbOpts) {
    dbOpts = {
      deterministic_revs: true
    };
  }

  var nRevNum;
  var newRevId;
  var revInfo;
  var opts = {status: 'available'};
  if (doc._deleted) {
    opts.deleted = true;
  }

  if (newEdits) {
    if (!doc._id) {
      doc._id = uuid();
    }
    newRevId = rev(doc, dbOpts.deterministic_revs);
    if (doc._rev) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      doc._rev_tree = [{
        pos: revInfo.prefix,
        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]
      }];
      nRevNum = revInfo.prefix + 1;
    } else {
      doc._rev_tree = [{
        pos: 1,
        ids : [newRevId, opts, []]
      }];
      nRevNum = 1;
    }
  } else {
    if (doc._revisions) {
      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
      nRevNum = doc._revisions.start;
      newRevId = doc._revisions.ids[0];
    }
    if (!doc._rev_tree) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      nRevNum = revInfo.prefix;
      newRevId = revInfo.id;
      doc._rev_tree = [{
        pos: nRevNum,
        ids: [newRevId, opts, []]
      }];
    }
  }

  invalidIdError(doc._id);

  doc._rev = nRevNum + '-' + newRevId;

  var result = {metadata : {}, data : {}};
  for (var key in doc) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(doc, key)) {
      var specialKey = key[0] === '_';
      if (specialKey && !reservedWords[key]) {
        var error = createError(DOC_VALIDATION, key);
        error.message = DOC_VALIDATION.message + ': ' + key;
        throw error;
      } else if (specialKey && !dataWords[key]) {
        result.metadata[key.slice(1)] = doc[key];
      } else {
        result.data[key] = doc[key];
      }
    }
  }
  return result;
}

function parseBase64(data) {
  try {
    return thisAtob(data);
  } catch (e) {
    var err = createError(BAD_ARG,
      'Attachment is not a valid base64 string');
    return {error: err};
  }
}

function preprocessString(att, blobType, callback) {
  var asBinary = parseBase64(att.data);
  if (asBinary.error) {
    return callback(asBinary.error);
  }

  att.length = asBinary.length;
  if (blobType === 'blob') {
    att.data = binStringToBluffer(asBinary, att.content_type);
  } else if (blobType === 'base64') {
    att.data = thisBtoa(asBinary);
  } else { // binary
    att.data = asBinary;
  }
  binaryMd5(asBinary, function (result) {
    att.digest = 'md5-' + result;
    callback();
  });
}

function preprocessBlob(att, blobType, callback) {
  binaryMd5(att.data, function (md5) {
    att.digest = 'md5-' + md5;
    // size is for blobs (browser), length is for buffers (node)
    att.length = att.data.size || att.data.length || 0;
    if (blobType === 'binary') {
      blobToBinaryString(att.data, function (binString) {
        att.data = binString;
        callback();
      });
    } else if (blobType === 'base64') {
      blobToBase64(att.data, function (b64) {
        att.data = b64;
        callback();
      });
    } else {
      callback();
    }
  });
}

function preprocessAttachment(att, blobType, callback) {
  if (att.stub) {
    return callback();
  }
  if (typeof att.data === 'string') { // input is a base64 string
    preprocessString(att, blobType, callback);
  } else { // input is a blob
    preprocessBlob(att, blobType, callback);
  }
}

function preprocessAttachments(docInfos, blobType, callback) {

  if (!docInfos.length) {
    return callback();
  }

  var docv = 0;
  var overallErr;

  docInfos.forEach(function (docInfo) {
    var attachments = docInfo.data && docInfo.data._attachments ?
      Object.keys(docInfo.data._attachments) : [];
    var recv = 0;

    if (!attachments.length) {
      return done();
    }

    function processedAttachment(err) {
      overallErr = err;
      recv++;
      if (recv === attachments.length) {
        done();
      }
    }

    for (var key in docInfo.data._attachments) {
      if (docInfo.data._attachments.hasOwnProperty(key)) {
        preprocessAttachment(docInfo.data._attachments[key],
          blobType, processedAttachment);
      }
    }
  });

  function done() {
    docv++;
    if (docInfos.length === docv) {
      if (overallErr) {
        callback(overallErr);
      } else {
        callback();
      }
    }
  }
}

function updateDoc(revLimit, prev, docInfo, results,
                   i, cb, writeDoc, newEdits) {

  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {
    results[i] = docInfo;
    return cb();
  }

  // sometimes this is pre-calculated. historically not always
  var previousWinningRev = prev.winningRev || winningRev(prev);
  var previouslyDeleted = 'deleted' in prev ? prev.deleted :
    isDeleted(prev, previousWinningRev);
  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :
    isDeleted(docInfo.metadata);
  var isRoot = /^1-/.test(docInfo.metadata.rev);

  if (previouslyDeleted && !deleted && newEdits && isRoot) {
    var newDoc = docInfo.data;
    newDoc._rev = previousWinningRev;
    newDoc._id = docInfo.metadata.id;
    docInfo = parseDoc(newDoc, newEdits);
  }

  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);

  var inConflict = newEdits && ((
    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||
    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||
    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));

  if (inConflict) {
    var err = createError(REV_CONFLICT);
    results[i] = err;
    return cb();
  }

  var newRev = docInfo.metadata.rev;
  docInfo.metadata.rev_tree = merged.tree;
  docInfo.stemmedRevs = merged.stemmedRevs || [];
  /* istanbul ignore else */
  if (prev.rev_map) {
    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
  }

  // recalculate
  var winningRev$$1 = winningRev(docInfo.metadata);
  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);

  // calculate the total number of documents that were added/removed,
  // from the perspective of total_rows/doc_count
  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :
    previouslyDeleted < winningRevIsDeleted ? -1 : 1;

  var newRevIsDeleted;
  if (newRev === winningRev$$1) {
    // if the new rev is the same as the winning rev, we can reuse that value
    newRevIsDeleted = winningRevIsDeleted;
  } else {
    // if they're not the same, then we need to recalculate
    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);
  }

  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
    true, delta, i, cb);
}

function rootIsMissing(docInfo) {
  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
}

function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,
                     writeDoc, opts, overallCallback) {

  // Default to 1000 locally
  revLimit = revLimit || 1000;

  function insertDoc(docInfo, resultsIdx, callback) {
    // Cant insert new deleted documents
    var winningRev$$1 = winningRev(docInfo.metadata);
    var deleted = isDeleted(docInfo.metadata, winningRev$$1);
    if ('was_delete' in opts && deleted) {
      results[resultsIdx] = createError(MISSING_DOC, 'deleted');
      return callback();
    }

    // 4712 - detect whether a new document was inserted with a _rev
    var inConflict = newEdits && rootIsMissing(docInfo);

    if (inConflict) {
      var err = createError(REV_CONFLICT);
      results[resultsIdx] = err;
      return callback();
    }

    var delta = deleted ? 0 : 1;

    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,
      delta, resultsIdx, callback);
  }

  var newEdits = opts.new_edits;
  var idsToDocs = new ExportedMap();

  var docsDone = 0;
  var docsToDo = docInfos.length;

  function checkAllDocsDone() {
    if (++docsDone === docsToDo && overallCallback) {
      overallCallback();
    }
  }

  docInfos.forEach(function (currentDoc, resultsIdx) {

    if (currentDoc._id && isLocalId(currentDoc._id)) {
      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
      api[fun](currentDoc, {ctx: tx}, function (err, res) {
        results[resultsIdx] = err || res;
        checkAllDocsDone();
      });
      return;
    }

    var id = currentDoc.metadata.id;
    if (idsToDocs.has(id)) {
      docsToDo--; // duplicate
      idsToDocs.get(id).push([currentDoc, resultsIdx]);
    } else {
      idsToDocs.set(id, [[currentDoc, resultsIdx]]);
    }
  });

  // in the case of new_edits, the user can provide multiple docs
  // with the same id. these need to be processed sequentially
  idsToDocs.forEach(function (docs, id) {
    var numDone = 0;

    function docWritten() {
      if (++numDone < docs.length) {
        nextDoc();
      } else {
        checkAllDocsDone();
      }
    }
    function nextDoc() {
      var value = docs[numDone];
      var currentDoc = value[0];
      var resultsIdx = value[1];

      if (fetchedDocs.has(id)) {
        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,
          resultsIdx, docWritten, writeDoc, newEdits);
      } else {
        // Ensure stemming applies to new writes as well
        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);
        currentDoc.metadata.rev_tree = merged.tree;
        currentDoc.stemmedRevs = merged.stemmedRevs || [];
        insertDoc(currentDoc, resultsIdx, docWritten);
      }
    }
    nextDoc();
  });
}

// IndexedDB requires a versioned database structure, so we use the
// version here to manage migrations.
var ADAPTER_VERSION = 5;

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
// Keyed by document id
var DOC_STORE = 'document-store';
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
var BY_SEQ_STORE = 'by-sequence';
// Where we store attachments
var ATTACH_STORE = 'attach-store';
// Where we store many-to-many relations
// between attachment digests and seqs
var ATTACH_AND_SEQ_STORE = 'attach-seq-store';

// Where we store database-wide meta data in a single record
// keyed by id: META_STORE
var META_STORE = 'meta-store';
// Where we store local documents
var LOCAL_STORE = 'local-store';
// Where we detect blob support
var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

function safeJsonParse(str) {
  // This try/catch guards against stack overflow errors.
  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela
  // cannot overflow.
  try {
    return JSON.parse(str);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela__WEBPACK_IMPORTED_MODULE_3___default.a.parse(str);
  }
}

function safeJsonStringify(json) {
  try {
    return JSON.stringify(json);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela__WEBPACK_IMPORTED_MODULE_3___default.a.stringify(json);
  }
}

function idbError(callback) {
  return function (evt) {
    var message = 'unknown_error';
    if (evt.target && evt.target.error) {
      message = evt.target.error.name || evt.target.error.message;
    }
    callback(createError(IDB_ERROR, message, evt.type));
  };
}

// Unfortunately, the metadata has to be stringified
// when it is put into the database, because otherwise
// IndexedDB can throw errors for deeply-nested objects.
// Originally we just used JSON.parse/JSON.stringify; now
// we use this custom vuvuzela library that avoids recursion.
// If we could do it all over again, we'd probably use a
// format for the revision trees other than JSON.
function encodeMetadata(metadata, winningRev, deleted) {
  return {
    data: safeJsonStringify(metadata),
    winningRev: winningRev,
    deletedOrLocal: deleted ? '1' : '0',
    seq: metadata.seq, // highest seq for this doc
    id: metadata.id
  };
}

function decodeMetadata(storedObject) {
  if (!storedObject) {
    return null;
  }
  var metadata = safeJsonParse(storedObject.data);
  metadata.winningRev = storedObject.winningRev;
  metadata.deleted = storedObject.deletedOrLocal === '1';
  metadata.seq = storedObject.seq;
  return metadata;
}

// read the doc back out from the database. we don't store the
// _id or _rev because we already have _doc_id_rev.
function decodeDoc(doc) {
  if (!doc) {
    return doc;
  }
  var idx = doc._doc_id_rev.lastIndexOf(':');
  doc._id = doc._doc_id_rev.substring(0, idx - 1);
  doc._rev = doc._doc_id_rev.substring(idx + 1);
  delete doc._doc_id_rev;
  return doc;
}

// Read a blob from the database, encoding as necessary
// and translating from base64 if the IDB doesn't support
// native Blobs
function readBlobData(body, type, asBlob, callback) {
  if (asBlob) {
    if (!body) {
      callback(createBlob([''], {type: type}));
    } else if (typeof body !== 'string') { // we have blob support
      callback(body);
    } else { // no blob support
      callback(b64ToBluffer(body, type));
    }
  } else { // as base64 string
    if (!body) {
      callback('');
    } else if (typeof body !== 'string') { // we have blob support
      readAsBinaryString(body, function (binary) {
        callback(thisBtoa(binary));
      });
    } else { // no blob support
      callback(body);
    }
  }
}

function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
  var attachments = Object.keys(doc._attachments || {});
  if (!attachments.length) {
    return cb && cb();
  }
  var numDone = 0;

  function checkDone() {
    if (++numDone === attachments.length && cb) {
      cb();
    }
  }

  function fetchAttachment(doc, att) {
    var attObj = doc._attachments[att];
    var digest = attObj.digest;
    var req = txn.objectStore(ATTACH_STORE).get(digest);
    req.onsuccess = function (e) {
      attObj.body = e.target.result.body;
      checkDone();
    };
  }

  attachments.forEach(function (att) {
    if (opts.attachments && opts.include_docs) {
      fetchAttachment(doc, att);
    } else {
      doc._attachments[att].stub = true;
      checkDone();
    }
  });
}

// IDB-specific postprocessing necessary because
// we don't know whether we stored a true Blob or
// a base64-encoded string, and if it's a Blob it
// needs to be read outside of the transaction context
function postProcessAttachments(results, asBlob) {
  return Promise.all(results.map(function (row) {
    if (row.doc && row.doc._attachments) {
      var attNames = Object.keys(row.doc._attachments);
      return Promise.all(attNames.map(function (att) {
        var attObj = row.doc._attachments[att];
        if (!('body' in attObj)) { // already processed
          return;
        }
        var body = attObj.body;
        var type = attObj.content_type;
        return new Promise(function (resolve) {
          readBlobData(body, type, asBlob, function (data) {
            row.doc._attachments[att] = $inject_Object_assign(
              pick(attObj, ['digest', 'content_type']),
              {data: data}
            );
            resolve();
          });
        });
      }));
    }
  }));
}

function compactRevs(revs, docId, txn) {

  var possiblyOrphanedDigests = [];
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var attStore = txn.objectStore(ATTACH_STORE);
  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
  var count = revs.length;

  function checkDone() {
    count--;
    if (!count) { // done processing all revs
      deleteOrphanedAttachments();
    }
  }

  function deleteOrphanedAttachments() {
    if (!possiblyOrphanedDigests.length) {
      return;
    }
    possiblyOrphanedDigests.forEach(function (digest) {
      var countReq = attAndSeqStore.index('digestSeq').count(
        IDBKeyRange.bound(
          digest + '::', digest + '::\\uffff', false, false));
      countReq.onsuccess = function (e) {
        var count = e.target.result;
        if (!count) {
          // orphaned
          attStore.delete(digest);
        }
      };
    });
  }

  revs.forEach(function (rev$$1) {
    var index = seqStore.index('_doc_id_rev');
    var key = docId + "::" + rev$$1;
    index.getKey(key).onsuccess = function (e) {
      var seq = e.target.result;
      if (typeof seq !== 'number') {
        return checkDone();
      }
      seqStore.delete(seq);

      var cursor = attAndSeqStore.index('seq')
        .openCursor(IDBKeyRange.only(seq));

      cursor.onsuccess = function (event) {
        var cursor = event.target.result;
        if (cursor) {
          var digest = cursor.value.digestSeq.split('::')[0];
          possiblyOrphanedDigests.push(digest);
          attAndSeqStore.delete(cursor.primaryKey);
          cursor.continue();
        } else { // done
          checkDone();
        }
      };
    };
  });
}

function openTransactionSafely(idb, stores, mode) {
  try {
    return {
      txn: idb.transaction(stores, mode)
    };
  } catch (err) {
    return {
      error: err
    };
  }
}

var changesHandler = new Changes();

function idbBulkDocs(dbOpts, req, opts, api, idb, callback) {
  var docInfos = req.docs;
  var txn;
  var docStore;
  var bySeqStore;
  var attachStore;
  var attachAndSeqStore;
  var metaStore;
  var docInfoError;
  var metaDoc;

  for (var i = 0, len = docInfos.length; i < len; i++) {
    var doc = docInfos[i];
    if (doc._id && isLocalId(doc._id)) {
      continue;
    }
    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);
    if (doc.error && !docInfoError) {
      docInfoError = doc;
    }
  }

  if (docInfoError) {
    return callback(docInfoError);
  }

  var allDocsProcessed = false;
  var docCountDelta = 0;
  var results = new Array(docInfos.length);
  var fetchedDocs = new ExportedMap();
  var preconditionErrored = false;
  var blobType = api._meta.blobSupport ? 'blob' : 'base64';

  preprocessAttachments(docInfos, blobType, function (err) {
    if (err) {
      return callback(err);
    }
    startTransaction();
  });

  function startTransaction() {

    var stores = [
      DOC_STORE, BY_SEQ_STORE,
      ATTACH_STORE,
      LOCAL_STORE, ATTACH_AND_SEQ_STORE,
      META_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    txn = txnResult.txn;
    txn.onabort = idbError(callback);
    txn.ontimeout = idbError(callback);
    txn.oncomplete = complete;
    docStore = txn.objectStore(DOC_STORE);
    bySeqStore = txn.objectStore(BY_SEQ_STORE);
    attachStore = txn.objectStore(ATTACH_STORE);
    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
    metaStore = txn.objectStore(META_STORE);

    metaStore.get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result;
      updateDocCountIfReady();
    };

    verifyAttachments(function (err) {
      if (err) {
        preconditionErrored = true;
        return callback(err);
      }
      fetchExistingDocs();
    });
  }

  function onAllDocsProcessed() {
    allDocsProcessed = true;
    updateDocCountIfReady();
  }

  function idbProcessDocs() {
    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,
                txn, results, writeDoc, opts, onAllDocsProcessed);
  }

  function updateDocCountIfReady() {
    if (!metaDoc || !allDocsProcessed) {
      return;
    }
    // caching the docCount saves a lot of time in allDocs() and
    // info(), which is why we go to all the trouble of doing this
    metaDoc.docCount += docCountDelta;
    metaStore.put(metaDoc);
  }

  function fetchExistingDocs() {

    if (!docInfos.length) {
      return;
    }

    var numFetched = 0;

    function checkDone() {
      if (++numFetched === docInfos.length) {
        idbProcessDocs();
      }
    }

    function readMetadata(event) {
      var metadata = decodeMetadata(event.target.result);

      if (metadata) {
        fetchedDocs.set(metadata.id, metadata);
      }
      checkDone();
    }

    for (var i = 0, len = docInfos.length; i < len; i++) {
      var docInfo = docInfos[i];
      if (docInfo._id && isLocalId(docInfo._id)) {
        checkDone(); // skip local docs
        continue;
      }
      var req = docStore.get(docInfo.metadata.id);
      req.onsuccess = readMetadata;
    }
  }

  function complete() {
    if (preconditionErrored) {
      return;
    }

    changesHandler.notify(api._meta.name);
    callback(null, results);
  }

  function verifyAttachment(digest, callback) {

    var req = attachStore.get(digest);
    req.onsuccess = function (e) {
      if (!e.target.result) {
        var err = createError(MISSING_STUB,
          'unknown stub attachment with digest ' +
          digest);
        err.status = 412;
        callback(err);
      } else {
        callback();
      }
    };
  }

  function verifyAttachments(finish) {


    var digests = [];
    docInfos.forEach(function (docInfo) {
      if (docInfo.data && docInfo.data._attachments) {
        Object.keys(docInfo.data._attachments).forEach(function (filename) {
          var att = docInfo.data._attachments[filename];
          if (att.stub) {
            digests.push(att.digest);
          }
        });
      }
    });
    if (!digests.length) {
      return finish();
    }
    var numDone = 0;
    var err;

    function checkDone() {
      if (++numDone === digests.length) {
        finish(err);
      }
    }
    digests.forEach(function (digest) {
      verifyAttachment(digest, function (attErr) {
        if (attErr && !err) {
          err = attErr;
        }
        checkDone();
      });
    });
  }

  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
                    isUpdate, delta, resultsIdx, callback) {

    docInfo.metadata.winningRev = winningRev$$1;
    docInfo.metadata.deleted = winningRevIsDeleted;

    var doc = docInfo.data;
    doc._id = docInfo.metadata.id;
    doc._rev = docInfo.metadata.rev;

    if (newRevIsDeleted) {
      doc._deleted = true;
    }

    var hasAttachments = doc._attachments &&
      Object.keys(doc._attachments).length;
    if (hasAttachments) {
      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
        isUpdate, resultsIdx, callback);
    }

    docCountDelta += delta;
    updateDocCountIfReady();

    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
      isUpdate, resultsIdx, callback);
  }

  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
                     isUpdate, resultsIdx, callback) {

    var doc = docInfo.data;
    var metadata = docInfo.metadata;

    doc._doc_id_rev = metadata.id + '::' + metadata.rev;
    delete doc._id;
    delete doc._rev;

    function afterPutDoc(e) {
      var revsToDelete = docInfo.stemmedRevs || [];

      if (isUpdate && api.auto_compaction) {
        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));
      }

      if (revsToDelete && revsToDelete.length) {
        compactRevs(revsToDelete, docInfo.metadata.id, txn);
      }

      metadata.seq = e.target.result;
      // Current _rev is calculated from _rev_tree on read
      // delete metadata.rev;
      var metadataToStore = encodeMetadata(metadata, winningRev$$1,
        winningRevIsDeleted);
      var metaDataReq = docStore.put(metadataToStore);
      metaDataReq.onsuccess = afterPutMetadata;
    }

    function afterPutDocError(e) {
      // ConstraintError, need to update, not put (see #1638 for details)
      e.preventDefault(); // avoid transaction abort
      e.stopPropagation(); // avoid transaction onerror
      var index = bySeqStore.index('_doc_id_rev');
      var getKeyReq = index.getKey(doc._doc_id_rev);
      getKeyReq.onsuccess = function (e) {
        var putReq = bySeqStore.put(doc, e.target.result);
        putReq.onsuccess = afterPutDoc;
      };
    }

    function afterPutMetadata() {
      results[resultsIdx] = {
        ok: true,
        id: metadata.id,
        rev: metadata.rev
      };
      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
      insertAttachmentMappings(docInfo, metadata.seq, callback);
    }

    var putReq = bySeqStore.put(doc);

    putReq.onsuccess = afterPutDoc;
    putReq.onerror = afterPutDocError;
  }

  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
                            isUpdate, resultsIdx, callback) {


    var doc = docInfo.data;

    var numDone = 0;
    var attachments = Object.keys(doc._attachments);

    function collectResults() {
      if (numDone === attachments.length) {
        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
          isUpdate, resultsIdx, callback);
      }
    }

    function attachmentSaved() {
      numDone++;
      collectResults();
    }

    attachments.forEach(function (key) {
      var att = docInfo.data._attachments[key];
      if (!att.stub) {
        var data = att.data;
        delete att.data;
        att.revpos = parseInt(winningRev$$1, 10);
        var digest = att.digest;
        saveAttachment(digest, data, attachmentSaved);
      } else {
        numDone++;
        collectResults();
      }
    });
  }

  // map seqs to attachment digests, which
  // we will need later during compaction
  function insertAttachmentMappings(docInfo, seq, callback) {

    var attsAdded = 0;
    var attsToAdd = Object.keys(docInfo.data._attachments || {});

    if (!attsToAdd.length) {
      return callback();
    }

    function checkDone() {
      if (++attsAdded === attsToAdd.length) {
        callback();
      }
    }

    function add(att) {
      var digest = docInfo.data._attachments[att].digest;
      var req = attachAndSeqStore.put({
        seq: seq,
        digestSeq: digest + '::' + seq
      });

      req.onsuccess = checkDone;
      req.onerror = function (e) {
        // this callback is for a constaint error, which we ignore
        // because this docid/rev has already been associated with
        // the digest (e.g. when new_edits == false)
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
        checkDone();
      };
    }
    for (var i = 0; i < attsToAdd.length; i++) {
      add(attsToAdd[i]); // do in parallel
    }
  }

  function saveAttachment(digest, data, callback) {


    var getKeyReq = attachStore.count(digest);
    getKeyReq.onsuccess = function (e) {
      var count = e.target.result;
      if (count) {
        return callback(); // already exists
      }
      var newAtt = {
        digest: digest,
        body: data
      };
      var putReq = attachStore.put(newAtt);
      putReq.onsuccess = callback;
    };
  }
}

// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations
// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or
// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because
// we're not processing each document one-at-a-time.
function runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {

  if (batchSize === -1) {
    batchSize = 1000;
  }

  // Bail out of getAll()/getAllKeys() in the following cases:
  // 1) either method is unsupported - we need both
  // 2) batchSize is 1 (might as well use IDBCursor)
  // 3) descending – no real way to do this via getAll()/getAllKeys()

  var useGetAll = typeof objectStore.getAll === 'function' &&
    typeof objectStore.getAllKeys === 'function' &&
    batchSize > 1 && !descending;

  var keysBatch;
  var valuesBatch;
  var pseudoCursor;

  function onGetAll(e) {
    valuesBatch = e.target.result;
    if (keysBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function onGetAllKeys(e) {
    keysBatch = e.target.result;
    if (valuesBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function continuePseudoCursor() {
    if (!keysBatch.length) { // no more results
      return onBatch();
    }
    // fetch next batch, exclusive start
    var lastKey = keysBatch[keysBatch.length - 1];
    var newKeyRange;
    if (keyRange && keyRange.upper) {
      try {
        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,
          true, keyRange.upperOpen);
      } catch (e) {
        if (e.name === "DataError" && e.code === 0) {
          return onBatch(); // we're done, startkey and endkey are equal
        }
      }
    } else {
      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
    }
    keyRange = newKeyRange;
    keysBatch = null;
    valuesBatch = null;
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  }

  function onCursor(e) {
    var cursor = e.target.result;
    if (!cursor) { // done
      return onBatch();
    }
    // regular IDBCursor acts like a batch where batch size is always 1
    onBatch([cursor.key], [cursor.value], cursor);
  }

  if (useGetAll) {
    pseudoCursor = {"continue": continuePseudoCursor};
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  } else if (descending) {
    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
  } else {
    objectStore.openCursor(keyRange).onsuccess = onCursor;
  }
}

// simple shim for objectStore.getAll(), falling back to IDBCursor
function getAll(objectStore, keyRange, onSuccess) {
  if (typeof objectStore.getAll === 'function') {
    // use native getAll
    objectStore.getAll(keyRange).onsuccess = onSuccess;
    return;
  }
  // fall back to cursors
  var values = [];

  function onCursor(e) {
    var cursor = e.target.result;
    if (cursor) {
      values.push(cursor.value);
      cursor.continue();
    } else {
      onSuccess({
        target: {
          result: values
        }
      });
    }
  }

  objectStore.openCursor(keyRange).onsuccess = onCursor;
}

function allDocsKeys(keys, docStore, onBatch) {
  // It's not guaranted to be returned in right order  
  var valuesBatch = new Array(keys.length);
  var count = 0;
  keys.forEach(function (key, index) {
    docStore.get(key).onsuccess = function (event) {
      if (event.target.result) {
        valuesBatch[index] = event.target.result;
      } else {
        valuesBatch[index] = {key: key, error: 'not_found'};
      }
      count++;
      if (count === keys.length) {
        onBatch(keys, valuesBatch, {});
      }
    };
  });
}

function createKeyRange(start, end, inclusiveEnd, key, descending) {
  try {
    if (start && end) {
      if (descending) {
        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
      } else {
        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
      }
    } else if (start) {
      if (descending) {
        return IDBKeyRange.upperBound(start);
      } else {
        return IDBKeyRange.lowerBound(start);
      }
    } else if (end) {
      if (descending) {
        return IDBKeyRange.lowerBound(end, !inclusiveEnd);
      } else {
        return IDBKeyRange.upperBound(end, !inclusiveEnd);
      }
    } else if (key) {
      return IDBKeyRange.only(key);
    }
  } catch (e) {
    return {error: e};
  }
  return null;
}

function idbAllDocs(opts, idb, callback) {
  var start = 'startkey' in opts ? opts.startkey : false;
  var end = 'endkey' in opts ? opts.endkey : false;
  var key = 'key' in opts ? opts.key : false;
  var keys = 'keys' in opts ? opts.keys : false; 
  var skip = opts.skip || 0;
  var limit = typeof opts.limit === 'number' ? opts.limit : -1;
  var inclusiveEnd = opts.inclusive_end !== false;

  var keyRange ; 
  var keyRangeError;
  if (!keys) {
    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);
    keyRangeError = keyRange && keyRange.error;
    if (keyRangeError && 
      !(keyRangeError.name === "DataError" && keyRangeError.code === 0)) {
      // DataError with error code 0 indicates start is less than end, so
      // can just do an empty query. Else need to throw
      return callback(createError(IDB_ERROR,
        keyRangeError.name, keyRangeError.message));
    }
  }

  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];

  if (opts.attachments) {
    stores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, stores, 'readonly');
  if (txnResult.error) {
    return callback(txnResult.error);
  }
  var txn = txnResult.txn;
  txn.oncomplete = onTxnComplete;
  txn.onabort = idbError(callback);
  var docStore = txn.objectStore(DOC_STORE);
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var metaStore = txn.objectStore(META_STORE);
  var docIdRevIndex = seqStore.index('_doc_id_rev');
  var results = [];
  var docCount;
  var updateSeq;

  metaStore.get(META_STORE).onsuccess = function (e) {
    docCount = e.target.result.docCount;
  };

  /* istanbul ignore if */
  if (opts.update_seq) {
    getMaxUpdateSeq(seqStore, function (e) { 
      if (e.target.result && e.target.result.length > 0) {
        updateSeq = e.target.result[0];
      }
    });
  }

  function getMaxUpdateSeq(objectStore, onSuccess) {
    function onCursor(e) {
      var cursor = e.target.result;
      var maxKey = undefined;
      if (cursor && cursor.key) {
        maxKey = cursor.key;
      } 
      return onSuccess({
        target: {
          result: [maxKey]
        }
      });
    }
    objectStore.openCursor(null, 'prev').onsuccess = onCursor;
  }

  // if the user specifies include_docs=true, then we don't
  // want to block the main cursor while we're fetching the doc
  function fetchDocAsynchronously(metadata, row, winningRev$$1) {
    var key = metadata.id + "::" + winningRev$$1;
    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {
      row.doc = decodeDoc(e.target.result) || {};
      if (opts.conflicts) {
        var conflicts = collectConflicts(metadata);
        if (conflicts.length) {
          row.doc._conflicts = conflicts;
        }
      }
      fetchAttachmentsIfNecessary(row.doc, opts, txn);
    };
  }

  function allDocsInner(winningRev$$1, metadata) {
    var row = {
      id: metadata.id,
      key: metadata.id,
      value: {
        rev: winningRev$$1
      }
    };
    var deleted = metadata.deleted;
    if (deleted) {
      if (keys) {
        results.push(row);
        // deleted docs are okay with "keys" requests
        row.value.deleted = true;
        row.doc = null;
      }
    } else if (skip-- <= 0) {
      results.push(row);
      if (opts.include_docs) {
        fetchDocAsynchronously(metadata, row, winningRev$$1);
      }
    }
  }

  function processBatch(batchValues) {
    for (var i = 0, len = batchValues.length; i < len; i++) {
      if (results.length === limit) {
        break;
      }
      var batchValue = batchValues[i];
      if (batchValue.error && keys) {
        // key was not found with "keys" requests
        results.push(batchValue);
        continue;
      }
      var metadata = decodeMetadata(batchValue);
      var winningRev$$1 = metadata.winningRev;
      allDocsInner(winningRev$$1, metadata);
    }
  }

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor) {
      return;
    }
    processBatch(batchValues);
    if (results.length < limit) {
      cursor.continue();
    }
  }

  function onGetAll(e) {
    var values = e.target.result;
    if (opts.descending) {
      values = values.reverse();
    }
    processBatch(values);
  }

  function onResultsReady() {
    var returnVal = {
      total_rows: docCount,
      offset: opts.skip,
      rows: results
    };
    
    /* istanbul ignore if */
    if (opts.update_seq && updateSeq !== undefined) {
      returnVal.update_seq = updateSeq;
    }
    callback(null, returnVal);
  }

  function onTxnComplete() {
    if (opts.attachments) {
      postProcessAttachments(results, opts.binary).then(onResultsReady);
    } else {
      onResultsReady();
    }
  }

  // don't bother doing any requests if start > end or limit === 0
  if (keyRangeError || limit === 0) {
    return;
  }
  if (keys) {
    return allDocsKeys(opts.keys, docStore, onBatch);
  }
  if (limit === -1) { // just fetch everything
    return getAll(docStore, keyRange, onGetAll);
  }
  // else do a cursor
  // choose a batch size based on the skip, since we'll need to skip that many
  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
function checkBlobSupport(txn) {
  return new Promise(function (resolve) {
    var blob$$1 = createBlob(['']);
    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');

    req.onsuccess = function () {
      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);
      var matchedEdge = navigator.userAgent.match(/Edge\\//);
      // MS Edge pretends to be Chrome 42:
      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
      resolve(matchedEdge || !matchedChrome ||
        parseInt(matchedChrome[1], 10) >= 43);
    };

    req.onerror = txn.onabort = function (e) {
      // If the transaction aborts now its due to not being able to
      // write to the database, likely due to the disk being full
      e.preventDefault();
      e.stopPropagation();
      resolve(false);
    };
  }).catch(function () {
    return false; // error, so assume unsupported
  });
}

function countDocs(txn, cb) {
  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
    cb(e.target.result);
  };
}

// This task queue ensures that IDB open calls are done in their own tick

var running = false;
var queue = [];

function tryCode(fun, err, res, PouchDB) {
  try {
    fun(err, res);
  } catch (err) {
    // Shouldn't happen, but in some odd cases
    // IndexedDB implementations might throw a sync
    // error, in which case this will at least log it.
    PouchDB.emit('error', err);
  }
}

function applyNext() {
  if (running || !queue.length) {
    return;
  }
  running = true;
  queue.shift()();
}

function enqueueTask(action, callback, PouchDB) {
  queue.push(function runAction() {
    action(function runCallback(err, res) {
      tryCode(callback, err, res, PouchDB);
      running = false;
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function runNext() {
        applyNext(PouchDB);
      });
    });
  });
  applyNext();
}

function changes(opts, api, dbName, idb) {
  opts = clone(opts);

  if (opts.continuous) {
    var id = dbName + ':' + uuid();
    changesHandler.addListener(dbName, id, api, opts);
    changesHandler.notify(dbName);
    return {
      cancel: function () {
        changesHandler.removeListener(dbName, id);
      }
    };
  }

  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);

  opts.since = opts.since || 0;
  var lastSeq = opts.since;

  var limit = 'limit' in opts ? opts.limit : -1;
  if (limit === 0) {
    limit = 1; // per CouchDB _changes spec
  }

  var results = [];
  var numResults = 0;
  var filter = filterChange(opts);
  var docIdsToMetadata = new ExportedMap();

  var txn;
  var bySeqStore;
  var docStore;
  var docIdRevIndex;

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor || !batchKeys.length) { // done
      return;
    }

    var winningDocs = new Array(batchKeys.length);
    var metadatas = new Array(batchKeys.length);

    function processMetadataAndWinningDoc(metadata, winningDoc) {
      var change = opts.processChange(winningDoc, metadata, opts);
      lastSeq = change.seq = metadata.seq;

      var filtered = filter(change);
      if (typeof filtered === 'object') { // anything but true/false indicates error
        return Promise.reject(filtered);
      }

      if (!filtered) {
        return Promise.resolve();
      }
      numResults++;
      if (opts.return_docs) {
        results.push(change);
      }
      // process the attachment immediately
      // for the benefit of live listeners
      if (opts.attachments && opts.include_docs) {
        return new Promise(function (resolve) {
          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
            postProcessAttachments([change], opts.binary).then(function () {
              resolve(change);
            });
          });
        });
      } else {
        return Promise.resolve(change);
      }
    }

    function onBatchDone() {
      var promises = [];
      for (var i = 0, len = winningDocs.length; i < len; i++) {
        if (numResults === limit) {
          break;
        }
        var winningDoc = winningDocs[i];
        if (!winningDoc) {
          continue;
        }
        var metadata = metadatas[i];
        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));
      }

      Promise.all(promises).then(function (changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          if (changes[i]) {
            opts.onChange(changes[i]);
          }
        }
      }).catch(opts.complete);

      if (numResults !== limit) {
        cursor.continue();
      }
    }

    // Fetch all metadatas/winningdocs from this batch in parallel, then process
    // them all only once all data has been collected. This is done in parallel
    // because it's faster than doing it one-at-a-time.
    var numDone = 0;
    batchValues.forEach(function (value, i) {
      var doc = decodeDoc(value);
      var seq = batchKeys[i];
      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {
        metadatas[i] = metadata;
        winningDocs[i] = winningDoc;
        if (++numDone === batchKeys.length) {
          onBatchDone();
        }
      });
    });
  }

  function onGetMetadata(doc, seq, metadata, cb) {
    if (metadata.seq !== seq) {
      // some other seq is later
      return cb();
    }

    if (metadata.winningRev === doc._rev) {
      // this is the winning doc
      return cb(metadata, doc);
    }

    // fetch winning doc in separate request
    var docIdRev = doc._id + '::' + metadata.winningRev;
    var req = docIdRevIndex.get(docIdRev);
    req.onsuccess = function (e) {
      cb(metadata, decodeDoc(e.target.result));
    };
  }

  function fetchWinningDocAndMetadata(doc, seq, cb) {
    if (docIds && !docIds.has(doc._id)) {
      return cb();
    }

    var metadata = docIdsToMetadata.get(doc._id);
    if (metadata) { // cached
      return onGetMetadata(doc, seq, metadata, cb);
    }
    // metadata not cached, have to go fetch it
    docStore.get(doc._id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      docIdsToMetadata.set(doc._id, metadata);
      onGetMetadata(doc, seq, metadata, cb);
    };
  }

  function finish() {
    opts.complete(null, {
      results: results,
      last_seq: lastSeq
    });
  }

  function onTxnComplete() {
    if (!opts.continuous && opts.attachments) {
      // cannot guarantee that postProcessing was already done,
      // so do it again
      postProcessAttachments(results).then(finish);
    } else {
      finish();
    }
  }

  var objectStores = [DOC_STORE, BY_SEQ_STORE];
  if (opts.attachments) {
    objectStores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');
  if (txnResult.error) {
    return opts.complete(txnResult.error);
  }
  txn = txnResult.txn;
  txn.onabort = idbError(opts.complete);
  txn.oncomplete = onTxnComplete;

  bySeqStore = txn.objectStore(BY_SEQ_STORE);
  docStore = txn.objectStore(DOC_STORE);
  docIdRevIndex = bySeqStore.index('_doc_id_rev');

  var keyRange = (opts.since && !opts.descending) ?
    IDBKeyRange.lowerBound(opts.since, true) : null;

  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);
}

var cachedDBs = new ExportedMap();
var blobSupportPromise;
var openReqList = new ExportedMap();

function IdbPouch(opts, callback) {
  var api = this;

  enqueueTask(function (thisCallback) {
    init(api, opts, thisCallback);
  }, callback, api.constructor);
}

function init(api, opts, callback) {

  var dbName = opts.name;

  var idb = null;
  api._meta = null;

  // called when creating a fresh new database
  function createSchema(db) {
    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});
    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});
    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);

    // added in v2
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    // added in v3
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});

    // added in v4
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 2
  // unfortunately "deletedOrLocal" is a misnomer now that we no longer
  // store local docs in the main doc-store, but whaddyagonnado
  function addDeletedOrLocalIndex(txn, callback) {
    var docStore = txn.objectStore(DOC_STORE);
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    docStore.openCursor().onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var deleted = isDeleted(metadata);
        metadata.deletedOrLocal = deleted ? "1" : "0";
        docStore.put(metadata);
        cursor.continue();
      } else {
        callback();
      }
    };
  }

  // migration to version 3 (part 1)
  function createLocalStoreSchema(db) {
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
  }

  // migration to version 3 (part 2)
  function migrateLocalStore(txn, cb) {
    var localStore = txn.objectStore(LOCAL_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var seqStore = txn.objectStore(BY_SEQ_STORE);

    var cursor = docStore.openCursor();
    cursor.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var docId = metadata.id;
        var local = isLocalId(docId);
        var rev$$1 = winningRev(metadata);
        if (local) {
          var docIdRev = docId + "::" + rev$$1;
          // remove all seq entries
          // associated with this docId
          var start = docId + "::";
          var end = docId + "::~";
          var index = seqStore.index('_doc_id_rev');
          var range = IDBKeyRange.bound(start, end, false, false);
          var seqCursor = index.openCursor(range);
          seqCursor.onsuccess = function (e) {
            seqCursor = e.target.result;
            if (!seqCursor) {
              // done
              docStore.delete(cursor.primaryKey);
              cursor.continue();
            } else {
              var data = seqCursor.value;
              if (data._doc_id_rev === docIdRev) {
                localStore.put(data);
              }
              seqStore.delete(seqCursor.primaryKey);
              seqCursor.continue();
            }
          };
        } else {
          cursor.continue();
        }
      } else if (cb) {
        cb();
      }
    };
  }

  // migration to version 4 (part 1)
  function addAttachAndSeqStore(db) {
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 4 (part 2)
  function migrateAttsAndSeqs(txn, callback) {
    var seqStore = txn.objectStore(BY_SEQ_STORE);
    var attStore = txn.objectStore(ATTACH_STORE);
    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

    // need to actually populate the table. this is the expensive part,
    // so as an optimization, check first that this database even
    // contains attachments
    var req = attStore.count();
    req.onsuccess = function (e) {
      var count = e.target.result;
      if (!count) {
        return callback(); // done
      }

      seqStore.openCursor().onsuccess = function (e) {
        var cursor = e.target.result;
        if (!cursor) {
          return callback(); // done
        }
        var doc = cursor.value;
        var seq = cursor.primaryKey;
        var atts = Object.keys(doc._attachments || {});
        var digestMap = {};
        for (var j = 0; j < atts.length; j++) {
          var att = doc._attachments[atts[j]];
          digestMap[att.digest] = true; // uniq digests, just in case
        }
        var digests = Object.keys(digestMap);
        for (j = 0; j < digests.length; j++) {
          var digest = digests[j];
          attAndSeqStore.put({
            seq: seq,
            digestSeq: digest + '::' + seq
          });
        }
        cursor.continue();
      };
    };
  }

  // migration to version 5
  // Instead of relying on on-the-fly migration of metadata,
  // this brings the doc-store to its modern form:
  // - metadata.winningrev
  // - metadata.seq
  // - stringify the metadata when storing it
  function migrateMetadata(txn) {

    function decodeMetadataCompat(storedObject) {
      if (!storedObject.data) {
        // old format, when we didn't store it stringified
        storedObject.deleted = storedObject.deletedOrLocal === '1';
        return storedObject;
      }
      return decodeMetadata(storedObject);
    }

    // ensure that every metadata has a winningRev and seq,
    // which was previously created on-the-fly but better to migrate
    var bySeqStore = txn.objectStore(BY_SEQ_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var cursor = docStore.openCursor();
    cursor.onsuccess = function (e) {
      var cursor = e.target.result;
      if (!cursor) {
        return; // done
      }
      var metadata = decodeMetadataCompat(cursor.value);

      metadata.winningRev = metadata.winningRev ||
        winningRev(metadata);

      function fetchMetadataSeq() {
        // metadata.seq was added post-3.2.0, so if it's missing,
        // we need to fetch it manually
        var start = metadata.id + '::';
        var end = metadata.id + '::\\uffff';
        var req = bySeqStore.index('_doc_id_rev').openCursor(
          IDBKeyRange.bound(start, end));

        var metadataSeq = 0;
        req.onsuccess = function (e) {
          var cursor = e.target.result;
          if (!cursor) {
            metadata.seq = metadataSeq;
            return onGetMetadataSeq();
          }
          var seq = cursor.primaryKey;
          if (seq > metadataSeq) {
            metadataSeq = seq;
          }
          cursor.continue();
        };
      }

      function onGetMetadataSeq() {
        var metadataToStore = encodeMetadata(metadata,
          metadata.winningRev, metadata.deleted);

        var req = docStore.put(metadataToStore);
        req.onsuccess = function () {
          cursor.continue();
        };
      }

      if (metadata.seq) {
        return onGetMetadataSeq();
      }

      fetchMetadataSeq();
    };

  }

  api._remote = false;
  api.type = function () {
    return 'idb';
  };

  api._id = toPromise(function (callback) {
    callback(null, api._meta.instanceId);
  });

  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
    idbBulkDocs(opts, req, reqOpts, api, idb, callback);
  };

  // First we look up the metadata in the ids database, then we fetch the
  // current revision(s) from the by sequence store
  api._get = function idb_get(id, opts, callback) {
    var doc;
    var metadata;
    var err;
    var txn = opts.ctx;
    if (!txn) {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }

    function finish() {
      callback(err, {doc: doc, metadata: metadata, ctx: txn});
    }

    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      // we can determine the result here if:
      // 1. there is no such document
      // 2. the document is deleted and we don't ask about specific rev
      // When we ask with opts.rev we expect the answer to be either
      // doc (possibly with _deleted=true) or missing error
      if (!metadata) {
        err = createError(MISSING_DOC, 'missing');
        return finish();
      }

      var rev$$1;
      if (!opts.rev) {
        rev$$1 = metadata.winningRev;
        var deleted = isDeleted(metadata);
        if (deleted) {
          err = createError(MISSING_DOC, "deleted");
          return finish();
        }
      } else {
        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;
      }

      var objectStore = txn.objectStore(BY_SEQ_STORE);
      var key = metadata.id + '::' + rev$$1;

      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
        doc = e.target.result;
        if (doc) {
          doc = decodeDoc(doc);
        }
        if (!doc) {
          err = createError(MISSING_DOC, 'missing');
          return finish();
        }
        finish();
      };
    };
  };

  api._getAttachment = function (docId, attachId, attachment, opts, callback) {
    var txn;
    if (opts.ctx) {
      txn = opts.ctx;
    } else {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }
    var digest = attachment.digest;
    var type = attachment.content_type;

    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
      var body = e.target.result.body;
      readBlobData(body, type, opts.binary, function (blobData) {
        callback(null, blobData);
      });
    };
  };

  api._info = function idb_info(callback) {
    var updateSeq;
    var docCount;

    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      docCount = e.target.result.docCount;
    };
    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {
      var cursor = e.target.result;
      updateSeq = cursor ? cursor.key : 0;
    };

    txn.oncomplete = function () {
      callback(null, {
        doc_count: docCount,
        update_seq: updateSeq,
        // for debugging
        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')
      });
    };
  };

  api._allDocs = function idb_allDocs(opts, callback) {
    idbAllDocs(opts, idb, callback);
  };

  api._changes = function idbChanges(opts) {
    return changes(opts, api, dbName, idb);
  };

  api._close = function (callback) {
    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
    // "Returns immediately and closes the connection in a separate thread..."
    idb.close();
    cachedDBs.delete(dbName);
    callback();
  };

  api._getRevisionTree = function (docId, callback) {
    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    var req = txn.objectStore(DOC_STORE).get(docId);
    req.onsuccess = function (event) {
      var doc = decodeMetadata(event.target.result);
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        callback(null, doc.rev_tree);
      }
    };
  };

  // This function removes revisions of document docId
  // which are listed in revs and sets this document
  // revision to to rev_tree
  api._doCompaction = function (docId, revs, callback) {
    var stores = [
      DOC_STORE,
      BY_SEQ_STORE,
      ATTACH_STORE,
      ATTACH_AND_SEQ_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;

    var docStore = txn.objectStore(DOC_STORE);

    docStore.get(docId).onsuccess = function (event) {
      var metadata = decodeMetadata(event.target.result);
      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                         revHash, ctx, opts) {
        var rev$$1 = pos + '-' + revHash;
        if (revs.indexOf(rev$$1) !== -1) {
          opts.status = 'missing';
        }
      });
      compactRevs(revs, docId, txn);
      var winningRev$$1 = metadata.winningRev;
      var deleted = metadata.deleted;
      txn.objectStore(DOC_STORE).put(
        encodeMetadata(metadata, winningRev$$1, deleted));
    };
    txn.onabort = idbError(callback);
    txn.oncomplete = function () {
      callback();
    };
  };


  api._getLocal = function (id, callback) {
    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var tx = txnResult.txn;
    var req = tx.objectStore(LOCAL_STORE).get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var doc = e.target.result;
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        delete doc['_doc_id_rev']; // for backwards compat
        callback(null, doc);
      }
    };
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;
    if (!oldRev) {
      doc._rev = '0-1';
    } else {
      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
    }

    var tx = opts.ctx;
    var ret;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.onerror = idbError(callback);
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }

    var oStore = tx.objectStore(LOCAL_STORE);
    var req;
    if (oldRev) {
      req = oStore.get(id);
      req.onsuccess = function (e) {
        var oldDoc = e.target.result;
        if (!oldDoc || oldDoc._rev !== oldRev) {
          callback(createError(REV_CONFLICT));
        } else { // update
          var req = oStore.put(doc);
          req.onsuccess = function () {
            ret = {ok: true, id: doc._id, rev: doc._rev};
            if (opts.ctx) { // return immediately
              callback(null, ret);
            }
          };
        }
      };
    } else { // new doc
      req = oStore.add(doc);
      req.onerror = function (e) {
        // constraint error, already exists
        callback(createError(REV_CONFLICT));
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
      };
      req.onsuccess = function () {
        ret = {ok: true, id: doc._id, rev: doc._rev};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      };
    }
  };

  api._removeLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var tx = opts.ctx;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }
    var ret;
    var id = doc._id;
    var oStore = tx.objectStore(LOCAL_STORE);
    var req = oStore.get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var oldDoc = e.target.result;
      if (!oldDoc || oldDoc._rev !== doc._rev) {
        callback(createError(MISSING_DOC));
      } else {
        oStore.delete(id);
        ret = {ok: true, id: id, rev: '0-0'};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      }
    };
  };

  api._destroy = function (opts, callback) {
    changesHandler.removeAllListeners(dbName);

    //Close open request for "dbName" database to fix ie delay.
    var openReq = openReqList.get(dbName);
    if (openReq && openReq.result) {
      openReq.result.close();
      cachedDBs.delete(dbName);
    }
    var req = indexedDB.deleteDatabase(dbName);

    req.onsuccess = function () {
      //Remove open request from the list.
      openReqList.delete(dbName);
      if (hasLocalStorage() && (dbName in localStorage)) {
        delete localStorage[dbName];
      }
      callback(null, { 'ok': true });
    };

    req.onerror = idbError(callback);
  };

  var cached = cachedDBs.get(dbName);

  if (cached) {
    idb = cached.idb;
    api._meta = cached.global;
    return immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
      callback(null, api);
    });
  }

  var req = indexedDB.open(dbName, ADAPTER_VERSION);
  openReqList.set(dbName, req);

  req.onupgradeneeded = function (e) {
    var db = e.target.result;
    if (e.oldVersion < 1) {
      return createSchema(db); // new db, initial schema
    }
    // do migrations

    var txn = e.currentTarget.transaction;
    // these migrations have to be done in this function, before
    // control is returned to the event loop, because IndexedDB

    if (e.oldVersion < 3) {
      createLocalStoreSchema(db); // v2 -> v3
    }
    if (e.oldVersion < 4) {
      addAttachAndSeqStore(db); // v3 -> v4
    }

    var migrations = [
      addDeletedOrLocalIndex, // v1 -> v2
      migrateLocalStore,      // v2 -> v3
      migrateAttsAndSeqs,     // v3 -> v4
      migrateMetadata         // v4 -> v5
    ];

    var i = e.oldVersion;

    function next() {
      var migration = migrations[i - 1];
      i++;
      if (migration) {
        migration(txn, next);
      }
    }

    next();
  };

  req.onsuccess = function (e) {

    idb = e.target.result;

    idb.onversionchange = function () {
      idb.close();
      cachedDBs.delete(dbName);
    };

    idb.onabort = function (e) {
      guardedConsole('error', 'Database has a global failure', e.target.error);
      idb.close();
      cachedDBs.delete(dbName);
    };

    // Do a few setup operations (in parallel as much as possible):
    // 1. Fetch meta doc
    // 2. Check blob support
    // 3. Calculate docCount
    // 4. Generate an instanceId if necessary
    // 5. Store docCount and instanceId on meta doc

    var txn = idb.transaction([
      META_STORE,
      DETECT_BLOB_SUPPORT_STORE,
      DOC_STORE
    ], 'readwrite');

    var storedMetaDoc = false;
    var metaDoc;
    var docCount;
    var blobSupport;
    var instanceId;

    function completeSetup() {
      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {
        return;
      }
      api._meta = {
        name: dbName,
        instanceId: instanceId,
        blobSupport: blobSupport
      };

      cachedDBs.set(dbName, {
        idb: idb,
        global: api._meta
      });
      callback(null, api);
    }

    function storeMetaDocIfReady() {
      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {
        return;
      }
      var instanceKey = dbName + '_id';
      if (instanceKey in metaDoc) {
        instanceId = metaDoc[instanceKey];
      } else {
        metaDoc[instanceKey] = instanceId = uuid();
      }
      metaDoc.docCount = docCount;
      txn.objectStore(META_STORE).put(metaDoc);
    }

    //
    // fetch or generate the instanceId
    //
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result || { id: META_STORE };
      storeMetaDocIfReady();
    };

    //
    // countDocs
    //
    countDocs(txn, function (count) {
      docCount = count;
      storeMetaDocIfReady();
    });

    //
    // check blob support
    //
    if (!blobSupportPromise) {
      // make sure blob support is only checked once
      blobSupportPromise = checkBlobSupport(txn);
    }

    blobSupportPromise.then(function (val) {
      blobSupport = val;
      completeSetup();
    });

    // only when the metadata put transaction has completed,
    // consider the setup done
    txn.oncomplete = function () {
      storedMetaDoc = true;
      completeSetup();
    };
    txn.onabort = idbError(callback);
  };

  req.onerror = function (e) {
    var msg = e.target.error && e.target.error.message;

    if (!msg) {
      msg = 'Failed to open indexedDB, are you in private browsing mode?';
    } else if (msg.indexOf("stored database is a higher version") !== -1) {
      msg = new Error('This DB was created with the newer "indexeddb" adapter, but you are trying to open it with the older "idb" adapter');
    }

    guardedConsole('error', msg);
    callback(createError(IDB_ERROR, msg));
  };
}

IdbPouch.valid = function () {
  // Following #7085 buggy idb versions (typically Safari < 10.1) are
  // considered valid.

  // On Firefox SecurityError is thrown while referencing indexedDB if cookies
  // are not allowed. \`typeof indexedDB\` also triggers the error.
  try {
    // some outdated implementations of IDB that appear on Samsung
    // and HTC Android devices <4.4 are missing IDBKeyRange
    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
  } catch (e) {
    return false;
  }
};

function IDBPouch (PouchDB) {
  PouchDB.adapter('idb', IdbPouch, true);
}

// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool
// but much smaller in code size. limits the number of concurrent promises that are executed


function pool(promiseFactories, limit) {
  return new Promise(function (resolve, reject) {
    var running = 0;
    var current = 0;
    var done = 0;
    var len = promiseFactories.length;
    var err;

    function runNext() {
      running++;
      promiseFactories[current++]().then(onSuccess, onError);
    }

    function doNext() {
      if (++done === len) {
        /* istanbul ignore if */
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      } else {
        runNextBatch();
      }
    }

    function onSuccess() {
      running--;
      doNext();
    }

    /* istanbul ignore next */
    function onError(thisErr) {
      running--;
      err = err || thisErr;
      doNext();
    }

    function runNextBatch() {
      while (running < limit && current < len) {
        runNext();
      }
    }

    runNextBatch();
  });
}

var CHANGES_BATCH_SIZE = 25;
var MAX_SIMULTANEOUS_REVS = 50;
var CHANGES_TIMEOUT_BUFFER = 5000;
var DEFAULT_HEARTBEAT = 10000;

var supportsBulkGetMap = {};

function readAttachmentsAsBlobOrBuffer(row) {
  var doc = row.doc || row.ok;
  var atts = doc && doc._attachments;
  if (!atts) {
    return;
  }
  Object.keys(atts).forEach(function (filename) {
    var att = atts[filename];
    att.data = b64ToBluffer(att.data, att.content_type);
  });
}

function encodeDocId(id) {
  if (/^_design/.test(id)) {
    return '_design/' + encodeURIComponent(id.slice(8));
  }
  if (/^_local/.test(id)) {
    return '_local/' + encodeURIComponent(id.slice(7));
  }
  return encodeURIComponent(id);
}

function preprocessAttachments$1(doc) {
  if (!doc._attachments || !Object.keys(doc._attachments)) {
    return Promise.resolve();
  }

  return Promise.all(Object.keys(doc._attachments).map(function (key) {
    var attachment = doc._attachments[key];
    if (attachment.data && typeof attachment.data !== 'string') {
      return new Promise(function (resolve) {
        blobToBase64(attachment.data, resolve);
      }).then(function (b64) {
        attachment.data = b64;
      });
    }
  }));
}

function hasUrlPrefix(opts) {
  if (!opts.prefix) {
    return false;
  }
  var protocol = parseUri(opts.prefix).protocol;
  return protocol === 'http' || protocol === 'https';
}

// Get all the information you possibly can about the URI given by name and
// return it as a suitable object.
function getHost(name, opts) {
  // encode db name if opts.prefix is a url (#5574)
  if (hasUrlPrefix(opts)) {
    var dbName = opts.name.substr(opts.prefix.length);
    // Ensure prefix has a trailing slash
    var prefix = opts.prefix.replace(/\\/?$/, '/');
    name = prefix + encodeURIComponent(dbName);
  }

  var uri = parseUri(name);
  if (uri.user || uri.password) {
    uri.auth = {username: uri.user, password: uri.password};
  }

  // Split the path part of the URI into parts using '/' as the delimiter
  // after removing any leading '/' and any trailing '/'
  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');

  uri.db = parts.pop();
  // Prevent double encoding of URI component
  if (uri.db.indexOf('%') === -1) {
    uri.db = encodeURIComponent(uri.db);
  }

  uri.path = parts.join('/');

  return uri;
}

// Generate a URL with the host data given by opts and the given path
function genDBUrl(opts, path) {
  return genUrl(opts, opts.db + '/' + path);
}

// Generate a URL with the host data given by opts and the given path
function genUrl(opts, path) {
  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  var pathDel = !opts.path ? '' : '/';

  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  return opts.protocol + '://' + opts.host +
         (opts.port ? (':' + opts.port) : '') +
         '/' + opts.path + pathDel + path;
}

function paramsToStr(params) {
  return '?' + Object.keys(params).map(function (k) {
    return k + '=' + encodeURIComponent(params[k]);
  }).join('&');
}

function shouldCacheBust(opts) {
  var ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?
      navigator.userAgent.toLowerCase() : '';
  var isIE = ua.indexOf('msie') !== -1;
  var isTrident = ua.indexOf('trident') !== -1;
  var isEdge = ua.indexOf('edge') !== -1;
  var isGET = !('method' in opts) || opts.method === 'GET';
  return (isIE || isTrident || isEdge) && isGET;
}

// Implements the PouchDB API for dealing with CouchDB instances over HTTP
function HttpPouch(opts, callback) {

  // The functions that will be publicly available for HttpPouch
  var api = this;

  var host = getHost(opts.name, opts);
  var dbUrl = genDBUrl(host, '');

  opts = clone(opts);

  var ourFetch = function (url, options) {

    options = options || {};
    options.headers = options.headers || new h();

    options.credentials = 'include';

    if (opts.auth || host.auth) {
      var nAuth = opts.auth || host.auth;
      var str = nAuth.username + ':' + nAuth.password;
      var token = thisBtoa(unescape(encodeURIComponent(str)));
      options.headers.set('Authorization', 'Basic ' + token);
    }

    var headers = opts.headers || {};
    Object.keys(headers).forEach(function (key) {
      options.headers.append(key, headers[key]);
    });

    /* istanbul ignore if */
    if (shouldCacheBust(options)) {
      url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();
    }

    var fetchFun = opts.fetch || f$1;
    return fetchFun(url, options);
  };

  function adapterFun$$1(name, fun) {
    return adapterFun(name, argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
      setup().then(function () {
        return fun.apply(this, args);
      }).catch(function (e) {
        var callback = args.pop();
        callback(e);
      });
    })).bind(api);
  }

  function fetchJSON(url, options, callback) {

    var result = {};

    options = options || {};
    options.headers = options.headers || new h();

    if (!options.headers.get('Content-Type')) {
      options.headers.set('Content-Type', 'application/json');
    }
    if (!options.headers.get('Accept')) {
      options.headers.set('Accept', 'application/json');
    }

    return ourFetch(url, options).then(function (response) {
      result.ok = response.ok;
      result.status = response.status;
      return response.json();
    }).then(function (json) {
      result.data = json;
      if (!result.ok) {
        result.data.status = result.status;
        var err = generateErrorFromResponse(result.data);
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }

      if (Array.isArray(result.data)) {
        result.data = result.data.map(function (v) {
          if (v.error || v.missing) {
            return generateErrorFromResponse(v);
          } else {
            return v;
          }
        });
      }

      if (callback) {
        callback(null, result.data);
      } else {
        return result;
      }
    });
  }

  var setupPromise;

  function setup() {
    if (opts.skip_setup) {
      return Promise.resolve();
    }

    // If there is a setup in process or previous successful setup
    // done then we will use that
    // If previous setups have been rejected we will try again
    if (setupPromise) {
      return setupPromise;
    }

    setupPromise = fetchJSON(dbUrl).catch(function (err) {
      if (err && err.status && err.status === 404) {
        // Doesnt exist, create it
        explainError(404, 'PouchDB is just detecting if the remote exists.');
        return fetchJSON(dbUrl, {method: 'PUT'});
      } else {
        return Promise.reject(err);
      }
    }).catch(function (err) {
      // If we try to create a database that already exists, skipped in
      // istanbul since its catching a race condition.
      /* istanbul ignore if */
      if (err && err.status && err.status === 412) {
        return true;
      }
      return Promise.reject(err);
    });

    setupPromise.catch(function () {
      setupPromise = null;
    });

    return setupPromise;
  }

  immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
    callback(null, api);
  });

  api._remote = true;

  /* istanbul ignore next */
  api.type = function () {
    return 'http';
  };

  api.id = adapterFun$$1('id', function (callback) {
    ourFetch(genUrl(host, '')).then(function (response) {
      return response.json();
    }).catch(function () {
      return {};
    }).then(function (result) {
      // Bad response or missing \`uuid\` should not prevent ID generation.
      var uuid$$1 = (result && result.uuid) ?
          (result.uuid + host.db) : genDBUrl(host, '');
      callback(null, uuid$$1);
    });
  });

  // Sends a POST request to the host calling the couchdb _compact function
  //    version: The version of CouchDB it is running
  api.compact = adapterFun$$1('compact', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'}).then(function () {
      function ping() {
        api.info(function (err, res) {
          // CouchDB may send a "compact_running:true" if it's
          // already compacting. PouchDB Server doesn't.
          /* istanbul ignore else */
          if (res && !res.compact_running) {
            callback(null, {ok: true});
          } else {
            setTimeout(ping, opts.interval || 200);
          }
        });
      }
      // Ping the http if it's finished compaction
      ping();
    });
  });

  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {
    var self = this;

    function doBulkGet(cb) {
      var params = {};
      if (opts.revs) {
        params.revs = true;
      }
      if (opts.attachments) {
        /* istanbul ignore next */
        params.attachments = true;
      }
      if (opts.latest) {
        params.latest = true;
      }
      fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {
        method: 'POST',
        body: JSON.stringify({ docs: opts.docs})
      }).then(function (result) {
        if (opts.attachments && opts.binary) {
          result.data.results.forEach(function (res) {
            res.docs.forEach(readAttachmentsAsBlobOrBuffer);
          });
        }
        cb(null, result.data);
      }).catch(cb);
    }

    /* istanbul ignore next */
    function doBulkGetShim() {
      // avoid "url too long error" by splitting up into multiple requests
      var batchSize = MAX_SIMULTANEOUS_REVS;
      var numBatches = Math.ceil(opts.docs.length / batchSize);
      var numDone = 0;
      var results = new Array(numBatches);

      function onResult(batchNum) {
        return function (err, res) {
          // err is impossible because shim returns a list of errs in that case
          results[batchNum] = res.results;
          if (++numDone === numBatches) {
            callback(null, {results: flatten(results)});
          }
        };
      }

      for (var i = 0; i < numBatches; i++) {
        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);
        subOpts.docs = opts.docs.slice(i * batchSize,
          Math.min(opts.docs.length, (i + 1) * batchSize));
        bulkGet(self, subOpts, onResult(i));
      }
    }

    // mark the whole database as either supporting or not supporting _bulk_get
    var dbUrl = genUrl(host, '');
    var supportsBulkGet = supportsBulkGetMap[dbUrl];

    /* istanbul ignore next */
    if (typeof supportsBulkGet !== 'boolean') {
      // check if this database supports _bulk_get
      doBulkGet(function (err, res) {
        if (err) {
          supportsBulkGetMap[dbUrl] = false;
          explainError(
            err.status,
            'PouchDB is just detecting if the remote ' +
            'supports the _bulk_get API.'
          );
          doBulkGetShim();
        } else {
          supportsBulkGetMap[dbUrl] = true;
          callback(null, res);
        }
      });
    } else if (supportsBulkGet) {
      doBulkGet(callback);
    } else {
      doBulkGetShim();
    }
  });

  // Calls GET on the host, which gets back a JSON string containing
  //    couchdb: A welcome string
  //    version: The version of CouchDB it is running
  api._info = function (callback) {
    setup().then(function () {
      return ourFetch(genDBUrl(host, ''));
    }).then(function (response) {
      return response.json();
    }).then(function (info) {
      info.host = genDBUrl(host, '');
      callback(null, info);
    }).catch(callback);
  };

  api.fetch = function (path, options) {
    return setup().then(function () {
      var url = path.substring(0, 1) === '/' ?
        genUrl(host, path.substring(1)) :
        genDBUrl(host, path);
      return ourFetch(url, options);
    });
  };

  // Get the document with the given id from the database given by host.
  // The id could be solely the _id in the database, or it may be a
  // _design/ID or _local/ID path
  api.get = adapterFun$$1('get', function (id, opts, callback) {
    // If no options were given, set the callback to the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};

    if (opts.revs) {
      params.revs = true;
    }

    if (opts.revs_info) {
      params.revs_info = true;
    }

    if (opts.latest) {
      params.latest = true;
    }

    if (opts.open_revs) {
      if (opts.open_revs !== "all") {
        opts.open_revs = JSON.stringify(opts.open_revs);
      }
      params.open_revs = opts.open_revs;
    }

    if (opts.rev) {
      params.rev = opts.rev;
    }

    if (opts.conflicts) {
      params.conflicts = opts.conflicts;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = opts.update_seq;
    }

    id = encodeDocId(id);

    function fetchAttachments(doc) {
      var atts = doc._attachments;
      var filenames = atts && Object.keys(atts);
      if (!atts || !filenames.length) {
        return;
      }
      // we fetch these manually in separate XHRs, because
      // Sync Gateway would normally send it back as multipart/mixed,
      // which we cannot parse. Also, this is more efficient than
      // receiving attachments as base64-encoded strings.
      function fetchData(filename) {
        var att = atts[filename];
        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +
            '?rev=' + doc._rev;
        return ourFetch(genDBUrl(host, path)).then(function (response) {
          if ('buffer' in response) {
            return response.buffer();
          } else {
            /* istanbul ignore next */
            return response.blob();
          }
        }).then(function (blob) {
          if (opts.binary) {
            var typeFieldDescriptor = Object.getOwnPropertyDescriptor(blob.__proto__, 'type');
            if (!typeFieldDescriptor || typeFieldDescriptor.set) {
              blob.type = att.content_type;
            }
            return blob;
          }
          return new Promise(function (resolve) {
            blobToBase64(blob, resolve);
          });
        }).then(function (data) {
          delete att.stub;
          delete att.length;
          att.data = data;
        });
      }

      var promiseFactories = filenames.map(function (filename) {
        return function () {
          return fetchData(filename);
        };
      });

      // This limits the number of parallel xhr requests to 5 any time
      // to avoid issues with maximum browser request limits
      return pool(promiseFactories, 5);
    }

    function fetchAllAttachments(docOrDocs) {
      if (Array.isArray(docOrDocs)) {
        return Promise.all(docOrDocs.map(function (doc) {
          if (doc.ok) {
            return fetchAttachments(doc.ok);
          }
        }));
      }
      return fetchAttachments(docOrDocs);
    }

    var url = genDBUrl(host, id + paramsToStr(params));
    fetchJSON(url).then(function (res) {
      return Promise.resolve().then(function () {
        if (opts.attachments) {
          return fetchAllAttachments(res.data);
        }
      }).then(function () {
        callback(null, res.data);
      });
    }).catch(function (e) {
      e.docId = id;
      callback(e);
    });
  });


  // Delete the document given by doc from the database given by host.
  api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, cb) {
    var doc;
    if (typeof optsOrRev === 'string') {
      // id, rev, opts, callback style
      doc = {
        _id: docOrId,
        _rev: optsOrRev
      };
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
    } else {
      // doc, opts, callback style
      doc = docOrId;
      if (typeof optsOrRev === 'function') {
        cb = optsOrRev;
        opts = {};
      } else {
        cb = opts;
        opts = optsOrRev;
      }
    }

    var rev$$1 = (doc._rev || opts.rev);
    var url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1;

    fetchJSON(url, {method: 'DELETE'}, cb).catch(cb);
  });

  function encodeAttachmentId(attachmentId) {
    return attachmentId.split("/").map(encodeURIComponent).join("/");
  }

  // Get the attachment
  api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId,
                                                            opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var params = opts.rev ? ('?rev=' + opts.rev) : '';
    var url = genDBUrl(host, encodeDocId(docId)) + '/' +
        encodeAttachmentId(attachmentId) + params;
    var contentType;
    ourFetch(url, {method: 'GET'}).then(function (response) {
      contentType = response.headers.get('content-type');
      if (!response.ok) {
        throw response;
      } else {
        if (typeof process !== 'undefined' && !process.browser && typeof response.buffer === 'function') {
          return response.buffer();
        } else {
          /* istanbul ignore next */
          return response.blob();
        }
      }
    }).then(function (blob) {
      // TODO: also remove
      if (typeof process !== 'undefined' && !process.browser) {
        blob.type = contentType;
      }
      callback(null, blob);
    }).catch(function (err) {
      callback(err);
    });
  });

  // Remove the attachment given by the id and rev
  api.removeAttachment =  adapterFun$$1('removeAttachment', function (docId,
                                                                   attachmentId,
                                                                   rev$$1,
                                                                   callback) {
    var url = genDBUrl(host, encodeDocId(docId) + '/' +
                       encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;
    fetchJSON(url, {method: 'DELETE'}, callback).catch(callback);
  });

  // Add the attachment given by blob and its contentType property
  // to the document with the given id, the revision given by rev, and
  // add it to the database given by host.
  api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId,
                                                            rev$$1, blob,
                                                            type, callback) {
    if (typeof type === 'function') {
      callback = type;
      type = blob;
      blob = rev$$1;
      rev$$1 = null;
    }
    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
    var url = genDBUrl(host, id);
    if (rev$$1) {
      url += '?rev=' + rev$$1;
    }

    if (typeof blob === 'string') {
      // input is assumed to be a base64 string
      var binary;
      try {
        binary = thisAtob(blob);
      } catch (err) {
        return callback(createError(BAD_ARG,
                        'Attachment is not a valid base64 string'));
      }
      blob = binary ? binStringToBluffer(binary, type) : '';
    }

    // Add the attachment
    fetchJSON(url, {
      headers: new h({'Content-Type': type}),
      method: 'PUT',
      body: blob
    }, callback).catch(callback);
  });

  // Update/create multiple documents given by req in the database
  // given by host.
  api._bulkDocs = function (req, opts, callback) {
    // If new_edits=false then it prevents the database from creating
    // new revision numbers for the documents. Instead it just uses
    // the old ones. This is used in database replication.
    req.new_edits = opts.new_edits;

    setup().then(function () {
      return Promise.all(req.docs.map(preprocessAttachments$1));
    }).then(function () {
      // Update/create the documents
      return fetchJSON(genDBUrl(host, '_bulk_docs'), {
        method: 'POST',
        body: JSON.stringify(req)
      }, callback);
    }).catch(callback);
  };


  // Update/create document
  api._put = function (doc, opts, callback) {
    setup().then(function () {
      return preprocessAttachments$1(doc);
    }).then(function () {
      return fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {
        method: 'PUT',
        body: JSON.stringify(doc)
      });
    }).then(function (result) {
      callback(null, result.data);
    }).catch(function (err) {
      err.docId = doc && doc._id;
      callback(err);
    });
  };


  // Get a listing of the documents in the database given
  // by host and ordered by increasing id.
  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};
    var body;
    var method = 'GET';

    if (opts.conflicts) {
      params.conflicts = true;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    if (opts.include_docs) {
      params.include_docs = true;
    }

    // added in CouchDB 1.6.0
    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.key) {
      params.key = JSON.stringify(opts.key);
    }

    if (opts.start_key) {
      opts.startkey = opts.start_key;
    }

    if (opts.startkey) {
      params.startkey = JSON.stringify(opts.startkey);
    }

    if (opts.end_key) {
      opts.endkey = opts.end_key;
    }

    if (opts.endkey) {
      params.endkey = JSON.stringify(opts.endkey);
    }

    if (typeof opts.inclusive_end !== 'undefined') {
      params.inclusive_end = !!opts.inclusive_end;
    }

    if (typeof opts.limit !== 'undefined') {
      params.limit = opts.limit;
    }

    if (typeof opts.skip !== 'undefined') {
      params.skip = opts.skip;
    }

    var paramStr = paramsToStr(params);

    if (typeof opts.keys !== 'undefined') {
      method = 'POST';
      body = {keys: opts.keys};
    }

    fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {
       method: method,
      body: JSON.stringify(body)
    }).then(function (result) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);
      }
      callback(null, result.data);
    }).catch(callback);
  });

  // Get a list of changes made to documents in the database given by host.
  // TODO According to the README, there should be two other methods here,
  // api.changes.addListener and api.changes.removeListener.
  api._changes = function (opts) {

    // We internally page the results of a changes request, this means
    // if there is a large set of changes to be returned we can start
    // processing them quicker instead of waiting on the entire
    // set of changes to return and attempting to process them at once
    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;

    opts = clone(opts);

    if (opts.continuous && !('heartbeat' in opts)) {
      opts.heartbeat = DEFAULT_HEARTBEAT;
    }

    var requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;

    // ensure CHANGES_TIMEOUT_BUFFER applies
    if ('timeout' in opts && opts.timeout &&
      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;
    }

    /* istanbul ignore if */
    if ('heartbeat' in opts && opts.heartbeat &&
       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;
    }

    var params = {};
    if ('timeout' in opts && opts.timeout) {
      params.timeout = opts.timeout;
    }

    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
    var leftToFetch = limit;

    if (opts.style) {
      params.style = opts.style;
    }

    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
      params.include_docs = true;
    }

    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.continuous) {
      params.feed = 'longpoll';
    }

    if (opts.seq_interval) {
      params.seq_interval = opts.seq_interval;
    }

    if (opts.conflicts) {
      params.conflicts = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = true;
    }

    if ('heartbeat' in opts) {
      // If the heartbeat value is false, it disables the default heartbeat
      if (opts.heartbeat) {
        params.heartbeat = opts.heartbeat;
      }
    }

    if (opts.filter && typeof opts.filter === 'string') {
      params.filter = opts.filter;
    }

    if (opts.view && typeof opts.view === 'string') {
      params.filter = '_view';
      params.view = opts.view;
    }

    // If opts.query_params exists, pass it through to the changes request.
    // These parameters may be used by the filter on the source database.
    if (opts.query_params && typeof opts.query_params === 'object') {
      for (var param_name in opts.query_params) {
        /* istanbul ignore else */
        if (opts.query_params.hasOwnProperty(param_name)) {
          params[param_name] = opts.query_params[param_name];
        }
      }
    }

    var method = 'GET';
    var body;

    if (opts.doc_ids) {
      // set this automagically for the user; it's annoying that couchdb
      // requires both a "filter" and a "doc_ids" param.
      params.filter = '_doc_ids';
      method = 'POST';
      body = {doc_ids: opts.doc_ids };
    }
    /* istanbul ignore next */
    else if (opts.selector) {
      // set this automagically for the user, similar to above
      params.filter = '_selector';
      method = 'POST';
      body = {selector: opts.selector };
    }

    var controller = new a();
    var lastFetchedSeq;

    // Get all the changes starting wtih the one immediately after the
    // sequence number given by since.
    var fetchData = function (since, callback) {
      if (opts.aborted) {
        return;
      }
      params.since = since;
      // "since" can be any kind of json object in Cloudant/CouchDB 2.x
      /* istanbul ignore next */
      if (typeof params.since === "object") {
        params.since = JSON.stringify(params.since);
      }

      if (opts.descending) {
        if (limit) {
          params.limit = leftToFetch;
        }
      } else {
        params.limit = (!limit || leftToFetch > batchSize) ?
          batchSize : leftToFetch;
      }

      // Set the options for the ajax call
      var url = genDBUrl(host, '_changes' + paramsToStr(params));
      var fetchOpts = {
        signal: controller.signal,
        method: method,
        body: JSON.stringify(body)
      };
      lastFetchedSeq = since;

      /* istanbul ignore if */
      if (opts.aborted) {
        return;
      }

      // Get the changes
      setup().then(function () {
        return fetchJSON(url, fetchOpts, callback);
      }).catch(callback);
    };

    // If opts.since exists, get all the changes from the sequence
    // number given by opts.since. Otherwise, get all the changes
    // from the sequence number 0.
    var results = {results: []};

    var fetched = function (err, res) {
      if (opts.aborted) {
        return;
      }
      var raw_results_length = 0;
      // If the result of the ajax call (res) contains changes (res.results)
      if (res && res.results) {
        raw_results_length = res.results.length;
        results.last_seq = res.last_seq;
        var pending = null;
        var lastSeq = null;
        // Attach 'pending' property if server supports it (CouchDB 2.0+)
        /* istanbul ignore if */
        if (typeof res.pending === 'number') {
          pending = res.pending;
        }
        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {
          lastSeq = results.last_seq;
        }
        // For each change
        var req = {};
        req.query = opts.query_params;
        res.results = res.results.filter(function (c) {
          leftToFetch--;
          var ret = filterChange(opts)(c);
          if (ret) {
            if (opts.include_docs && opts.attachments && opts.binary) {
              readAttachmentsAsBlobOrBuffer(c);
            }
            if (opts.return_docs) {
              results.results.push(c);
            }
            opts.onChange(c, pending, lastSeq);
          }
          return ret;
        });
      } else if (err) {
        // In case of an error, stop listening for changes and call
        // opts.complete
        opts.aborted = true;
        opts.complete(err);
        return;
      }

      // The changes feed may have timed out with no results
      // if so reuse last update sequence
      if (res && res.last_seq) {
        lastFetchedSeq = res.last_seq;
      }

      var finished = (limit && leftToFetch <= 0) ||
        (res && raw_results_length < batchSize) ||
        (opts.descending);

      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {
        // Queue a call to fetch again with the newest sequence number
        immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () { fetchData(lastFetchedSeq, fetched); });
      } else {
        // We're done, call the callback
        opts.complete(null, results);
      }
    };

    fetchData(opts.since || 0, fetched);

    // Return a method to cancel this method from processing any more
    return {
      cancel: function () {
        opts.aborted = true;
        controller.abort();
      }
    };
  };

  // Given a set of document/revision IDs (given by req), tets the subset of
  // those that do NOT correspond to revisions stored in the database.
  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {
    // If no options were given, set the callback to be the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }

    // Get the missing document/revision IDs
    fetchJSON(genDBUrl(host, '_revs_diff'), {
      method: 'POST',
      body: JSON.stringify(req)
    }, callback).catch(callback);
  });

  api._close = function (callback) {
    callback();
  };

  api._destroy = function (options, callback) {
    fetchJSON(genDBUrl(host, ''), {method: 'DELETE'}).then(function (json) {
      callback(null, json);
    }).catch(function (err) {
      /* istanbul ignore if */
      if (err.status === 404) {
        callback(null, {ok: true});
      } else {
        callback(err);
      }
    });
  };
}

// HttpPouch is a valid adapter.
HttpPouch.valid = function () {
  return true;
};

function HttpPouch$1 (PouchDB) {
  PouchDB.adapter('http', HttpPouch, false);
  PouchDB.adapter('https', HttpPouch, false);
}

function QueryParseError(message) {
  this.status = 400;
  this.name = 'query_parse_error';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, QueryParseError);
  } catch (e) {}
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(QueryParseError, Error);

function NotFoundError(message) {
  this.status = 404;
  this.name = 'not_found';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, NotFoundError);
  } catch (e) {}
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(NotFoundError, Error);

function BuiltInError(message) {
  this.status = 500;
  this.name = 'invalid_value';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, BuiltInError);
  } catch (e) {}
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(BuiltInError, Error);

function promisedCallback(promise, callback) {
  if (callback) {
    promise.then(function (res) {
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
        callback(null, res);
      });
    }, function (reason) {
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
        callback(reason);
      });
    });
  }
  return promise;
}

function callbackify(fun) {
  return argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    var cb = args.pop();
    var promise = fun.apply(this, args);
    if (typeof cb === 'function') {
      promisedCallback(promise, cb);
    }
    return promise;
  });
}

// Promise finally util similar to Q.finally
function fin(promise, finalPromiseFactory) {
  return promise.then(function (res) {
    return finalPromiseFactory().then(function () {
      return res;
    });
  }, function (reason) {
    return finalPromiseFactory().then(function () {
      throw reason;
    });
  });
}

function sequentialize(queue, promiseFactory) {
  return function () {
    var args = arguments;
    var that = this;
    return queue.add(function () {
      return promiseFactory.apply(that, args);
    });
  };
}

// uniq an array of strings, order not guaranteed
// similar to underscore/lodash _.uniq
function uniq(arr) {
  var theSet = new ExportedSet(arr);
  var result = new Array(theSet.size);
  var index = -1;
  theSet.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

function mapToKeysArray(map) {
  var result = new Array(map.size);
  var index = -1;
  map.forEach(function (value, key) {
    result[++index] = key;
  });
  return result;
}

function createBuiltInError(name) {
  var message = 'builtin ' + name +
    ' function requires map values to be numbers' +
    ' or number arrays';
  return new BuiltInError(message);
}

function sum(values) {
  var result = 0;
  for (var i = 0, len = values.length; i < len; i++) {
    var num = values[i];
    if (typeof num !== 'number') {
      if (Array.isArray(num)) {
        // lists of numbers are also allowed, sum them separately
        result = typeof result === 'number' ? [result] : result;
        for (var j = 0, jLen = num.length; j < jLen; j++) {
          var jNum = num[j];
          if (typeof jNum !== 'number') {
            throw createBuiltInError('_sum');
          } else if (typeof result[j] === 'undefined') {
            result.push(jNum);
          } else {
            result[j] += jNum;
          }
        }
      } else { // not array/number
        throw createBuiltInError('_sum');
      }
    } else if (typeof result === 'number') {
      result += num;
    } else { // add number to array
      result[0] += num;
    }
  }
  return result;
}

var log = guardedConsole.bind(null, 'log');
var isArray = Array.isArray;
var toJSON = JSON.parse;

function evalFunctionWithEval(func, emit) {
  return scopeEval(
    "return (" + func.replace(/;\\s*$/, "") + ");",
    {
      emit: emit,
      sum: sum,
      log: log,
      isArray: isArray,
      toJSON: toJSON
    }
  );
}

/*
 * Simple task queue to sequentialize actions. Assumes
 * callbacks will eventually fire (once).
 */


function TaskQueue$1() {
  this.promise = new Promise(function (fulfill) {fulfill(); });
}
TaskQueue$1.prototype.add = function (promiseFactory) {
  this.promise = this.promise.catch(function () {
    // just recover
  }).then(function () {
    return promiseFactory();
  });
  return this.promise;
};
TaskQueue$1.prototype.finish = function () {
  return this.promise;
};

function stringify(input) {
  if (!input) {
    return 'undefined'; // backwards compat for empty reduce
  }
  // for backwards compat with mapreduce, functions/strings are stringified
  // as-is. everything else is JSON-stringified.
  switch (typeof input) {
    case 'function':
      // e.g. a mapreduce map
      return input.toString();
    case 'string':
      // e.g. a mapreduce built-in _reduce function
      return input.toString();
    default:
      // e.g. a JSON object in the case of mango queries
      return JSON.stringify(input);
  }
}

/* create a string signature for a view so we can cache it and uniq it */
function createViewSignature(mapFun, reduceFun) {
  // the "undefined" part is for backwards compatibility
  return stringify(mapFun) + stringify(reduceFun) + 'undefined';
}

function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {
  var viewSignature = createViewSignature(mapFun, reduceFun);

  var cachedViews;
  if (!temporary) {
    // cache this to ensure we don't try to update the same view twice
    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};
    if (cachedViews[viewSignature]) {
      return cachedViews[viewSignature];
    }
  }

  var promiseForView = sourceDB.info().then(function (info) {

    var depDbName = info.db_name + '-mrview-' +
      (temporary ? 'temp' : stringMd5(viewSignature));

    // save the view name in the source db so it can be cleaned up if necessary
    // (e.g. when the _design doc is deleted, remove all associated view data)
    function diffFunction(doc) {
      doc.views = doc.views || {};
      var fullViewName = viewName;
      if (fullViewName.indexOf('/') === -1) {
        fullViewName = viewName + '/' + viewName;
      }
      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
      /* istanbul ignore if */
      if (depDbs[depDbName]) {
        return; // no update necessary
      }
      depDbs[depDbName] = true;
      return doc;
    }
    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {
      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
        var db = res.db;
        db.auto_compaction = true;
        var view = {
          name: depDbName,
          db: db,
          sourceDB: sourceDB,
          adapter: sourceDB.adapter,
          mapFun: mapFun,
          reduceFun: reduceFun
        };
        return view.db.get('_local/lastSeq').catch(function (err) {
          /* istanbul ignore if */
          if (err.status !== 404) {
            throw err;
          }
        }).then(function (lastSeqDoc) {
          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
          if (cachedViews) {
            view.db.once('destroyed', function () {
              delete cachedViews[viewSignature];
            });
          }
          return view;
        });
      });
    });
  });

  if (cachedViews) {
    cachedViews[viewSignature] = promiseForView;
  }
  return promiseForView;
}

var persistentQueues = {};
var tempViewQueue = new TaskQueue$1();
var CHANGES_BATCH_SIZE$1 = 50;

function parseViewName(name) {
  // can be either 'ddocname/viewname' or just 'viewname'
  // (where the ddoc name is the same)
  return name.indexOf('/') === -1 ? [name, name] : name.split('/');
}

function isGenOne(changes) {
  // only return true if the current change is 1-
  // and there are no other leafs
  return changes.length === 1 && /^1-/.test(changes[0].rev);
}

function emitError(db, e) {
  try {
    db.emit('error', e);
  } catch (err) {
    guardedConsole('error',
      'The user\\'s map/reduce function threw an uncaught error.\\n' +
      'You can debug this error by doing:\\n' +
      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +
      'Please double-check your map/reduce function.');
    guardedConsole('error', e);
  }
}

/**
 * Returns an "abstract" mapreduce object of the form:
 *
 *   {
 *     query: queryFun,
 *     viewCleanup: viewCleanupFun
 *   }
 *
 * Arguments are:
 *
 * localDoc: string
 *   This is for the local doc that gets saved in order to track the
 *   "dependent" DBs and clean them up for viewCleanup. It should be
 *   unique, so that indexer plugins don't collide with each other.
 * mapper: function (mapFunDef, emit)
 *   Returns a map function based on the mapFunDef, which in the case of
 *   normal map/reduce is just the de-stringified function, but may be
 *   something else, such as an object in the case of pouchdb-find.
 * reducer: function (reduceFunDef)
 *   Ditto, but for reducing. Modules don't have to support reducing
 *   (e.g. pouchdb-find).
 * ddocValidator: function (ddoc, viewName)
 *   Throws an error if the ddoc or viewName is not valid.
 *   This could be a way to communicate to the user that the configuration for the
 *   indexer is invalid.
 */
function createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {

  function tryMap(db, fun, doc) {
    // emit an event if there was an error thrown by a map function.
    // putting try/catches in a single function also avoids deoptimizations.
    try {
      fun(doc);
    } catch (e) {
      emitError(db, e);
    }
  }

  function tryReduce(db, fun, keys, values, rereduce) {
    // same as above, but returning the result or an error. there are two separate
    // functions to avoid extra memory allocations since the tryCode() case is used
    // for custom map functions (common) vs this function, which is only used for
    // custom reduce functions (rare)
    try {
      return {output : fun(keys, values, rereduce)};
    } catch (e) {
      emitError(db, e);
      return {error: e};
    }
  }

  function sortByKeyThenValue(x, y) {
    var keyCompare = collate(x.key, y.key);
    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
  }

  function sliceResults(results, limit, skip) {
    skip = skip || 0;
    if (typeof limit === 'number') {
      return results.slice(skip, limit + skip);
    } else if (skip > 0) {
      return results.slice(skip);
    }
    return results;
  }

  function rowToDocId(row) {
    var val = row.value;
    // Users can explicitly specify a joined doc _id, or it
    // defaults to the doc _id that emitted the key/value.
    var docId = (val && typeof val === 'object' && val._id) || row.id;
    return docId;
  }

  function readAttachmentsAsBlobOrBuffer(res) {
    res.rows.forEach(function (row) {
      var atts = row.doc && row.doc._attachments;
      if (!atts) {
        return;
      }
      Object.keys(atts).forEach(function (filename) {
        var att = atts[filename];
        atts[filename].data = b64ToBluffer(att.data, att.content_type);
      });
    });
  }

  function postprocessAttachments(opts) {
    return function (res) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        readAttachmentsAsBlobOrBuffer(res);
      }
      return res;
    };
  }

  function addHttpParam(paramName, opts, params, asJson) {
    // add an http param from opts to params, optionally json-encoded
    var val = opts[paramName];
    if (typeof val !== 'undefined') {
      if (asJson) {
        val = encodeURIComponent(JSON.stringify(val));
      }
      params.push(paramName + '=' + val);
    }
  }

  function coerceInteger(integerCandidate) {
    if (typeof integerCandidate !== 'undefined') {
      var asNumber = Number(integerCandidate);
      // prevents e.g. '1foo' or '1.1' being coerced to 1
      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {
        return asNumber;
      } else {
        return integerCandidate;
      }
    }
  }

  function coerceOptions(opts) {
    opts.group_level = coerceInteger(opts.group_level);
    opts.limit = coerceInteger(opts.limit);
    opts.skip = coerceInteger(opts.skip);
    return opts;
  }

  function checkPositiveInteger(number) {
    if (number) {
      if (typeof number !== 'number') {
        return  new QueryParseError('Invalid value for integer: "' +
          number + '"');
      }
      if (number < 0) {
        return new QueryParseError('Invalid value for positive integer: ' +
          '"' + number + '"');
      }
    }
  }

  function checkQueryParseError(options, fun) {
    var startkeyName = options.descending ? 'endkey' : 'startkey';
    var endkeyName = options.descending ? 'startkey' : 'endkey';

    if (typeof options[startkeyName] !== 'undefined' &&
      typeof options[endkeyName] !== 'undefined' &&
      collate(options[startkeyName], options[endkeyName]) > 0) {
      throw new QueryParseError('No rows can match your key range, ' +
        'reverse your start_key and end_key or set {descending : true}');
    } else if (fun.reduce && options.reduce !== false) {
      if (options.include_docs) {
        throw new QueryParseError('{include_docs:true} is invalid for reduce');
      } else if (options.keys && options.keys.length > 1 &&
        !options.group && !options.group_level) {
        throw new QueryParseError('Multi-key fetches for reduce views must use ' +
          '{group: true}');
      }
    }
    ['group_level', 'limit', 'skip'].forEach(function (optionName) {
      var error = checkPositiveInteger(options[optionName]);
      if (error) {
        throw error;
      }
    });
  }

  function httpQuery(db, fun, opts) {
    // List of parameters to add to the PUT request
    var params = [];
    var body;
    var method = 'GET';
    var ok, status;

    // If opts.reduce exists and is defined, then add it to the list
    // of parameters.
    // If reduce=false then the results are that of only the map function
    // not the final result of map and reduce.
    addHttpParam('reduce', opts, params);
    addHttpParam('include_docs', opts, params);
    addHttpParam('attachments', opts, params);
    addHttpParam('limit', opts, params);
    addHttpParam('descending', opts, params);
    addHttpParam('group', opts, params);
    addHttpParam('group_level', opts, params);
    addHttpParam('skip', opts, params);
    addHttpParam('stale', opts, params);
    addHttpParam('conflicts', opts, params);
    addHttpParam('startkey', opts, params, true);
    addHttpParam('start_key', opts, params, true);
    addHttpParam('endkey', opts, params, true);
    addHttpParam('end_key', opts, params, true);
    addHttpParam('inclusive_end', opts, params);
    addHttpParam('key', opts, params, true);
    addHttpParam('update_seq', opts, params);

    // Format the list of parameters into a valid URI query string
    params = params.join('&');
    params = params === '' ? '' : '?' + params;

    // If keys are supplied, issue a POST to circumvent GET query string limits
    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.keys !== 'undefined') {
      var MAX_URL_LENGTH = 2000;
      // according to http://stackoverflow.com/a/417184/680742,
      // the de facto URL length limit is 2000 characters

      var keysAsString =
        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
        // If the keys are short enough, do a GET. we do this to work around
        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)
        params += (params[0] === '?' ? '&' : '?') + keysAsString;
      } else {
        method = 'POST';
        if (typeof fun === 'string') {
          body = {keys: opts.keys};
        } else { // fun is {map : mapfun}, so append to this
          fun.keys = opts.keys;
        }
      }
    }

    // We are referencing a query defined in the design doc
    if (typeof fun === 'string') {
      var parts = parseViewName(fun);
      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {
        headers: new h({'Content-Type': 'application/json'}),
        method: method,
        body: JSON.stringify(body)
      }).then(function (response) {
        ok = response.ok;
        status = response.status;
        return response.json();
      }).then(function (result) {
        if (!ok) {
          result.status = status;
          throw generateErrorFromResponse(result);
        }
        // fail the entire request if the result contains an error
        result.rows.forEach(function (row) {
          /* istanbul ignore if */
          if (row.value && row.value.error && row.value.error === "builtin_reduce_error") {
            throw new Error(row.reason);
          }
        });
        return result;
      }).then(postprocessAttachments(opts));
    }

    // We are using a temporary view, terrible for performance, good for testing
    body = body || {};
    Object.keys(fun).forEach(function (key) {
      if (Array.isArray(fun[key])) {
        body[key] = fun[key];
      } else {
        body[key] = fun[key].toString();
      }
    });

    return db.fetch('_temp_view' + params, {
      headers: new h({'Content-Type': 'application/json'}),
      method: 'POST',
      body: JSON.stringify(body)
    }).then(function (response) {
        ok = response.ok;
        status = response.status;
      return response.json();
    }).then(function (result) {
      if (!ok) {
        result.status = status;
        throw generateErrorFromResponse(result);
      }
      return result;
    }).then(postprocessAttachments(opts));
  }

  // custom adapters can define their own api._query
  // and override the default behavior
  /* istanbul ignore next */
  function customQuery(db, fun, opts) {
    return new Promise(function (resolve, reject) {
      db._query(fun, opts, function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  // custom adapters can define their own api._viewCleanup
  // and override the default behavior
  /* istanbul ignore next */
  function customViewCleanup(db) {
    return new Promise(function (resolve, reject) {
      db._viewCleanup(function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  function defaultsTo(value) {
    return function (reason) {
      /* istanbul ignore else */
      if (reason.status === 404) {
        return value;
      } else {
        throw reason;
      }
    };
  }

  // returns a promise for a list of docs to update, based on the input docId.
  // the order doesn't matter, because post-3.2.0, bulkDocs
  // is an atomic operation in all three adapters.
  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
    var metaDocId = '_local/doc_' + docId;
    var defaultMetaDoc = {_id: metaDocId, keys: []};
    var docData = docIdsToChangesAndEmits.get(docId);
    var indexableKeysToKeyValues = docData[0];
    var changes = docData[1];

    function getMetaDoc() {
      if (isGenOne(changes)) {
        // generation 1, so we can safely assume initial state
        // for performance reasons (avoids unnecessary GETs)
        return Promise.resolve(defaultMetaDoc);
      }
      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));
    }

    function getKeyValueDocs(metaDoc) {
      if (!metaDoc.keys.length) {
        // no keys, no need for a lookup
        return Promise.resolve({rows: []});
      }
      return view.db.allDocs({
        keys: metaDoc.keys,
        include_docs: true
      });
    }

    function processKeyValueDocs(metaDoc, kvDocsRes) {
      var kvDocs = [];
      var oldKeys = new ExportedSet();

      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
        var row = kvDocsRes.rows[i];
        var doc = row.doc;
        if (!doc) { // deleted
          continue;
        }
        kvDocs.push(doc);
        oldKeys.add(doc._id);
        doc._deleted = !indexableKeysToKeyValues.has(doc._id);
        if (!doc._deleted) {
          var keyValue = indexableKeysToKeyValues.get(doc._id);
          if ('value' in keyValue) {
            doc.value = keyValue.value;
          }
        }
      }
      var newKeys = mapToKeysArray(indexableKeysToKeyValues);
      newKeys.forEach(function (key) {
        if (!oldKeys.has(key)) {
          // new doc
          var kvDoc = {
            _id: key
          };
          var keyValue = indexableKeysToKeyValues.get(key);
          if ('value' in keyValue) {
            kvDoc.value = keyValue.value;
          }
          kvDocs.push(kvDoc);
        }
      });
      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));
      kvDocs.push(metaDoc);

      return kvDocs;
    }

    return getMetaDoc().then(function (metaDoc) {
      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
        return processKeyValueDocs(metaDoc, kvDocsRes);
      });
    });
  }

  // updates all emitted key/value docs and metaDocs in the mrview database
  // for the given batch of documents from the source database
  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
    var seqDocId = '_local/lastSeq';
    return view.db.get(seqDocId)
      .catch(defaultsTo({_id: seqDocId, seq: 0}))
      .then(function (lastSeqDoc) {
        var docIds = mapToKeysArray(docIdsToChangesAndEmits);
        return Promise.all(docIds.map(function (docId) {
          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
        })).then(function (listOfDocsToPersist) {
          var docsToPersist = flatten(listOfDocsToPersist);
          lastSeqDoc.seq = seq;
          docsToPersist.push(lastSeqDoc);
          // write all docs in a single operation, update the seq once
          return view.db.bulkDocs({docs : docsToPersist});
        });
      });
  }

  function getQueue(view) {
    var viewName = typeof view === 'string' ? view : view.name;
    var queue = persistentQueues[viewName];
    if (!queue) {
      queue = persistentQueues[viewName] = new TaskQueue$1();
    }
    return queue;
  }

  function updateView(view) {
    return sequentialize(getQueue(view), function () {
      return updateViewInQueue(view);
    })();
  }

  function updateViewInQueue(view) {
    // bind the emit function once
    var mapResults;
    var doc;

    function emit(key, value) {
      var output = {id: doc._id, key: normalizeKey(key)};
      // Don't explicitly store the value unless it's defined and non-null.
      // This saves on storage space, because often people don't use it.
      if (typeof value !== 'undefined' && value !== null) {
        output.value = normalizeKey(value);
      }
      mapResults.push(output);
    }

    var mapFun = mapper(view.mapFun, emit);

    var currentSeq = view.seq || 0;

    function processChange(docIdsToChangesAndEmits, seq) {
      return function () {
        return saveKeyValues(view, docIdsToChangesAndEmits, seq);
      };
    }

    var queue = new TaskQueue$1();

    function processNextBatch() {
      return view.sourceDB.changes({
        return_docs: true,
        conflicts: true,
        include_docs: true,
        style: 'all_docs',
        since: currentSeq,
        limit: CHANGES_BATCH_SIZE$1
      }).then(processBatch);
    }

    function processBatch(response) {
      var results = response.results;
      if (!results.length) {
        return;
      }
      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);
      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
      if (results.length < CHANGES_BATCH_SIZE$1) {
        return;
      }
      return processNextBatch();
    }

    function createDocIdsToChangesAndEmits(results) {
      var docIdsToChangesAndEmits = new ExportedMap();
      for (var i = 0, len = results.length; i < len; i++) {
        var change = results[i];
        if (change.doc._id[0] !== '_') {
          mapResults = [];
          doc = change.doc;

          if (!doc._deleted) {
            tryMap(view.sourceDB, mapFun, doc);
          }
          mapResults.sort(sortByKeyThenValue);

          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);
          docIdsToChangesAndEmits.set(change.doc._id, [
            indexableKeysToKeyValues,
            change.changes
          ]);
        }
        currentSeq = change.seq;
      }
      return docIdsToChangesAndEmits;
    }

    function createIndexableKeysToKeyValues(mapResults) {
      var indexableKeysToKeyValues = new ExportedMap();
      var lastKey;
      for (var i = 0, len = mapResults.length; i < len; i++) {
        var emittedKeyValue = mapResults[i];
        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];
        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {
          complexKey.push(i); // dup key+id, so make it unique
        }
        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);
        lastKey = emittedKeyValue.key;
      }
      return indexableKeysToKeyValues;
    }

    return processNextBatch().then(function () {
      return queue.finish();
    }).then(function () {
      view.seq = currentSeq;
    });
  }

  function reduceView(view, results, options) {
    if (options.group_level === 0) {
      delete options.group_level;
    }

    var shouldGroup = options.group || options.group_level;

    var reduceFun = reducer(view.reduceFun);

    var groups = [];
    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :
      options.group_level;
    results.forEach(function (e) {
      var last = groups[groups.length - 1];
      var groupKey = shouldGroup ? e.key : null;

      // only set group_level for array keys
      if (shouldGroup && Array.isArray(groupKey)) {
        groupKey = groupKey.slice(0, lvl);
      }

      if (last && collate(last.groupKey, groupKey) === 0) {
        last.keys.push([e.key, e.id]);
        last.values.push(e.value);
        return;
      }
      groups.push({
        keys: [[e.key, e.id]],
        values: [e.value],
        groupKey: groupKey
      });
    });
    results = [];
    for (var i = 0, len = groups.length; i < len; i++) {
      var e = groups[i];
      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);
      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {
        // CouchDB returns an error if a built-in errors out
        throw reduceTry.error;
      }
      results.push({
        // CouchDB just sets the value to null if a non-built-in errors out
        value: reduceTry.error ? null : reduceTry.output,
        key: e.groupKey
      });
    }
    // no total_rows/offset when reducing
    return {rows: sliceResults(results, options.limit, options.skip)};
  }

  function queryView(view, opts) {
    return sequentialize(getQueue(view), function () {
      return queryViewInQueue(view, opts);
    })();
  }

  function queryViewInQueue(view, opts) {
    var totalRows;
    var shouldReduce = view.reduceFun && opts.reduce !== false;
    var skip = opts.skip || 0;
    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
      // equivalent query
      opts.limit = 0;
      delete opts.keys;
    }

    function fetchFromView(viewOpts) {
      viewOpts.include_docs = true;
      return view.db.allDocs(viewOpts).then(function (res) {
        totalRows = res.total_rows;
        return res.rows.map(function (result) {

          // implicit migration - in older versions of PouchDB,
          // we explicitly stored the doc as {id: ..., key: ..., value: ...}
          // this is tested in a migration test
          /* istanbul ignore next */
          if ('value' in result.doc && typeof result.doc.value === 'object' &&
            result.doc.value !== null) {
            var keys = Object.keys(result.doc.value).sort();
            // this detection method is not perfect, but it's unlikely the user
            // emitted a value which was an object with these 3 exact keys
            var expectedKeys = ['id', 'key', 'value'];
            if (!(keys < expectedKeys || keys > expectedKeys)) {
              return result.doc.value;
            }
          }

          var parsedKeyAndDocId = parseIndexableString(result.doc._id);
          return {
            key: parsedKeyAndDocId[0],
            id: parsedKeyAndDocId[1],
            value: ('value' in result.doc ? result.doc.value : null)
          };
        });
      });
    }

    function onMapResultsReady(rows) {
      var finalResults;
      if (shouldReduce) {
        finalResults = reduceView(view, rows, opts);
      } else {
        finalResults = {
          total_rows: totalRows,
          offset: skip,
          rows: rows
        };
      }
      /* istanbul ignore if */
      if (opts.update_seq) {
        finalResults.update_seq = view.seq;
      }
      if (opts.include_docs) {
        var docIds = uniq(rows.map(rowToDocId));

        return view.sourceDB.allDocs({
          keys: docIds,
          include_docs: true,
          conflicts: opts.conflicts,
          attachments: opts.attachments,
          binary: opts.binary
        }).then(function (allDocsRes) {
          var docIdsToDocs = new ExportedMap();
          allDocsRes.rows.forEach(function (row) {
            docIdsToDocs.set(row.id, row.doc);
          });
          rows.forEach(function (row) {
            var docId = rowToDocId(row);
            var doc = docIdsToDocs.get(docId);
            if (doc) {
              row.doc = doc;
            }
          });
          return finalResults;
        });
      } else {
        return finalResults;
      }
    }

    if (typeof opts.keys !== 'undefined') {
      var keys = opts.keys;
      var fetchPromises = keys.map(function (key) {
        var viewOpts = {
          startkey : toIndexableString([key]),
          endkey   : toIndexableString([key, {}])
        };
        /* istanbul ignore if */
        if (opts.update_seq) {
          viewOpts.update_seq = true;
        }
        return fetchFromView(viewOpts);
      });
      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);
    } else { // normal query, no 'keys'
      var viewOpts = {
        descending : opts.descending
      };
      /* istanbul ignore if */
      if (opts.update_seq) {
        viewOpts.update_seq = true;
      }
      var startkey;
      var endkey;
      if ('start_key' in opts) {
        startkey = opts.start_key;
      }
      if ('startkey' in opts) {
        startkey = opts.startkey;
      }
      if ('end_key' in opts) {
        endkey = opts.end_key;
      }
      if ('endkey' in opts) {
        endkey = opts.endkey;
      }
      if (typeof startkey !== 'undefined') {
        viewOpts.startkey = opts.descending ?
          toIndexableString([startkey, {}]) :
          toIndexableString([startkey]);
      }
      if (typeof endkey !== 'undefined') {
        var inclusiveEnd = opts.inclusive_end !== false;
        if (opts.descending) {
          inclusiveEnd = !inclusiveEnd;
        }

        viewOpts.endkey = toIndexableString(
          inclusiveEnd ? [endkey, {}] : [endkey]);
      }
      if (typeof opts.key !== 'undefined') {
        var keyStart = toIndexableString([opts.key]);
        var keyEnd = toIndexableString([opts.key, {}]);
        if (viewOpts.descending) {
          viewOpts.endkey = keyStart;
          viewOpts.startkey = keyEnd;
        } else {
          viewOpts.startkey = keyStart;
          viewOpts.endkey = keyEnd;
        }
      }
      if (!shouldReduce) {
        if (typeof opts.limit === 'number') {
          viewOpts.limit = opts.limit;
        }
        viewOpts.skip = skip;
      }
      return fetchFromView(viewOpts).then(onMapResultsReady);
    }
  }

  function httpViewCleanup(db) {
    return db.fetch('_view_cleanup', {
      headers: new h({'Content-Type': 'application/json'}),
      method: 'POST'
    }).then(function (response) {
      return response.json();
    });
  }

  function localViewCleanup(db) {
    return db.get('_local/' + localDocName).then(function (metaDoc) {
      var docsToViews = new ExportedMap();
      Object.keys(metaDoc.views).forEach(function (fullViewName) {
        var parts = parseViewName(fullViewName);
        var designDocName = '_design/' + parts[0];
        var viewName = parts[1];
        var views = docsToViews.get(designDocName);
        if (!views) {
          views = new ExportedSet();
          docsToViews.set(designDocName, views);
        }
        views.add(viewName);
      });
      var opts = {
        keys : mapToKeysArray(docsToViews),
        include_docs : true
      };
      return db.allDocs(opts).then(function (res) {
        var viewsToStatus = {};
        res.rows.forEach(function (row) {
          var ddocName = row.key.substring(8); // cuts off '_design/'
          docsToViews.get(row.key).forEach(function (viewName) {
            var fullViewName = ddocName + '/' + viewName;
            /* istanbul ignore if */
            if (!metaDoc.views[fullViewName]) {
              // new format, without slashes, to support PouchDB 2.2.0
              // migration test in pouchdb's browser.migration.js verifies this
              fullViewName = viewName;
            }
            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
            // design doc deleted, or view function nonexistent
            var statusIsGood = row.doc && row.doc.views &&
              row.doc.views[viewName];
            viewDBNames.forEach(function (viewDBName) {
              viewsToStatus[viewDBName] =
                viewsToStatus[viewDBName] || statusIsGood;
            });
          });
        });
        var dbsToDelete = Object.keys(viewsToStatus).filter(
          function (viewDBName) { return !viewsToStatus[viewDBName]; });
        var destroyPromises = dbsToDelete.map(function (viewDBName) {
          return sequentialize(getQueue(viewDBName), function () {
            return new db.constructor(viewDBName, db.__opts).destroy();
          })();
        });
        return Promise.all(destroyPromises).then(function () {
          return {ok: true};
        });
      });
    }, defaultsTo({ok: true}));
  }

  function queryPromised(db, fun, opts) {
    /* istanbul ignore next */
    if (typeof db._query === 'function') {
      return customQuery(db, fun, opts);
    }
    if (isRemote(db)) {
      return httpQuery(db, fun, opts);
    }

    if (typeof fun !== 'string') {
      // temp_view
      checkQueryParseError(opts, fun);

      tempViewQueue.add(function () {
        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ 'temp_view/temp_view',
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ true,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          return fin(updateView(view).then(function () {
            return queryView(view, opts);
          }), function () {
            return view.db.destroy();
          });
        });
      });
      return tempViewQueue.finish();
    } else {
      // persistent view
      var fullViewName = fun;
      var parts = parseViewName(fullViewName);
      var designDocName = parts[0];
      var viewName = parts[1];
      return db.get('_design/' + designDocName).then(function (doc) {
        var fun = doc.views && doc.views[viewName];

        if (!fun) {
          // basic validator; it's assumed that every subclass would want this
          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +
            viewName);
        }

        ddocValidator(doc, viewName);
        checkQueryParseError(opts, fun);

        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ fullViewName,
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ false,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          if (opts.stale === 'ok' || opts.stale === 'update_after') {
            if (opts.stale === 'update_after') {
              immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
                updateView(view);
              });
            }
            return queryView(view, opts);
          } else { // stale not ok
            return updateView(view).then(function () {
              return queryView(view, opts);
            });
          }
        });
      });
    }
  }

  function abstractQuery(fun, opts, callback) {
    var db = this;
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = opts ? coerceOptions(opts) : {};

    if (typeof fun === 'function') {
      fun = {map : fun};
    }

    var promise = Promise.resolve().then(function () {
      return queryPromised(db, fun, opts);
    });
    promisedCallback(promise, callback);
    return promise;
  }

  var abstractViewCleanup = callbackify(function () {
    var db = this;
    /* istanbul ignore next */
    if (typeof db._viewCleanup === 'function') {
      return customViewCleanup(db);
    }
    if (isRemote(db)) {
      return httpViewCleanup(db);
    }
    return localViewCleanup(db);
  });

  return {
    query: abstractQuery,
    viewCleanup: abstractViewCleanup
  };
}

var builtInReduce = {
  _sum: function (keys, values) {
    return sum(values);
  },

  _count: function (keys, values) {
    return values.length;
  },

  _stats: function (keys, values) {
    // no need to implement rereduce=true, because Pouch
    // will never call it
    function sumsqr(values) {
      var _sumsqr = 0;
      for (var i = 0, len = values.length; i < len; i++) {
        var num = values[i];
        _sumsqr += (num * num);
      }
      return _sumsqr;
    }
    return {
      sum     : sum(values),
      min     : Math.min.apply(null, values),
      max     : Math.max.apply(null, values),
      count   : values.length,
      sumsqr : sumsqr(values)
    };
  }
};

function getBuiltIn(reduceFunString) {
  if (/^_sum/.test(reduceFunString)) {
    return builtInReduce._sum;
  } else if (/^_count/.test(reduceFunString)) {
    return builtInReduce._count;
  } else if (/^_stats/.test(reduceFunString)) {
    return builtInReduce._stats;
  } else if (/^_/.test(reduceFunString)) {
    throw new Error(reduceFunString + ' is not a supported reduce function.');
  }
}

function mapper(mapFun, emit) {
  // for temp_views one can use emit(doc, emit), see #38
  if (typeof mapFun === "function" && mapFun.length === 2) {
    var origMap = mapFun;
    return function (doc) {
      return origMap(doc, emit);
    };
  } else {
    return evalFunctionWithEval(mapFun.toString(), emit);
  }
}

function reducer(reduceFun) {
  var reduceFunString = reduceFun.toString();
  var builtIn = getBuiltIn(reduceFunString);
  if (builtIn) {
    return builtIn;
  } else {
    return evalFunctionWithEval(reduceFunString);
  }
}

function ddocValidator(ddoc, viewName) {
  var fun = ddoc.views && ddoc.views[viewName];
  if (typeof fun.map !== 'string') {
    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +
      viewName + ', instead found object of type: ' + typeof fun.map);
  }
}

var localDocName = 'mrviews';
var abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);

function query(fun, opts, callback) {
  return abstract.query.call(this, fun, opts, callback);
}

function viewCleanup(callback) {
  return abstract.viewCleanup.call(this, callback);
}

var mapreduce = {
  query: query,
  viewCleanup: viewCleanup
};

function isGenOne$1(rev$$1) {
  return /^1-/.test(rev$$1);
}

function fileHasChanged(localDoc, remoteDoc, filename) {
  return !localDoc._attachments ||
         !localDoc._attachments[filename] ||
         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;
}

function getDocAttachments(db, doc) {
  var filenames = Object.keys(doc._attachments);
  return Promise.all(filenames.map(function (filename) {
    return db.getAttachment(doc._id, filename, {rev: doc._rev});
  }));
}

function getDocAttachmentsFromTargetOrSource(target, src, doc) {
  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);
  var filenames = Object.keys(doc._attachments);

  if (!doCheckForLocalAttachments) {
    return getDocAttachments(src, doc);
  }

  return target.get(doc._id).then(function (localDoc) {
    return Promise.all(filenames.map(function (filename) {
      if (fileHasChanged(localDoc, doc, filename)) {
        return src.getAttachment(doc._id, filename);
      }

      return target.getAttachment(localDoc._id, filename);
    }));
  }).catch(function (error) {
    /* istanbul ignore if */
    if (error.status !== 404) {
      throw error;
    }

    return getDocAttachments(src, doc);
  });
}

function createBulkGetOpts(diffs) {
  var requests = [];
  Object.keys(diffs).forEach(function (id) {
    var missingRevs = diffs[id].missing;
    missingRevs.forEach(function (missingRev) {
      requests.push({
        id: id,
        rev: missingRev
      });
    });
  });

  return {
    docs: requests,
    revs: true,
    latest: true
  };
}

//
// Fetch all the documents from the src as described in the "diffs",
// which is a mapping of docs IDs to revisions. If the state ever
// changes to "cancelled", then the returned promise will be rejected.
// Else it will be resolved with a list of fetched documents.
//
function getDocs(src, target, diffs, state) {
  diffs = clone(diffs); // we do not need to modify this

  var resultDocs = [],
      ok = true;

  function getAllDocs() {

    var bulkGetOpts = createBulkGetOpts(diffs);

    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests
      return;
    }

    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {
      /* istanbul ignore if */
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {
        return Promise.all(bulkGetInfo.docs.map(function (doc) {
          var remoteDoc = doc.ok;

          if (doc.error) {
            // when AUTO_COMPACTION is set, docs can be returned which look
            // like this: {"missing":"1-7c3ac256b693c462af8442f992b83696"}
            ok = false;
          }

          if (!remoteDoc || !remoteDoc._attachments) {
            return remoteDoc;
          }

          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)
                   .then(function (attachments) {
                           var filenames = Object.keys(remoteDoc._attachments);
                           attachments
                             .forEach(function (attachment, i) {
                                        var att = remoteDoc._attachments[filenames[i]];
                                        delete att.stub;
                                        delete att.length;
                                        att.data = attachment;
                                      });

                                      return remoteDoc;
                                    });
        }));
      }))

      .then(function (results) {
        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));
      });
    });
  }

  function hasAttachments(doc) {
    return doc._attachments && Object.keys(doc._attachments).length > 0;
  }

  function hasConflicts(doc) {
    return doc._conflicts && doc._conflicts.length > 0;
  }

  function fetchRevisionOneDocs(ids) {
    // Optimization: fetch gen-1 docs and attachments in
    // a single request using _all_docs
    return src.allDocs({
      keys: ids,
      include_docs: true,
      conflicts: true
    }).then(function (res) {
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      res.rows.forEach(function (row) {
        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||
            hasAttachments(row.doc) || hasConflicts(row.doc)) {
          // if any of these conditions apply, we need to fetch using get()
          return;
        }

        // strip _conflicts array to appease CSG (#5793)
        /* istanbul ignore if */
        if (row.doc._conflicts) {
          delete row.doc._conflicts;
        }

        // the doc we got back from allDocs() is sufficient
        resultDocs.push(row.doc);
        delete diffs[row.id];
      });
    });
  }

  function getRevisionOneDocs() {
    // filter out the generation 1 docs and get them
    // leaving the non-generation one docs to be got otherwise
    var ids = Object.keys(diffs).filter(function (id) {
      var missing = diffs[id].missing;
      return missing.length === 1 && isGenOne$1(missing[0]);
    });
    if (ids.length > 0) {
      return fetchRevisionOneDocs(ids);
    }
  }

  function returnResult() {
    return { ok:ok, docs:resultDocs };
  }

  return Promise.resolve()
    .then(getRevisionOneDocs)
    .then(getAllDocs)
    .then(returnResult);
}

var CHECKPOINT_VERSION = 1;
var REPLICATOR = "pouchdb";
// This is an arbitrary number to limit the
// amount of replication history we save in the checkpoint.
// If we save too much, the checkpoing docs will become very big,
// if we save fewer, we'll run a greater risk of having to
// read all the changes from 0 when checkpoint PUTs fail
// CouchDB 2.0 has a more involved history pruning,
// but let's go for the simple version for now.
var CHECKPOINT_HISTORY_SIZE = 5;
var LOWEST_SEQ = 0;

function updateCheckpoint(db, id, checkpoint, session, returnValue) {
  return db.get(id).catch(function (err) {
    if (err.status === 404) {
      if (db.adapter === 'http' || db.adapter === 'https') {
        explainError(
          404, 'PouchDB is just checking if a remote checkpoint exists.'
        );
      }
      return {
        session_id: session,
        _id: id,
        history: [],
        replicator: REPLICATOR,
        version: CHECKPOINT_VERSION
      };
    }
    throw err;
  }).then(function (doc) {
    if (returnValue.cancelled) {
      return;
    }

    // if the checkpoint has not changed, do not update
    if (doc.last_seq === checkpoint) {
      return;
    }

    // Filter out current entry for this replication
    doc.history = (doc.history || []).filter(function (item) {
      return item.session_id !== session;
    });

    // Add the latest checkpoint to history
    doc.history.unshift({
      last_seq: checkpoint,
      session_id: session
    });

    // Just take the last pieces in history, to
    // avoid really big checkpoint docs.
    // see comment on history size above
    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);

    doc.version = CHECKPOINT_VERSION;
    doc.replicator = REPLICATOR;

    doc.session_id = session;
    doc.last_seq = checkpoint;

    return db.put(doc).catch(function (err) {
      if (err.status === 409) {
        // retry; someone is trying to write a checkpoint simultaneously
        return updateCheckpoint(db, id, checkpoint, session, returnValue);
      }
      throw err;
    });
  });
}

function Checkpointer(src, target, id, returnValue, opts) {
  this.src = src;
  this.target = target;
  this.id = id;
  this.returnValue = returnValue;
  this.opts = opts || {};
}

Checkpointer.prototype.writeCheckpoint = function (checkpoint, session) {
  var self = this;
  return this.updateTarget(checkpoint, session).then(function () {
    return self.updateSource(checkpoint, session);
  });
};

Checkpointer.prototype.updateTarget = function (checkpoint, session) {
  if (this.opts.writeTargetCheckpoint) {
    return updateCheckpoint(this.target, this.id, checkpoint,
      session, this.returnValue);
  } else {
    return Promise.resolve(true);
  }
};

Checkpointer.prototype.updateSource = function (checkpoint, session) {
  if (this.opts.writeSourceCheckpoint) {
    var self = this;
    return updateCheckpoint(this.src, this.id, checkpoint,
      session, this.returnValue)
      .catch(function (err) {
        if (isForbiddenError(err)) {
          self.opts.writeSourceCheckpoint = false;
          return true;
        }
        throw err;
      });
  } else {
    return Promise.resolve(true);
  }
};

var comparisons = {
  "undefined": function (targetDoc, sourceDoc) {
    // This is the previous comparison function
    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {
      return sourceDoc.last_seq;
    }
    /* istanbul ignore next */
    return 0;
  },
  "1": function (targetDoc, sourceDoc) {
    // This is the comparison function ported from CouchDB
    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;
  }
};

Checkpointer.prototype.getCheckpoint = function () {
  var self = this;

  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {
    return self.src.get(self.id).then(function (sourceDoc) {
      return sourceDoc.last_seq || LOWEST_SEQ;
    }).catch(function (err) {
      /* istanbul ignore if */
      if (err.status !== 404) {
        throw err;
      }
      return LOWEST_SEQ;
    });
  }

  return self.target.get(self.id).then(function (targetDoc) {
    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {
      return targetDoc.last_seq || LOWEST_SEQ;
    }

    return self.src.get(self.id).then(function (sourceDoc) {
      // Since we can't migrate an old version doc to a new one
      // (no session id), we just go with the lowest seq in this case
      /* istanbul ignore if */
      if (targetDoc.version !== sourceDoc.version) {
        return LOWEST_SEQ;
      }

      var version;
      if (targetDoc.version) {
        version = targetDoc.version.toString();
      } else {
        version = "undefined";
      }

      if (version in comparisons) {
        return comparisons[version](targetDoc, sourceDoc);
      }
      /* istanbul ignore next */
      return LOWEST_SEQ;
    }, function (err) {
      if (err.status === 404 && targetDoc.last_seq) {
        return self.src.put({
          _id: self.id,
          last_seq: LOWEST_SEQ
        }).then(function () {
          return LOWEST_SEQ;
        }, function (err) {
          if (isForbiddenError(err)) {
            self.opts.writeSourceCheckpoint = false;
            return targetDoc.last_seq;
          }
          /* istanbul ignore next */
          return LOWEST_SEQ;
        });
      }
      throw err;
    });
  }).catch(function (err) {
    if (err.status !== 404) {
      throw err;
    }
    return LOWEST_SEQ;
  });
};
// This checkpoint comparison is ported from CouchDBs source
// they come from here:
// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906

function compareReplicationLogs(srcDoc, tgtDoc) {
  if (srcDoc.session_id === tgtDoc.session_id) {
    return {
      last_seq: srcDoc.last_seq,
      history: srcDoc.history
    };
  }

  return compareReplicationHistory(srcDoc.history, tgtDoc.history);
}

function compareReplicationHistory(sourceHistory, targetHistory) {
  // the erlang loop via function arguments is not so easy to repeat in JS
  // therefore, doing this as recursion
  var S = sourceHistory[0];
  var sourceRest = sourceHistory.slice(1);
  var T = targetHistory[0];
  var targetRest = targetHistory.slice(1);

  if (!S || targetHistory.length === 0) {
    return {
      last_seq: LOWEST_SEQ,
      history: []
    };
  }

  var sourceId = S.session_id;
  /* istanbul ignore if */
  if (hasSessionId(sourceId, targetHistory)) {
    return {
      last_seq: S.last_seq,
      history: sourceHistory
    };
  }

  var targetId = T.session_id;
  if (hasSessionId(targetId, sourceRest)) {
    return {
      last_seq: T.last_seq,
      history: targetRest
    };
  }

  return compareReplicationHistory(sourceRest, targetRest);
}

function hasSessionId(sessionId, history) {
  var props = history[0];
  var rest = history.slice(1);

  if (!sessionId || history.length === 0) {
    return false;
  }

  if (sessionId === props.session_id) {
    return true;
  }

  return hasSessionId(sessionId, rest);
}

function isForbiddenError(err) {
  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;
}

var STARTING_BACK_OFF = 0;

function backOff(opts, returnValue, error, callback) {
  if (opts.retry === false) {
    returnValue.emit('error', error);
    returnValue.removeAllListeners();
    return;
  }
  /* istanbul ignore if */
  if (typeof opts.back_off_function !== 'function') {
    opts.back_off_function = defaultBackOff;
  }
  returnValue.emit('requestError', error);
  if (returnValue.state === 'active' || returnValue.state === 'pending') {
    returnValue.emit('paused', error);
    returnValue.state = 'stopped';
    var backOffSet = function backoffTimeSet() {
      opts.current_back_off = STARTING_BACK_OFF;
    };
    var removeBackOffSetter = function removeBackOffTimeSet() {
      returnValue.removeListener('active', backOffSet);
    };
    returnValue.once('paused', removeBackOffSetter);
    returnValue.once('active', backOffSet);
  }

  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;
  opts.current_back_off = opts.back_off_function(opts.current_back_off);
  setTimeout(callback, opts.current_back_off);
}

function sortObjectPropertiesByKey(queryParams) {
  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {
    result[key] = queryParams[key];
    return result;
  }, {});
}

// Generate a unique id particular to this replication.
// Not guaranteed to align perfectly with CouchDB's rep ids.
function generateReplicationId(src, target, opts) {
  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';
  var filterFun = opts.filter ? opts.filter.toString() : '';
  var queryParams = '';
  var filterViewName =  '';
  var selector = '';

  // possibility for checkpoints to be lost here as behaviour of
  // JSON.stringify is not stable (see #6226)
  /* istanbul ignore if */
  if (opts.selector) {
    selector = JSON.stringify(opts.selector);
  }

  if (opts.filter && opts.query_params) {
    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));
  }

  if (opts.filter && opts.filter === '_view') {
    filterViewName = opts.view.toString();
  }

  return Promise.all([src.id(), target.id()]).then(function (res) {
    var queryData = res[0] + res[1] + filterFun + filterViewName +
      queryParams + docIds + selector;
    return new Promise(function (resolve) {
      binaryMd5(queryData, resolve);
    });
  }).then(function (md5sum) {
    // can't use straight-up md5 alphabet, because
    // the char '/' is interpreted as being for attachments,
    // and + is also not url-safe
    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');
    return '_local/' + md5sum;
  });
}

function replicate(src, target, opts, returnValue, result) {
  var batches = [];               // list of batches to be processed
  var currentBatch;               // the batch currently being processed
  var pendingBatch = {
    seq: 0,
    changes: [],
    docs: []
  }; // next batch, not yet ready to be processed
  var writingCheckpoint = false;  // true while checkpoint is being written
  var changesCompleted = false;   // true when all changes received
  var replicationCompleted = false; // true when replication has completed
  var last_seq = 0;
  var continuous = opts.continuous || opts.live || false;
  var batch_size = opts.batch_size || 100;
  var batches_limit = opts.batches_limit || 10;
  var changesPending = false;     // true while src.changes is running
  var doc_ids = opts.doc_ids;
  var selector = opts.selector;
  var repId;
  var checkpointer;
  var changedDocs = [];
  // Like couchdb, every replication gets a unique session id
  var session = uuid();

  result = result || {
    ok: true,
    start_time: new Date().toISOString(),
    docs_read: 0,
    docs_written: 0,
    doc_write_failures: 0,
    errors: []
  };

  var changesOpts = {};
  returnValue.ready(src, target);

  function initCheckpointer() {
    if (checkpointer) {
      return Promise.resolve();
    }
    return generateReplicationId(src, target, opts).then(function (res) {
      repId = res;

      var checkpointOpts = {};
      if (opts.checkpoint === false) {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'source') {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'target') {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };
      } else {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };
      }

      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);
    });
  }

  function writeDocs() {
    changedDocs = [];

    if (currentBatch.docs.length === 0) {
      return;
    }
    var docs = currentBatch.docs;
    var bulkOpts = {timeout: opts.timeout};
    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }

      // \`res\` doesn't include full documents (which live in \`docs\`), so we create a map of 
      // (id -> error), and check for errors while iterating over \`docs\`
      var errorsById = Object.create(null);
      res.forEach(function (res) {
        if (res.error) {
          errorsById[res.id] = res;
        }
      });

      var errorsNo = Object.keys(errorsById).length;
      result.doc_write_failures += errorsNo;
      result.docs_written += docs.length - errorsNo;

      docs.forEach(function (doc) {
        var error = errorsById[doc._id];
        if (error) {
          result.errors.push(error);
          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
          var errorName = (error.name || '').toLowerCase();
          if (errorName === 'unauthorized' || errorName === 'forbidden') {
            returnValue.emit('denied', clone(error));
          } else {
            throw error;
          }
        } else {
          changedDocs.push(doc);
        }
      });

    }, function (err) {
      result.doc_write_failures += docs.length;
      throw err;
    });
  }

  function finishBatch() {
    if (currentBatch.error) {
      throw new Error('There was a problem getting docs.');
    }
    result.last_seq = last_seq = currentBatch.seq;
    var outResult = clone(result);
    if (changedDocs.length) {
      outResult.docs = changedDocs;
      // Attach 'pending' property if server supports it (CouchDB 2.0+)
      /* istanbul ignore if */
      if (typeof currentBatch.pending === 'number') {
        outResult.pending = currentBatch.pending;
        delete currentBatch.pending;
      }
      returnValue.emit('change', outResult);
    }
    writingCheckpoint = true;
    return checkpointer.writeCheckpoint(currentBatch.seq,
        session).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      currentBatch = undefined;
      getChanges();
    }).catch(function (err) {
      onCheckpointError(err);
      throw err;
    });
  }

  function getDiffs() {
    var diff = {};
    currentBatch.changes.forEach(function (change) {
      // Couchbase Sync Gateway emits these, but we can ignore them
      /* istanbul ignore if */
      if (change.id === "_user/") {
        return;
      }
      diff[change.id] = change.changes.map(function (x) {
        return x.rev;
      });
    });
    return target.revsDiff(diff).then(function (diffs) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      // currentBatch.diffs elements are deleted as the documents are written
      currentBatch.diffs = diffs;
    });
  }

  function getBatchDocs() {
    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {
      currentBatch.error = !got.ok;
      got.docs.forEach(function (doc) {
        delete currentBatch.diffs[doc._id];
        result.docs_read++;
        currentBatch.docs.push(doc);
      });
    });
  }

  function startNextBatch() {
    if (returnValue.cancelled || currentBatch) {
      return;
    }
    if (batches.length === 0) {
      processPendingBatch(true);
      return;
    }
    currentBatch = batches.shift();
    getDiffs()
      .then(getBatchDocs)
      .then(writeDocs)
      .then(finishBatch)
      .then(startNextBatch)
      .catch(function (err) {
        abortReplication('batch processing terminated with error', err);
      });
  }


  function processPendingBatch(immediate$$1) {
    if (pendingBatch.changes.length === 0) {
      if (batches.length === 0 && !currentBatch) {
        if ((continuous && changesOpts.live) || changesCompleted) {
          returnValue.state = 'pending';
          returnValue.emit('paused');
        }
        if (changesCompleted) {
          completeReplication();
        }
      }
      return;
    }
    if (
      immediate$$1 ||
      changesCompleted ||
      pendingBatch.changes.length >= batch_size
    ) {
      batches.push(pendingBatch);
      pendingBatch = {
        seq: 0,
        changes: [],
        docs: []
      };
      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {
        returnValue.state = 'active';
        returnValue.emit('active');
      }
      startNextBatch();
    }
  }


  function abortReplication(reason, err) {
    if (replicationCompleted) {
      return;
    }
    if (!err.message) {
      err.message = reason;
    }
    result.ok = false;
    result.status = 'aborting';
    batches = [];
    pendingBatch = {
      seq: 0,
      changes: [],
      docs: []
    };
    completeReplication(err);
  }


  function completeReplication(fatalError) {
    if (replicationCompleted) {
      return;
    }
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      result.status = 'cancelled';
      if (writingCheckpoint) {
        return;
      }
    }
    result.status = result.status || 'complete';
    result.end_time = new Date().toISOString();
    result.last_seq = last_seq;
    replicationCompleted = true;

    if (fatalError) {
      // need to extend the error because Firefox considers ".result" read-only
      fatalError = createError(fatalError);
      fatalError.result = result;

      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
      var errorName = (fatalError.name || '').toLowerCase();
      if (errorName === 'unauthorized' || errorName === 'forbidden') {
        returnValue.emit('error', fatalError);
        returnValue.removeAllListeners();
      } else {
        backOff(opts, returnValue, fatalError, function () {
          replicate(src, target, opts, returnValue);
        });
      }
    } else {
      returnValue.emit('complete', result);
      returnValue.removeAllListeners();
    }
  }


  function onChange(change, pending, lastSeq) {
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    // Attach 'pending' property if server supports it (CouchDB 2.0+)
    /* istanbul ignore if */
    if (typeof pending === 'number') {
      pendingBatch.pending = pending;
    }

    var filter = filterChange(opts)(change);
    if (!filter) {
      return;
    }
    pendingBatch.seq = change.seq || lastSeq;
    pendingBatch.changes.push(change);
    immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
      processPendingBatch(batches.length === 0 && changesOpts.live);
    });
  }


  function onChangesComplete(changes) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }

    // if no results were returned then we're done,
    // else fetch more
    if (changes.results.length > 0) {
      changesOpts.since = changes.results[changes.results.length - 1].seq;
      getChanges();
      processPendingBatch(true);
    } else {

      var complete = function () {
        if (continuous) {
          changesOpts.live = true;
          getChanges();
        } else {
          changesCompleted = true;
        }
        processPendingBatch(true);
      };

      // update the checkpoint so we start from the right seq next time
      if (!currentBatch && changes.results.length === 0) {
        writingCheckpoint = true;
        checkpointer.writeCheckpoint(changes.last_seq,
            session).then(function () {
          writingCheckpoint = false;
          result.last_seq = last_seq = changes.last_seq;
          complete();
        })
        .catch(onCheckpointError);
      } else {
        complete();
      }
    }
  }


  function onChangesError(err) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    abortReplication('changes rejected', err);
  }


  function getChanges() {
    if (!(
      !changesPending &&
      !changesCompleted &&
      batches.length < batches_limit
      )) {
      return;
    }
    changesPending = true;
    function abortChanges() {
      changes.cancel();
    }
    function removeListener() {
      returnValue.removeListener('cancel', abortChanges);
    }

    if (returnValue._changes) { // remove old changes() and listeners
      returnValue.removeListener('cancel', returnValue._abortChanges);
      returnValue._changes.cancel();
    }
    returnValue.once('cancel', abortChanges);

    var changes = src.changes(changesOpts)
      .on('change', onChange);
    changes.then(removeListener, removeListener);
    changes.then(onChangesComplete)
      .catch(onChangesError);

    if (opts.retry) {
      // save for later so we can cancel if necessary
      returnValue._changes = changes;
      returnValue._abortChanges = abortChanges;
    }
  }


  function startChanges() {
    initCheckpointer().then(function () {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      return checkpointer.getCheckpoint().then(function (checkpoint) {
        last_seq = checkpoint;
        changesOpts = {
          since: last_seq,
          limit: batch_size,
          batch_size: batch_size,
          style: 'all_docs',
          doc_ids: doc_ids,
          selector: selector,
          return_docs: true // required so we know when we're done
        };
        if (opts.filter) {
          if (typeof opts.filter !== 'string') {
            // required for the client-side filter in onChange
            changesOpts.include_docs = true;
          } else { // ddoc filter
            changesOpts.filter = opts.filter;
          }
        }
        if ('heartbeat' in opts) {
          changesOpts.heartbeat = opts.heartbeat;
        }
        if ('timeout' in opts) {
          changesOpts.timeout = opts.timeout;
        }
        if (opts.query_params) {
          changesOpts.query_params = opts.query_params;
        }
        if (opts.view) {
          changesOpts.view = opts.view;
        }
        getChanges();
      });
    }).catch(function (err) {
      abortReplication('getCheckpoint rejected with ', err);
    });
  }

  /* istanbul ignore next */
  function onCheckpointError(err) {
    writingCheckpoint = false;
    abortReplication('writeCheckpoint completed with error', err);
  }

  /* istanbul ignore if */
  if (returnValue.cancelled) { // cancelled immediately
    completeReplication();
    return;
  }

  if (!returnValue._addedListeners) {
    returnValue.once('cancel', completeReplication);

    if (typeof opts.complete === 'function') {
      returnValue.once('error', opts.complete);
      returnValue.once('complete', function (result) {
        opts.complete(null, result);
      });
    }
    returnValue._addedListeners = true;
  }

  if (typeof opts.since === 'undefined') {
    startChanges();
  } else {
    initCheckpointer().then(function () {
      writingCheckpoint = true;
      return checkpointer.writeCheckpoint(opts.since, session);
    }).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      last_seq = opts.since;
      startChanges();
    }).catch(onCheckpointError);
  }
}

// We create a basic promise so the caller can cancel the replication possibly
// before we have actually started listening to changes etc
inherits__WEBPACK_IMPORTED_MODULE_5___default()(Replication, events__WEBPACK_IMPORTED_MODULE_6___default.a);
function Replication() {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);
  this.cancelled = false;
  this.state = 'pending';
  var self = this;
  var promise = new Promise(function (fulfill, reject) {
    self.once('complete', fulfill);
    self.once('error', reject);
  });
  self.then = function (resolve, reject) {
    return promise.then(resolve, reject);
  };
  self.catch = function (reject) {
    return promise.catch(reject);
  };
  // As we allow error handling via "error" event as well,
  // put a stub in here so that rejecting never throws UnhandledError.
  self.catch(function () {});
}

Replication.prototype.cancel = function () {
  this.cancelled = true;
  this.state = 'cancelled';
  this.emit('cancel');
};

Replication.prototype.ready = function (src, target) {
  var self = this;
  if (self._readyCalled) {
    return;
  }
  self._readyCalled = true;

  function onDestroy() {
    self.cancel();
  }
  src.once('destroyed', onDestroy);
  target.once('destroyed', onDestroy);
  function cleanup() {
    src.removeListener('destroyed', onDestroy);
    target.removeListener('destroyed', onDestroy);
  }
  self.once('complete', cleanup);
};

function toPouch(db, opts) {
  var PouchConstructor = opts.PouchConstructor;
  if (typeof db === 'string') {
    return new PouchConstructor(db, opts);
  } else {
    return db;
  }
}

function replicateWrapper(src, target, opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }

  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {
    throw createError(BAD_REQUEST,
                       "\`doc_ids\` filter parameter is not a list.");
  }

  opts.complete = callback;
  opts = clone(opts);
  opts.continuous = opts.continuous || opts.live;
  opts.retry = ('retry' in opts) ? opts.retry : false;
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  var replicateRet = new Replication(opts);
  var srcPouch = toPouch(src, opts);
  var targetPouch = toPouch(target, opts);
  replicate(srcPouch, targetPouch, opts, replicateRet);
  return replicateRet;
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(Sync, events__WEBPACK_IMPORTED_MODULE_6___default.a);
function sync(src, target, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }
  opts = clone(opts);
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  src = toPouch(src, opts);
  target = toPouch(target, opts);
  return new Sync(src, target, opts, callback);
}

function Sync(src, target, opts, callback) {
  var self = this;
  this.canceled = false;

  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;
  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;

  this.push = replicateWrapper(src, target, optsPush);
  this.pull = replicateWrapper(target, src, optsPull);

  this.pushPaused = true;
  this.pullPaused = true;

  function pullChange(change) {
    self.emit('change', {
      direction: 'pull',
      change: change
    });
  }
  function pushChange(change) {
    self.emit('change', {
      direction: 'push',
      change: change
    });
  }
  function pushDenied(doc) {
    self.emit('denied', {
      direction: 'push',
      doc: doc
    });
  }
  function pullDenied(doc) {
    self.emit('denied', {
      direction: 'pull',
      doc: doc
    });
  }
  function pushPaused() {
    self.pushPaused = true;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('paused');
    }
  }
  function pullPaused() {
    self.pullPaused = true;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('paused');
    }
  }
  function pushActive() {
    self.pushPaused = false;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('active', {
        direction: 'push'
      });
    }
  }
  function pullActive() {
    self.pullPaused = false;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('active', {
        direction: 'pull'
      });
    }
  }

  var removed = {};

  function removeAll(type) { // type is 'push' or 'pull'
    return function (event, func) {
      var isChange = event === 'change' &&
        (func === pullChange || func === pushChange);
      var isDenied = event === 'denied' &&
        (func === pullDenied || func === pushDenied);
      var isPaused = event === 'paused' &&
        (func === pullPaused || func === pushPaused);
      var isActive = event === 'active' &&
        (func === pullActive || func === pushActive);

      if (isChange || isDenied || isPaused || isActive) {
        if (!(event in removed)) {
          removed[event] = {};
        }
        removed[event][type] = true;
        if (Object.keys(removed[event]).length === 2) {
          // both push and pull have asked to be removed
          self.removeAllListeners(event);
        }
      }
    };
  }

  if (opts.live) {
    this.push.on('complete', self.pull.cancel.bind(self.pull));
    this.pull.on('complete', self.push.cancel.bind(self.push));
  }

  function addOneListener(ee, event, listener) {
    if (ee.listeners(event).indexOf(listener) == -1) {
      ee.on(event, listener);
    }
  }

  this.on('newListener', function (event) {
    if (event === 'change') {
      addOneListener(self.pull, 'change', pullChange);
      addOneListener(self.push, 'change', pushChange);
    } else if (event === 'denied') {
      addOneListener(self.pull, 'denied', pullDenied);
      addOneListener(self.push, 'denied', pushDenied);
    } else if (event === 'active') {
      addOneListener(self.pull, 'active', pullActive);
      addOneListener(self.push, 'active', pushActive);
    } else if (event === 'paused') {
      addOneListener(self.pull, 'paused', pullPaused);
      addOneListener(self.push, 'paused', pushPaused);
    }
  });

  this.on('removeListener', function (event) {
    if (event === 'change') {
      self.pull.removeListener('change', pullChange);
      self.push.removeListener('change', pushChange);
    } else if (event === 'denied') {
      self.pull.removeListener('denied', pullDenied);
      self.push.removeListener('denied', pushDenied);
    } else if (event === 'active') {
      self.pull.removeListener('active', pullActive);
      self.push.removeListener('active', pushActive);
    } else if (event === 'paused') {
      self.pull.removeListener('paused', pullPaused);
      self.push.removeListener('paused', pushPaused);
    }
  });

  this.pull.on('removeListener', removeAll('pull'));
  this.push.on('removeListener', removeAll('push'));

  var promise = Promise.all([
    this.push,
    this.pull
  ]).then(function (resp) {
    var out = {
      push: resp[0],
      pull: resp[1]
    };
    self.emit('complete', out);
    if (callback) {
      callback(null, out);
    }
    self.removeAllListeners();
    return out;
  }, function (err) {
    self.cancel();
    if (callback) {
      // if there's a callback, then the callback can receive
      // the error event
      callback(err);
    } else {
      // if there's no callback, then we're safe to emit an error
      // event, which would otherwise throw an unhandled error
      // due to 'error' being a special event in EventEmitters
      self.emit('error', err);
    }
    self.removeAllListeners();
    if (callback) {
      // no sense throwing if we're already emitting an 'error' event
      throw err;
    }
  });

  this.then = function (success, err) {
    return promise.then(success, err);
  };

  this.catch = function (err) {
    return promise.catch(err);
  };
}

Sync.prototype.cancel = function () {
  if (!this.canceled) {
    this.canceled = true;
    this.push.cancel();
    this.pull.cancel();
  }
};

function replication(PouchDB) {
  PouchDB.replicate = replicateWrapper;
  PouchDB.sync = sync;

  Object.defineProperty(PouchDB.prototype, 'replicate', {
    get: function () {
      var self = this;
      if (typeof this.replicateMethods === 'undefined') {
        this.replicateMethods = {
          from: function (other, opts, callback) {
            return self.constructor.replicate(other, self, opts, callback);
          },
          to: function (other, opts, callback) {
            return self.constructor.replicate(self, other, opts, callback);
          }
        };
      }
      return this.replicateMethods;
    }
  });

  PouchDB.prototype.sync = function (dbName, opts, callback) {
    return this.constructor.sync(this, dbName, opts, callback);
  };
}

PouchDB.plugin(IDBPouch)
  .plugin(HttpPouch$1)
  .plugin(mapreduce)
  .plugin(replication);

/* harmony default export */ __webpack_exports__["default"] = (PouchDB);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/lib/index.es.js?`)},"./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js":function(module,exports){eval(`if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js?`)},"./node_modules/pouchdb-browser/node_modules/spark-md5/spark-md5.js":function(module,exports,__webpack_require__){eval(`(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\\u0080-\\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/spark-md5/spark-md5.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  return (bth[buf[i + 0]] + bth[buf[i + 1]] + bth[buf[i + 2]] + bth[buf[i + 3]] + '-' + bth[buf[i + 4]] + bth[buf[i + 5]] + '-' + bth[buf[i + 6]] + bth[buf[i + 7]] + '-' + bth[buf[i + 8]] + bth[buf[i + 9]] + '-' + bth[buf[i + 10]] + bth[buf[i + 11]] + bth[buf[i + 12]] + bth[buf[i + 13]] + bth[buf[i + 14]] + bth[buf[i + 15]]).toLowerCase();
}

/* harmony default export */ __webpack_exports__["default"] = (bytesToUuid);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/index.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v1", function() { return _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v3", function() { return _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v4", function() { return _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v5", function() { return _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });






//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/index.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/md5.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ __webpack_exports__["default"] = (md5);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/md5.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rng; });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
var getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
  }

  return getRandomValues(rnds8);
}

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/sha1.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ __webpack_exports__["default"] = (sha1);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/sha1.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v1.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytesToUuid.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js");

 // **\`v1()\` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // \`time_low\`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // \`time_mid\`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // \`time_high_and_version\`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // \`clock_seq_hi_and_reserved\` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // \`clock_seq_low\`

  b[i++] = clockseq & 0xff; // \`node\`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ __webpack_exports__["default"] = (v1);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v1.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v3.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/md5.js");


var v3 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (v3);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v3.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DNS", function() { return DNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URL", function() { return URL; });
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytesToUuid.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js");


function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ __webpack_exports__["default"] = (function (name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value === 'string') value = stringToBytes(value);
    if (typeof namespace === 'string') namespace = uuidToBytes(namespace);

    if (!Array.isArray(value)) {
      throw TypeError('value must be an array of bytes');
    }

    if (!Array.isArray(namespace) || namespace.length !== 16) {
      throw TypeError('namespace must be uuid string or an Array of 16 byte values');
    } // Per 4.3


    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }

    return buf || Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
});

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v4.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytesToUuid.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js");



function v4(options, buf, offset) {
  if (typeof options === 'string') {
    buf = options === 'binary' ? new Uint8Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and \`clock_seq_hi_and_reserved\`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    var start = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[start + i] = rnds[i];
    }

    return buf;
  }

  return Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ __webpack_exports__["default"] = (v4);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v4.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v5.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (v5);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v5.js?`)},"./node_modules/process/browser.js":function(module,exports){eval(`// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


//# sourceURL=webpack://%5Bname%5D/./node_modules/process/browser.js?`)},"./node_modules/spark-md5/spark-md5.js":function(module,exports,__webpack_require__){eval(`(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\\u0080-\\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


//# sourceURL=webpack://%5Bname%5D/./node_modules/spark-md5/spark-md5.js?`)},"./node_modules/uri-js/dist/es5/uri.all.js":function(module,exports,__webpack_require__){eval(`/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\\\x0A]",
        SP$$ = "[\\\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]",
        SUB_DELIMS$$ = "[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\\\uE000-\\\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\\\-\\\\.\\\\_\\\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\\\+\\\\-\\\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,1}" + H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,2}" + H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,3}" + H16$) + "?\\\\:\\\\:" + H16$ + "\\\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,4}" + H16$) + "?\\\\:\\\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,5}" + H16$) + "?\\\\:\\\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,6}" + H16$) + "?\\\\:\\\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\\\%25|\\\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:]") + "+"),
        IP_LITERAL$ = subexp("\\\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\\\/\\\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\\\/\\\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\\\/\\\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\\\:" + HIER_PART$ + subexp("\\\\?" + QUERY$) + "?" + subexp("\\\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\\\/\\\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\\\?" + QUERY$) + "?" + subexp("\\\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\\\:" + HIER_PART$ + subexp("\\\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\\\:" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\\\:" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\\\+\\\\-\\\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\\\%\\\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\\\%\\\\[\\\\]\\\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\\\%\\\\/\\\\:\\\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\\\%\\\\/\\\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@\\\\/\\\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@\\\\/\\\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\\\%25|\\\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars
var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a \`RangeError\` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic \`Array#map\` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple \`Array#map\`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to \`@\`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid \`split(regex)\` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see \`punycode.ucs2.encode\`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see \`punycode.ucs2.decode\`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see \`digitToBasic()\`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range \`0\` to \`base - 1\`, or \`base\` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see \`basicToDigit()\`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is \`digit\`, which needs to be in the range
 * \`0\` to \`base - 1\`. If \`flag\` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if \`flag\` is non-zero and \`digit\` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let \`basic\` be the number of input code
	// points before the last delimiter, or \`0\` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// \`index\` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into \`delta\`,
		// which gets added to \`i\`. The overflow checking is easier
		// if we increase \`i\` as we go, then subtract off its starting
		// value at the end to obtain \`delta\`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// \`i\` was supposed to wrap around from \`out\` to \`0\`,
		// incrementing \`n\` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert \`n\` at position \`i\` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// \`handledCPCount\` is the number of code points that have been handled;
	// \`basicLength\` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase \`delta\` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT \`\`AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\\.\\.?\\//;
var RDS2 = /^\\/\\.(\\/|$)/;
var RDS3 = /^\\/\\.\\.(\\/|$)/;
var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\\/\\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~" + (isIRI ? "\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\\`\\\\{\\\\|\\\\}\\\\~]";
//const WSP$$ = "[\\\\x20\\\\x09]";
//const OBS_QTEXT$$ = "[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\\\x21-\\\\x7E]";
//const WSP$$ = "[\\\\x20\\\\x09]";
//const OBS_QP$ = subexp("\\\\\\\\" + merge("[\\\\x00\\\\x0D\\\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\\\x0D\\\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\\\"');
var ATEXT$$ = "[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\\`\\\\{\\\\|\\\\}\\\\~]";
var QTEXT$$ = "[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\\\\"\\\\\\\\]");
var SOME_DELIMS$$ = "[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\\\.]", '[\\\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\\:]+)\\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map


//# sourceURL=webpack://%5Bname%5D/./node_modules/uri-js/dist/es5/uri.all.js?`)},"./node_modules/vuvuzela/index.js":function(module,exports,__webpack_require__){eval(`

/**
 * Stringify/parse functions that don't operate
 * recursively, so they avoid call stack exceeded
 * errors.
 */
exports.stringify = function stringify(input) {
  var queue = [];
  queue.push({obj: input});

  var res = '';
  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
  while ((next = queue.pop())) {
    obj = next.obj;
    prefix = next.prefix || '';
    val = next.val || '';
    res += prefix;
    if (val) {
      res += val;
    } else if (typeof obj !== 'object') {
      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
    } else if (obj === null) {
      res += 'null';
    } else if (Array.isArray(obj)) {
      queue.push({val: ']'});
      for (i = obj.length - 1; i >= 0; i--) {
        arrayPrefix = i === 0 ? '' : ',';
        queue.push({obj: obj[i], prefix: arrayPrefix});
      }
      queue.push({val: '['});
    } else { // object
      keys = [];
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          keys.push(k);
        }
      }
      queue.push({val: '}'});
      for (i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        value = obj[key];
        objPrefix = (i > 0 ? ',' : '');
        objPrefix += JSON.stringify(key) + ':';
        queue.push({obj: value, prefix: objPrefix});
      }
      queue.push({val: '{'});
    }
  }
  return res;
};

// Convenience function for the parse function.
// This pop function is basically copied from
// pouchCollate.parseIndexableString
function pop(obj, stack, metaStack) {
  var lastMetaElement = metaStack[metaStack.length - 1];
  if (obj === lastMetaElement.element) {
    // popping a meta-element, e.g. an object whose value is another object
    metaStack.pop();
    lastMetaElement = metaStack[metaStack.length - 1];
  }
  var element = lastMetaElement.element;
  var lastElementIndex = lastMetaElement.index;
  if (Array.isArray(element)) {
    element.push(obj);
  } else if (lastElementIndex === stack.length - 2) { // obj with key+value
    var key = stack.pop();
    element[key] = obj;
  } else {
    stack.push(obj); // obj with key only
  }
}

exports.parse = function (str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;
  var collationIndex,parsedNum,numChar;
  var parsedString,lastCh,numConsecutiveSlashes,ch;
  var arrayElement, objElement;
  while (true) {
    collationIndex = str[i++];
    if (collationIndex === '}' ||
        collationIndex === ']' ||
        typeof collationIndex === 'undefined') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack.pop(), stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case ' ':
      case '\\t':
      case '\\n':
      case ':':
      case ',':
        break;
      case 'n':
        i += 3; // 'ull'
        pop(null, stack, metaStack);
        break;
      case 't':
        i += 3; // 'rue'
        pop(true, stack, metaStack);
        break;
      case 'f':
        i += 4; // 'alse'
        pop(false, stack, metaStack);
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        parsedNum = '';
        i--;
        while (true) {
          numChar = str[i++];
          if (/[\\d\\.\\-e\\+]/.test(numChar)) {
            parsedNum += numChar;
          } else {
            i--;
            break;
          }
        }
        pop(parseFloat(parsedNum), stack, metaStack);
        break;
      case '"':
        parsedString = '';
        lastCh = void 0;
        numConsecutiveSlashes = 0;
        while (true) {
          ch = str[i++];
          if (ch !== '"' || (lastCh === '\\\\' &&
              numConsecutiveSlashes % 2 === 1)) {
            parsedString += ch;
            lastCh = ch;
            if (lastCh === '\\\\') {
              numConsecutiveSlashes++;
            } else {
              numConsecutiveSlashes = 0;
            }
          } else {
            break;
          }
        }
        pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
        break;
      case '[':
        arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '{':
        objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      default:
        throw new Error(
          'unexpectedly reached end of input: ' + collationIndex);
    }
  }
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/vuvuzela/index.js?`)},"./node_modules/webpack/buildin/amd-define.js":function(module,exports){eval(`module.exports = function() {
	throw new Error("define cannot be used indirect");
};


//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/amd-define.js?`)},"./node_modules/webpack/buildin/amd-options.js":function(module,exports){eval(`/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/amd-options.js?`)},"./node_modules/webpack/buildin/global.js":function(module,exports){eval(`var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/global.js?`)},"./node_modules/webpack/buildin/module.js":function(module,exports){eval(`module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/module.js?`)},"./package.json":function(module){eval(`module.exports = JSON.parse("{\\"name\\":\\"imjoy-core\\",\\"version\\":\\"0.14.4\\",\\"private\\":false,\\"description\\":\\"The core library for ImJoy -- a sandboxed plugin framework for computational web applications.\\",\\"author\\":\\"imjoy-team <imjoy.team@gmail.com>\\",\\"license\\":\\"MIT\\",\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/imjoy-team/imjoy-core.git\\"},\\"keywords\\":[\\"ImJoy\\",\\"PWA\\",\\"Deep Learning\\"],\\"bugs\\":{\\"url\\":\\"https://github.com/imjoy-team/ImJoy/issues\\"},\\"homepage\\":\\"https://imjoy.io\\",\\"module\\":\\"index.js\\",\\"scripts\\":{\\"serve\\":\\"webpack-dev-server --config webpack.config.js --mode development\\",\\"build\\":\\"rm -rf dist && npm run build-prod && npm run build-dev\\",\\"build-prod\\":\\"NODE_ENV=production webpack --config webpack.config.js --mode production  --devtool source-map\\",\\"build-dev\\":\\"NODE_ENV=development webpack --config webpack.config.js --mode development\\",\\"watch\\":\\"webpack --watch --progress --config  webpack.config.js --mode development\\",\\"check-format\\":\\"prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"format\\":\\"prettier --write \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"lint\\":\\"eslint \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"check\\":\\"eslint \\\\\\"{src,tests}/**/**\\\\\\" && prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"test\\":\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\",\\"test-watch\\":\\"karma start --auto-watch --browsers Chrome,FirefoxHeadless karma.conf.js --debug\\",\\"deploy\\":\\"npm run build && node deploy-site.js\\",\\"publish-npm\\":\\"npm install && npm run build && npm publish\\"},\\"dependencies\\":{\\"ajv\\":\\"^6.9.1\\",\\"axios\\":\\"^0.21.1\\",\\"dompurify\\":\\"^2.0.8\\",\\"file-saver\\":\\"^1.3.3\\",\\"imjoy-rpc\\":\\"^0.5.9\\",\\"js-yaml\\":\\"^3.13.1\\",\\"lodash\\":\\"^4.17.15\\",\\"lz-string\\":\\"^1.4.4\\",\\"minibus\\":\\"^3.1.0\\",\\"pouchdb-browser\\":\\"^7.2.2\\",\\"socket.io-client\\":\\"^2.3.0\\",\\"spark-md5\\":\\"^3.0.0\\"},\\"devDependencies\\":{\\"@babel/core\\":\\"^7.0.0-beta.39\\",\\"@babel/plugin-syntax-dynamic-import\\":\\"^7.0.0-beta.39\\",\\"@babel/polyfill\\":\\"^7.0.0-beta.39\\",\\"@babel/preset-env\\":\\"^7.0.0-beta.39\\",\\"@types/requirejs\\":\\"^2.1.28\\",\\"babel-core\\":\\"^6.26.0\\",\\"babel-eslint\\":\\"^10.1.0\\",\\"babel-loader\\":\\"^8.1.0\\",\\"babel-plugin-lodash\\":\\"^3.3.4\\",\\"babel-runtime\\":\\"^6.26.0\\",\\"chai\\":\\"^4.1.2\\",\\"cname-webpack-plugin\\":\\"^1.0.3\\",\\"copy-webpack-plugin\\":\\"^5.1.1\\",\\"create-file-webpack\\":\\"^1.0.2\\",\\"cross-env\\":\\"^5.0.1\\",\\"cross-spawn\\":\\"^5.0.1\\",\\"eslint\\":\\"^6.8.0\\",\\"eslint-config-prettier\\":\\"^4.2.0\\",\\"gh-pages\\":\\"^2.0.1\\",\\"husky\\":\\"^4.2.3\\",\\"karma\\":\\"^6.1.1\\",\\"karma-chrome-launcher\\":\\"^3.1.0\\",\\"karma-firefox-launcher\\":\\"^1.3.0\\",\\"karma-mocha\\":\\"^1.3.0\\",\\"karma-spec-reporter\\":\\"0.0.32\\",\\"karma-webpack\\":\\"^4.0.2\\",\\"lint-staged\\":\\"^10.0.8\\",\\"mocha\\":\\"^7.1.0\\",\\"postcss-import\\":\\"^11.0.0\\",\\"postcss-loader\\":\\"^2.0.8\\",\\"postcss-url\\":\\"^7.2.1\\",\\"prettier\\":\\"1.17.0\\",\\"raw-loader\\":\\"^1.0.0\\",\\"rename-output-webpack-plugin\\":\\"^1.0.1\\",\\"uglify-es\\":\\"github:mishoo/UglifyJS2#harmony\\",\\"uglify-js\\":\\"^2.8.29\\",\\"url-loader\\":\\"^1.1.2\\",\\"webpack\\":\\"^4.42.0\\",\\"webpack-bundle-analyzer\\":\\"^3.7.0\\",\\"webpack-cli\\":\\"^3.3.6\\",\\"webpack-dev-server\\":\\"^3.1.1\\",\\"worker-loader\\":\\"^2.0.0\\"},\\"eslintConfig\\":{\\"root\\":true,\\"env\\":{\\"browser\\":true,\\"node\\":true,\\"es6\\":true},\\"extends\\":[\\"eslint:recommended\\"],\\"rules\\":{\\"no-console\\":\\"off\\",\\"no-debugger\\":\\"off\\",\\"no-empty\\":[\\"error\\",{\\"allowEmptyCatch\\":true}]},\\"parserOptions\\":{\\"parser\\":\\"babel-eslint\\",\\"ecmaVersion\\":2017,\\"sourceType\\":\\"module\\",\\"ecmaFeatures\\":{\\"modules\\":true}}},\\"prettier\\":{\\"trailingComma\\":\\"es5\\"},\\"postcss\\":{\\"plugins\\":{\\"autoprefixer\\":{}}},\\"browserslist\\":[\\"> 1%\\",\\"last 2 versions\\",\\"not ie <= 8\\"],\\"husky\\":{\\"hooks\\":{\\"pre-commit\\":\\"lint-staged\\"}},\\"lint-staged\\":{\\"{src,tests}/**/**}\\":\\"prettier --write\\"}}");

//# sourceURL=webpack://%5Bname%5D/./package.json?`)},"./src/api.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ajv", function() { return ajv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIGURABLE_FIELDS", function() { return CONFIGURABLE_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLUGIN_CONFIG_FIELDS", function() { return PLUGIN_CONFIG_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackends", function() { return getBackends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackendByType", function() { return getBackendByType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upgradePluginAPI", function() { return upgradePluginAPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLUGIN_SCHEMA", function() { return PLUGIN_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BACKEND_SCHEMA", function() { return BACKEND_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JOY_SCHEMA", function() { return JOY_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WINDOW_SCHEMA", function() { return WINDOW_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OP_SCHEMA", function() { return OP_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENGINE_FACTORY_SCHEMA", function() { return ENGINE_FACTORY_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENGINE_SCHEMA", function() { return ENGINE_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILE_MANAGER_SCHEMA", function() { return FILE_MANAGER_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG_SCHEMA", function() { return CONFIG_SCHEMA; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceSpec.js */ "./src/serviceSpec.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ajv */ "./node_modules/ajv/lib/ajv.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_2__);



const ajv = new ajv__WEBPACK_IMPORTED_MODULE_2___default.a();
ajv.addKeyword("file", {
  compile: function (config) {
    if (config && !config.mime && !config.ext && !(typeof config === "string")) throw new Error("Invalid config for keyword: file");

    if (config && config.maxSize) {
      if (typeof config.maxSize !== "number") throw new Error("maxSize must be a number");
    }

    if (config && config.minSize) {
      if (typeof config.minSize !== "number") throw new Error("minSize must be a number");
    }

    if (config && config.size) {
      if (typeof config.size !== "number" && !Array.isArray(config.size)) throw new Error("size must be a number");
    }

    return function (data) {
      if (!(data instanceof File)) return false;
      if (!config) return true;

      for (let k in config) {
        if (k === "mime") {
          const mime = config[k];
          let _ok = false;

          if (typeof mime === "string") {
            _ok = data.type.match(mime);
          } else if (Array.isArray(mime)) {
            for (let m of mime) {
              if (data.type.match(m)) {
                _ok = true;
              }
            }
          }

          if (!_ok) return false;
        }

        if (k === "ext") {
          const ext = config[k];
          let _ok = false;

          if (typeof ext === "string") {
            _ok = data.name.endsWith(ext);
          } else if (Array.isArray(ext)) {
            for (let e of ext) {
              if (data.name.endsWith(e)) {
                _ok = true;
              }
            }
          }

          if (!_ok) return false;
        }

        if (k === "maxSize") {
          if (data.size > config[k]) return false;
        }

        if (k === "minSize") {
          if (data.size < config[k]) return false;
        }

        if (k === "size") {
          if (Array.isArray(config[k]) && !config[k].includes(data.size)) return false;
          if (data.size !== config[k]) return false;
        }
      }

      return true;
    };
  }
});
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;
const _typedarray2dtype = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};

const _dtypes = Object.values(_typedarray2dtype);

ajv.addKeyword("ndarray", {
  compile: function (config) {
    if (config && config.ndim) {
      if (typeof config.ndim !== "number" && !Array.isArray(config.ndim)) {
        throw new Error("ndim must be a number");
      }
    }

    if (config && config.shape) {
      if (!Array.isArray(config.shape)) {
        throw new Error("shape must be an array");
      }

      if (config.ndim) {
        if (typeof config.ndim !== "number" || config.shape.length !== config.ndim) throw new Error("mismatch between shape and ndim");
      }
    }

    if (config && config.dtype) {
      if (typeof config.dtype !== "string" && !Array.isArray(config.dtype)) throw new Error("Invalid dtype format");
      let dtypes;
      if (typeof config.dtype === "string") dtypes = [config.dtype];else dtypes = config.dtype;

      for (let dt of dtypes) {
        if (typeof dt !== "string" || !_dtypes.includes(dt)) {
          throw new Error("Invalid dtype: " + dt + ", valid types: " + _dtypes.join(","));
        }
      }
    }

    return function (data) {
      const isndarray = data._rtype === "ndarray" && data._rvalue && data._rvalue instanceof ArrayBufferView && data._rshape && Array.isArray(data._rshape) && data._rdtype && _dtypes.includes(data._rdtype);

      if (!isndarray) return false;
      if (!config) return true;

      for (let k in config) {
        if (k === "shape") {
          const shape = config[k];
          if (data._rshape.length !== shape.length) return false;

          for (let i = 0; i < data._rshape.length; i++) {
            if (typeof shape[i] === "number" && data._rshape[i] !== shape[i]) {
              return false;
            }
          }
        }

        if (k === "dtype") {
          const dtype = config[k];
          let _ok = false;

          if (typeof dtype === "string") {
            _ok = data._rdtype === config[k];
          } else if (Array.isArray(dtype)) {
            _ok = dtype.includes(data._rdtype);
          }

          if (!_ok) return false;
        }

        if (k === "ndim") {
          const ndim = config[k];
          let _ok = false;

          if (typeof ndim === "number") {
            _ok = data._rshape.length === ndim;
          } else if (Array.isArray(ndim)) {
            _ok = ndim.includes(data._rshape.length);
          }

          if (!_ok) return false;
        }
      }

      return true;
    };
  }
});
ajv.addKeyword("instanceof", {
  compile: function (Class) {
    return function (data) {
      if (Array.isArray(Class)) {
        let match = false;

        for (let c of Class) {
          if (data instanceof c) {
            match = true;
            break;
          }
        }

        return match;
      } else {
        return data instanceof Class;
      }
    };
  }
});
const CONFIGURABLE_FIELDS = ["env", "requirements", "dependencies", "icon", "ui", "type", "flags", "labels", "cover", "base_frame", "base_worker", "passive"];
const PLUGIN_CONFIG_FIELDS = CONFIGURABLE_FIELDS.concat(["name", "type", "tags", "version", "api_version", "defaults", "inputs", "outputs", "permissions"]);
const _backends = {
  "web-worker": {
    type: "internal",
    name: "Web Worker",
    lang: "javascript"
  },
  iframe: {
    type: "internal",
    name: "IFrame",
    lang: "javascript",
    icon: "⚙️"
  },
  window: {
    type: "internal",
    name: "Window",
    lang: "javascript"
  },
  "rpc-window": {
    type: "external",
    name: "RPC Window",
    lang: "*",
    icon: "🌟"
  },
  "rpc-worker": {
    type: "external",
    name: "RPC Worker",
    lang: "*",
    icon: "⚙️"
  },
  collection: {
    type: "-",
    name: "Collection",
    lang: "*",
    icon: ""
  }
};
function getBackends() {
  return _backends;
}
function getBackendByType(type) {
  return _backends[type];
}
function upgradePluginAPI(config) {
  if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["compareVersions"])(config.api_version, "<=", "0.1.1")) {
    config.type = config.type || config.mode;
    delete config.mode;

    if (config.type === "pyworker") {
      config.type = "native-python";
    } else if (config.type === "webworker") {
      config.type = "web-worker";
    } else if (config.type === "webpython") {
      config.type = "web-python";
    }
  }

  return config;
}
const PLUGIN_SCHEMA = ajv.compile({
  properties: {
    _id: {
      type: ["null", "string"]
    },
    name: {
      type: "string"
    },
    code: {
      type: "string"
    },
    lang: {
      type: ["null", "string"]
    },
    script: {
      type: ["null", "string"]
    }
  }
});
const BACKEND_SCHEMA = ajv.compile({
  properties: {
    type: {
      type: "string"
    },
    name: {
      type: "string"
    },
    lang: {
      type: "string"
    },
    icon: {
      type: ["null", "string"]
    },
    connection: {}
  }
});
const JOY_SCHEMA = ajv.compile({
  properties: {
    name: {
      type: "string"
    },
    type: {
      type: "string"
    },
    init: {
      type: ["null", "string", "array", "object"]
    }
  }
});
const WINDOW_SCHEMA = ajv.compile({
  properties: {
    name: {
      type: "string"
    },
    type: {
      type: "string"
    },
    config: {
      type: ["null", "object"]
    },
    data: {
      type: ["null", "number", "string", "array", "object"]
    },
    //attachments: {}
    panel: {
      type: ["null", "object"]
    }
  }
});
const OP_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["operator"]);
const ENGINE_FACTORY_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["engine-factory"]);
const ENGINE_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["engine"]);
const FILE_MANAGER_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["file-manager"]);
const CONFIG_SCHEMA = ajv.compile({
  properties: {
    allow_execution: {
      type: "boolean"
    },
    auth: {
      type: ["object", "null"]
    },
    api_version: {
      type: "string",
      maxLength: 32
    },
    cover: {
      type: ["string", "array"],
      maxLength: 1024
    },
    dedicated_thread: {
      type: "boolean"
    },
    description: {
      type: "string",
      maxLength: 256
    },
    flags: {
      type: "array",
      maxLength: 32
    },
    icon: {
      type: "string"
    },
    id: {
      type: "string",
      maxLength: 128
    },
    inputs: {
      type: ["object", "array"]
    },
    labels: {
      type: "array",
      maxLength: 32
    },
    lang: {
      type: "string",
      maxLength: 32
    },
    name: {
      type: "string",
      maxLength: 48
    },
    outputs: {
      type: ["object", "array"]
    },
    tags: {
      type: "array",
      maxLength: 32
    },
    type: {
      type: "string",
      enum: Object.keys(_backends)
    },
    ui: {
      type: "string",
      maxLength: 2048
    },
    version: {
      type: "string",
      maxLength: 32
    },
    docs: {
      type: ["string", "object"]
    }
  },
  required: ["name", "version", "description", "api_version", "id", "allow_execution"]
});

//# sourceURL=webpack://%5Bname%5D/./src/api.js?`)},"./src/connection.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicConnection", function() { return BasicConnection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerConnection", function() { return WebWorkerConnection; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");

const all_connections = {};
class BasicConnection extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(sourceIframe) {
    super();
    this._event_handlers = {};
    this._disconnected = false;
    this.pluginConfig = {};
    this._frame = sourceIframe;
    this._access_token = null;
    this._refresh_token = null;
    this._peer_id = null;
    this._plugin_origin = null;
    this.on("initialized", data => {
      this.pluginConfig = data.config; // peer_id can only be set for once

      this._peer_id = data.peer_id;
      this._plugin_origin = data.origin || "*";
      all_connections[this._peer_id] = this;

      if (this._plugin_origin !== "*") {
        console.log(\`connection to the imjoy-rpc peer \${this._peer_id} is limited to origin \${this._plugin_origin}.\`);
      }

      if (!this._peer_id) {
        throw new Error("Please provide a peer_id for the connection.");
      }

      if (this.pluginConfig.auth) {
        if (this._plugin_origin === "*") {
          console.error("Refuse to transmit the token without an explicit origin, there is a security risk that you may leak the credential to website from other origin. Please specify the \`origin\` explicitly.");
          this._access_token = null;
          this._refresh_token = null;
        }

        if (this.pluginConfig.auth.type !== "jwt") {
          console.error("Unsupported authentication type: " + this.pluginConfig.auth.type);
        } else {
          this._expires_in = this.pluginConfig.auth.expires_in;
          this._access_token = this.pluginConfig.auth.access_token;
          this._refresh_token = this.pluginConfig.auth.refresh_token;
        }
      }
    });
  }

  connect() {
    const messageHandler = e => {
      if (this._frame.contentWindow && e.source === this._frame.contentWindow) {
        const target_id = e.data.target_id;

        if (target_id && this._peer_id && target_id !== this._peer_id) {
          const conn = all_connections[target_id];
          if (conn) conn._fire(e.data.type, e.data);else console.warn(\`connection with target_id \${target_id} not found, discarding data: \`, e.data);
        } else {
          this._fire(e.data.type, e.data);
        }
      }
    };

    this._messageHandler = messageHandler.bind(this);
    window.addEventListener("message", this._messageHandler);

    this._fire("connected");
  }

  execute(code) {
    return new Promise((resolve, reject) => {
      this.once("executed", result => {
        if (result.error) {
          reject(new Error(result.error));
        } else {
          resolve();
        }
      });

      if (this.pluginConfig.allow_execution) {
        this.emit({
          type: "execute",
          code: code
        });
      } else {
        reject("Connection does not allow execution");
      }
    });
  }
  /**
   * Sends a message to the plugin site
   *
   * @param {Object} data to send
   */


  emit(data) {
    let transferables = undefined;

    if (data.__transferables__) {
      transferables = data.__transferables__;
      delete data.__transferables__;
    }

    if (this._access_token) {
      if (Date.now() >= this._expires_in * 1000) {
        //TODO: refresh access token
        throw new Error("Refresh token is not implemented.");
      }

      data.access_token = this._access_token;
    }

    data.peer_id = this._peer_id || data.peer_id;
    this._frame.contentWindow && this._frame.contentWindow.postMessage(data, this._plugin_origin || "*", transferables);
  }
  /**
   * Disconnects the plugin (= kills the frame)
   */


  disconnect(details) {
    if (this._messageHandler) window.removeEventListener("message", this._messageHandler);

    if (!this._disconnected) {
      this._disconnected = true;

      if (typeof this._frame !== "undefined") {
        this._frame.parentNode.removeChild(this._frame);
      } // otherwise farme is not yet created


      this._fire("disconnected", details);
    }

    if (this._peer_id && all_connections[this._peer_id]) delete all_connections[this._peer_id];
  }

}
class WebWorkerConnection extends BasicConnection {
  constructor(worker) {
    super();
    this._worker = worker;
  }

  connect() {
    // TODO: remove listener when disconnected
    this._worker.addEventListener("message", e => {
      const target_id = e.data.target_id;

      if (target_id && this._peer_id && target_id !== this._peer_id) {
        const conn = all_connections[target_id];
        if (conn) conn._fire(e.data.type, e.data);else console.warn(\`connection with target_id \${target_id} not found, discarding data: \`, e.data);
      } else {
        this._fire(e.data.type, e.data);
      }
    });

    this._fire("connected");
  }

  emit(data) {
    let transferables = undefined;

    if (data.__transferables__) {
      transferables = data.__transferables__;
      delete data.__transferables__;
    }

    if (this._access_token) {
      if (Date.now() >= this._expires_in * 1000) {
        //TODO: refresh access token
        throw new Error("Refresh token is not implemented.");
      }

      data.access_token = this._access_token;
    }

    data.peer_id = this._peer_id || data.peer_id;

    this._worker.postMessage(data, transferables);
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/connection.js?`)},"./src/engineManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EngineManager", function() { return EngineManager; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _evilEngine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./evilEngine.js */ "./src/evilEngine.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api.js */ "./src/api.js");



class EngineManager {
  constructor({
    event_bus = null,
    config_db = null,
    client_id = null,
    engine_selector = null
  }) {
    this.event_bus = event_bus;
    this.config_db = config_db;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.event_bus);
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.config_db, "config database is not available");
    this.client_id = client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    this.engines = [];
    this.engine_factories = [];
    this.pm = null;
    this.engine_selector = engine_selector;
  }

  setPluginManager(pm) {
    this.pm = pm;
  }

  async init() {
    this.register(_evilEngine_js__WEBPACK_IMPORTED_MODULE_1__["evil_engine"]);
    this.event_bus.on("register", async ({
      plugin,
      config
    }) => {
      try {
        if (config.type === "engine-factory") {
          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(plugin.config.flags && plugin.config.flags.indexOf("engine-factory") >= 0, "Please add \`engine-factory\` to \`config.flags\` before registering an engine factory.");

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_FACTORY_SCHEMA"])(config)) {
            const error = _api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_FACTORY_SCHEMA"].errors;
            console.error("Error occured registering engine factory", config, error);
            throw error;
          }

          this.registerFactory(config);
          plugin.on("close", () => {
            this.unregisterFactory(config);
          });
        } else if (config.type === "engine") {
          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(plugin.config.flags && plugin.config.flags.indexOf("engine") >= 0, "Please add \`engine\` to \`config.flags\` before registering an engine.");

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_SCHEMA"])(config)) {
            const error = _api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_SCHEMA"].errors;
            console.error("Error occured registering engine ", config, error);
            throw error;
          }

          await this.register(config);
          plugin.on("close", () => {
            this.unregister(config);
          });
        }
      } catch (e) {
        this.pm.unregister(plugin, config);
        throw e;
      }
    });
    this.event_bus.on("unregister", async ({
      config
    }) => {
      if (config.type === "engine") {
        this.unregister(config);
      } else if (config.type === "engine-factory") {
        this.unregisterFactory(config);
      }
    });
  }

  matchEngineByType(pluginType) {
    return this.engines.filter(engine => {
      return engine.pluginType === pluginType;
    });
  }

  async findEngine(plugin_config) {
    if (this.engine_selector) return await this.engine_selector(plugin_config, this.engines);
    const egs = this.engines.filter(engine => {
      return plugin_config.type && engine.pluginType === plugin_config.type;
    });

    if (!egs || egs.length <= 0) {
      return null;
    }

    if (plugin_config.engine_mode === "auto") {
      const matched = egs.filter(eg => {
        return eg.connected;
      });

      if (matched.length <= 0) {
        // let's try to connect the first one
        try {
          const engine = egs[0];
          await engine.connect();
          engine.connected = true;
          return engine;
        } catch (e) {
          console.error("Failed to connect", e);
        }

        return null;
      }

      return matched[matched.length - 1];
    }

    return egs.filter(eg => {
      return eg.name === plugin_config.engine_mode;
    })[0];
  }

  getEngineByUrl(url) {
    for (let e of this.engines) {
      if (e.url === url) {
        return e;
      }
    }

    return null;
  }

  getEngineByName(name) {
    for (let e of this.engines) {
      if (e.name === name) {
        return e;
      }
    }

    return null;
  }

  async register(engine_) {
    const engine = Object.assign({}, engine_); // backup the engine api

    engine.api = engine_;

    if (engine_ && engine_ === _evilEngine_js__WEBPACK_IMPORTED_MODULE_1__["evil_engine"]) {
      // make an exception for localhost debugging
      if (window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost") {
        engine._is_evil = false;
      } else {
        engine._is_evil = true;
      }
    } else {
      engine._is_evil = false;
    } // make sure the name is unique


    for (let i = 0; i < this.engines.length; i++) {
      if (engine.name && this.engines[i].name === engine.name) {
        try {
          this.unregister(this.engines[i]);
        } catch (e) {
          console.error(e);
        }
      }
    } // make sure the url is unique


    for (let i = 0; i < this.engines.length; i++) {
      if (engine.url && this.engines[i].url === engine.url) {
        try {
          this.unregister(this.engines[i]);
        } catch (e) {
          console.error(e);
        }
      }
    }

    engine.connected = false;
    engine.engine_status = engine.engine_status || {};

    if (engine.getEngineConfig) {
      Promise.resolve(engine.getEngineConfig()).then(engine_config => {
        engine.engine_config = engine_config;
      });
    }

    const update_connectivity = () => {
      if (engine.connected) {
        this.event_bus.emit("engine_connected", engine);
      } else {
        this.event_bus.emit("engine_disconnected", engine);
      }
    };

    const check_connectivity = async () => {
      const live = await engine.heartbeat();

      if (!engine.connected && live) {
        engine.connected = true;
        update_connectivity();
      } else if (engine.connected && !live) {
        engine.connected = false;
        update_connectivity();

        for (let p of engine._plugins) {
          p.terminate();
        } // clearInterval(timerId);

      } else {
        engine.connected = live;
      }
    };

    engine._plugins = [];

    engine.registerPlugin = p => {
      engine._plugins.push(p);
    };

    this.engines.push(engine);

    if (!engine.lazy_connection) {
      await engine.connect();
      engine.connected = true;
    }

    update_connectivity();

    if (engine.heartbeat) {
      await check_connectivity();
      engine.heartbeat_timer = setInterval(check_connectivity, 5000);
    }
  }

  async unregister(engine) {
    const url = engine.url;
    engine = this.getEngineByUrl(url);
    if (!engine) return false;
    const index = this.engines.indexOf(engine);

    for (let p of engine._plugins) {
      p.terminate();
    }

    if (index > -1) {
      this.engines.splice(index, 1);
    }

    if (engine.heartbeat_timer) clearInterval(engine.heartbeat_timer);
    await engine.disconnect();
    engine.connected = false;
    this.event_bus.emit("engine_disconnected", engine);
    return true;
  }

  registerFactory(factory_) {
    const factory = Object.assign({}, factory_); //backup the factory api

    factory.api = factory_;

    for (let i = 0; i < this.engine_factories.length; i++) {
      if (this.engine_factories[i].name === factory.name) {
        this.engine_factories.splice(i, 1);
        break;
      }
    }

    this.engine_factories.push(factory);
  }

  unregisterFactory(factory) {
    factory = this.getFactory(factory.name);
    if (!factory) return false;
    const index = this.engine_factories.indexOf(factory);

    if (index > -1) {
      this.engine_factories.splice(index, 1);
    }

    return true;
  }

  getFactory(name) {
    for (let e of this.engine_factories) {
      if (e.name === name) {
        return e;
      }
    }

    return null;
  }

  destroy() {
    for (let e of this.engines) {
      this.unregister(e);
    }
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/engineManager.js?`)},"./src/evilEngine.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evil_engine", function() { return evil_engine; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);



async function _importScript(url, scope) {
  const response = await axios__WEBPACK_IMPORTED_MODULE_1___default.a.get(url);

  if (response && response.status == 200 && response.data) {
    const code = response.data; // Avoid loading the script as amd module (requirejs)

    scope["define"] = null;
    evalInScope(code, scope);
  } else {
    throw "Faild to fetch code from " + url;
  }
}

function evalInScope(code, scope) {
  var keys = Object.keys(scope);
  var values = keys.map(function (key) {
    return scope[key];
  });
  var f = Function(keys.join(", "), code); // Note that at this point you could cache the function f.

  return f.apply(undefined, values);
} // evaluates the provided string


var execute = async function (code, api_interface) {
  if (code.type == "requirements") {
    if (code.requirements && (Array.isArray(code.requirements) || typeof code.requirements === "string")) {
      try {
        code.requirements = typeof code.requirements === "string" ? [code.requirements] : code.requirements;

        if (Array.isArray(code.requirements)) {
          for (var i = 0; i < code.requirements.length; i++) {
            if (code.requirements[i].toLowerCase().endsWith(".js") || code.requirements[i].startsWith("js:")) {
              if (code.requirements[i].startsWith("js:")) {
                code.requirements[i] = code.requirements[i].slice(3);
              }

              await _importScript(code.requirements[i], {
                api: api_interface
              });
            } else if (code.requirements[i].startsWith("http")) {
              await _importScript(code.requirements[i], {
                api: api_interface
              });
            } else if (code.requirements[i].startsWith("cache:")) {//ignore cache
            } else {
              console.log("Unprocessed requirements url: " + code.requirements[i]);
            }
          }
        } else {
          throw "Unsupported requirements definition";
        }
      } catch (e) {
        throw \`Failed to import required scripts \${code.requirements}: \${e}\`;
      }
    }
  } else if (code.type === "script") {
    if (code.src) {
      var script_node = document.createElement("script");
      script_node.setAttribute("type", code.attrs.type);
      script_node.setAttribute("src", code.src);
      document.head.appendChild(script_node);
    } else {
      if (code.content && (!code.attrs.type || code.attrs.type === "text/javascript")) {
        // document.addEventListener("DOMContentLoaded", function(){
        evalInScope(code.content, {
          api: api_interface
        }); // });
      } else {
        var node = document.createElement("script");
        node.setAttribute("type", code.attrs.type);
        node.appendChild(document.createTextNode(code.content));
        document.body.appendChild(node);
      }
    }
  } else {
    throw "unsupported code type.";
  }
};

function promisify_functions(obj) {
  for (let k in obj) {
    if (typeof obj[k] === "function") {
      // make sure it returns a promise
      const func = obj[k];

      if (func.constructor.name !== "AsyncFunction") {
        obj[k] = function (...args) {
          return Promise.resolve(func(...args));
        };
      }
    }
  }
}

async function cacheRequirements(requirements) {
  if (requirements && requirements.length > 0) {
    for (let req of requirements) {
      //remove prefix
      if (req.startsWith("js:")) req = req.slice(3);
      if (req.startsWith("css:")) req = req.slice(4);
      if (req.startsWith("cache:")) req = req.slice(6);
      if (!req.startsWith("http")) continue;

      try {
        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["cacheUrlInServiceWorker"])(req);
      } catch (e) {
        console.error(e);
      }
    }
  }
}

const evil_engine = {
  type: "engine",
  pluginType: "evil",
  icon: "😈",
  name: "imjoy engine",
  url: "https://imjoy.io",
  config: {},
  hide: true,

  connect() {
    this._disconnected = false;
    return true;
  },

  disconnect() {
    this._disconnected = true;
  },

  async startPlugin(config, api_interface) {
    if (this._disconnected) throw "engine is disconnected."; // eslint-disable-next-line no-async-promise-executor

    return new Promise(async (resolve, reject) => {
      const export_api = remote_api => {
        console.log(\`plugin \${config.name} (id=\${config.id}) initialized.\`, Object.keys(remote_api));
        promisify_functions(remote_api);
        resolve(remote_api);
      };

      api_interface = Object.assign({}, api_interface);
      api_interface.export = export_api;
      const raw_register = api_interface.register;

      api_interface.register = config => {
        promisify_functions(config);
        return raw_register(config);
      };

      const raw_on = api_interface.on;

      api_interface.on = (name, cb) => {
        const promise_cb = function (...args) {
          return Promise.resolve(cb(...args));
        };

        return raw_on(name, promise_cb);
      };

      promisify_functions(api_interface);

      try {
        await execute({
          type: "requirements",
          lang: config.lang,
          requirements: config.requirements,
          env: config.env
        }, api_interface);

        for (let i = 0; i < config.scripts.length; i++) {
          await execute({
            type: "script",
            content: config.scripts[i].content,
            lang: config.scripts[i].attrs.lang,
            attrs: config.scripts[i].attrs,
            src: config.scripts[i].attrs.src
          }, api_interface);
        }

        await cacheRequirements(config.requirements);
      } catch (e) {
        reject(e);
      }
    });
  },

  heartbeat: null
};

//# sourceURL=webpack://%5Bname%5D/./src/evilEngine.js?`)},"./src/fileManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileManager", function() { return FileManager; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.js */ "./src/api.js");


class FileManager {
  constructor({
    event_bus = null,
    client_id = null
  }) {
    this.event_bus = event_bus;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.event_bus);
    this.client_id = client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    this.fileManagers = [];
    this.pm = null;
  }

  setPluginManager(pm) {
    this.pm = pm;
  }

  async init() {
    this.event_bus.on("register", async ({
      plugin,
      config
    }) => {
      if (config.type === "file-manager") {
        try {
          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(plugin.config.flags && plugin.config.flags.indexOf("file-manager") >= 0, "Please add \`file-manager\` to \`config.flags\` before registering a file manager.");

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["FILE_MANAGER_SCHEMA"])(config)) {
            const error = _api_js__WEBPACK_IMPORTED_MODULE_1__["FILE_MANAGER_SCHEMA"].errors;
            console.error("Error occured registering file manager", config, error);
            throw error;
          }

          await this.register(config);
          plugin.on("close", () => {
            this.unregister(config);
          });
        } catch (e) {
          this.pm.unregister(config);
          throw e;
        }
      }
    });
    this.event_bus.on("register", async ({
      config
    }) => {
      if (config.type === "file-manager") {
        this.unregister(config);
      }
    });
  }

  getFileManagerByName(name) {
    for (let fm of this.fileManagers) {
      if (fm.name === name) {
        return fm;
      }
    }

    return null;
  }

  getFileManagerByUrl(url) {
    for (let fm of this.fileManagers) {
      if (fm.url === url) {
        return fm;
      }
    }

    return null;
  }

  async register(manager_) {
    const manager = Object.assign({}, manager_); //backup the manager api

    manager.api = manager_;

    for (let i = 0; i < this.fileManagers.length; i++) {
      if (this.fileManagers[i].name === manager.name) {
        this.fileManagers.splice(i, 1);
        break;
      }
    }

    manager.connected = false;

    const check_connectivity = async () => {
      manager.connected = await manager.heartbeat();
    };

    await check_connectivity();
    manager.heart_beat_timer = setInterval(check_connectivity, 10000);
    this.fileManagers.push(manager);
  }

  unregister(manager) {
    manager = this.getFileManagerByUrl(manager.url);
    if (!manager) return false;
    const index = this.fileManagers.indexOf(manager);

    if (index > -1) {
      this.fileManagers.splice(index, 1);
    }

    if (manager.heart_beat_timer) {
      clearInterval(manager.heart_beat_timer);
    }

    return true;
  }

  destroy() {
    for (let e of this.fileManagers) {
      e.destroy();
    }
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/fileManager.js?`)},"./src/imjoyBasicApp.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "injectScript", function() { return injectScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyBasicApp", function() { return loadImJoyBasicApp; });
/* harmony import */ var _imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imjoyBasicApp.template.css */ "./src/imjoyBasicApp.template.css");
/* harmony import */ var _imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imjoyBasicApp.template.html */ "./src/imjoyBasicApp.template.html");
/* harmony import */ var _imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imjoyBasicAppMenu.template.html */ "./src/imjoyBasicAppMenu.template.html");
/* harmony import */ var _imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./imjoyBasicAppWindows.template.html */ "./src/imjoyBasicAppWindows.template.html");
/* harmony import */ var _imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3__);




function injectScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;
    script.addEventListener("load", resolve);
    script.addEventListener("error", () => {
      document.head.removeChild(script);
      reject("Error loading script: " + src);
    });
    script.addEventListener("abort", () => reject("Script loading aborted."));
    document.head.appendChild(script);
  });
}

function getUrlParameter(name) {
  name = name.replace(/[\\[]/, "\\\\[").replace(/[\\]]/, "\\\\]");
  var regex = new RegExp("[\\\\?&]" + name + "=([^&#]*)");
  var results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\\+/g, " "));
}

function loadCss(url) {
  const fileref = document.createElement("link");
  fileref.setAttribute("rel", "stylesheet");
  fileref.setAttribute("type", "text/css");
  fileref.setAttribute("href", url);
  document.getElementsByTagName("head")[0].appendChild(fileref);
}

async function loadImJoyBasicApp(config) {
  await injectScript("https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js");
  await injectScript("https://imjoy-team.github.io/vue-js-modal/index.js");
  loadCss("https://imjoy-team.github.io/vue-js-modal/styles.css");
  await injectScript("https://cdn.jsdelivr.net/npm/@oeway/vue-window@2.4.1-a/lib/index.js");
  config = config || {};
  let app;
  const imjoy_api = {
    showDialog(plugin, cfg, extra_cfg) {
      extra_cfg = extra_cfg || {};
      extra_cfg.dialog = true;
      return imjoy.pm.createWindow(plugin, cfg, extra_cfg);
    },

    createWindow(plugin, cfg, extra_cfg) {
      extra_cfg = extra_cfg || {};
      if (!config.window_manager_container) extra_cfg.dialog = true;
      return imjoy.pm.createWindow(plugin, cfg, extra_cfg);
    },

    showSnackbar(plugin, msg, duration) {
      app.showSnackbar(msg, duration);
    },

    showMessage(plugin, msg) {
      app.showSnackbar(msg, 5);
    },

    showStatus(plugin, msg) {
      app.showSnackbar(msg, 5);
    },

    showProgress(plugin, progress) {
      progress = progress || 0;
      if (progress < 1) progress = progress * 100;
      app.progress = progress;
      app.$forceUpdate();
    }

  };

  if (config.imjoy_api) {
    for (let k of Object.keys(config.imjoy_api)) {
      imjoy_api[k] = config.imjoy_api[k];
    }
  }

  const imjoyCore = await loadImJoyCore(config);
  const imjoy = new imjoyCore.ImJoy({
    imjoy_api
  });
  await imjoy.start(config);
  console.log("ImJoy Core started successfully!");
  Vue.use(window["vue-js-modal"].default);
  Vue.use(window.VueWindow);
  let elem;

  if (config.main_container) {
    if (typeof config.main_container === "string") elem = document.getElementById(config.main_container);else elem = config.main_container;
  } else {
    elem = document.createElement("div");
    document.body.appendChild(elem);
  }

  elem.style.visibility = "hidden";
  elem.innerHTML = _imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1___default.a;
  document.head.insertAdjacentHTML("beforeend", \`<style>\${_imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0___default.a}</style>\`);
  let windowManager;

  if (config.window_manager_container) {
    let windowsElem;
    if (typeof config.window_manager_container === "string") windowsElem = document.getElementById(config.window_manager_container);else windowsElem = config.window_manager_container;
    windowsElem.innerHTML = _imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3___default.a;
    windowManager = new Vue({
      el: windowsElem,
      data: {
        type: config.window_manager_type || "standard",
        windowSizePosChanging: false,
        windowStyle: config.window_style || {},
        showEmpty: config.show_empty_window || false,
        showWindowTitle: config.show_window_title || false,
        windows: [],
        activeWindow: null
      },
      watch: {
        windowSizePosChanging: function (newVal) {
          app.$emit("window-size-pos-changing", newVal);
        }
      },
      methods: {
        closeWindow(w) {
          this.windowSizePosChanging = false;
          w.hidden = true;
          this.$forceUpdate();
          w.close();
        }

      }
    });
  }

  let menuManager;

  if (config.menu_container) {
    let menuElem;
    if (typeof config.menu_container === "string") menuElem = document.getElementById(config.menu_container);else menuElem = config.menu_container;
    menuElem.innerHTML = _imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2___default.a;
    menuElem.style.minHeight = "30px";
    menuManager = new Vue({
      el: menuElem,
      data: {
        menuPos: config.menu_pos || "right",
        menuStyle: config.menu_style || {
          "z-index": 999
        },
        activeWindow: null,
        closeWindow: null,
        showAboutImJoy: null,
        extraMenuItems: [],
        loadedPlugins: [],
        allWindows: [],
        showContent: true
      },

      mounted() {
        this.menuStyle = this.menuStyle || {};
        this.menuStyle.float = this.menuPos === "left" ? "left" : "right";
      },

      methods: {
        menuClicked() {
          // force closing the menu for touch screen devices
          this.showContent = false;
          this.$forceUpdate();
          setTimeout(() => {
            this.showContent = true;
            this.$forceUpdate();
          }, 0);
        }

      }
    });
  }

  app = new Vue({
    el: elem,
    data: {
      dialogWindows: [],
      selectedDialogWindow: null,
      selectedWindowsStack: [],
      selectedRegularWindow: null,
      fullscreen: false,
      loading: false,
      snackBarContent: false,
      snackBarTimer: null,
      progress: 0,
      loadedPlugins: [],
      allWindows: [],
      extraMenuItems: [],
      showProgressBar: config.show_progress_bar,
      showLoaderCallback: config.show_loader,
      showWindows: config.show_windows
    },

    mounted() {
      this.$el.style.visibility = "visible";
      imjoy.event_bus.on("close_window", w => {
        this.closeWindow(w);
        this.$forceUpdate();
      });
      imjoy.event_bus.on("add_window", w => {
        this.allWindows.push(w);
        this.addWindow(w);
      });
      this.imjoy = imjoy;

      if (config.process_url_query) {
        this.processURLQuery();
      }

      if (menuManager) {
        menuManager.closeWindow = w => {
          this.closeWindow(w);
        };

        if (!config.hide_about_imjoy) {
          menuManager.showAboutImJoy = () => {
            imjoy.api.showDialog({
              src: "https://imjoy.io/docs/",
              passive: true
            });
          };
        }
      }
    },

    computed: {
      regularWindows: function () {
        return this.allWindows.filter(w => !this.dialogWindows.includes(w) && !w.inline);
      }
    },
    watch: {
      regularWindows: function (newVal) {
        if (windowManager) {
          windowManager.windows = newVal;
          windowManager.$forceUpdate();
        }
      },
      selectedRegularWindow: function (newVal) {
        if (windowManager) {
          windowManager.activeWindow = newVal;
          windowManager.$forceUpdate();
        }

        if (menuManager && config.window_manager_type === "simple") {
          menuManager.activeWindow = newVal;
          menuManager.$forceUpdate();
        }
      },
      extraMenuItems: function (newVal) {
        if (menuManager) {
          menuManager.extraMenuItems = newVal;
          menuManager.$forceUpdate();
        }
      },
      allWindows: function (newVal) {
        if (menuManager) {
          menuManager.allWindows = newVal;
          menuManager.$forceUpdate();
        }
      },
      loadedPlugins: function (newVal) {
        if (menuManager) {
          menuManager.loadedPlugins = newVal;
          menuManager.$forceUpdate();
        }
      }
    },
    methods: {
      async processURLQuery() {
        const engine = getUrlParameter("engine");
        const p = getUrlParameter("plugin") || getUrlParameter("p");
        const binder = getUrlParameter("binder");

        if (engine) {
          const token = getUrlParameter("token");
          const name = getUrlParameter("name");
          await this.setupPluginEngine(engine, token, name);
        }

        if (binder) {
          const name = getUrlParameter("name");
          const spec = getUrlParameter("spec");
          await this.setupBinderEngine(binder, spec, name);
        }

        if (p) {
          this.loadPlugin(p).then(plugin => {
            let config = {},
                data = {},
                tmp;
            tmp = getUrlParameter("data");
            if (tmp) data = JSON.parse(tmp);
            tmp = getUrlParameter("config");
            if (tmp) config = JSON.parse(tmp);
            this.runPlugin(plugin, config, data);
          });
        }
      },

      async runPlugin(plugin, config, data) {
        if (!config && plugin.config.ui && plugin.config.ui.indexOf("{") > -1) {
          config = await imjoy.pm.imjoy_api.showDialog(plugin, plugin.config);
        }

        data = data || {};
        return await plugin.api.run({
          config: config,
          data: data
        });
      },

      async setupPluginEngine(engine, token, name) {
        try {
          console.log("Loading Jupyter-Engine-Manager from Gist...");

          if (!imjoy.em.getFactory("Jupyter-Engine")) {
            await imjoy.pm.reloadPluginRecursively({
              uri: "https://imjoy-team.github.io/jupyter-engine-manager/Jupyter-Engine-Manager.imjoy.html"
            });
            console.log("Jupyter-Engine-Manager loaded.");
            await imjoy.em.unregister("https://mybinder.org");
          }

          const factory = imjoy.em.getFactory("Jupyter-Engine");
          await factory.addEngine({
            name: name,
            url: engine,
            nbUrl: engine + "?token=" + token
          });
          console.log("plugin engine added:", engine);
        } catch (e) {
          console.error(e);
          alert(\`Failed to connect to the engine: \${e}\`);
        }
      },

      async setupBinderEngine(url, spec, name) {
        try {
          console.log("Loading Jupyter-Engine-Manager from Gist...");

          if (!imjoy.em.getFactory("MyBinder-Engine")) {
            await imjoy.pm.reloadPluginRecursively({
              uri: "https://imjoy-team.github.io/jupyter-engine-manager/Jupyter-Engine-Manager.imjoy.html"
            });
            console.log("Jupyter-Engine-Manager loaded.");
            await imjoy.em.unregister("https://mybinder.org");
          }

          const factory = imjoy.em.getFactory("MyBinder-Engine");
          await factory.addEngine({
            name,
            spec,
            url
          });
          console.log("Binder engine added:", url);
        } catch (e) {
          console.error(e);
          alert(\`Failed to connect to the engine: \${e}\`);
        }
      },

      async loadPlugin(uri) {
        try {
          this.loading = true;
          const p = await imjoy.pm.reloadPluginRecursively({
            uri
          });
          this.loadedPlugins.push(p);
          this.showSnackbar(\`Plugin \${p.name} successfully loaded.\`);
          return p;
        } finally {
          this.loading = false;
        }
      },

      addMenuItem(config) {
        this.extraMenuItems.push(config);
        this.$forceUpdate();
      },

      removeMenuItem(label) {
        const item = this.extraMenuItems.filter(it => it.label === label)[0];
        const idx = this.extraMenuItems.indexOf(item);
        if (idx >= 0) this.extraMenuItems.splice(idx, 1);
      },

      showSnackbar(msg, duration) {
        if (this.snackBarTimer) clearTimeout(this.snackBarTimer);
        duration = duration || 3;
        this.snackBarContent = msg;
        this.$forceUpdate();
        this.snackBarTimer = setTimeout(() => {
          this.snackBarContent = null;
          this.snackBarTimer = null;
          this.$forceUpdate();
        }, duration * 1000);
      },

      showLoader(loading) {
        if (this.showLoaderCallback) {
          this.showLoaderCallback(loading);
        } else {
          this.loading = loading;
        }

        this.$forceUpdate();
      },

      addWindow(w) {
        w.api = w.api || {};
        const windowElm = document.getElementById(w.window_id);

        if (windowElm) {
          if (w.window_style) Object.assign(windowElm.style, w.window_style);
          w.inline = true;

          w.api.show = w.show = () => {
            windowElm.scrollIntoView();
          };

          return;
        }

        if (!w.dialog) {
          this.selectedRegularWindow = w;
          setTimeout(() => {
            if (w.fullscreen || w.standalone) {
              w.sizeState = "maximized";
            } else {
              w.sizeState = "normal";
            }

            this.$forceUpdate();
          }, 0);
          const self = this;

          w.api.show = w.show = () => {
            w.sizeState = "restore";
            self.selectedRegularWindow = w;
            self.$forceUpdate();
            imjoy.wm.selectWindow(w);
            w.api.emit("show");
          };
        } else {
          this.dialogWindows.push(w);

          if (this.selectedDialogWindow) {
            this.selectedWindowsStack.push(this.selectedDialogWindow);
          }

          this.selectedDialogWindow = w;
          if (w.fullscreen || w.standalone) this.fullscreen = true;else this.fullscreen = false;
          this.$modal.show("window-modal-dialog");
          this.$forceUpdate();

          w.api.show = w.show = () => {
            this.selectedDialogWindow = w;
            this.$modal.show("window-modal-dialog");
            imjoy.wm.selectWindow(w);
            w.api.emit("show");
          };

          w.api.hide = w.hide = () => {
            if (this.selectedDialogWindow === w) {
              this.$modal.hide("window-modal-dialog");
            }

            w.api.emit("hide");
          };

          setTimeout(() => {
            try {
              w.show();
            } catch (e) {
              console.error(e);
            }
          }, 500);
        }
      },

      showWindow(w) {
        if (w.fullscreen || w.standalone) this.fullscreen = true;else this.fullscreen = false;
        if (w) this.selectedDialogWindow = w;
        this.$modal.show("window-modal-dialog");
      },

      closeWindow(w) {
        let idx = this.dialogWindows.indexOf(w);
        if (idx >= 0) this.dialogWindows.splice(idx, 1);
        idx = this.allWindows.indexOf(w);
        if (idx >= 0) this.allWindows.splice(idx, 1);

        if (w === this.selectedDialogWindow) {
          this.selectedDialogWindow = this.selectedWindowsStack.pop();
        }

        if (!this.selectedDialogWindow) this.$modal.hide("window-modal-dialog");

        if (w === this.selectedRegularWindow) {
          if (this.regularWindows.length > 0) this.selectedRegularWindow = this.regularWindows[this.regularWindows.length - 1] || null;else this.selectedRegularWindow = null;
        }

        this.$forceUpdate();
      },

      minimizeWindow() {
        this.$modal.hide("window-modal-dialog");
      },

      maximizeWindow() {
        this.fullscreen = !this.fullscreen;
      }

    }
  });
  return app;
}

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicApp.js?`)},"./src/imjoyBasicApp.template.css":function(module,exports){eval(`module.exports = ".vm--modal {\\n  max-height: 100% !important;\\n  max-width: 100% !important;\\n}\\n\\n.imjoy-inline-window {\\n  width: 100%;\\n  height: 600px;\\n}\\n\\n.imjoy-progress-border > div {\\n  background-color: #448aff;\\n  height: 3px;\\n}\\n\\n.imjoy-progress-border {\\n  top: 0;\\n  left: 0;\\n  position: absolute;\\n  width: 100%;\\n  height: 3px;\\n}\\n\\n.imjoy-noselect {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n\\nbody {\\n  margin: 0px;\\n}\\n.imjoy-dialog-control {\\n  padding: 0px;\\n  line-height: 10px;\\n  height: 23px;\\n  width: 25px;\\n  border: 0px;\\n  font-size: 1rem;\\n  position: absolute;\\n  color: white;\\n  top: 1px;\\n}\\n\\n.imjoy-dialog-control:focus {\\n  outline: none;\\n}\\n\\n.imjoy-loader {\\n  position: fixed;\\n  top: 40%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  transform: -webkit-translate(-50%, -50%);\\n  transform: -moz-translate(-50%, -50%);\\n  transform: -ms-translate(-50%, -50%);\\n  border: 10px solid #f3f3f3;\\n  /* Light grey */\\n  border-top: 10px solid #448aff;\\n  /* Blue */\\n  border-radius: 50%;\\n  width: 40px;\\n  height: 40px;\\n  animation: spin 2s linear infinite;\\n}\\n\\n@keyframes spin {\\n  0% {\\n    transform: rotate(0deg);\\n  }\\n\\n  100% {\\n    transform: rotate(360deg);\\n  }\\n}\\n\\n/* The snackbar - position it at the bottom and in the middle of the screen */\\n.imjoy-snackbar {\\n  font-family: Arial, Helvetica, sans-serif;\\n  visibility: hidden;\\n  /* Hidden by default. Visible on click */\\n  min-width: 250px;\\n  /* Set a default minimum width */\\n  background-color: #333333c2;\\n  /* Black background color */\\n  color: #fff;\\n  /* White text color */\\n  text-align: center;\\n  /* Centered text */\\n  border-radius: 5px;\\n  /* Rounded borders */\\n  padding: 16px;\\n  /* Padding */\\n  position: fixed;\\n  /* Sit on top of the screen */\\n  z-index: 9999;\\n  /* Add a z-index if needed */\\n  left: 50%;\\n  /* Center the snackbar */\\n  transform: translate(-50%, 0);\\n  bottom: 20px;\\n  /* 20px from the bottom */\\n}\\n\\n.imjoy-window-title-bar {\\n  cursor: move;\\n  background-color: #448aff;\\n  color: white;\\n  text-align: center;\\n  height: 24px;\\n}\\n\\n.imjoy-window-title {\\n  text-align: center;\\n  font-family: Arial, Helvetica, sans-serif;\\n  font-size: 16px;\\n  line-height: 23px;\\n  margin: 0px;\\n}\\n\\n/* Show the snackbar when clicking on a button (class added with JavaScript) */\\n.imjoy-snackbar.show-snackbar {\\n  visibility: visible;\\n  /* Show the snackbar */\\n  /* Add animation: Take 0.5 seconds to fade in and out the snackbar.\\n  However, delay the fade out process for 2.5 seconds */\\n  -webkit-animation: imjoy-fadein 0.5s;\\n  animation: imjoy-fadein 0.5s;\\n}\\n\\n/* Animations to fade the snackbar in and out */\\n@-webkit-keyframes imjoy-fadein {\\n  from {\\n    bottom: 0;\\n    opacity: 0;\\n  }\\n\\n  to {\\n    bottom: 30px;\\n    opacity: 1;\\n  }\\n}\\n\\n@keyframes imjoy-fadein {\\n  from {\\n    bottom: 0;\\n    opacity: 0;\\n  }\\n\\n  to {\\n    bottom: 30px;\\n    opacity: 1;\\n  }\\n}\\n\\n.imjoy-dropdown-btn {\\n  padding: 4px;\\n  font-size: 16px;\\n  border: none;\\n  cursor: pointer;\\n}\\n\\n.imjoy-dropdown {\\n  position: relative;\\n  display: inline-block;\\n}\\n\\n.imjoy-dropdown-content {\\n  display: none;\\n  position: absolute;\\n  right: 0;\\n  background-color: #f9f9f9;\\n  min-width: 200px;\\n  box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);\\n  z-index: 1;\\n}\\n\\n.imjoy-dropdown-content a {\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: black;\\n  padding: 6px 10px;\\n  text-decoration: none;\\n  display: block;\\n}\\n\\n.imjoy-dropdown-content a:hover {\\n  background-color: #f1f1f1;\\n}\\n\\n.imjoy-dropdown:hover .imjoy-dropdown-content {\\n  display: block;\\n}\\n\\n.imjoy-window-container {\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.imjoy-windows {\\n  position: relative;\\n  min-height: 100px;\\n  height: calc(100% - 30px);\\n}\\n\\n.block-pointer-events {\\n  pointer-events: none;\\n}\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicApp.template.css?`)},"./src/imjoyBasicApp.template.html":function(module,exports){eval(`module.exports = "<div v-if=\\"showLoader\\" class=\\"imjoy-loader\\" v-show=\\"loading\\"></div>\\n<div v-if=\\"showProgressBar\\" class=\\"imjoy-progress-border\\" v-show=\\"progress\\">\\n  <div :style=\\"{width: progress+'%'}\\"></div>\\n</div>\\n<div\\n  v-show=\\"snackBarContent\\"\\n  :class=\\"{'show-snackbar': snackBarContent}\\"\\n  class=\\"imjoy-snackbar\\"\\n>\\n  {{snackBarContent}}\\n</div>\\n<modal\\n  name=\\"window-modal-dialog\\"\\n  height=\\"500px\\"\\n  style=\\"max-height: 100%; max-width: 100%\\"\\n  :fullscreen=\\"fullscreen\\"\\n  :resizable=\\"true\\"\\n  draggable=\\".imjoy-drag-handle\\"\\n  :scrollable=\\"true\\"\\n>\\n  <div\\n    v-if=\\"selectedDialogWindow\\"\\n    @dblclick=\\"maximizeWindow()\\"\\n    class=\\"imjoy-drag-handle imjoy-window-title-bar\\"\\n  >\\n    <span class=\\"imjoy-noselect imjoy-window-title\\"\\n      >{{ selectedDialogWindow.name}}</span\\n    >\\n    <button\\n      @click=\\"closeWindow(selectedDialogWindow)\\"\\n      class=\\"imjoy-noselect imjoy-dialog-control\\"\\n      style=\\"background:#ff0000c4;left:1px;\\"\\n    >\\n      x\\n    </button>\\n    <button\\n      @click=\\"minimizeWindow()\\"\\n      class=\\"imjoy-noselect imjoy-dialog-control\\"\\n      style=\\"background:#00cdff61;left:28px;\\"\\n    >\\n      -\\n    </button>\\n    <button\\n      @click=\\"maximizeWindow()\\"\\n      class=\\"imjoy-noselect imjoy-dialog-control\\"\\n      style=\\"background:#00cdff61;left:55px;\\"\\n    >\\n      {{fullscreen?'=': '+'}}\\n    </button>\\n  </div>\\n  <template v-for=\\"wdialog in dialogWindows\\">\\n    <div\\n      :key=\\"wdialog.window_id\\"\\n      v-show=\\"wdialog === selectedDialogWindow\\"\\n      style=\\"height: calc(100% - 18px);\\"\\n    >\\n      <div :id=\\"wdialog.window_id\\" style=\\"width: 100%;height: 100%;\\"></div>\\n    </div>\\n  </template>\\n</modal>\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicApp.template.html?`)},"./src/imjoyBasicAppMenu.template.html":function(module,exports){eval(`module.exports = "<div class=\\"imjoy-dropdown\\" :style=\\"menuStyle\\">\\n  <a class=\\"imjoy-dropdown-btn\\"\\n    ><img\\n      style=\\"width:24px;\\"\\n      src=\\"https://imjoy.io/static/img/imjoy-icon.svg\\"\\n    />\\n  </a>\\n  <div\\n    class=\\"imjoy-dropdown-content\\"\\n    v-if=\\"showContent\\"\\n    @click=\\"menuClicked\\"\\n    :style=\\"{left: menuPos==='left'? 0: null}\\"\\n  >\\n    <a\\n      href=\\"#\\"\\n      v-for=\\"item in extraMenuItems\\"\\n      :key=\\"item.label\\"\\n      @click.prevent=\\"item.callback()\\"\\n      >{{item.label}}</a\\n    >\\n    <hr\\n      style=\\"margin: 0;border-style: solid;color: rgb(157 205 255 / 45%);\\"\\n      v-show=\\"extraMenuItems.length>0 && loadedPlugins.length>0\\"\\n    />\\n    <a\\n      href=\\"#\\"\\n      v-for=\\"p in loadedPlugins\\"\\n      :key=\\"p.id\\"\\n      @click.prevent=\\"p.api.run()\\"\\n      >🧩 {{p.name}}</a\\n    >\\n    <hr\\n      style=\\"margin: 0;border-style: solid;color: rgb(157 205 255 / 45%);\\"\\n      v-show=\\"allWindows.length>0 && loadedPlugins.length>0\\"\\n    />\\n    <a href=\\"#\\" v-if=\\"showAboutImJoy\\" @click.prevent=\\"showAboutImJoy()\\"\\n      >ℹ️ About ImJoy</a\\n    >\\n    <hr\\n      style=\\"margin: 0;border-style: solid;color: rgb(157 205 255 / 45%);\\"\\n      v-show=\\"allWindows.length>0 && loadedPlugins.length>0\\"\\n    />\\n    <a\\n      href=\\"#\\"\\n      v-for=\\"w in allWindows\\"\\n      :style=\\"{'background-color': activeWindow===w?'#adcafb78':'', 'font-weight': activeWindow===w? 600:300}\\"\\n      :key=\\"w.id\\"\\n      @click.prevent=\\"w.api.show()\\"\\n      >🔳 {{w.name}}</a\\n    >\\n    <a\\n      href=\\"#\\"\\n      v-if=\\"activeWindow && closeWindow\\"\\n      @click.prevent=\\"closeWindow(activeWindow)\\"\\n      >❌ Close Window</a\\n    >\\n  </div>\\n</div>\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicAppMenu.template.html?`)},"./src/imjoyBasicAppWindows.template.html":function(module,exports){eval(`module.exports = "<template v-if=\\"type==='standard'\\">\\n  <hsc-window-style-material>\\n    <hsc-window\\n      v-for=\\"w in windows\\"\\n      :key=\\"w.id\\"\\n      v-show=\\"!w.hidden\\"\\n      :title=\\"w.name\\"\\n      :minimize-style=\\"{display: 'none'}\\"\\n      :close-button=\\"!w.disable_close\\"\\n      @close=\\"closeWindow(w)\\"\\n      :size-state.sync=\\"w.sizeState\\"\\n      :maximize-button=\\"true\\"\\n      :resizable=\\"true\\"\\n      :width=\\"w.w*30\\"\\n      :height=\\"w.h*30\\"\\n      :resizable=\\"true\\"\\n      @resize-start=\\"windowSizePosChanging = true\\"\\n      @resize-end=\\"windowSizePosChanging = false\\"\\n      @move-start=\\"windowSizePosChanging = true\\"\\n      @move-end=\\"windowSizePosChanging = false\\"\\n    >\\n      <div\\n        :class=\\"{'block-pointer-events': windowSizePosChanging }\\"\\n        :id=\\"w.window_id\\"\\n        class=\\"imjoy-window-container\\"\\n      ></div>\\n    </hsc-window>\\n  </hsc-window-style-material>\\n</template>\\n<template v-else>\\n  <div\\n    v-for=\\"w in windows\\"\\n    v-show=\\"w === activeWindow\\"\\n    :key=\\"w.id\\"\\n    class=\\"imjoy-windows\\"\\n    :style=\\"windowStyle\\"\\n  >\\n    <div\\n      v-if=\\"showWindowTitle\\"\\n      style=\\"text-align: center;height:24px; background: #cacaca66;\\"\\n    >\\n      <span\\n        style=\\"font-size:1rem;font-family: Arial, Helvetica, sans-serif;line-height: 24px;\\"\\n        >{{ w.name }}</span\\n      >\\n    </div>\\n    <div\\n      :id=\\"w.window_id\\"\\n      class=\\"imjoy-window-container\\"\\n      :style=\\"{height: showWindowTitle?'calc(100% - 24px)': '100%'}\\"\\n    ></div>\\n  </div>\\n</template>\\n<div\\n  v-if=\\"showEmpty && (!activeWindow || windows.length <= 0)\\"\\n  class=\\"imjoy-windows\\"\\n  :style=\\"windowStyle\\"\\n>\\n  <img\\n    style=\\"width:80px; position:absolute; left:50%; top: 50%; transform: translate(-50%, -50%);\\"\\n    src=\\"https://imjoy.io/static/img/imjoy-icon.svg\\"\\n  />\\n</div>\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicAppWindows.template.html?`)},"./src/imjoyCore.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return utils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImJoy", function() { return ImJoy; });
/* harmony import */ var _pluginManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginManager.js */ "./src/pluginManager.js");
/* harmony import */ var _windowManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./windowManager.js */ "./src/windowManager.js");
/* harmony import */ var _engineManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engineManager.js */ "./src/engineManager.js");
/* harmony import */ var _fileManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fileManager.js */ "./src/fileManager.js");
/* harmony import */ var _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jailedPlugin.js */ "./src/jailedPlugin.js");
/* harmony import */ var pouchdb_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pouchdb-browser */ "./node_modules/pouchdb-browser/lib/index.es.js");
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! imjoy-rpc */ "./node_modules/imjoy-rpc/index.js");
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(imjoy_rpc__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var minibus__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! minibus */ "./node_modules/minibus/minibus.js");
/* harmony import */ var minibus__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(minibus__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _joy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./joy */ "./src/joy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Joy", function() { return _joy__WEBPACK_IMPORTED_MODULE_9__["Joy"]; });

/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./api */ "./src/api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ajv", function() { return _api__WEBPACK_IMPORTED_MODULE_10__["ajv"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_11___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_11__["version"]; });













const utils = _utils_js__WEBPACK_IMPORTED_MODULE_7__;

class ImJoy {
  constructor({
    imjoy_api = null,
    event_bus = null,
    client_id = null,
    config_db = null,
    default_base_frame = null,
    default_rpc_base_url = null,
    expose_api = false,
    debug = false,
    flags = [],
    engine_selector = null
  }) {
    this.config_db = config_db || new pouchdb_browser__WEBPACK_IMPORTED_MODULE_5__["default"]("imjoy_config", {
      revs_limit: 2,
      auto_compaction: true
    });
    this.expose_api = expose_api;
    this.event_bus = event_bus || minibus__WEBPACK_IMPORTED_MODULE_8___default.a.create();
    this.client_id = client_id || "imjoy_web_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_7__["randId"])();
    this.imjoy_api = imjoy_api || {};
    this.engine_selector = engine_selector;
    this.flags = flags;
    this.em = new _engineManager_js__WEBPACK_IMPORTED_MODULE_2__["EngineManager"]({
      event_bus: this.event_bus,
      config_db: this.config_db,
      client_id: this.client_id,
      engine_selector: this.engine_selector
    });
    this.wm = new _windowManager_js__WEBPACK_IMPORTED_MODULE_1__["WindowManager"]({
      event_bus: this.event_bus
    });
    this.fm = new _fileManager_js__WEBPACK_IMPORTED_MODULE_3__["FileManager"]({
      event_bus: this.event_bus
    });
    this.pm = new _pluginManager_js__WEBPACK_IMPORTED_MODULE_0__["PluginManager"]({
      event_bus: this.event_bus,
      config_db: this.config_db,
      engine_manager: this.em,
      window_manager: this.wm,
      file_manager: this.fm,
      imjoy_api: this.imjoy_api,
      default_base_frame: default_base_frame,
      default_rpc_base_url: default_rpc_base_url,
      debug: debug,
      flags: this.flags
    });
  }

  async init() {
    await this.fm.init();
    await this.pm.init();
    this.root_plugin = this.pm.root_plugin;
    if (this.root_plugin) this.api = this.pm.root_plugin.getBoundInterface();

    try {
      await this.pm.loadWorkspaceList();
    } catch (e) {
      console.error(e);
      this.event_bus.emit("show_message", "Failed to load the workspace list: " + e.toString());
    }

    try {
      await this.em.init();
      console.log("Successfully initialized the engine manager.");
    } catch (e) {
      console.error(e);
      this.event_bus.emit("show_message", "Failed to initialize the engine manager: " + e.toString());
    } // inside an iframe


    if (this.expose_api && window.self !== window.top) {
      const api = await imjoy_rpc__WEBPACK_IMPORTED_MODULE_6__["imjoyRPC"].setupRPC({
        name: "ImJoy"
      });
      const root_plugin_config = {
        _id: "root",
        name: "ImJoy",
        type: "window",
        ui: null,
        tag: null,
        inputs: null,
        outputs: null,
        docs: "https://imjoy.io/docs/",
        attachments: []
      };
      const imjoy_api = this.pm.imjoy_api;
      const wrapped_api = {};
      const rootPlugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_4__["DynamicPlugin"](root_plugin_config, imjoy_api, null, true);

      for (let k in imjoy_api) {
        if (typeof imjoy_api[k] === "function") {
          wrapped_api[k] = function () {
            return imjoy_api[k].apply(imjoy_api, [rootPlugin].concat(Array.prototype.slice.call(arguments)));
          };
        } else if (typeof imjoy_api[k] === "object") {
          wrapped_api[k] = {};

          for (let u in imjoy_api[k]) {
            wrapped_api[k][u] = function () {
              return imjoy_api[k][u].apply(imjoy_api, [rootPlugin].concat(Array.prototype.slice.call(arguments)));
            };
          }
        }
      }

      wrapped_api.setup = function () {
        api.log("ImJoy App loaded successfully.");
      }; // Note: we need to overwrite this run function here, otherwise, api.run function will be called
      // we need to mask out api.run for the first run to make sure the window plugin runs
      // then we can restore the actual api.run


      let firstRun = true;

      wrapped_api.run = function () {
        if (firstRun) {
          firstRun = false;
          return;
        }

        return imjoy_api.run.apply(imjoy_api, [rootPlugin].concat(Array.prototype.slice.call(arguments)));
      };

      api.export(wrapped_api);
    }
  }

  async start(config) {
    config = config || {};
    await this.init();

    if (config.workspace) {
      await this.pm.loadWorkspace(config.workspace);
      await this.pm.reloadPlugins();
    } else {
      await this.pm.reloadInternalPlugins(true);
    }
  }

  async destroy() {
    this.pm.destroy();
    this.em.destroy();
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/imjoyCore.js?`)},"./src/imjoyLoader.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyCore", function() { return loadImJoyCore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "latest_rpc_version", function() { return latest_rpc_version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyRPC", function() { return loadImJoyRPC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyRPCSocketIO", function() { return loadImJoyRPCSocketIO; });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony import */ var _imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imjoyBasicApp.js */ "./src/imjoyBasicApp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImJoyBasicApp", function() { return _imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["loadImJoyBasicApp"]; });



/**
 * Get the URL parameters
 * source: https://css-tricks.com/snippets/javascript/get-url-variables/
 * @param  {String} url The URL
 * @return {Object}     The URL parameters
 */

var _getParams = function (url) {
  var params = {};
  var parser = document.createElement("a");
  parser.href = url;
  var query = parser.search.substring(1);
  var vars = query.split("&");

  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split("=");
    params[pair[0]] = decodeURIComponent(pair[1]);
  }

  return params;
}; // Load the imjoy core script
// it support the following options:
// 1) version, you can specify a specific version of the core,
// for example \`version: "0.11.13"\` or \`version: "latest"\`
// 2) debug, by default, the minified version will be used,
// if debug==true, the full version will be served
// 3) base_url, the url for loading the core library


function loadImJoyCore(config) {
  config = config || {}; // eslint-disable-next-line no-async-promise-executor

  return new Promise(async (resolve, reject) => {
    try {
      var baseUrl = config.base_url;

      if (!baseUrl) {
        const version = config.version || "latest";
        baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-core@\${version}/dist/\`;
      }

      delete window.imjoyCore;

      if (config.debug) {
        await Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(baseUrl + "imjoy-core.js");
      } else {
        await Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(baseUrl + "imjoy-core.min.js");
      }

      if (window.imjoyCore) {
        const imjoyCore = window.imjoyCore;
        delete window.imjoyCore;
        resolve(imjoyCore);
      } else if (typeof define === "function" && // eslint-disable-next-line no-undef
      __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) eval("require")(["imjoyCore"], resolve);else reject("Failed to import imjoy-core.");
    } catch (e) {
      reject(e);
    }
  });
}
const _rpc_registry = {}; // get version number from package.json

const latest_rpc_version = _package_json__WEBPACK_IMPORTED_MODULE_0__["dependencies"]["imjoy-rpc"].replace(/[^\\d.-]/g, "");
const _rpc_api_versions = {
  "0.2.0": {
    from: "0.1.10",
    to: "0.1.17",
    skips: []
  },
  "0.2.1": {
    from: "0.1.18",
    to: "0.2.5",
    skips: []
  },
  "0.2.2": {
    from: "0.2.6",
    to: "0.2.6",
    skips: []
  },
  "0.2.3": {
    from: "0.2.7",
    to: latest_rpc_version,
    skips: ["0.2.9", "0.2.15", "0.2.16", "0.2.18", "0.2.23", "0.2.24", "0.2.25"]
  }
}; // specify an api version and this function will return the actual imjoy-rpc version
// if you set latestOnly to true, then it returns always the latest for the api version
// otherwise, it will try to find a compatible version in the cached version.

function findRPCVersionByAPIVersion(apiVersion, latestOnly) {
  if (!apiVersion || !apiVersion.includes(".")) return;
  let cached = Object.keys(_rpc_registry);

  if (_rpc_api_versions[apiVersion]) {
    if (cached.length <= 0 || latestOnly) {
      return _rpc_api_versions[apiVersion].to;
    } // see if we can find a compatible version in the cache
    // sort the cached version


    cached = (f => f(f(cached, 1).sort(), -1))((cached, v) => cached.map(a => a.replace(/\\d+/g, n => +n + v * 100000)));

    for (let c of cached.reverse()) {
      if (_rpc_registry[c].API_VERSION === apiVersion) return c;
    }

    return _rpc_api_versions[apiVersion].to;
  } else {
    return null;
  }
} // Load the script for a plugin to communicate with imjoy-rpc
// This should only be called when the window is inside the iframe
// it support the following options:
// 1) version, you can specify a specific version of the imjoy-rpc,
// for example \`version: "0.11.13"\` or \`version: "latest"\`
// 2) api_version, specify the api version of the imjoy-rpc
// 3) debug, by default, the minified version will be used,
// if debug==true, the full version will be served
// 4) base_url, the url for loading the rpc library


function loadImJoyRPC(config) {
  config = config || {};
  return new Promise((resolve, reject) => {
    var baseUrl = config.base_url;
    let version = config.version;

    if (!baseUrl) {
      if (config.version) {
        baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc@\${config.version}/dist/\`;
      } else {
        if (config.api_version) {
          // find the latest version for this api_version
          version = findRPCVersionByAPIVersion(config.api_version, true);

          if (version) {
            baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc@\${version}/dist/\`;
          } else {
            reject(Error(\`Cannot find a version of imjoy-rpc that supports api v\${config.api_version}\`));
            return;
          }
        } else {
          baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc@latest/dist/\`;
          version = "latest";
          console.info(\`Using imjoy-rpc library from \${baseUrl}.\`);
        }
      }
    }

    if (version && _rpc_registry[version]) {
      console.info(\`Using cached imjoy-rpc library v\${version}.\`);
      resolve(_rpc_registry[version]);
      return;
    }

    let rpc_url = baseUrl + "imjoy-rpc.min.js";

    if (config.debug) {
      rpc_url = baseUrl + "imjoy-rpc.js";
    }

    function checkAndCacheLib(imjoyRPC) {
      if (version && version !== "latest" && version !== imjoyRPC.VERSION) {
        throw new Error(\`imjoy-rpc version mismatch \${version} != \${imjoyRPC.VERSION}\`);
      }

      if (config.api_version && config.api_version !== imjoyRPC.API_VERSION) {
        throw new Error(\`imjoy-rpc api version mismatch \${config.api_version} != \${imjoyRPC.API_VERSION}\`);
      }

      _rpc_registry[imjoyRPC.VERSION] = imjoyRPC;
    }

    delete window.imjoyRPC;
    Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(rpc_url).then(() => {
      if (window.imjoyRPC) {
        const imjoyRPC = window.imjoyRPC;
        delete window.imjoyRPC;

        try {
          checkAndCacheLib(imjoyRPC);
          resolve(imjoyRPC);
        } catch (e) {
          reject(e);
        }
      } else if (typeof define === "function" && // eslint-disable-next-line no-undef
      __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) eval("require")(["imjoyRPC"], imjoyRPC => {
        try {
          checkAndCacheLib(imjoyRPC);
          resolve(imjoyRPC);
        } catch (e) {
          reject(e);
        }
      });else {
        reject("Failed to import imjoy-rpc.");
        return;
      }
    }).catch(reject);
  });
}
function loadImJoyRPCSocketIO(config) {
  config = config || {};
  return new Promise((resolve, reject) => {
    var baseUrl = config.base_url;
    let version = config.version;

    if (!baseUrl) {
      if (config.version) {
        baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc-socketio@\${config.version}/dist/\`;
      } else {
        if (config.api_version) {
          // find the latest version for this api_version
          version = findRPCVersionByAPIVersion(config.api_version, true);

          if (version) {
            baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc-socketio@\${version}/dist/\`;
          } else {
            reject(Error(\`Cannot find a version of imjoy-rpc-socketio that supports api v\${config.api_version}\`));
            return;
          }
        } else {
          baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc-socketio@latest/dist/\`;
          version = "latest";
          console.info(\`Using imjoy-rpc-socketio library from \${baseUrl}.\`);
        }
      }
    }

    let rpc_url = baseUrl + "imjoy-rpc-socketio.min.js";

    if (config.debug) {
      rpc_url = baseUrl + "imjoy-rpc-socketio.js";
    }

    delete window.imjoyRPCSocketIO;
    Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(rpc_url).then(() => {
      if (window.imjoyRPCSocketIO) {
        const imjoyRPCSocketIO = window.imjoyRPCSocketIO;
        delete window.imjoyRPCSocketIO;
        resolve(imjoyRPCSocketIO);
      } else if (typeof define === "function" && // eslint-disable-next-line no-undef
      __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) eval("require")(["imjoyRPCSocketIO"], resolve);else {
        reject("Failed to import imjoy-rpc-socketio.");
      }
    }).catch(reject);
  });
}

async function loadImJoyRPCByQueryString() {
  const urlParams = _getParams(window.location);

  return await loadImJoyRPC(urlParams);
}


window.loadImJoyRPCByQueryString = loadImJoyRPCByQueryString;
window.loadImJoyRPC = loadImJoyRPC;
window.loadImJoyRPCSocketIO = loadImJoyRPCSocketIO;
window.loadImJoyCore = loadImJoyCore;
window.loadImJoyBasicApp = _imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["loadImJoyBasicApp"];

//# sourceURL=webpack://%5Bname%5D/./src/imjoyLoader.js?`)},"./src/internalPlugins.json":function(module){eval(`module.exports = JSON.parse("{\\"BrowserFS\\":{\\"src\\":\\"https://imjoy-team.github.io/imjoy-core-plugins/BrowserFS.imjoy.html\\",\\"startup\\":false},\\"Jupyter-Engine-Manager\\":{\\"src\\":\\"https://imjoy-team.github.io/jupyter-engine-manager/Jupyter-Engine-Manager.imjoy.html\\",\\"startup\\":true},\\"WebPythonWorker\\":{\\"src\\":\\"https://imjoy-team.github.io/imjoy-core-plugins/WebPythonWorker.imjoy.html\\",\\"startup\\":true}}");

//# sourceURL=webpack://%5Bname%5D/./src/internalPlugins.json?`)},"./src/jailedPlugin.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createIframe", function() { return createIframe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeJailed", function() { return initializeJailed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicPlugin", function() { return DynamicPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExternalPluginConfig", function() { return getExternalPluginConfig; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.js */ "./src/api.js");
/* harmony import */ var _connection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./connection.js */ "./src/connection.js");
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _imjoyLoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./imjoyLoader.js */ "./src/imjoyLoader.js");
/**
 * @fileoverview Jailed - safe yet flexible sandbox
 *
 * @license MIT, see http://github.com/imjoy-team/imjoy-core
 * Copyright (c) 2020 ImJoy Team <imjoy.team@gmail.com>
 *
 * @license MIT, see http://github.com/asvd/jailed
 * Copyright (c) 2014 asvd <heliosframework@gmail.com>
 */






const JailedConfig = {
  default_rpc_base_url: null,
  default_base_frame: null
};
/**
 * Initializes the library site for web environment
 */

let _initialized = false;

const initializeJailed = config => {
  if (config) {
    for (let k in config) {
      JailedConfig[k] = config[k];
    }
  }

  if (!JailedConfig.default_base_frame) JailedConfig.default_base_frame = "https://lib.imjoy.io/default_base_frame.html";

  if (JailedConfig.default_rpc_base_url && !JailedConfig.default_rpc_base_url.endsWith("/")) {
    JailedConfig.default_rpc_base_url = JailedConfig.default_rpc_base_url + "/";
  }

  _initialized = true;
};

function createIframe(config) {
  var sample = document.createElement("iframe");
  sample.src = config.base_frame;
  sample.sandbox = "";
  sample.frameBorder = "0";
  sample.style.width = "100%";
  sample.style.height = "100%";
  sample.style.margin = "0";
  sample.style.padding = "0";
  sample.style.display = "none";
  const frame = sample.cloneNode(false);
  var perm = ["allow-scripts", "allow-forms", "allow-downloads", "allow-modals", "allow-popups", "allow-same-origin"];
  var allows = "";

  if (config.permissions) {
    if (config.permissions.includes("midi") && !allows.includes("midi *;")) {
      allows += "midi *;";
    }

    if (config.permissions.includes("geolocation") && !allows.includes("geolocation *;")) {
      allows += "geolocation *;";
    }

    if (config.permissions.includes("microphone") && !allows.includes("microphone *;")) {
      allows += "microphone *;";
    }

    if (config.permissions.includes("camera") && !allows.includes("camera *;")) {
      allows += "camera *;";
    }

    if (config.permissions.includes("encrypted-media") && !allows.includes("encrypted-media *;")) {
      allows += "encrypted-media *;";
    }

    if (config.permissions.includes("full-screen")) {
      frame.allowfullscreen = "";
    }

    if (config.permissions.includes("payment-request")) {
      frame.allowpaymentrequest = "";
    }
  }

  frame.sandbox = perm.join(" ");
  frame.allow = allows;
  frame.id = "iframe_" + config.id;
  return frame;
}
/**
 * DynamicPlugin constructor, represents a plugin initialized by a
 * string containing the code to be executed
 *
 * @param {String} code of the plugin
 * @param {Object} _interface to provide to the plugin
 */

class DynamicPlugin {
  constructor(config, _interface, engine, is_proxy, allow_evil, connection) {
    if (!_initialized) throw "Please call \`initializeJailed()\` before using Jailed.";
    this.config = config;
    this.id = config.id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    this._id = config._id;
    this.name = config.name;
    this.tag = config.tag;
    this.tags = config.tags;
    this.type = config.type;
    this.initializing = false;
    this.running = false;
    this._log_history = [];
    this._callbacks = config._callbacks || {};
    this._is_proxy = is_proxy;
    this.backend = Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["getBackendByType"])(this.type);
    this.engine = engine;
    this.allow_evil = allow_evil;
    this._hasVisibleWindow = ["window", "rpc-window"].includes(this.type);

    this._updateUI = _interface && _interface.utils && _interface.utils.$forceUpdate || function () {};

    this._bindInterface(_interface);

    if (is_proxy) {
      this._disconnected = false;
    } else {
      this._disconnected = true; // use the plugin event functions if it doesn't exist (window plugins has their own event functions)

      if (!this._initialInterface.on) this._initialInterface.on = this.on;
      if (!this._initialInterface.off) this._initialInterface.off = this.off;
      if (!this._initialInterface.emit) this._initialInterface.emit = this.emit;
      this.api = null;
      this._connected = new _utils_js__WEBPACK_IMPORTED_MODULE_0__["Whenable"](true);
      this._fail = new _utils_js__WEBPACK_IMPORTED_MODULE_0__["Whenable"](true);
      this._disconnect = new _utils_js__WEBPACK_IMPORTED_MODULE_0__["Whenable"](true);
      this.connected = new Promise((resolve, reject) => {
        this._resolveConnected = resolve;
        this._rejectConnected = reject;
      });

      this._connected.whenEmitted(this._resolveConnected);

      this._fail.whenEmitted(this._rejectConnected);

      if (connection) {
        this._setupRPC(connection, config);

        this._initialized_from_connection = true;
      } else {
        if (!this.backend) {
          this._setupViaEngine();
        } else if (this.type === "web-worker" && this.config.base_worker) {
          this._setupViaWebWorker();
        } else {
          this._setupViaIframe();
        }
      }
    }

    this._updateUI();
  }
  /**
   * Get the bound interface of the plugin
   */


  getBoundInterface() {
    return this._initialInterface;
  }
  /**
   * Bind the first argument of all the interface functions to this plugin
   */


  _bindInterface(_interface) {
    _interface = _interface || {};
    this._initialInterface = {
      _rintf: true
    }; // bind this plugin to api functions

    for (var k in _interface) {
      if (Object.prototype.hasOwnProperty.call(_interface, k)) {
        if (typeof _interface[k] === "function") {
          this._initialInterface[k] = _interface[k].bind(null, this);
        } else if (typeof _interface[k] === "object") {
          var utils = {};

          for (var u in _interface[k]) {
            if (Object.prototype.hasOwnProperty.call(_interface[k], u)) {
              if (typeof _interface[k][u] === "function") {
                utils[u] = _interface[k][u].bind(null, this);
              }
            }
          }

          this._initialInterface[k] = utils;
        } else {
          this._initialInterface[k] = _interface[k];
        }
      }
    }
  }

  _engineSetRemote(remote) {
    // check if the plugin is terminated during startup
    if (!this.engine) {
      console.warn("Plugin " + this.id + " is ready, but it was termianted.");
    }

    this.api = remote;
    this.api._rintf = true;
    this.api.config = {
      id: this.id,
      name: this.config.name,
      workspace: this.config.workspace,
      type: this.config.type,
      namespace: this.config.namespace,
      tag: this.config.tag,
      engine_mode: this.config.engine_mode,
      engine: this.engine.url,
      flags: this.config.flags
    };

    if (this.window_id) {
      this.api.config.window_id = this.config.window_id;
    }

    this._disconnected = false;

    if (this.initializing) {
      this.initializing = false;

      this._updateUI();

      this._connected.emit();

      this.engine.registerPlugin(this);
    }
  }

  async _setupViaEngine() {
    if (this.engine && this.engine._is_evil && this.allow_evil !== "eval is evil") {
      this._fail.emit("Evil engine is not allowed.");

      this._connection = null;
      this.error("Evil engine is not allowed.");

      this._set_disconnected();

      return;
    }

    if (!this.engine || !this.engine.connected) {
      this._fail.emit("Please connect to the Plugin Engine 🚀.");

      this._connection = null;
      this.error("Please connect to the Plugin Engine 🚀.");

      this._set_disconnected();

      return;
    }

    this.initializing = true;

    this._updateUI();

    const me = this;
    const engine_utils = {
      _rintf: true,

      setPluginAPI(remote) {
        me._engineSetRemote(remote);
      },

      terminatePlugin() {
        me.terminate();
      },

      setPluginStatus(status) {
        if (!me._disconnected) {
          me.running = status.running;

          me._updateUI();
        }
      }

    };

    if (this.config.passive) {
      this.engine.startPlugin(this.config, this._initialInterface, engine_utils);

      this._engineSetRemote({
        passive: true,
        _rintf: true,
        setup: async function () {},
        on: async function () {},
        off: async function () {},
        emit: async function () {}
      });
    } else {
      try {
        const remote = await this.engine.startPlugin(this.config, this._initialInterface, engine_utils); // the plugin can either return the api or call engine_utils.setPluginAPI later

        if (remote) {
          this._engineSetRemote(remote);
        }
      } catch (e) {
        this.error(e);

        this._set_disconnected();
      }
    }
  }

  _setupViaWebWorker() {
    if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["getBackendByType"])(this.type)) {
      throw \`Unsupported backend type (\${this.type})\`;
    }

    let webworker;
    webworker = new Worker(this.config.base_worker, {
      name: this.id
    });
    this.webworker = webworker;
    const connection = new _connection_js__WEBPACK_IMPORTED_MODULE_2__["WebWorkerConnection"](webworker);

    this._setupConnection(connection);
  }

  _setupViaIframe() {
    if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["getBackendByType"])(this.type)) {
      throw \`Unsupported backend type (\${this.type})\`;
    }

    if (!this.config.base_frame) {
      let frame_url = JailedConfig.default_base_frame;

      if (JailedConfig.default_rpc_base_url) {
        frame_url = frame_url + "?base_url=" + JailedConfig.default_rpc_base_url;
        console.log("imjoy-rpc library will be loaded from " + JailedConfig.default_rpc_base_url);
      } else {
        frame_url = frame_url + "?version=" + _imjoyLoader_js__WEBPACK_IMPORTED_MODULE_4__["latest_rpc_version"];
      }

      frame_url = frame_url + "&id=" + this.config.id;
      this.config.base_frame = frame_url;
    }

    const _frame = createIframe(this.config);

    if (this._hasVisibleWindow) {
      let window_id = this.config.window_id;

      if (typeof window_id === "string") {
        window_id = document.getElementById(window_id);
      }

      if (window_id) {
        _frame.style.display = "block";
        window_id.innerHTML = "";
        window_id.appendChild(_frame);
        this.window_id = window_id;
      } else {
        throw new Error(\`Failed to load plugin \${this.config.name}, iframe container (id=\${window_id}) not found.\`);
      }
    } else {
      document.body.appendChild(_frame);
    }

    const connection = new _connection_js__WEBPACK_IMPORTED_MODULE_2__["BasicConnection"](_frame);

    this._setupConnection(connection);
  }

  async _setupRPC(connection, pluginConfig) {
    this._connection = connection;
    this.initializing = true;

    this._updateUI();

    try {
      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"])(pluginConfig)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"].errors;
        console.error("Invalid config " + pluginConfig.name || false, pluginConfig, error);
        throw error;
      }

      const imjoyRPC = await Object(_imjoyLoader_js__WEBPACK_IMPORTED_MODULE_4__["loadImJoyRPC"])({
        base_url: JailedConfig.default_rpc_base_url,
        api_version: pluginConfig.api_version,
        debug: JailedConfig.debug
      });
      console.log(\`loaded imjoy-rpc v\${imjoyRPC.VERSION} for \${pluginConfig.name}\`);

      if (!this._rpc) {
        this._rpc = new imjoyRPC.RPC(this._connection, {
          name: "imjoy-core"
        });

        this._registerRPCEvents(this._rpc);

        this._rpc.setInterface(this._initialInterface);
      }

      await this._sendInterface();
      this._allow_execution = pluginConfig.allow_execution;

      if (pluginConfig.allow_execution) {
        await this._executePlugin();
      }

      this.config.passive = this.config.passive || pluginConfig.passive;

      if (this.config.passive) {
        this.api = {
          passive: true,
          _rintf: true,
          setup: async function () {},
          on: async function () {},
          off: async function () {},
          emit: async function () {}
        };
      } else {
        this.api = await this._requestRemote();
      }

      this.api.config = {
        id: this.id,
        name: this.config.name,
        workspace: this.config.workspace,
        type: this.config.type,
        namespace: this.config.namespace,
        tag: this.config.tag,
        flags: this.config.flags
      };

      if (this.window_id) {
        this.api.config.window_id = this.config.window_id;
      }

      this._disconnected = false;
      this.initializing = false;

      this._updateUI();

      this._connected.emit();
    } catch (error) {
      this._fail.emit(error);

      this.disconnect();
      this.initializing = false;
      if (error) this.error(error.toString());

      if (this._hasVisibleWindow && this.config.window_id) {
        const container = document.getElementById(this.config.window_id);
        container.innerHTML = \`<h5>Oops! failed to load the window.</h5><code>Details: \${dompurify__WEBPACK_IMPORTED_MODULE_3___default.a.sanitize(String(error))}</code>\`;
      }

      this._updateUI();
    }
  }

  _setupConnection(connection) {
    this._connection = connection;
    this.initializing = true;

    this._updateUI();

    initializeIfNeeded(this._connection, this.config);

    this._connection.on("initialized", async data => {
      if (data.error) {
        console.error("Plugin failed to initialize", data.error);
        throw new Error(data.error);
      }

      this._setupRPC(this._connection, data.config);
    }); // TODO: check when this will fire


    this._connection.on("failed", e => {
      this._fail.emit(e);
    });

    this._connection.on("disconnected", details => {
      if (details) {
        if (details.error) {
          this.error(details.error);
        } else if (details.info) {
          this.log(details.info);
        }
      }

      this._set_disconnected();
    });

    this._connection.connect();
  }

  _registerRPCEvents(_rpc) {
    _rpc.on("disconnected", details => {
      this._disconnect.emit();

      if (details) {
        if (details.error) {
          this.error(details.message);
        } else if (details.info) {
          this.log(details.info);
        }
      }

      this._set_disconnected();
    });

    _rpc.on("remoteIdle", () => {
      if (this.running) {
        this.running = false;

        this._updateUI();
      }
    });

    _rpc.on("remoteBusy", () => {
      if (!this._disconnected && !this.running) {
        this.running = true;

        this._updateUI();
      }
    });
  }

  async hotReload() {
    if (!this.backend) {
      this.config.hot_reloading = true;
      await this._setupViaEngine();
    } else {
      if (!this._rpc || this._disconnected) throw new Error("There is no RPC connection to the plugin.");
      this.initializing = true;

      this._updateUI();

      if (this._allow_execution) {
        try {
          await this._executePlugin(true);

          if (!this.config.passive) {
            this.api = await this._requestRemote();
          }
        } catch (error) {
          this.error(error.toString());
          throw error;
        } finally {
          this.initializing = false;

          this._updateUI();
        }
      } else {
        this.initializing = false;

        this._updateUI();

        throw new Error("This plugin does not allow execution.");
      }
    }
  }
  /**
   * Loads the plugin body (executes the code in case of the
   * DynamicPlugin)
   */


  async _executePlugin(hot_reloading) {
    if (hot_reloading && this.config.type === "window") //clear the page
      await this._connection.execute({
        type: "script",
        content: \`document.querySelectorAll('style,link[rel="stylesheet"]').forEach(item => item.remove());document.body.innerHTML = '';\`,
        attrs: {
          type: "application/javascript"
        },
        lang: "javascript"
      });

    if (this.config.requirements) {
      const requirement = {
        type: "requirements",
        lang: this.config.lang,
        requirements: this.config.requirements,
        env: this.config.env
      };
      const serialized_requirement = JSON.stringify(requirement);

      if (!hot_reloading || this._executed_requirements !== serialized_requirement) {
        await this._connection.execute(requirement);
        this._executed_requirements = JSON.stringify(requirement);
      }
    }

    if (this._hasVisibleWindow) {
      // TODO: support hot-reloading of window content
      if (this.config.styles) {
        for (let i = 0; i < this.config.styles.length; i++) {
          await this._connection.execute({
            type: "style",
            content: this.config.styles[i].content,
            attrs: this.config.styles[i].attrs,
            src: this.config.styles[i].attrs.src
          });
        }
      }

      if (this.config.links) {
        for (let i = 0; i < this.config.links.length; i++) {
          await this._connection.execute({
            type: "link",
            rel: this.config.links[i].attrs.rel,
            type_: this.config.links[i].attrs.type,
            attrs: this.config.links[i].attrs,
            href: this.config.links[i].attrs.href
          });
        }
      }

      if (this.config.windows) {
        for (let i = 0; i < this.config.windows.length; i++) {
          await this._connection.execute({
            type: "html",
            content: this.config.windows[i].content,
            attrs: this.config.windows[i].attrs
          });
        }
      }
    }

    if (this.config.scripts) {
      const scripts = [];
      let serialized_script = "";

      for (let i = 0; i < this.config.scripts.length; i++) {
        const script = {
          type: "script",
          content: this.config.scripts[i].content,
          lang: this.config.scripts[i].attrs.lang,
          attrs: this.config.scripts[i].attrs,
          src: this.config.scripts[i].attrs.src
        };
        serialized_script = serialized_script + JSON.stringify(script);
        scripts.push(script);
      }

      if (!hot_reloading || serialized_script !== this._executed_scripts) {
        for (let script of scripts) {
          await this._connection.execute(script);
        }

        this._executed_scripts = serialized_script;
      }
    }
  }
  /**
   * Requests the remote interface from the plugin (which was
   * probably set by the plugin during its initialization), emits
   * the connect event when done, then the plugin is fully usable
   * (meaning both the plugin and the application can use the
   * interfaces provided to each other)
   */


  _requestRemote() {
    return new Promise(resolve => {
      this._rpc.once("remoteReady", () => {
        resolve(this._rpc.getRemote());
      });

      this._rpc.requestRemote();
    });
  }

  _sendInterface() {
    return new Promise(resolve => {
      this._rpc.once("interfaceSetAsRemote", resolve);

      this._rpc.sendInterface();
    });
  }
  /**
   * Disconnects the plugin immideately
   */


  disconnect() {
    if (this._connection) this._connection.disconnect();

    this._disconnect.emit();
  }
  /**
   * Saves the provided function as a handler for the connection
   * failure Whenable event
   *
   * @param {Function} handler to be issued upon disconnect
   */


  onFailed(handler) {
    this._fail.whenEmitted(handler);
  }
  /**
   * Saves the provided function as a handler for the connection
   * success Whenable event
   *
   * @param {Function} handler to be issued upon connection
   */


  onConnected(handler) {
    this._connected.whenEmitted(handler);
  }
  /**
   * Saves the provided function as a handler for the connection
   * failure Whenable event
   *
   * @param {Function} handler to be issued upon connection failure
   */


  onDisconnected(handler) {
    this._disconnect.whenEmitted(handler);
  }

  _set_disconnected() {
    this._disconnected = true;
    this.running = false;
    this.initializing = false;
    this.terminating = false;
    this.engine = null;

    this._updateUI();
  }

  _forceDisconnect() {
    this._set_disconnected();

    if (this._rpc) {
      this._rpc.disconnect();

      this._rpc = null;
    }

    if (this._connection) {
      this._connection.disconnect();

      this._connection = null;
    }
  }

  async terminate(force) {
    if (this._disconnected) {
      this._set_disconnected();

      return;
    } // prevent call loop


    if (this.terminating) {
      return;
    }

    if (force) {
      this._forceDisconnect();
    }

    try {
      if (this.api && this.api.exit && typeof this.api.exit == "function") {
        this.api.exit();
      }
    } catch (e) {
      console.error("error occured when terminating the plugin", e);
    } finally {
      setTimeout((() => {
        this._forceDisconnect();
      }).bind(this), 1000);
    }
  }

  on(name, handler, fire_if_emitted) {
    this._callbacks = this._callbacks || {};

    if (this._callbacks[name]) {
      this._callbacks[name].push(handler);
    } else {
      this._callbacks[name] = [handler];
    }

    if (fire_if_emitted && this._callbacks[name].emitted) {
      handler(this._callbacks[name].emitted_data);
    }
  }

  off(name, handler) {
    if (this._callbacks[name]) {
      if (handler) {
        const handlers = this._callbacks[name];
        const idx = handlers.indexOf(handler);

        if (idx >= 0) {
          handlers.splice(idx, 1);
        } else {
          console.warn(\`callback \${name} does not exist.\`);
        }
      } else {
        delete this._callbacks[name];
      }
    } else {
      console.warn(\`callback \${name} does not exist.\`);
    }
  }

  emit(name, data) {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const errors = [];

      try {
        if (this._callbacks[name]) {
          for (let cb of this._callbacks[name]) {
            try {
              await cb(data !== undefined ? data : undefined);
            } catch (e) {
              errors.push(e);
              console.error(e);
            }
          }
        } else {
          // if no handler set, store the data
          this._callbacks[name] = [];
          this._callbacks[name].emitted = true;
          this._callbacks[name].emitted_data = data;
        }

        if (errors.length <= 0) {
          resolve();
        } else {
          reject(errors);
        }
      } catch (e) {
        reject(e);
      }
    });
  }

  log(msg) {
    if (typeof msg === "object") {
      this._log_history.push(msg);

      console.log(\`Plugin \${this.id}:\`, msg);
    } else {
      const args = Array.prototype.slice.call(arguments).join(" ");
      this._log_history._info = args.slice(0, 100);

      this._log_history.push({
        type: "info",
        value: args
      });

      console.log(\`Plugin \${this.id}: \${args}\`);
    }
  }

  error() {
    const args = Array.prototype.slice.call(arguments).join(" ");
    this._log_history._error = args.slice(0, 100);

    this._log_history.push({
      type: "error",
      value: args
    });

    console.error(\`Error in Plugin \${this.id}: \${args}\`);
  }

  progress(p) {
    if (p < 1) this._progress = p * 100;else this._progress = p;
  }

}

function initializeIfNeeded(connection, default_config) {
  connection.once("imjoyRPCReady", async data => {
    const config = data.config || {};
    let forwarding_functions = ["close", "on", "off", "emit"];

    if (["rpc-window", "window"].includes(config.type || default_config.type)) {
      forwarding_functions = forwarding_functions.concat(["resize", "show", "hide", "refresh"]);
    }

    let credential;

    if (config.credential_required) {
      if (!Array.isArray(config.credential_fields)) {
        throw new Error("Please specify the \`config.credential_fields\` as an array of object.");
      }

      if (default_config.credential_handler) {
        credential = await default_config.credential_handler(config.credential_fields);
      } else {
        credential = {};

        for (let k in config.credential_fields) {
          credential[k.id] = window.prompt(k.label, k.value);
        }
      }
    }

    connection.emit({
      type: "initialize",
      config: {
        name: default_config.name,
        type: default_config.type,
        allow_execution: true,
        enable_service_worker: false,
        forwarding_functions: forwarding_functions,
        expose_api_globally: true,
        credential: credential
      },
      peer_id: data.peer_id
    });
  });
}

function getExternalPluginConfig(src, container, show) {
  return new Promise((resolve, reject) => {
    let _connection, url, _frame;

    container = container || document.body;

    if (typeof src === "string") {
      _frame = createIframe({
        id: "external_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])(),
        type: "window",
        base_frame: src,
        permissions: []
      });
      if (!show) _frame.style.display = "none";
      container.appendChild(_frame);
      _connection = new _connection_js__WEBPACK_IMPORTED_MODULE_2__["BasicConnection"](_frame);
      url = src;
    } else {
      url = src.url;
      _connection = src;
    }

    const connection_timer = setTimeout(() => {
      reject("Timeout error: failed to connect to the plugin");
    }, 15000);
    initializeIfNeeded(_connection, {});

    _connection.once("initialized", async data => {
      if (_frame) container.removeChild(_frame);
      clearTimeout(connection_timer);
      const pluginConfig = data.config;

      if (data.error) {
        console.error("Plugin failed to initialize", data.error);
        throw new Error(data.error);
      }

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"])(pluginConfig)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"].errors;
        console.error("Invalid config " + pluginConfig.name || false, pluginConfig, error);
        throw error;
      }

      pluginConfig.base_frame = url;
      pluginConfig.code = \`<config lang="json">\\n\${JSON.stringify(pluginConfig, null, "  ")}\\n</config>\`;
      pluginConfig.uri = url;
      pluginConfig.origin = url;
      resolve(pluginConfig);
    });

    _connection.once("failed", e => {
      clearTimeout(connection_timer);
      if (_frame) container.removeChild(_frame);
      reject(e);
    });

    _connection.connect();
  });
}



//# sourceURL=webpack://%5Bname%5D/./src/jailedPlugin.js?`)},"./src/joy.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Joy", function() { return Joy; });
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lz-string */ "./node_modules/lz-string/libs/lz-string.js");
/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_1__);
/* eslint-disable */

/*****************

JOY.js: make happy little programs

VERSION 0 (the incredibly clunky first version) (sorry)

Created by Nicky Case http://ncase.me/

*****************/

 // THE JOY MASTER

function Joy(options) {
  // You can call this as "new Joy()" or just "Joy()"
  var self = this == window ? {} : this; // Modules to import?

  if (options.modules) {
    for (var i = 0; i < options.modules.length; i++) {
      Joy.loadModule(options.modules[i]);
    }
  } // I'm a Joy.Op!


  Joy.Op.call(self, options); // Initialize References

  Joy.initReferences(self); // Allow previewing of... ops, numbers, variables?

  if (self.previewOps == undefined) self.previewOps = false;
  if (self.previewNumbers == undefined) self.previewNumbers = false; //if(self.previewVariables==undefined) self.previewVariables = false;

  self.activePreview = null;

  self.canPreview = function (type) {
    type = type.charAt(0).toUpperCase() + type.slice(1);
    var allowed = self["preview" + type];
    return allowed && !self.activePreview;
  }; // And: automatically create MY widget!


  self.createWidget();

  if (self.container) {
    // ...and auto-add my DOM to a container, if provided in options
    if (typeof self.container === "string") self.container = document.body.querySelector(self.container);
    self.container.appendChild(self.dom);
  } // Initialize UI & Modal


  Joy.ui.init(self);
  Joy.modal.init(self); // Return to sender

  return self;
}

Joy.normalizeUI = function (ui) {
  if (!ui) {
    return "";
  }

  let normui = "";

  if (Array.isArray(ui)) {
    for (let it of ui) {
      if (typeof it === "string") normui = normui + it + "<br>";else if (typeof it === "object") {
        for (let k in it) {
          if (typeof it[k] === "string") normui = normui + k + ": " + it[k] + "<br>";else normui = normui + k + ": " + JSON.stringify(it[k]) + "<br>";
        }
      } else normui = normui + JSON.stringify(it) + "<br>";
    }
  } else if (typeof ui === "object") {
    throw "ui can not be an object, you can only use a string or an array.";
  } else if (typeof ui === "string") {
    normui = ui.trim();
  } else {
    normui = "";
    console.log("Warning: removing ui string.");
  }

  return normui;
};
/*****************

ACTORS help the Player, Editor & Data talk to each other.

To create an Op, you need to pass it a "options" object like so:
(ALL the parameters are optional, btw)
{
	id: "steps", // by default, this is opID AND dataID
	dataID: "steps", // ONLY if opID=/=dataID. (e.g. two ops modify same data)
	type: "number", // what Op Template to inherit from, if any
	placeholder: 50 // if no data, what should be the placeholder?
}

*****************/


Joy.Op = function (options, parent, data) {
  var self = this; // Meta

  self._class_ = "Op";
  self.options = options;
  self.parent = parent;
  self.top = self.parent ? self.parent.top : self; // if no parent, I'M top dog.
  // Inherit from Op Template, if any. THEN inherit from "options"

  self.type = options.type;

  if (self.type) {
    var opTemplate = Joy.getTemplateByType(self.type);

    _configure(self, opTemplate);
  }

  _configure(self, self.options);

  if (parent && typeof parent.onupdate == "object" && parent.onupdate[self.id]) {
    self.onupdate = parent.onupdate[self.id];
  } // Adding child ops


  self.children = [];

  self.addChild = function (child, data) {
    //get onupdate for the child
    if (typeof self.onupdate == "object" && self.onupdate[child.id]) {
      child.onupdate = self.onupdate[child.id];
    } // If child's not an Op, it's options to create a new Op.


    if (child._class_ != "Op") child = new Joy.Op(child, self, data);
    self.children.push(child); // If it has an ID, reference child with ID

    if (child.id) self[child.id] = child; // gimme

    return child;
  };

  self.removeChild = function (child) {
    _removeFromArray(self.children, child);

    child.kill();
  }; // Kill!


  self.onkill = self.onkill || function () {};

  self.kill = function () {
    // Remove my DOM, if any.
    if (self.dom && self.dom.parentNode) self.dom.parentNode.removeChild(self.dom); // Kill all children, too

    while (self.children.length > 0) {
      self.removeChild(self.children[0]);
    } // On Kill?


    self.onkill(self);
  }; /////////////////////////////////
  // ACTOR <-> DATA: //////////////
  /////////////////////////////////
  // Placeholder... convert to {value:w/e} object.


  if (self.placeholder === undefined) {
    // If nothing, blank object.
    self.placeholder = {};
  }

  if (typeof self.placeholder === "function") {
    // If placeholder's a function, run it!
    self.placeholder = self.placeholder();
  }

  if (typeof self.placeholder !== "object" || Array.isArray(self.placeholder)) {
    // If placeholder value's not an object (or is array)
    self.placeholder = {
      value: _clone(self.placeholder)
    };
  } // If data type not already specified, do that!


  if (!self.placeholder.type) {
    self.placeholder.type = self.type;
  } // If you didn't already pass in a data object, let's figure it out!


  self.data = self.data || data;

  if (!self.data) {
    var parent = self.parent;
    var dataID = self.dataID;

    if (parent && dataID) {
      // if nothing, put placeholder in parent
      if (!parent.data[dataID]) parent.data[dataID] = _clone(self.placeholder);
      self.data = parent.data[dataID]; // i'm parent's sub-data!
    } else {
      // ...otherwise, I'm standalone data.
      self.data = _clone(self.placeholder);
    }
  } // Get & Set!


  self.getData = function (dataID) {
    return self.data[dataID];
  };

  self.setData = function (dataID, newValue, noUpdate) {
    if (newValue === undefined) {
      delete self.data[dataID]; // DELETE the thing!
    } else {
      self.data[dataID] = newValue;
    }

    if (!noUpdate) self.update();
  }; /////////////////////////////////
  // ACTOR <-> EDITOR: "WIDGETS" //
  /////////////////////////////////


  self.dom = null; // to be created in "createWidget"!
  // Init & Create Widget (if none, just put a "todo")

  self.initWidget = self.initWidget || function () {
    self.dom = document.createElement("span");
    self.dom.innerHTML = "[todo: define ui for '" + self.type + "']";
  };

  self.createWidget = function () {
    self.initWidget(self); // bind

    return self.dom;
  }; // "Preview Data"


  self.previewData = null; /////////////////////////////////
  // ACTOR <-> PLAYER: "TARGETS" //
  /////////////////////////////////
  // Ops can ACT ON targets...

  self.onexecute = self.onexecute || function () {
    console.log("no execute function found.");
  };

  self.execute = async function (target, altData) {
    // Real or Preview data?
    var data;

    if (altData) {
      data = _clone(altData);
    } else if (self.previewData) {
      data = _clone(self.previewData);
    } else {
      data = _clone(self.data);
    } // Try to pre-evaluate all data beforehand!


    self.children.forEach(function (childOp) {
      var dataID = childOp.dataID;

      if (dataID) {
        var value = childOp.get(target);
        data[dataID] = value;
      }
    }); // On Execute!

    return await self.onexecute({
      op: self,
      target: target,
      data: data
    });
  }; // Update


  self.update = function () {
    // if(self.onchange && typeof self.onchange == 'function') self.onchange({});
    if (self.parent) self.parent.update();

    if (self.onupdate && typeof self.onupdate === "function") {
      // Real or Preview data?
      var data;

      if (self.previewData) {
        data = _clone(self.previewData);
      } else {
        data = _clone(self.data);
      } // Try to pre-evaluate all data beforehand!


      self.children.forEach(function (childOp) {
        var dataID = childOp.dataID;

        if (dataID) {
          var value = childOp.get({});
          data[dataID] = value;
        }
      });
      var ret = self.onupdate({
        data: data
      }); // TODO: make consistent with .execute()
      // if(ret instanceof Promise){
      // 	ret.then((res)=>{
      // 		try {
      // 			if(res && res.init){
      // 				// TODO: update the widget
      // 				// self.children = [];
      // 				// replace the entire dom
      // 				// Joy.initializeWithString(self, res.init);
      // 				// self.createWidget();
      // 				// if(self.top && self.top.container){
      // 				// 	self.top.container.innerHTML=""
      // 				// 	self.top.container.appendChild(self.dom);
      // 				// }
      // 				var old_dom = self.dom
      // 				self.children = [];
      // 				Joy.initializeWithString(self, res.init);
      // 				self.createWidget();
      // 				if(self.parent && self.parent.dom){
      // 					self.parent.dom.replaceChild(self.dom, old_dom);
      // 				}
      // 			}
      // 		} catch (e) {
      // 			console.error(e)
      // 		}
      // 	}).catch(()=>{
      // 		console.error('failed to run onupdate function in ' + self.id)
      // 	}); //my
      // }
    }
  };

  self.get_config = function (target) {
    target = target || {}; // Real or Preview data?

    var data;

    if (self.previewData) {
      data = _clone(self.previewData);
    } else {
      data = _clone(self.data);
    } // Try to pre-evaluate all data beforehand!


    self.children.forEach(function (childOp) {
      var dataID = childOp.dataID;

      if (dataID && target) {
        var value = childOp.get(target);
        data[dataID] = value;
      }
    });
    return data;
  }; // ...or GET INFO from targets.


  self.onget = self.onget || function (my) {
    return my.data;
  }; // dy default it returns data (my.config)


  self.get = function (target) {
    // Real or Preview data?
    var data = self.previewData ? self.previewData : self.data;
    data = _clone(data); // On Get!

    return self.onget({
      op: self,
      target: target,
      data: data
    });
  }; /////////////////////////////////
  // INITIALIZE ///////////////////
  /////////////////////////////////
  // Initialization: string or function?


  if (self.init) {
    if (typeof self.init === "string") Joy.initializeWithString(self, self.init);
    if (typeof self.init === "function") self.init(self);
  }
};
/*****************

ACTOR TEMPLATES that future Ops can be made from! Looks like this:

Joy.add({
	name: "Turn turtle", // what the Ops Widget calls it
	type: "turtle/turn", // what it's called in Op & Data
	tags: ["turtle", "op"], // meta tags
	init: "Turn {id:'angle', type:'number', placeholder:10} degrees", // for init'ing op & widget
	onexecute: function(my){
		my.target.turn(my.data.angle);
	}
});

*****************/
// Add Template


Joy.templates = [];

Joy.add = function (template) {
  var duplicated = Joy.templates.filter(function (t) {
    if (t.type === undefined || template.type === undefined) return false;else return t.type === template.type;
  });

  if (duplicated.length <= 0) {
    Joy.templates.push(template);
  } else {
    // console.log('replacing template ', template.name, template.type)
    for (var i = 0; i < duplicated.length; i++) _removeFromArray(Joy.templates, duplicated[i]);

    Joy.templates.push(template);
  }
};

Joy.remove = function (type) {
  var duplicated = Joy.templates.filter(function (t) {
    if (t.type === type) return true;
  });

  if (duplicated.length > 0) {
    // console.log('replacing template ', template.name, template.type)
    for (var i = 0; i < duplicated.length; i++) _removeFromArray(Joy.templates, duplicated[i]);
  }
};

Joy.reset = function () {
  Joy.templates = [];
}; // Get Template


Joy.getTemplateByType = function (type) {
  var template = Joy.templates.find(function (template) {
    return template.type === type;
  });
  if (!template) throw Error("No op template of type '" + type + "'!");
  return template;
};

Joy.getTemplatesByTag = function (tag) {
  return Joy.templates.filter(function (template) {
    return template.tags && template.tags.indexOf(tag) >= 0;
  });
}; // Modify Templates


Joy.modify = function () {
  // Arguments: (type, callback) or (type, rename, callback)
  var type, rename, callback;

  if (arguments.length == 2) {
    type = arguments[0];
    callback = arguments[1];
  } else {
    type = arguments[0];
    rename = arguments[1];
    callback = arguments[2];
  } // New Template inherits from old...


  var newTemplate = {};

  var _old = Joy.getTemplateByType(type);

  _configure(newTemplate, _old); // Then inherits from modifications


  var modifications = callback(_old);

  _configure(newTemplate, modifications); // Then, either RENAME or REMOVE old op template!


  if (rename) {
    _old.type = rename;
  } else {
    _removeFromArray(Joy.templates, _old);
  } // And add the new one!


  Joy.add(newTemplate);
}; // Converts a string into an ENTIRE ACTOR


Joy.initializeWithString = function (self, markup) {
  try {
    markup = dompurify__WEBPACK_IMPORTED_MODULE_0___default.a.sanitize(markup);
  } catch (e) {
    console.log("Failed to sanitize the ui string", e);
  }

  var opOptions = [];
  var html = markup; // Split the markup into Op Options & Widget HTML

  var startIndex = -1;
  var endIndex = -1;
  var stack = 0; // Go through each character. When you find a top-level "{...}" JSON string,
  // 1) parse it into an Op Option
  // 2) replace it in the markup with a <span> saying where its widget should go

  for (var i = 0; i < html.length; i++) {
    var character = html[i]; // ONLY the top-level {...}'s...

    if (stack == 0 && character == "{") startIndex = i;
    if (character == "{") stack++;
    if (character == "}") stack--;

    if (stack == 0 && character == "}") {
      endIndex = i + 1; // Cut out start to end, save as JSON & replace markup with <span>

      var json = html.slice(startIndex, endIndex);
      json = json.replace(/(\\w+)\\:/g, "'$1':"); // cleanup: give nameerties quotes

      json = json.replace(/\\'/g, '"'); // cleanup: replace ' with "

      json = JSON.parse(json);
      json.dataID = json.dataID || json.id; // cleanup: dataID=id by default

      opOptions.push(json); // remember option!

      html = html.substr(0, startIndex) + "<span id='widget_" + json.id + "'></span>" + html.substr(endIndex); // replace markup
      // GO BACK TO THE BEGINNING & START OVER
      // because i'm too lazy to calculate where the index should go now

      i = 0;
      startIndex = -1;
      endIndex = -1;
      stack = 0;
    }
  } // Create all child Ops


  opOptions.forEach(function (opOption) {
    self.addChild(opOption);
  }); // Create Widget: html, and replace

  self.createWidget = function () {
    self.dom = document.createElement("span");
    self.dom.innerHTML = html; // Replace all <spans> with childrens' widgets.

    self.children.forEach(function (child) {
      // Make child create a widget!
      child.createWidget(); // Replace <span> with child's widget

      var selector = "#widget_" + child.id;
      var span = self.dom.querySelector(selector);
      self.dom.replaceChild(child.dom, span);
    }); // Return to sender

    return self.dom;
  };
};
/*****************

JOY MODULES

So that a player can slowly step up the staircase of complexity
(also maybe import Ops in the future?)

*****************/


Joy.modules = {};

Joy.module = function (id, callback) {
  Joy.modules[id] = callback;
};

Joy.loadModule = function (id) {
  var module = Joy.modules[id];
  if (!module) throw Error("There's no module called '" + id + "'!");
  module();
};
/******************************

GETTING & SETTING REFERENCES FROM TOP.DATA

This is so you can sync variables, functions, strings, object names, etc.

Each reference should have: Unique ID, Tag, Data, Watchers
// (when Watchers[].length==0, delete that reference. Garbage day)

******************************/


Joy.initReferences = function (op) {
  // Create if not already
  var topdata = op.top.data;
  if (!topdata._references) topdata._references = {}; // Zero out all connected, it's a brand new world.

  for (var id in topdata._references) {
    var ref = topdata._references[id];
    ref.connected = 0;
  }
};

Joy.createReference = function (op, tags, data) {
  // The reference
  var topdata = op.top.data;
  var reference = {
    id: _generateUID(topdata._references),
    tags: _forceToArray(tags),
    data: data,
    connected: 0 // tracks how many ops this thing actually depends on

  };
  topdata._references[reference.id] = reference; // Gimme

  return reference;
};

Joy.getReferenceById = function (op, refID) {
  var topdata = op.top.data;
  return topdata._references[refID];
};

Joy.getReferencesByTag = function (op, tag) {
  var topdata = op.top.data;
  var refs = [];

  for (var id in topdata._references) {
    var ref = topdata._references[id];
    if (ref.tags.indexOf(tag) >= 0) refs.push(ref);
  }

  return refs;
};

Joy.connectReference = function (op, refID) {
  var ref = Joy.getReferenceById(op, refID);
  ref.connected++;
};

Joy.disconnectReference = function (op, refID) {
  var ref = Joy.getReferenceById(op, refID);
  ref.connected--;
  if (ref.connected == 0) Joy.deleteReference(op, refID);
};

Joy.deleteReference = function (op, refID) {
  var topdata = op.top.data;
  var reference = topdata._references[refID];
  delete topdata._references[refID];
};
/*
Joy.watchReference = function(topdata, id){
	var reference = topdata._references[id];
	reference._creators++;
	return reference;
};

Joy.unwatchReference = function(topdata, id){

	// The reference?
	var reference = topdata._references[id];
	reference._creators--;

	// If no more _creators, DELETE.
	if(reference._creators==0) Joy.deleteReference(topdata, id);

	return reference;

};
*/

/******************************

SAVE & LOAD

No need for a server!
Just compresses JSON with LZ-String and puts it in the URL

******************************/


Joy.encodeWorkflow = function (data) {
  var json = JSON.stringify(data); // Stringify

  var compressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.compressToEncodedURIComponent(json); // Compress

  return compressed;
};

Joy.decodeWorkflow = function (hash) {
  var decompressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.decompressFromEncodedURIComponent(hash);

  if (decompressed) {
    var data = JSON.parse(decompressed);
    return data;
  } else {
    return null;
  }
};

Joy.saveToURL = function (data) {
  var json = JSON.stringify(data); // Stringify

  var compressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.compressToEncodedURIComponent(json); // Compress

  var url = window.location.origin + window.location.pathname + "#/app?workflow=" + compressed; // append to current URL
  // TODO: keep # and OTHER query stuff the same, just change ?data

  return url;
};

Joy.loadFromURL = function () {
  var hash = _getParameterByName("workflow");

  var decompressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.decompressFromEncodedURIComponent(hash);

  if (decompressed) {
    var data = JSON.parse(decompressed);
    return data;
  } else {
    return null;
  }
};
/**********************************

RANDOM CRAP TO MAKE MY LIFE EASIER

TODO: namespace these to avoid conflict

**********************************/
// For true believers


Math.TAU = 2 * Math.PI; // Deep clone

var _clone = function (json) {
  return JSON.parse(JSON.stringify(json));
}; // "Configure": or just slap all properties of one object onto another


var _configure = function (target, config) {
  for (var key in config) {
    var value = config[key];
    target[key] = value;
  }
}; // Array stuff


var _removeFromArray = function (array, toDelete) {
  var index = array.indexOf(toDelete);
  if (index < 0) return false;
  array.splice(index, 1);
  return true;
}; // Instant space


var _nbsp = function () {
  var span = document.createElement("span");
  span.innerHTML = "&nbsp;";
  return span;
}; // When in Rome, use a completely unuseable numeric system
// from http://blog.stevenlevithan.com/archives/javascript-roman-numeral-converter


var _numberToRoman = function (num) {
  if (!+num) return NaN;
  var digits = String(+num).split(""),
      key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"],
      roman = "",
      i = 3;

  while (i--) roman = (key[+digits.pop() + i * 10] || "") + roman;

  var result = Array(+digits.join("") + 1).join("M") + roman;
  return result.toLowerCase();
}; // Number to Alphabetic Base 26
// from https://stackoverflow.com/a/8604591


var _numberToAlphabet = function (a) {
  var alpha = "abcdefghijklmnopqrstuvwxyz"; // First figure out how many digits there are.

  var c = 0;
  var x = 1;

  while (a >= x) {
    c++;
    a -= x;
    x *= 26;
  } // Now you can do normal base conversion.


  var s = "";

  for (var i = 0; i < c; i++) {
    s = alpha.charAt(a % 26) + s;
    a = Math.floor(a / 26);
  }

  return s;
}; // Helps prevent copy-pasting weird stuff into contenteditable
// see: http://jsfiddle.net/marinagon/1v63t05q/


var _insertTextAtCursor = function (text) {
  var sel, range, html;

  if (window.getSelection) {
    sel = window.getSelection();

    if (sel.getRangeAt && sel.rangeCount) {
      range = sel.getRangeAt(0);
      range.deleteContents();
      range.insertNode(document.createTextNode(text));
    }
  } else if (document.selection && document.selection.createRange) {
    document.selection.createRange().text = text;
  }
};

var _preventWeirdCopyPaste = function (element) {
  element.addEventListener("paste", function (e) {
    e.preventDefault();

    if (e.clipboardData && e.clipboardData.getData) {
      var text = e.clipboardData.getData("text/plain");
      document.execCommand("insertHTML", false, text);
    } else if (window.clipboardData && window.clipboardData.getData) {
      var text = window.clipboardData.getData("Text");

      _insertTextAtCursor(text);
    }
  });
};

var _selectAll = function (input, collapseToEnd) {
  // select all text in contenteditable
  // see http://stackoverflow.com/a/6150060/145346
  var range = document.createRange();
  range.selectNodeContents(input);
  if (collapseToEnd) range.collapse(false); // total hack

  var selection = window.getSelection();
  selection.removeAllRanges();

  try {
    selection.addRange(range);
  } catch (e) {}
};

var _unselectAll = function () {
  var selection = window.getSelection();
  selection.removeAllRanges();
};

var _fixStringInput = function (input) {
  // Empty? Fix that!
  if (input.innerText == "") {
    input.innerHTML = "&nbsp;"; // Is it empty? Let's fix that.

    _selectAll(input);
  } // Line breaks? HECK NO!


  if (input.innerHTML.search("<br>") >= 0) {
    input.innerHTML = input.innerHTML.replace(/(\\<br\\>)+/g, "&nbsp;");

    _selectAll(input, true);
  }
};

var _blurOnEnter = function (input) {
  input.addEventListener("keypress", function (event) {
    if (event.which === 13) {
      event.preventDefault();
      input.blur();
    }
  });
}; // Find a unique ID within an object


var _generateUID = function (obj) {
  var num = 0;
  var id;

  do {
    //id = Math.floor(Math.random()*1000000)+""; // a MILLION random IDs, hopefully don't go over
    id = "id" + num; // linear time but who cares

    num++;
  } while (obj[id]);

  return id;
}; // Make this an array, if not already


var _forceToArray = function (thing) {
  if (Array.isArray(thing)) return thing;else return [thing];
}; // Generate a deterministically pseudo-random color from an ID
// TODO: not looking like crap. same luminance, etc.
//var _generateColor = function(obj){	};
// Remove all children from a DOM


var _emptyDOM = function (node) {
  while (node.hasChildNodes()) node.removeChild(node.lastChild);
}; // Get Query Param
// thx to https://stackoverflow.com/a/901144


var _getParameterByName = function (name, url) {
  if (!url) url = window.location.href;
  name = name.replace(/[\\[\\]]/g, "\\\\$&");
  var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
      results = regex.exec(url);
  if (!results) return null;
  if (!results[2]) return "";
  return decodeURIComponent(results[2].replace(/\\+/g, " "));
}; ////////////////////////////
// Good Color Shtuff ///////
// thx to: https://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately/17243070#17243070
////////////////////////////

/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR
 * h, s, v
 */


function _HSVtoRGB(h, s, v) {
  var r, g, b, i, f, p, q, t;

  if (arguments.length === 1) {
    s = h.s, v = h.v, h = h.h;
  }

  h /= 360; // convert, yo.

  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;

    case 1:
      r = q, g = v, b = p;
      break;

    case 2:
      r = p, g = v, b = t;
      break;

    case 3:
      r = p, g = q, b = v;
      break;

    case 4:
      r = t, g = p, b = v;
      break;

    case 5:
      r = v, g = p, b = q;
      break;
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function _HSVToRGBString(h, s, v) {
  if (arguments.length === 1) {
    s = h[1], v = h[2], h = h[0]; // cast to different vars
  }

  var rgb = _HSVtoRGB(h, s, v);

  return "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
} // well, "random"


var _randomHSVIndex = 0;
var _randomHSVArray = [[0, 0.6, 1.0], [30, 0.8, 1.0], //[120, 0.9, 0.9],
[210, 0.8, 1.0], [260, 0.7, 1.0], [310, 0.6, 1.0]];

function _randomHSV() {
  var hsv = _randomHSVArray[_randomHSVIndex];
  _randomHSVIndex = (_randomHSVIndex + 1) % _randomHSVArray.length; //return _HSVToRGBString(hsv[0], hsv[1], hsv[2]);

  return hsv;
}

function _forceToRGB(color) {
  if (Array.isArray(color)) {
    color = _HSVToRGBString(color[0], color[1], color[2]); // HSV
  }

  return color;
}

(function () {
  // SINGLETON
  var ui = {};
  Joy.ui = ui;

  ui.init = function (master) {
    // CSS
    master.dom.classList.add("joy-master"); // Manual Scroll (to prevent it propagating up...)

    master.container.addEventListener("wheel", function (event) {
      var delta = event.deltaY;
      master.container.scrollTop += delta; // event.preventDefault();

      return false;
    }); // Prevent accidental backspace-history
    // because why the heck is this even a thing, jeez.
    // thx: https://stackoverflow.com/a/2768256
    // document.body.addEventListener('keydown', function(event){
    //     if(event.keyCode === 8) {
    //         var doPrevent = true;
    //         var types = ["text", "password", "file", "search", "email", "number", "date", "color", "datetime", "datetime-local", "month", "range", "search", "tel", "time", "url", "week"];
    //         var d = event.srcElement || event.target;
    //         var disabled = d.getAttribute("readonly") || d.getAttribute("disabled");
    //         if (!disabled) {
    //             if (d.isContentEditable) {
    //                 doPrevent = false;
    //             } else if (d.tagName.toUpperCase() == "INPUT") {
    //                 var type = d.getAttribute("type");
    //                 if (type) {
    //                     type = type.toLowerCase();
    //                 }
    //                 if (types.indexOf(type) > -1) {
    //                     doPrevent = false;
    //                 }
    //             } else if (d.tagName.toUpperCase() == "TEXTAREA") {
    //                 doPrevent = false;
    //             }
    //         }
    //         if (doPrevent) {
    //             event.preventDefault();
    //             return false;
    //         }
    //     }
    // });
  };
  /********************
  Button's config:
  {
  label: "derp",
  onclick: function(){},
  styles: ["round", "hollow"] // optional
  }
  ********************/


  ui.Button = function (config) {
    var self = this; // DOM. Pretty simple.

    var dom = document.createElement("div");
    dom.className = "joy-button";
    self.dom = dom; // Setting Label

    config.label = config.label || "";
    self.label = document.createElement("span");
    dom.appendChild(self.label);

    self.setLabel = function (newLabel) {
      self.label.innerHTML = newLabel;
    };

    self.setLabel(config.label); // On Click

    dom.onclick = function () {
      config.onclick();
    }; // Styles


    self.styles = config.styles || [];

    for (var i = 0; i < self.styles.length; i++) dom.classList.add(self.styles[i]);
  };
  /********************
  ChooserButton's config:
  {
  value: [current value], (optional)
  staticLabel: "+", (optional)
  options: options,
  onchange: function(value){},
  position: "left" // optional: for the Joy.modal
  styles: ["round", "hollow"] // optional: for the button
  }
  ********************/


  ui.ChooserButton = function (config) {
    var self = this; // Properties

    self.value = config.value;
    self.options = config.options; // expose, coz may change later

    self.onchange = config.onchange; // IF NO VALUE, PICK FIRST ONE, WHATEVER

    if (!self.value) {
      self.value = self.options[0].value;
    } // This is just a Button that calls Chooser Popup when clicked


    ui.Button.call(self, {
      label: config.staticLabel === undefined ? "" : config.staticLabel,
      onclick: function () {
        // Chooser Modal!
        Joy.modal.Chooser({
          source: self.dom,
          options: self.options,
          onchange: function (value) {
            // Update value & label
            self.value = value;

            _updateLabel(); // On Select callback


            self.onchange(value);
          },
          position: config.position
        });
      },
      styles: config.styles
    }); // Helper method

    var _updateLabel = function () {
      if (config.staticLabel !== undefined) return; // if static, no.
      // Otherwise, find the corresponding label to my current value & set to that.

      var label = self.options.find(function (pair) {
        return pair.value == self.value;
      }).label;
      self.setLabel(label);
    };

    _updateLabel();
  };
  /********************
  Scrubber's config:
  {
  min: 0,
  max: 180,
  value: [current value],
  onchange: function(value){}
  }
  ********************/


  ui.Scrubber = function (config) {
    var self = this; // Config...

    var min = config.min;
    var max = config.max;
    self.value = config.value; // DOM

    var dom = document.createElement("div");
    dom.className = "joy-scrubber";
    self.dom = dom; // DOM *is* Label

    self.setLabel = function (newValue) {
      dom.innerHTML = newValue.toFixed(self.sigfigs);
    }; // On Value Change: make sure it's the right num of sigfigs


    var _onValueChange = function (newValue) {
      newValue = parseFloat(newValue.toFixed(self.sigfigs));
      config.onchange(newValue);
    }; // DRAG IT, BABY


    var isDragging = false;
    var wasDragging = false;
    var lastDragX, startDragValue;
    var delta = 0;

    var _onmousedown = function (event) {
      isDragging = true;
      lastDragX = event.clientX;
      startDragValue = self.value;
      delta = 0;
      if (config.onstart) config.onstart();
    };

    var _onmousemove = function (event) {
      if (isDragging) {
        wasDragging = true; // What's the step?

        var step = Math.pow(0.1, self.sigfigs);
        step = parseFloat(step.toPrecision(1)); // floating point crap
        // Change number

        var velocity = event.clientX - lastDragX;
        lastDragX = event.clientX;
        var multiplier = Math.abs(velocity / 10);
        if (multiplier < 1) multiplier = 1;
        if (multiplier > 3) multiplier = 3;
        delta += velocity * multiplier;
        var dx = Math.floor(delta / 2);
        var newValue = startDragValue + dx * step;
        newValue = _boundNumber(newValue); // Only update if ACTUALLY new.

        if (self.value != newValue) {
          self.value = newValue;
          self.setLabel(newValue);

          _onValueChange(newValue);
        }
      }
    };

    var _boundNumber = function (newValue) {
      if (min !== undefined && newValue < min) newValue = min;
      if (max !== undefined && newValue > max) newValue = max;
      return newValue;
    };

    var _onmouseup = function () {
      isDragging = false;
      if (config.onstop) config.onstop();
      setTimeout(function () {
        wasDragging = false; // so can't "click" if let go on scrubber
      }, 1);
    }; // MOUSE EVENTS


    dom.addEventListener("mousedown", _onmousedown);
    window.addEventListener("mousemove", _onmousemove);
    window.addEventListener("mouseup", _onmouseup); // KILL ALL LISTENERS

    self.kill = function () {
      dom.removeEventListener("mousedown", _onmousedown);
      window.removeEventListener("mousemove", _onmousemove);
      window.removeEventListener("mouseup", _onmouseup);
    }; // On click: edit manually!


    var _manuallyEditing = false;

    dom.onblur = function () {
      if (_manuallyEditing) {
        _manuallyEditing = false;
        dom.contentEditable = false;

        _unselectAll(); // Done manually updating! The new number!


        _countSigFigs(dom.innerText); // re-calc sigfigs


        self.value = _parseNumber();
        self.setLabel(self.value);

        _onValueChange(self.value); // On Stop editing


        if (config.onstop) config.onstop();
      }
    };

    _preventWeirdCopyPaste(dom);

    _blurOnEnter(dom);

    dom.onclick = function () {
      if (wasDragging) return; // can't click if I was just dragging!

      _manuallyEditing = true; // Make it editable, and select it!

      dom.contentEditable = true;
      dom.spellcheck = false;

      _selectAll(dom); // On Start editing


      if (config.onstart) config.onstart();
    };

    dom.oninput = function (event) {
      if (!_manuallyEditing) return; // Also, no non-decimal or numbers

      var regex = /[^0-9.\\-]/g;

      if (dom.innerText.match(regex)) {
        dom.innerText = dom.innerText.replace(regex, "");
      }

      _fixStringInput(dom); // Show that change!


      _onValueChange(_parseNumber());
    };

    var _parseNumber = function () {
      var num = parseFloat(dom.innerText);
      if (isNaN(num)) num = 0;
      num = _boundNumber(num);
      return num;
    }; // How many significant digits?


    self.sigfigs = 0;

    var _countSigFigs = function (string) {
      string = string.toString();
      var sigfigs;
      var positionOfPeriod = string.search(/\\./);

      if (positionOfPeriod >= 0) {
        // has a period
        sigfigs = string.length - 1 - positionOfPeriod;
      } else {
        sigfigs = 0;
      }

      self.sigfigs = sigfigs;
    };

    _countSigFigs(self.value); // Current value...


    self.setLabel(self.value);
  };
  /********************
  String's config:
  {
  prefix: "[",
  suffix: "]",
  color:"whatever",
  value: data.value,
  onchange: function(value){
  data.value = value;
  self.update();
  },
  styles: ["comment"]
  }
  ********************/


  ui.String = function (config) {
    var self = this; // DOM

    var dom = document.createElement("div");
    dom.className = "joy-string";
    self.dom = dom; // The Actual Part that's Content Editable

    var input = document.createElement("span");
    input.contentEditable = true;
    input.spellcheck = false; // Prefix & Suffix & Color: entirely cosmetic

    var prefixDOM = document.createElement("span");
    var suffixDOM = document.createElement("span");
    prefixDOM.innerHTML = config.prefix || "";
    suffixDOM.innerHTML = config.suffix || "";
    dom.appendChild(prefixDOM);
    dom.appendChild(input);
    dom.appendChild(suffixDOM); // On input!

    input.oninput = function (event) {
      _fixStringInput(input);

      var value = input.innerText.replace(/(\\xa0)+/g, ""); // NOT innerHTML

      config.onchange(value); // callback!
    }; // On focus, select all


    input.onfocus = function () {
      _selectAll(input);
    };

    input.onblur = function () {
      _unselectAll();
    };

    _preventWeirdCopyPaste(input); // On pressing <enter>, DON'T line break, just blur


    input.onkeypress = function (e) {
      if (e.which == 13) {
        input.blur();
        return false;
      }

      return true;
    }; // Set String


    self.setString = function (value) {
      input.innerText = value;

      _fixStringInput(input);
    }; // Set Color, why not


    self.setColor = function (color) {
      color = _forceToRGB(color);
      dom.style.color = color;
      dom.style.borderColor = color;
    };

    if (config.color) self.setColor(config.color); // Styles

    self.styles = config.styles || [];

    for (var i = 0; i < self.styles.length; i++) dom.classList.add(self.styles[i]); // Start with the current value


    self.setString(config.value);
  };
  /********************
  TextLine's config:
  {
  multiline: true,
  readonly: true,
  width: number or "[style]",
  onchange: function(newValue){},
  placeholder: "//derp"
  styles: ["box"]
  }
  ********************/
  // TODO: a full WSIYWIG editor?
  // https://hackernoon.com/easily-create-an-html-editor-with-designmode-and-contenteditable-7ed1c465d39b


  ui.TextBox = function (config) {
    var self = this; // DOM

    var input;

    if (config.multiline) {
      input = document.createElement("textarea");
    } else {
      input = document.createElement("input");
      input.type = "text";
    }

    if (config.placeholder) {
      input.placeholder = config.placeholder;
    }

    input.spellcheck = false;
    input.className = "joy-textbox";
    self.dom = input;
    var dom = self.dom; // Config options

    if (config.readonly) {
      input.setAttribute("readonly", 1);
      input.addEventListener("click", function () {
        self.select();
      });
    } else {
      input.oninput = function (event) {
        config.onchange(input.value);
      };
    }

    if (config.width) {
      input.style.width = typeof config.width === "number" ? config.width + "px" : config.width;
    } // Get & Set Value


    self.getValue = function () {
      return input.value;
    };

    self.setValue = function (value) {
      input.value = value;
    }; // Select


    self.select = function () {
      input.select();
    }; // Styles


    self.styles = config.styles || [];

    for (var i = 0; i < self.styles.length; i++) dom.classList.add(self.styles[i]); // Start


    if (config.value) self.setValue(config.value); // If it's multiline, auto-resize!
    // Thanks to this: https://stackoverflow.com/a/25621277

    if (config.multiline) {
      var _onInput = function () {
        this.style.height = "auto";
        this.style.height = this.scrollHeight + "px";
      };

      dom.addEventListener("input", _onInput, false);
      setTimeout(function () {
        dom.setAttribute("style", "height:" + dom.scrollHeight + "px; overflow-y:hidden;");
      }, 1); // some threading thing?
    }
  };
})();
/********************
MODAL:
Places a big ol' modal dialogue bubble over the editor!
********************/


(function () {
  // SINGLETON
  var modal = {};
  Joy.modal = modal;

  modal.init = function (master) {
    //remove existing model dialog
    var elements = document.querySelectorAll("#joy-modal");

    for (var i = 0; i < elements.length; i++) {
      elements[i].parentNode.removeChild(elements[i]);
    } // The main modal container


    modal.dom = document.createElement("div");
    modal.dom.id = "joy-modal";
    document.body.appendChild(modal.dom); // Transparent background you click to kill!

    modal.bg = document.createElement("div");
    modal.bg.id = "joy-bg";

    modal.bg.onclick = function () {
      modal.currentUI.kill();
    };

    modal.dom.appendChild(modal.bg); // The actual bubble box

    modal.box = document.createElement("div");
    modal.box.id = "joy-box";
    modal.box.className = "arrow_box";
    modal.dom.appendChild(modal.box); // NO SCROLL

    modal.dom.addEventListener("wheel", function (event) {
      if (modal.box.style.overflow != "auto") {
        event.preventDefault();
        return false;
      } else {
        return true;
      }
    });
  };

  modal.show = function (ui) {
    modal.dom.style.display = "block"; // hi
    // Remember & add UI

    modal.currentUI = ui;
    modal.box.appendChild(ui.dom); // Position the Box

    var position = ui.config.position || "below";
    var boxBounds = modal.box.getBoundingClientRect();
    var sourceBounds = ui.config.source.getBoundingClientRect();
    var bgBounds = modal.bg.getBoundingClientRect();
    var x,
        y,
        margin = 20;
    var overflow = false; // HACK: IF BELOW & NO SPACE, do LEFT

    if (position == "below") {
      var y = sourceBounds.top + sourceBounds.height + margin; // y: bottom

      if (y + boxBounds.height > document.body.clientHeight) {
        // below page!
        position = "left";
      }
    }

    modal.box.setAttribute("position", position);

    switch (position // TODO: smarter positioning
    ) {
      case "below":
        var x = sourceBounds.left + sourceBounds.width / 2; // x: middle

        var y = sourceBounds.top + sourceBounds.height + margin; // y: bottom

        x -= boxBounds.width / 2;
        break;

      case "left":
        var x = sourceBounds.left - margin; // x: left

        var y = sourceBounds.top + sourceBounds.height / 2; // y: middle

        x -= boxBounds.width;
        y -= boxBounds.height / 2;
        break;
    }

    if (x < 0) x = 1;
    if (y + boxBounds.height > bgBounds.height) y = bgBounds.height - boxBounds.height - 1;
    modal.box.style.left = x + "px";
    modal.box.style.top = y + "px"; // On Open

    if (modal.currentUI.config.onopen) modal.currentUI.config.onopen();
  };

  modal.hide = function () {
    _emptyDOM(modal.box);

    modal.dom.style.display = "none"; // bye
    // On Close

    if (modal.currentUI.config.onclose) modal.currentUI.config.onclose();
  };
  /********************
  Chooser's config:
  {
  source: [who this modal dialog should be "coming from"]
  value: [currently selected value, if any]
  options: [label-value pairs],
  onchange: function(value){}, // callback
  position: "below" // default is "below"
  };
  ********************/


  modal.Chooser = function (config) {
    var self = {}; // just an obj to scope this stuff
    // Config

    self.config = config; // Create DOM

    var dom = document.createElement("div");
    dom.className = "joy-modal-chooser";
    self.dom = dom; // Create List DOM

    var list = document.createElement("div");
    dom.appendChild(list); // Populate with list of options

    self.options = [];
    self.categories = {};
    var _placeholder_ = "_placeholder_";

    var _makeCategory = function (category) {
      // dom
      var categoryDOM = document.createElement("div");
      list.appendChild(categoryDOM); // remember

      self.categories[category] = categoryDOM;
    };

    self.populate = function () {
      // Create categories, if any!
      for (var i = 0; i < config.options.length; i++) {
        var option = config.options[i];
        var category = option.category;

        if (category) {
          // Category doesn't exist yet... make it!
          if (!self.categories[category]) _makeCategory(category);
        } else {
          // Make a placholder if not alredy!
          if (!self.categories[_placeholder_]) _makeCategory(_placeholder_);
        }
      } // Create options


      for (var i = 0; i < config.options.length; i++) {
        // Create option
        var option = config.options[i];
        var optionDOM = document.createElement("div");
        optionDOM.innerHTML = option.label;

        if (option.color) {
          optionDOM.style.color = option.color;
        } // Put it in its category!


        var category = option.category || _placeholder_;
        self.categories[category].appendChild(optionDOM); // On Click!

        (function (option) {
          // TODO: Hover & preview mode?
          optionDOM.onclick = function (event) {
            self.onchange(option.value);
            event.stopPropagation(); // no, don't double-fire
          };
        })(option);
      }
    };

    self.populate(); // On Select

    self.onchange = function (value) {
      self.kill();
      config.onchange(value); // on select AFTER kill, since can create ANOTHER modal
    }; // Kill & Remove


    self.kill = function () {
      modal.hide(); // hide modal
    }; // Show me!


    modal.show(self);
  };
  /********************
  Color's config:
  {
  source: [who this modal dialog should be "coming from"]
  value: [currently selected value, if any]
  onchange: function(value){}, // callback
  onclose: function(){}
  };
  ********************/


  modal.Color = function (config) {
    var self = {}; // just an obj to scope this stuff
    // Config

    self.config = config; // Create DOM

    var dom = document.createElement("div");
    dom.className = "joy-modal-color";
    self.dom = dom; // COLOR is HSV.

    config.value = config.value || [0, 1, 1];
    self.h = config.value[0];
    self.s = config.value[1];
    self.v = config.value[2]; // THREE ELEMENTS:
    // 1. Color Wheel
    // 2. Color Value
    // 3. Color Pickers

    var WHEEL_SIZE = 150;
    var SPECTRUM_WIDTH = 15;
    var MARGIN_1 = 10;
    var MARGIN_2 = 10;
    var MARGIN_3 = 10;
    var FULL_WIDTH = MARGIN_1 + WHEEL_SIZE + MARGIN_2 + SPECTRUM_WIDTH + MARGIN_3;
    var FULL_HEIGHT = MARGIN_1 + WHEEL_SIZE + MARGIN_3;
    self.dom.style.width = FULL_WIDTH + "px";
    self.dom.style.height = FULL_HEIGHT + "px"; /////////////////////////////
    // 1) The Color Wheel ///////
    /////////////////////////////

    var wheelCanvas = document.createElement("canvas");
    wheelCanvas.id = "joy-color-wheel";
    var wheelContext = wheelCanvas.getContext("2d");
    wheelCanvas.width = WHEEL_SIZE * 2;
    wheelCanvas.height = WHEEL_SIZE * 2;
    wheelCanvas.style.width = wheelCanvas.width / 2 + "px";
    wheelCanvas.style.height = wheelCanvas.height / 2 + "px";
    dom.appendChild(wheelCanvas);
    wheelCanvas.style.top = MARGIN_1 + "px";
    wheelCanvas.style.left = MARGIN_1 + "px";

    var _updateWheel = function () {
      // Image Data!
      var ctx = wheelContext;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      var w = wheelCanvas.width;
      var h = wheelCanvas.height;
      var image = ctx.createImageData(w, h);
      var imageData = image.data; // Create a circle of colors
      // Thanks to: https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43

      var cx = w / 2;
      var cy = h / 2;
      var radius = w / 2; // buffer for the crosshair

      var radiusBuffered = radius + 2; // small buffer for clipping

      for (var x = 0; x < w; x++) {
        for (var y = 0; y < h; y++) {
          var dx = x - cx;
          var dy = y - cy;
          var distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < radiusBuffered) {
            // buffer for clipping
            if (distance >= radius) distance = radius; // Angle & Distance, re-mapped to [0,1]

            var angle = Math.atan2(dy, dx); // from [-tau/2, tau/2]

            angle = (angle / Math.TAU + 0.5) * 360; // to [0,360]

            distance = distance / radius; // to [0,1]
            // HSV! (capitals, coz already using 'h')

            var H = angle;
            var S = distance;
            var V = self.v; // TO RGB

            var rgb = _HSVtoRGB(H, S, V);

            var i = (x + y * w) * 4;
            imageData[i] = rgb[0];
            imageData[i + 1] = rgb[1];
            imageData[i + 2] = rgb[2];
            imageData[i + 3] = 255;
          }
        }
      }

      ctx.putImageData(image, 0, 0); // Clip it, for aliasing

      ctx.save();
      ctx.globalCompositeOperation = "destination-in";
      ctx.beginPath();
      ctx.fillStyle = "#fff";
      ctx.arc(cx, cy, radius, 0, Math.TAU);
      ctx.fill();
      ctx.restore();
    };

    _updateWheel(); /////////////////////////////
    // 2) The Value Spectrum ////
    /////////////////////////////


    var spectrumCanvas = document.createElement("canvas");
    spectrumCanvas.id = "joy-color-value";
    var spectrumContext = spectrumCanvas.getContext("2d");
    spectrumCanvas.width = SPECTRUM_WIDTH * 2;
    spectrumCanvas.height = WHEEL_SIZE * 2;
    spectrumCanvas.style.width = spectrumCanvas.width / 2 + "px";
    spectrumCanvas.style.height = spectrumCanvas.height / 2 + "px";
    dom.appendChild(spectrumCanvas);
    spectrumCanvas.style.top = MARGIN_1 + "px";
    spectrumCanvas.style.right = MARGIN_3 + "px";

    var _updateSpectrum = function () {
      // Image data
      var ctx = spectrumContext;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      var w = spectrumCanvas.width;
      var h = spectrumCanvas.height;
      var image = ctx.createImageData(w, h);
      var imageData = image.data; // Just a good ol' spectrum of values

      for (var x = 0; x < w; x++) {
        for (var y = 0; y < h; y++) {
          // HSV! (capitals, coz already using 'h')
          var H = self.h;
          var S = self.s;
          var V = 1 - y / h; // TO RGB

          var rgb = _HSVtoRGB(H, S, V);

          var i = (x + y * w) * 4;
          imageData[i] = rgb[0];
          imageData[i + 1] = rgb[1];
          imageData[i + 2] = rgb[2];
          imageData[i + 3] = 255;
        }
      }

      ctx.putImageData(image, 0, 0);
    };

    _updateSpectrum(); /////////////////////////////
    // 3) The Color Pickers /////
    /////////////////////////////


    var pickerCanvas = document.createElement("canvas");
    pickerCanvas.id = "joy-color-picker";
    var pickerContext = pickerCanvas.getContext("2d");
    pickerCanvas.width = FULL_WIDTH * 2;
    pickerCanvas.height = FULL_HEIGHT * 2;
    pickerCanvas.style.width = pickerCanvas.width / 2 + "px";
    pickerCanvas.style.height = pickerCanvas.height / 2 + "px";
    dom.appendChild(pickerCanvas);

    var _updatePickers = function () {
      // What's the color?
      var x, y;
      var ctx = pickerContext;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = _HSVToRGBString(self.h, self.s, self.v);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2; // Draw it on the circle

      var cx = MARGIN_1 * 2 + wheelCanvas.width / 2;
      var cy = MARGIN_1 * 2 + wheelCanvas.height / 2;
      var angle = self.h * (Math.TAU / 360);
      var radius = self.s * (wheelCanvas.width / 2);
      x = cx - Math.cos(angle) * radius;
      y = cy - Math.sin(angle) * radius;
      ctx.beginPath();
      ctx.arc(x, y, SPECTRUM_WIDTH, 0, Math.TAU);
      ctx.fill();
      ctx.stroke(); // Draw it on the spectrum

      var sx = MARGIN_1 * 2 + wheelCanvas.width + MARGIN_2 * 2 + spectrumCanvas.width / 2;
      var sy = MARGIN_1 * 2;
      x = sx;
      y = sy + spectrumCanvas.height * (1 - self.v);
      ctx.beginPath();
      ctx.arc(x, y, SPECTRUM_WIDTH, 0, Math.TAU);
      ctx.fill();
      ctx.stroke();
    };

    _updatePickers(); // THE MOUSE EVENTS FOR THE PICKERS


    var editMode;
    var isDragging = false;

    var _update = function (event) {
      if (event.target != pickerCanvas) return; // if outta bounds forget it

      var x = event.offsetX * 2;
      var y = event.offsetY * 2;

      if (editMode == "hs") {
        x -= MARGIN_1 * 2;
        y -= MARGIN_1 * 2;

        _updateHS(x, y);
      } else {
        x -= MARGIN_1 * 2 + wheelCanvas.width + MARGIN_2 * 2;
        y -= MARGIN_1 * 2;

        _updateV(x, y);
      } // HEY TELL THE SOURCE


      _updateSource();
    };

    var _updateHS = function (x, y) {
      // get polar
      var radius = wheelCanvas.width / 2;
      var dx = x - radius;
      var dy = y - radius;
      var angle = Math.atan2(dy, dx);
      var distance = Math.sqrt(dx * dx + dy * dy); // Re-map

      angle = (angle / Math.TAU + 0.5) * 360; // to [0,360]

      if (angle < 0) angle = 0;
      if (angle > 360) angle = 360;
      distance = distance / radius; // to [0,1]

      if (distance < 0) distance = 0;
      if (distance > 1) distance = 1; // update

      self.h = angle;
      self.s = distance;

      _updateSpectrum();

      _updatePickers();
    };

    var _updateV = function (x, y) {
      self.v = 1 - y / spectrumCanvas.height;
      if (self.v < 0) self.v = 0;
      if (self.v > 1) self.v = 1;

      _updateWheel();

      _updatePickers();
    };

    var _onmousedown = function (event) {
      isDragging = true;

      if (event.offsetX * 2 < MARGIN_1 * 2 + wheelCanvas.width + MARGIN_2) {
        editMode = "hs";
      } else {
        editMode = "v";
      }

      _update(event);
    };

    var _onmousemove = function (event) {
      if (isDragging) _update(event);
    };

    var _onmouseup = function () {
      isDragging = false;
    }; // MOUSE EVENTS


    pickerCanvas.addEventListener("mousedown", _onmousedown);
    window.addEventListener("mousemove", _onmousemove);
    window.addEventListener("mouseup", _onmouseup); // UPDATE SOURCE

    var _updateSource = function () {
      var newValue = [self.h, self.s, self.v];
      newValue[0] = parseFloat(newValue[0].toFixed(0));
      newValue[1] = parseFloat(newValue[1].toFixed(2));
      newValue[2] = parseFloat(newValue[2].toFixed(2));
      config.onchange(newValue);
    }; // Kill


    self.kill = function () {
      // KILL LISTENERS
      dom.removeEventListener("mousedown", _onmousedown);
      window.removeEventListener("mousemove", _onmousemove);
      window.removeEventListener("mouseup", _onmouseup); // Hide Modal

      modal.hide();
    }; // Show me!


    modal.show(self);
  };
})(); /////////////////////////////////////////
// FUNDAMENTAL USER INTERACE ACTORS /////
/////////////////////////////////////////
// TODO: Angle widget

/****************

Raw number widget: JUST the scrubber, no chooser

Widget Options:
{id:'steps', type:'number', placeholder:10, min:0, max:180, step:1}

****************/


Joy.add({
  type: "number",
  tags: ["ui"],
  initWidget: function (self) {
    // Scrubber IS the DOM
    var o = self.options;
    var scrubber = new Joy.ui.Scrubber({
      min: o.min,
      max: o.max,
      step: o.step,
      value: self.getData("value"),
      onstart: function () {
        self.top.activePreview = self;
      },
      onstop: function () {
        self.top.activePreview = null;
      },
      onchange: function (value) {
        self.setData("value", value);
      }
    });
    self.dom = scrubber.dom; // PREVIEW ON HOVER. WIGGLE IT JUST ONCE.

    var _ticker = null;
    var _fps = 30;

    self.dom.onmouseenter = function () {
      if (!self.top.canPreview("numbers")) return; // Create Preview Data

      self.previewData = _clone(self.data); // Wiggle by 5%... as long as that's not less than 0.5, not more than 2.

      var _amplitude = Math.abs(self.data.value * 0.05); //if(_amplitude<0.5) _amplitude=0.5; // TODO: WITH SIGFIG
      //if(_amplitude>3) _amplitude=3;


      if (_amplitude == 0) _amplitude = 1; // If it's EXACTLY zero, wiggle with 1, whatever.

      var _timer = 0;
      _ticker = setInterval(function () {
        if (!self.top.canPreview("numbers")) return _stopPreview(); // don't even

        _timer += Math.TAU / _fps / 0.25; // 0.25 seconds

        self.previewData.value = self.data.value + Math.sin(_timer) * _amplitude;
        self.update();
        if (_timer > Math.TAU) _stopPreview(); // yer done, son.
      }, 1000 / _fps);
    };

    var _stopPreview = function () {
      if (_ticker) clearInterval(_ticker);
      self.previewData = null; // self.update();
    };

    self.dom.onmouseleave = _stopPreview;
  },
  onget: function (my) {
    return my.data.value;
  },
  placeholder: {
    value: 3
  }
});
/****************

A button widget

Widget Options:
{id:'direction', type:'button', label:'OK'}

When it's clicked, it will call the corresponding onupdate function

****************/

Joy.add({
  type: "button",
  tags: ["ui"],
  initWidget: function (self) {
    // DOM
    var dom = document.createElement("div");
    dom.className = "joy-save";
    self.dom = dom; // Save Button

    self.saveButton = new Joy.ui.Button({
      label: self.options.label || "--",
      onclick: function () {
        self.update();
      }
    });
    dom.appendChild(self.saveButton.dom);
  }
});
/****************

A color widget! (for now, same as choose except paints DOM, too)

Widget Options:
{id:'direction', type:'choose', options:['left','right'], placeholder:'left'}

****************/

Joy.add({
  type: "color",
  tags: ["ui"],
  initWidget: function (self) {
    // Color Button IS the DOM
    var colorButton = new Joy.ui.Button({
      label: "&nbsp;",
      onclick: function () {
        Joy.modal.Color({
          // TODO: precision for those floats, y'know
          source: self.dom,
          value: self.getData("value"),
          onchange: function (value) {
            self.setData("value", value);

            _changeLabelColor();
          },
          onopen: function () {
            self.top.activePreview = self;
          },
          onclose: function () {
            self.top.activePreview = null;
          }
        });
      },
      styles: ["joy-color"]
    });
    self.dom = colorButton.dom; // Change button color!

    var _changeLabelColor = function () {
      var hsl = self.getData("value");
      colorButton.dom.style.background = _HSVToRGBString(hsl);
    };

    _changeLabelColor(); // PREVIEW ON HOVER
    // BOUNCE the HSL Value up & down!


    var _ticker = null;
    var _fps = 30;

    var _initialV, _vel, _timer;

    self.dom.onmouseenter = function () {
      if (!self.top.canPreview("numbers")) return; // yeah let's pretend it's a number
      // Create Preview Data

      _initialV = self.data.value[2];
      self.previewData = _clone(self.data); // Bounce up & down for HALF a second

      _timer = 0;
      _vel = 2 * (2 / _fps);
      _ticker = setInterval(function () {
        if (!self.top.canPreview("numbers")) return _stopPreview(); // don't
        // Bounce up & down

        var hsl = self.previewData.value;
        hsl[2] += _vel;

        if (hsl[2] > 1) {
          hsl[2] = 1;
          _vel *= -1;
        }

        if (hsl[2] < 0) {
          hsl[2] = 0;
          _vel *= -1;
        }

        self.update(); // Done!

        _timer += 2 / _fps;
        if (_timer >= 1) _stopPreview();
      }, 1000 / _fps);
    };

    var _stopPreview = function () {
      if (_ticker) clearInterval(_ticker);
      self.previewData = null;
      self.update();
    };

    self.dom.onmouseleave = _stopPreview;
  },
  onget: function (my) {
    return _HSVToRGBString(my.data.value);
  },
  placeholder: function () {
    var hue = Math.floor(Math.random() * 360); // Random color!

    return [hue, 0.8, 1.0];
  }
});
/****************

A choose-y thing

Widget Options:
{name:'direction', type:'choose', options:['left','right'], placeholder:'left'}
// TODO... "options" gets overrided soooo UHHHHH.

****************/

Joy.add({
  type: "choose",
  tags: ["ui"],
  initWidget: function (self) {
    var data = self.data; // Options

    var options = self.options;

    for (var i = 0; i < options.length; i++) {
      // convert to label/value if not already
      var o = options[i];

      if (!(o.label !== undefined && o.value !== undefined)) {
        options[i] = {
          label: o.toString(),
          value: o
        };
      }
    } // ChooserButton *IS* DOM


    var chooserButton = new Joy.ui.ChooserButton({
      value: data.value,
      options: options,
      onchange: function (value) {
        data.value = value;
        self.update(); // you oughta know!
      },
      styles: self.styles
    });
    self.dom = chooserButton.dom;
  },
  onget: function (my) {
    return my.data.value;
  }
});
/****************

A widget to type in strings!

Widget Options:
{name:'name', type:'string', prefix:'&ldquo;', suffix:'&rdquo;', color:"whatever"}

****************/

Joy.add({
  type: "string",
  tags: ["ui"],
  initWidget: function (self) {
    // String *IS* DOM
    var o = self.options;
    self.stringUI = new Joy.ui.String({
      prefix: o.prefix,
      suffix: o.suffix,
      color: o.color,
      value: self.getData("value"),
      onchange: function (value) {
        self.setData("value", value);
      }
    });
    self.dom = self.stringUI.dom; // When data's changed, externally

    self.onDataChange = function () {
      var value = self.getData("value");
      self.stringUI.setString(value);
    };
  },
  onget: function (my) {
    return my.data.value;
  },
  placeholder: "???"
});
/****************

A widget to save data as hash!

Widget Options:
{type:'save'} // NO "id"! It just saves the top-most data.

****************/

Joy.add({
  type: "save",
  tags: ["ui"],
  initWidget: function (self) {
    // DOM
    var dom = document.createElement("div");
    dom.className = "joy-save";
    self.dom = dom; // Save Button

    self.saveButton = new Joy.ui.Button({
      label: "save",
      onclick: function () {
        var url = Joy.saveToURL(self.top.data);
        self.url.setValue(url);
        self.url.select(); // info

        var chars = url.length;
        self.info.innerHTML = "P.S: you can shorten your link with <a href='http://tinyurl.com/' target='_blank'>TinyURL</a>!";
      }
    });
    dom.appendChild(self.saveButton.dom); // URL TextBox

    self.url = new Joy.ui.TextBox({
      readonly: true
    });
    dom.appendChild(self.url.dom); // Details: chars & tinyurl link

    self.info = document.createElement("div");
    self.info.id = "joy-save-info";
    dom.appendChild(self.info);
  }
}); ////////////////////////////////////////////////////////
// THE BIG ACTOR: A "PROGRAMMABLE" LIST OF OPS <3 //
////////////////////////////////////////////////////////

/****************

A nice list of ops.

WidgetConfig:
{type:'ops', name:'ops', resetVariables:false}

****************/

Joy.add({
  type: "ops",
  tags: ["ui"],
  init: function (self) {
    if (self.resetVariables !== undefined) self.data.resetVariables = self.resetVariables; // TODO: ACTUALLY REFACTOR
    // TODO: Separate out Op code from Widget code
    // so that this can run EVEN WITHOUT WIDGETS.
    // Using messages, probably.
  },
  initWidget: function (self) {
    var data = self.data;
    var ops = data.ops; // DOM

    var dom = document.createElement("div");
    dom.className = "joy-ops";
    self.dom = dom; // List

    var list = document.createElement("list");
    list.id = "joy-list";
    dom.appendChild(list); // Preview Variables?

    /*var varPreview;
    if(self.top.canPreview("variables")){
    varPreview = document.createElement("div");
    varPreview.id = "joy-variables-preview";
    varPreview.innerHTML = "AHHHH";
    dom.appendChild(varPreview);
    }*/
    //////////////////////////////////////////
    // Create Bullet /////////////////////////
    //////////////////////////////////////////

    var bulletOptions = [{
      label: "Add op above",
      value: "op_above"
    }, {
      label: "Add op below",
      value: "op_below"
    }, {
      label: "Delete",
      value: "delete"
    }];

    var _onBulletChoice = function (entry, choice) {
      // ACTION ABOVE or BELOW
      var newOpWhere = 0;
      if (choice == "op_above") newOpWhere = -1; // above

      if (choice == "op_below") newOpWhere = 1; // below

      if (newOpWhere != 0) {
        // not NOT new op
        var newEntryIndex = self.entries.indexOf(entry);
        if (newOpWhere > 0) newEntryIndex += 1; // Chooser Modal!

        Joy.modal.Chooser({
          position: "below",
          source: entry.bullet.dom,
          options: opOptions,
          onchange: function (value) {
            _addOp(value, newEntryIndex);

            self.update(); // You oughta know!

            _updateBullets(); // update the UI, re-number it.

          }
        });
      } // DELETE


      if (choice == "delete") {
        _removeFromArray(self.entries, entry); // Delete entry from Entries[]


        _removeFromArray(ops, entry.opData); // Delete op from Data's Ops[]


        self.removeChild(entry.op); // Delete op from Children[]

        list.removeChild(entry.dom); // Delete entry from DOM

        self.update(); // You oughta know!

        _updateBullets(); // update the UI, re-number it.

      }
    };

    var _createBullet = function (entry) {
      var bullet = new Joy.ui.ChooserButton({
        position: "below",
        staticLabel: _getBulletLabel(entry),
        options: bulletOptions,
        onchange: function (choice) {
          _onBulletChoice(entry, choice);
        },
        styles: ["joy-bullet"]
      });
      bullet.dom.id = "joy-bullet";
      return bullet;
    }; // Get the digit (or letter, or roman) for this bullet...


    var _getBulletLabel = function (entry) {
      // What index am I?
      var index = self.entries.indexOf(entry) + 1; // How many levels deep in "ops" am I?

      var levelsDeep = 0;
      var parent = self.parent;

      while (parent) {
        if (parent.type == "ops") levelsDeep++;
        parent = parent.parent;
      } // Digit, Letter, or Roman? (Cycle around)


      var label;

      switch (levelsDeep % 3) {
        case 0:
          label = index;
          break;
        // digits

        case 1:
          label = _numberToAlphabet(index);
          break;
        // letter

        case 2:
          label = _numberToRoman(index);
          break;
        // roman
      }

      return label;
    }; // Re-number ALL these bad boys


    var _updateBullets = function () {
      for (var i = 0; i < self.entries.length; i++) {
        var entry = self.entries[i];
        var bullet = entry.bullet;

        var label = _getBulletLabel(entry);

        bullet.setLabel(label);
      }
    }; ////////////////////////////////////////////////////////////////////
    // Add Entry: Entries have a Bullet (the number) & actual widget! //
    ////////////////////////////////////////////////////////////////////


    self.entries = [];

    var _addEntry = function (opData, atIndex) {
      // New entry
      var entry = {};
      var entryDOM = document.createElement("div");
      if (atIndex === undefined) atIndex = self.entries.length;
      self.entries.splice(atIndex, 0, entry);
      list.insertBefore(entryDOM, list.children[atIndex]); // The Bullet is a Chooser!

      var bullet = _createBullet(entry);

      var bulletContainer = document.createElement("div");
      bulletContainer.id = "joy-bullet-container";
      entryDOM.appendChild(bulletContainer);
      bulletContainer.appendChild(bullet.dom); // New Op!

      var newOp = self.addChild({
        type: opData.type
      }, opData); // The Widget

      var newWidget = newOp.createWidget();
      newWidget.id = "joy-widget";
      entryDOM.appendChild(newWidget); // (Remember all this)

      entry.dom = entryDOM;
      entry.bullet = bullet;
      entry.op = newOp;
      entry.widget = newWidget;
      entry.opData = opData; // PREVIEW ON HOVER
      // Also tell the op "_PREVIEW": how far in the op to go?

      var _calculatePreviewParam = function (event) {
        var param = event.offsetY / bullet.dom.getBoundingClientRect().height;
        if (param < 0) param = 0;
        if (param > 1) param = 1;
        _previewOp._PREVIEW = param;
        self.update();
      };

      var _previewOp;

      var _previewStyle;

      bulletContainer.onmouseenter = function (event) {
        if (!self.top.canPreview("ops")) return;
        self.top.activePreview = self; // Create Preview Data

        self.previewData = _clone(self.data);
        var opIndex = self.entries.indexOf(entry);
        _previewOp = self.previewData.ops[opIndex]; // STOP after that op!

        self.previewData.ops.splice(opIndex + 1, 0, {
          STOP: true
        }); // How far to go along op?

        _calculatePreviewParam(event); // Add in a style


        _previewStyle = document.createElement("style");
        document.head.appendChild(_previewStyle);

        _previewStyle.sheet.insertRule(".joy-ops.joy-previewing > #joy-list > div:nth-child(n+" + (opIndex + 2) + ") { opacity:0.1; }");

        _previewStyle.sheet.insertRule(".joy-ops.joy-previewing > div.joy-bullet { opacity:0.1; }");

        dom.classList.add("joy-previewing");
      };

      bulletContainer.onmousemove = function (event) {
        if (self.previewData) _calculatePreviewParam(event);
      };

      bulletContainer.onmouseleave = function () {
        if (self.previewData) {
          self.previewData = null;
          self.top.activePreview = null;
          self.update();
          document.head.removeChild(_previewStyle);
          dom.classList.remove("joy-previewing");
        }
      };

      return entry;
    }; // add all INITIAL ops as widgets


    for (var i = 0; i < ops.length; i++) _addEntry(ops[i]); ///////////////////////////////////////
    // Add Op /////////////////////////
    ///////////////////////////////////////
    // Manually add New Op To Ops + Widgets + DOM


    var _addOp = function (opType, atIndex) {
      // Create that new entry & everything
      var newOp = {
        type: opType
      };

      if (atIndex === undefined) {
        ops.push(newOp);
      } else {
        ops.splice(atIndex, 0, newOp);
      }

      var entry = _addEntry(newOp, atIndex); // Focus on that entry's widget!
      // entry.widget.focus();

    }; // Ops you can add:
    // TODO: INCLUDE ALIASED OPS


    var opOptions = [];

    if (self.onlyOps) {
      for (var i = 0; i < self.onlyOps.length; i++) {
        var opType = self.onlyOps[i];
        var opTemplate = Joy.getTemplateByType(opType);
        var notOpTag = opTemplate.tags.filter(function (tag) {
          return tag != "op"; // first tag that's NOT "op"
        })[0];
        opOptions.push({
          label: opTemplate.name,
          value: opType,
          category: notOpTag
        });
      }
    } else {
      var opOps = Joy.getTemplatesByTag("op");

      for (var i = 0; i < opOps.length; i++) {
        var opOp = opOps[i];
        var notOpTag = opOp.tags.filter(function (tag) {
          return tag != "op";
        })[0];
        opOptions.push({
          label: opOp.name,
          value: opOp.type,
          category: notOpTag
        });
      }
    } // "+" Button: When clicked, prompt what ops to add!


    var addButton = new Joy.ui.ChooserButton({
      staticLabel: "+",
      options: opOptions,
      onchange: function (value) {
        _addOp(value);

        self.update(); // You oughta know!
      },
      styles: ["joy-bullet"]
    });
    dom.appendChild(addButton.dom);
  },
  onexecute: async function (my) {
    // Create _vars, if not already there
    if (!my.target._variables) my.target._variables = {}; // Reset all of target's variables?

    if (my.data.resetVariables) my.target._variables = {}; // Do those ops, baby!!!

    for (var i = 0; i < my.data.ops.length; i++) {
      // Stop?
      var opData = my.data.ops[i];
      if (opData.STOP) return "STOP"; // Run

      var op = my.op.entries[i].op; // TODO: THIS IS A HACK AND SHOULD NOT RELY ON THAT

      var result = await op.execute(my.target, opData); // use ol' op, but GIVEN data.

      if (result && result.target) {
        my.target = result.target;
      } else if (result && result.error) {
        console.error("ops stopped with error: ", result);
        return result;
      } else if (result && result.stop) {
        console.log("ops interrupted at step ", i, result);
        return result;
      } else if (result == "STOP") return result;
    }

    return my;
  },
  placeholder: {
    ops: [],
    resetVariables: true
  }
}); /////////////////////////////////////////
// LOGIC ACTORS /////////////////////////
/////////////////////////////////////////

Joy.module("instructions", function () {
  Joy.add({
    name: "Repeat the following...",
    type: "instructions/repeat",
    tags: ["instructions", "op"],
    init: "Repeat the following {id:'count', type:'number', min:1, placeholder:3} times: " + "{id:'ops', type:'ops', resetVariables:false}",
    onexecute: async function (my) {
      // Previewing? How much to preview?
      var param = 1;
      if (my.data._PREVIEW !== undefined) param = my.data._PREVIEW; // Loop through it... (as far as preview shows, anyway)

      var loops = Math.floor(my.data.count * param);

      for (var i = 0; i < loops; i++) {
        var result = await my.op.ops.execute(my.target);

        if (result && result.target) {
          my.target = result.target;
        } else if (result.error) {
          console.error("op stopped with error: ", result);
          return result;
        } else if (result.stop) {
          console.log("op interrupted at step ", i, result);
          return result;
        } else if (result == "STOP") return result; // STOP

      }

      return my;
    }
  });
  /*Joy.add({
  name: "If... then...",
  type: "instructions/if",
  tags: ["instructions", "op"],
  init: "If AHHH, then: "+
  	  "{id:'ops', type:'ops', resetVariables:false}",
  onexecute: function(my){
  	var message = my.op.ops.execute(my.target);
  	if(message=="STOP") return message; // STOP
  }
  });*/

  Joy.add({
    name: "// Write a note",
    type: "instructions/comment",
    tags: ["instructions", "op"],
    initWidget: function (self) {
      // DOM
      self.dom = document.createElement("div"); // Comment Box

      self.box = new Joy.ui.TextBox({
        multiline: true,
        placeholder: "// your notes here",
        value: self.getData("value"),
        onchange: function (value) {
          self.setData("value", value);
        },
        styles: ["box"]
      });
      self.dom.appendChild(self.box.dom);
    }
  });
}); // VARIABLE NAME: you're just a synchronized string, yo.

Joy.add({
  type: "variableName",
  tags: ["ui"],
  init: function (self) {
    var variableType = self.variableType; // Unique Variable Name

    var _uniqueVariableName = function () {
      var varnames = Joy.getReferencesByTag(self, variableType).map(function (ref) {
        return ref.data.value;
      });
      var highestCount = 0;
      varnames.forEach(function (varname) {
        var num;
        if (varname == "variable") num = 1; // at least 1

        var match = varname.match(/variable\\s(\\d+)/);
        if (match) num = parseInt(match[1]); // or more

        if (highestCount < num) highestCount = num;
      });
      if (highestCount == 0) return "variable";else return "variable " + (highestCount + 1);
    }; // Create Reference method


    self._createNewReference = function () {
      var refData = {
        value: _uniqueVariableName(),
        color: _randomHSV()
      };
      var ref = Joy.createReference(self, variableType, refData);
      self.setData("refID", ref.id, true); // Remember Ref ID. And DON'T update.

      Joy.connectReference(self, ref.id); // connect new ref
    }; // Do I already have a reference? Create one if no.


    var refID = self.getData("refID");

    if (refID) {
      Joy.connectReference(self, refID); // connect this ref
    } else {
      // Well, first try seeing if there are any vars.
      // If so, connect to most recently created one
      var varReferences = Joy.getReferencesByTag(self, variableType); // CONFIG: self.startWithExisting!

      if (self.startWithExisting && varReferences.length > 0) {
        var latestReference = varReferences[varReferences.length - 1];
        refID = latestReference.id;
        self.setData("refID", refID, true); // set data

        Joy.connectReference(self, refID); // connect this ref
      } else {
        // Otherwise, make a new one!
        self._createNewReference();
      }
    } // Switch reference


    self._switchReference = function (newRefID) {
      var refID = self.getData("refID");
      Joy.disconnectReference(self, refID); // disconnect old ref

      self.setData("refID", newRefID); // DO update this!

      Joy.connectReference(self, newRefID); // connect new ref
    };
  },
  initWidget: function (self) {
    self.dom = document.createElement("span"); // The String edits my REFERENCE'S data.

    var refID = self.getData("refID");
    var refData = Joy.getReferenceById(self, refID).data;
    var stringOp = self.addChild({
      type: "string",
      prefix: "[",
      suffix: "]",
      color: refData.color
    }, refData);
    var stringWidget = stringOp.createWidget();
    self.dom.appendChild(stringWidget); // This String Op also updates its color

    var _old_stringOp_onDataChange = stringOp.onDataChange;

    stringOp.onDataChange = function () {
      _old_stringOp_onDataChange();

      var color = stringOp.getData("color");
      stringOp.stringUI.setColor(color);
    }; // Chooser? Can choose to switch to other variables (or make new one)


    var variableType = self.variableType;

    var _showChooser = function () {
      var options = []; // Get all references that are of this type

      var refs = Joy.getReferencesByTag(self, variableType);
      var myRefID = self.getData("refID");
      refs.forEach(function (ref) {
        if (ref.id == myRefID) return; // don't show SELF

        var color = ref.data.color;
        color = _HSVToRGBString(color[0], color[1], color[2]);
        options.push({
          label: "[" + ref.data.value + "]",
          value: ref.id,
          color: color
        });
      }); // Meta Options:

      options.push({
        category: "meta",
        label: "(+new)",
        value: "NEW"
      });
      options.push({
        category: "meta",
        label: "(change color)",
        value: "CHANGE_COLOR"
      }); // Show all possible variables!

      Joy.modal.Chooser({
        source: self.dom,
        options: options,
        onchange: function (newRefID) {
          if (newRefID == "CHANGE_COLOR") {
            // Just change color, ha.
            Joy.modal.Color({
              source: self.dom,
              value: stringOp.getData("color"),
              onchange: function (newColor) {
                stringOp.setData("color", newColor);
                stringOp.stringUI.setColor(newColor); // do this again coz edit lock
              }
            });
          } else {
            // Make a new reference? Either way, set refID
            if (newRefID == "NEW") {
              var oldRefID = self.getData("refID");
              Joy.disconnectReference(self, oldRefID); // disconnect old ref

              self._createNewReference();

              self.update(); // update, yo
            } else {
              self._switchReference(newRefID);
            } // Make String Widget edit that instead


            var refID = self.getData("refID");
            var ref = Joy.getReferenceById(self, refID);
            stringOp.switchData(ref.data);
          }
        }
      });
    }; // Show ON CLICK!


    if (!self.noChooser) {
      self.dom.onclick = _showChooser;
    }
  },
  onget: function (my) {
    var refID = my.data.refID;
    var ref = Joy.getReferenceById(my.op, refID);
    return ref.data.value; // returns the variable name
  },
  onkill: function (self) {
    // Disconnect any references I may have
    var refID = self.getData("refID");
    Joy.disconnectReference(self, refID); // disconnect old ref
  }
}); /////////////////////////////////////////
// MATH ACTORS //////////////////////////
/////////////////////////////////////////

Joy.module("math", function () {
  /*********************
  Alright. This is gonna be a big one.
  It needs to be able to chain math elements,
  and each element needs to be able to switch between
  scrubbers, variables, and other number-getter ops.
  Data:
  {
  type: "number",
  chain:[
  	{type:"number_raw", value:3},
  	{type:"choose", value:"*"},
  	{type:"variableName", refID:whatever},
  	{type:"choose", value:"+"},
  	{type:"turtle/getAngle"}
  ]
  }
  *********************/
  Joy.modify("number", "number_raw", function (_old) {
    return {
      init: function (self) {
        // no variables?
        if (self.noVariables) return; // Force data to a chain...

        var originalValue = self.getData("value");

        if (typeof originalValue === "number") {
          self.setData("value", undefined, true); // delete "value", no update

          self.setData("chain", [{
            type: "number_raw",
            min: self.min,
            max: self.max,
            step: self.step,
            value: originalValue
          }], true); // create "chain", no update
        } // MAKE A NEW CHAIN ACTOR *AND DATA(?)*


        self._makeNewChainOp = function (chainItem, atIndex) {
          // Make it
          var chainOp;
          var type = chainItem.type;

          switch (type) {
            // Elements
            case "number_raw":
              chainOp = self.addChild({
                type: type,
                min: chainItem.min,
                max: chainItem.max,
                step: chainItem.step
              }, chainItem);
              break;

            case "variableName":
              chainOp = self.addChild({
                type: type,
                variableType: "number",
                noChooser: true
              }, chainItem);
              break;
            // Operand

            case "choose":
              chainOp = self.addChild({
                type: type,
                options: [{
                  label: "+",
                  value: "+"
                }, {
                  label: "-",
                  value: "-"
                }, {
                  label: "&times;",
                  value: "*"
                }, {
                  label: "&divide;",
                  value: "/"
                }],
                styles: ["joy-math"]
              }, chainItem);
              break;
          } // Add or splice to Chain Ops array! *AND THE DATA*


          var chain = self.getData("chain");

          if (atIndex !== undefined) {
            self.chainOps.splice(atIndex, 0, chainOp);
            chain.splice(atIndex, 0, chainItem);
          } else {
            self.chainOps.push(chainOp);
            chain.push(chainItem);
          } // Return


          return chainOp;
        }; // Create an op for each element in the chain


        self.chainOps = []; // keep a chain parallel to children. this one's in ORDER.

        var realChain = self.getData("chain");

        var chain = _clone(realChain);

        realChain.splice(0, realChain.length); // empty out realChain

        for (var i = 0; i < chain.length; i++) {
          self._makeNewChainOp(chain[i]);
        } // REPLACE A CHAIN ACTOR *AND DATA*


        self._replaceChainOp = function (oldChainOp, newItem) {
          // Delete old op, and add new op where it was
          var oldIndex = self._deleteChainOp(oldChainOp);

          var newChainOp = self._makeNewChainOp(newItem, oldIndex); // update manually!


          self.update(); // Return

          return newChainOp;
        }; // DELETE A CHAIN ACTOR *AND DATA*


        self._deleteChainOp = function (chainOp) {
          // Delete op
          var oldIndex = self.chainOps.indexOf(chainOp);

          _removeFromArray(self.chainOps, chainOp);

          self.removeChild(chainOp); // and data!

          var chain = self.getData("chain");
          chain.splice(oldIndex, 1); // so can re-use index

          return oldIndex;
        };
      },
      initWidget: function (self) {
        // no variables?
        if (self.noVariables) {
          _old.initWidget(self);

          return;
        } // Container!


        self.dom = document.createElement("span");
        self.dom.className = "joy-number"; // Show Chooser!

        var _showChooser = function (chainOp) {
          var options = []; // Show placeholder number (unless i'm a number_raw, or there isn't one)

          if (chainOp.type != "number_raw") {
            var placeholderNumber = self.placeholder.value;

            if (typeof placeholderNumber === "number") {
              options.push({
                label: placeholderNumber,
                value: {
                  type: "number_raw",
                  value: placeholderNumber
                }
              });
            }
          } // Show possible variables (except the current variable)


          var refs = Joy.getReferencesByTag(self, "number");
          var myRefID;
          if (chainOp.type == "variableName") myRefID = chainOp.getData("refID");
          refs.forEach(function (ref) {
            if (ref.id == myRefID) return; // don't show SELF

            var color = ref.data.color;
            color = _HSVToRGBString(color[0], color[1], color[2]);
            options.push({
              label: "[" + ref.data.value + "]",
              value: {
                type: "variableName",
                refID: ref.id
              },
              color: color
            });
          }); // Show all these dang options!

          if (options.length > 0) {
            Joy.modal.Chooser({
              source: chainOp.dom,
              options: options,
              onchange: function (newItem) {
                // REPLACE CHAIN ACTOR & ENTRY
                var newChainOp = self._replaceChainOp(chainOp, newItem);

                self._replaceChainEntry(chainOp, newChainOp);
              }
            });
          }
        }; // THE WAY TO ORGANIZE THIS: ENTRIES that have DOM *and* ACTOR


        self._chainEntries = []; // MAKE CHAIN ENTRY

        self._makeChainEntry = function (chainOp, atIndex) {
          // Widget
          var widget = document.createElement("span");
          chainOp.createWidget();
          widget.appendChild(chainOp.dom); // Widget chooser, if NOT an operand

          if (chainOp.type != "choose") {
            var entry;
            var moreButton = new Joy.ui.Button({
              onclick: function () {
                _showChainOptions(entry);
              },
              styles: ["joy-more"]
            });
            widget.appendChild(moreButton.dom);
          } // Place in widget


          if (atIndex !== undefined) {
            if (atIndex < self.dom.childNodes.length) {
              // replacing NOT at last child...
              var beforeThisWidget = self.dom.childNodes[atIndex];
              self.dom.insertBefore(widget, beforeThisWidget);
            } else {
              // Otherwise just append
              self.dom.appendChild(widget);
            }
          } else {
            self.dom.appendChild(widget);
          } // If it's NOT an operand, clicking it reveals options


          if (chainOp.type != "choose") {
            (function (ca) {
              // HACK: click, NOT scrub. detect w/ time frame
              var _mouseDownTime;

              ca.dom.addEventListener("mousedown", function () {
                _mouseDownTime = +new Date();
              });
              ca.dom.addEventListener("mouseup", function () {
                var _time = +new Date();

                if (_time - _mouseDownTime < 500) {
                  _showChooser(ca); // if clicked in less than a half second

                }
              });
            })(chainOp);
          } // Entry


          entry = {
            widget: widget,
            op: chainOp
          };

          if (atIndex !== undefined) {
            self._chainEntries.splice(atIndex, 0, entry);
          } else {
            self._chainEntries.push(entry);
          }
        }; // DELETE CHAIN ENTRY


        self._deleteChainEntry = function (chainOp) {
          // Get index (so can return later)
          var entry = self._chainEntries.find(function (entry) {
            return entry.op == chainOp;
          });

          var index = self._chainEntries.indexOf(entry); // Delete widget & entry (op's already been deleted)


          var widget = entry.widget;
          self.dom.removeChild(widget);

          _removeFromArray(self._chainEntries, entry); // Index?


          return index;
        }; // REPLACE CHAIN ENTRY


        self._replaceChainEntry = function (oldChainOp, newChainOp) {
          var oldIndex = self._deleteChainEntry(oldChainOp);

          self._makeChainEntry(newChainOp, oldIndex);
        }; // SHOW CHAIN OPTIONS


        var _showChainOptions = function (entry) {
          // Possible operands
          var currentLabel = entry.widget.innerText;
          var options = [{
            label: currentLabel + " + 2",
            value: "+"
          }, {
            label: currentLabel + " - 2",
            value: "-"
          }, {
            label: currentLabel + " &times; 2",
            value: "*"
          }, {
            label: currentLabel + " &divide; 2",
            value: "/"
          }]; // To delete... which operand?

          var elementIndex = self._chainEntries.indexOf(entry);

          if (self._chainEntries.length > 1) {
            // can't delete if just one
            // The operand...
            var operandIndex;
            if (elementIndex == 0) operandIndex = elementIndex + 1; // first
            else operandIndex = elementIndex - 1; // not
            // Label

            var label;
            var operandLabel = self._chainEntries[operandIndex].widget.innerText;
            if (elementIndex == 0) label = currentLabel + " " + operandLabel; // first
            else label = operandLabel + " " + currentLabel; // not
            // Indices to delete

            var indicesToDelete = [elementIndex, operandIndex].sort(); // increasing order
            // Push option!

            options.push({
              category: "meta",
              label: "(delete “" + label + "”)",
              value: indicesToDelete
            });
          } // Choose options!


          Joy.modal.Chooser({
            source: entry.widget,
            options: options,
            onchange: function (operand) {
              // It's an operand...
              if (typeof operand === "string") {
                // Get index of the op...
                var index = self._chainEntries.indexOf(entry); // Make the OPERAND op(+data) & entry


                index++;

                var operandOp = self._makeNewChainOp({
                  type: "choose",
                  value: operand
                }, index);

                self._makeChainEntry(operandOp, index); // Make the NUMBER op(+data) & entry (just the number 2, why hot)


                index++;

                var numberOp = self._makeNewChainOp({
                  type: "number_raw",
                  value: 2
                }, index);

                self._makeChainEntry(numberOp, index);
              } else {
                // Otherwise, DELETE ACTOR & ENTRY!
                var indices = operand;

                for (var i = indices.length - 1; i >= 0; i--) {
                  // flip around coz DELETING
                  var indexToDelete = indices[i];
                  var opToDelete = self._chainEntries[indexToDelete].op;

                  self._deleteChainOp(opToDelete);

                  self._deleteChainEntry(opToDelete);
                }
              } // Update!


              self.update();
            }
          });
        }; // For each chain op, put in that entry


        for (var i = 0; i < self.chainOps.length; i++) {
          var chainOp = self.chainOps[i];

          self._makeChainEntry(chainOp);
        }
      },
      onget: function (my) {
        // no variables?
        if (my.op.noVariables) {
          return _old.onget(my);
        } ////////////////


        var nums_and_ops = []; // just gets chain of nums & ops
        // EVALUATE EACH ELEMENT FIRST

        for (var i = 0; i < my.data.chain.length; i += 2) {
          // Synched indices!
          var chainOp = my.op.chainOps[i]; // Evaluate element

          var num;

          switch (chainOp.type) {
            case "number_raw":
              num = chainOp.get(my.target);
              break;

            case "variableName":
              var _variables = my.target._variables;
              var varname = chainOp.get(my.target); // it's just a synchronized string

              num = _variables[varname];
              break;
          } // Any operator before it?


          if (i > 0) {
            var operandOp = my.op.chainOps[i - 1];
            var op = operandOp.get();
            nums_and_ops.push(op);
          } // Push num


          nums_and_ops.push(num);
        } // MULTIPLICATION AND DIVISION FIRST. LEFT-ASSOCIATIVE


        for (var i = 1; i < nums_and_ops.length; i += 2) {
          var op = nums_and_ops[i];

          if (op == "*" || op == "/") {
            // Do math to the two numbers
            var num1 = nums_and_ops[i - 1];
            var num2 = nums_and_ops[i + 1];
            var res;
            if (op == "*") res = num1 * num2;else res = num1 / num2; // Modify array, and set index back
            // remove 3 items: num1, op, num2
            // replace with 1 item: result

            nums_and_ops.splice(i - 1, 3, res);
            i -= 2;
          } else {
            continue;
          }
        } // NOW DO ADDITION AND SUBTRACTION


        for (var i = 1; i < nums_and_ops.length; i += 2) {
          var op = nums_and_ops[i];

          if (op == "+" || op == "-") {
            // Do math to the two numbers
            var num1 = nums_and_ops[i - 1];
            var num2 = nums_and_ops[i + 1];
            var res;
            if (op == "+") res = num1 + num2;else res = num1 - num2; // Modify array, and set index back
            // remove 3 items: num1, op, num2
            // replace with 1 item: result

            nums_and_ops.splice(i - 1, 3, res);
            i -= 2;
          } else {
            continue;
          }
        }

        return nums_and_ops[0];
      }
    };
  });
  /****************
  Set a variable to some number.
  ****************/

  Joy.add({
    name: "Set [number]",
    type: "math/set",
    tags: ["math", "op"],
    init: "Set {id:'varname', type:'variableName', variableType:'number'} to {id:'value', type:'number'}",
    onexecute: function (my) {
      var _variables = my.target._variables;
      var varname = my.data.varname; // it's just a synchronized string

      _variables[varname] = my.data.value; // Set the variable
    }
  });
  /****************
  Do math on some variable
  ****************/

  Joy.add({
    name: "Do math to [number]",
    type: "math/operation",
    tags: ["math", "op"],
    init: JSON.stringify({
      id: "operation",
      type: "choose",
      placeholder: "+",
      options: [{
        label: "+ Increase",
        value: "+"
      }, {
        label: "- Decrease",
        value: "-"
      }, {
        label: "&times; Multiply",
        value: "*"
      }, {
        label: "&divide; Divide",
        value: "/"
      }]
    }) + " {id:'varname', type:'variableName', variableType:'number', startWithExisting:true}" + " by {id:'value', type:'number'}",
    onexecute: function (my) {
      var vars = my.target._variables;
      var varname = my.data.varname;
      if (vars[varname] === undefined) vars[varname] = 0; // Set to 0, if nothing's there.

      switch (my.data.operation) {
        case "+":
          vars[varname] += my.data.value;
          break;

        case "-":
          vars[varname] -= my.data.value;
          break;

        case "*":
          vars[varname] *= my.data.value;
          break;

        case "/":
          vars[varname] /= my.data.value;
          break;
      }
    }
  });
  /****************
  If then... for math
  ****************/

  Joy.add({
    name: "If [math] then...",
    type: "math/if",
    tags: ["math", "op"],
    init: "If {id:'value1', type:'number'} " + "{id:'test', type:'choose', options:['<','≤','=','≥','>'], placeholder:'='} " + "{id:'value2', type:'number'}, then: " + "{id:'ops', type:'ops', resetVariables:false}",
    onexecute: function (my) {
      var value1 = my.data.value1;
      var value2 = my.data.value2;
      var result;

      switch (my.data.test) {
        case "<":
          result = value1 < value2;
          break;

        case "≤":
          result = value1 <= value2;
          break;

        case "=":
          result = value1 == value2;
          break;

        case "≥":
          result = value1 >= value2;
          break;

        case ">":
          result = value1 > value2;
          break;
      }

      if (result) {
        var message = my.op.ops.execute(my.target);
        if (message == "STOP") return message; // STOP
      }
    }
  });
});
Joy.module("random", function () {
  Joy.add({
    name: "With a X% chance...",
    type: "random/if",
    tags: ["random", "op"],
    init: "With a {id:'chance', type:'number', min:0, max:100, placeholder:50}% chance, do:" + "{id:'ops', type:'ops', resetVariables:false}",
    onexecute: function (my) {
      var probability = my.data.chance / 100;

      if (Math.random() < probability) {
        var message = my.op.ops.execute(my.target);
        if (message == "STOP") return message; // STOP
      }
    }
  });
  /****************
  Set a variable to some number.
  ****************/

  Joy.add({
    name: "Set random [number]",
    type: "random/set",
    tags: ["random", "op"],
    init: "Set {id:'varname', type:'variableName', variableType:'number'} to a random " + "{id:'numtype', type:'choose', options:['number','integer'], placeholder:'number'} between " + "{id:'min', type:'number', placeholder:1} and {id:'max', type:'number', placeholder:100}",
    onexecute: function (my) {
      var _variables = my.target._variables;
      var varname = my.data.varname; // it's just a synchronized string

      var _min = my.data.min;
      var _max = my.data.max;
      var min = Math.min(_min, _max); // just in case

      var max = Math.max(_min, _max); // just in case

      var randomValue;

      if (my.data.numtype == "integer") {
        randomValue = min + Math.floor(Math.random() * (max - min + 1));
      } else {
        randomValue = min + Math.random() * (max - min);
      }

      _variables[varname] = randomValue; // Set the variable
    }
  });
});


//# sourceURL=webpack://%5Bname%5D/./src/joy.js?`)},"./src/pluginManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PluginManager", function() { return PluginManager; });
/* harmony import */ var lodash_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/trim */ "./node_modules/lodash/trim.js");
/* harmony import */ var lodash_trim__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_trim__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/assign */ "./node_modules/lodash/assign.js");
/* harmony import */ var lodash_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_assign__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pouchdb-browser */ "./node_modules/pouchdb-browser/lib/index.es.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! spark-md5 */ "./node_modules/spark-md5/spark-md5.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(spark_md5__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! js-yaml */ "./node_modules/js-yaml/index.js");
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(js_yaml__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _joy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./joy.js */ "./src/joy.js");
/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! file-saver */ "./node_modules/file-saver/FileSaver.js");
/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! imjoy-rpc */ "./node_modules/imjoy-rpc/index.js");
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(imjoy_rpc__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./jailedPlugin.js */ "./src/jailedPlugin.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./api.js */ "./src/api.js");
/* harmony import */ var _serviceSpec_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./serviceSpec.js */ "./src/serviceSpec.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _internalPlugins_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./internalPlugins.json */ "./src/internalPlugins.json");
var _internalPlugins_json__WEBPACK_IMPORTED_MODULE_13___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./internalPlugins.json */ "./src/internalPlugins.json", 1);
/* harmony import */ var _pluginParser_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pluginParser.js */ "./src/pluginParser.js");



/*eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_plugin$" }]*/















const compiledServiceSpec = {};

for (let k of Object.keys(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_11__["serviceSpec"])) {
  try {
    const key = k.startsWith("@") ? k : "@" + k;
    compiledServiceSpec[key] = _api_js__WEBPACK_IMPORTED_MODULE_10__["ajv"].compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_11__["serviceSpec"][k]);
  } catch (e) {
    console.error(e);
    throw new Error(\`Failed to compile service spec for \${k}, error: \${e}\`);
  }
}

class PluginManager {
  constructor({
    event_bus = null,
    config_db = null,
    engine_manager = null,
    window_manager = null,
    file_manager = null,
    imjoy_api = {},
    default_base_frame = null,
    default_rpc_base_url = null,
    debug = false,
    flags = []
  }) {
    this.event_bus = event_bus;
    this.em = engine_manager;
    this.em.setPluginManager(this);
    this.wm = window_manager;
    this.fm = file_manager;
    this.fm.setPluginManager(this);
    this.config_db = config_db;
    this.flags = flags;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.event_bus, "event bus is not available");
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.em, "engine manager is not available");
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.wm, "window manager is not available");
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.config_db, "config database is not available");
    this.default_base_frame = default_base_frame;
    this.default_rpc_base_url = default_rpc_base_url;
    this.debug = debug;
    this._allowed_evil_plugin = {};
    this.internal_plugins = _internalPlugins_json__WEBPACK_IMPORTED_MODULE_13__;
    this.default_repository_list = [{
      name: "ImJoy Repository",
      url: "imjoy-team/imjoy-plugins",
      description: "The official plugin repository provided by ImJoy.io."
    }, {
      name: "ImJoy Demos",
      url: "imjoy-team/imjoy-demo-plugins",
      description: "A set of demo plugins provided by ImJoy.io"
    }];
    this.repository_list = [];
    this.repository_names = [];
    this.available_plugins = [];
    this.installed_plugins = [];
    this.workspace_list = [];
    this.selected_workspace = null;
    this.selected_repository = null;
    this.workflow_list = [];
    this.service_registry = {};
    this.db = null;
    imjoy_api.utils = imjoy_api.utils || {};
    const api_utils_ = imjoy_api.utils;
    this.imjoy_api = {
      alert: (plugin, msg) => {
        return window.alert(Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["html2string"])(msg.content) || msg);
      },
      prompt: (plugin, msg, default_value) => {
        return window.prompt(Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["html2string"])(msg.content) || msg, msg.placeholder || default_value);
      },
      confirm: (plugin, msg) => {
        return window.confirm(Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["html2string"])(msg.content) || msg);
      },
      requestUploadUrl: this.requestUploadUrl,
      getFileUrl: this.getFileUrl,
      getFilePath: this.getFilePath,
      log: (plugin, ...args) => {
        plugin.log(...args);
        this.event_bus.emit("update_ui");
      },
      error: (plugin, ...args) => {
        plugin.error(...args);
        this.event_bus.emit("update_ui");
      },
      progress: (plugin, value) => {
        plugin.progress(value);
        this.event_bus.emit("update_ui");
      },

      exportFile(_plugin, file, name) {
        if (typeof file === "string") {
          file = new Blob([file], {
            type: "text/plain;charset=utf-8"
          });
        }

        Object(file_saver__WEBPACK_IMPORTED_MODULE_7__["saveAs"])(file, name || file._name || "file_export");
      },

      showDialog() {
        throw "\`api.showDialog\` is not implemented.";
      },

      showFileDialog() {
        throw "\`api.showFileDialog\` is not implemented.";
      },

      showProgress(_plugin, p) {
        console.log("api.showProgress: ", p);
      },

      showStatus(_plugin, s) {
        console.log("api.showStatus: ", s);
      },

      showSnackbar(_plugin, msg, duration) {
        console.log("api.showSnackbar: ", msg, duration);
      },

      showMessage: (plugin, info, duration) => {
        console.log("api.showMessage: ", info, duration);
      },
      register: this.register,
      // deprecated
      unregister: this.unregister,
      // deprecated
      registerService: this.registerService,
      unregisterService: this.unregisterService,
      createWindow: this.createWindow,
      loadPlugin: this.getPlugin,
      getPlugin: this.getPlugin,
      getWindow: this.getWindow,
      run: this.runPlugin,
      call: this.callPlugin,

      connectToServer(_plugin, config) {
        console.warn("api.connectToServer is deprecated.");
        return imjoy_rpc__WEBPACK_IMPORTED_MODULE_8__["imjoyRPCSocketIO"].connectToServer(config);
      },

      installPlugin: (_plugin, config) => {
        const tag = config.tag;
        const do_not_load = config.do_not_load;
        delete config.tag;
        delete config.do_not_load;
        return this.installPlugin(config, tag, do_not_load);
      },
      uninstallPlugin: (_plugin, config) => {
        return this.removePlugin(config);
      },
      getServices: this.getServices,
      getFileManager: this.getFileManager,
      getEngineFactory: this.getEngineFactory,
      getEngine: this.getEngine,
      setConfig: this.setPluginConfig,
      getConfig: this.getPluginConfig,
      getAttachment: this.getAttachment,
      onClose: (plugin, cb) => {
        console.warn('\`api.onClose\` is deprecated, please use \`api.on("close", ...)\` instead.');
        plugin.on("close", cb);
      },
      echo: (plugin, msg) => {
        return msg;
      },
      utils: {}
    }; // bind this to api functions

    for (let k in this.imjoy_api) {
      if (typeof this.imjoy_api[k] === "function") {
        this.imjoy_api[k] = this.imjoy_api[k].bind(this);
      } else if (typeof this.imjoy_api[k] === "object") {
        for (let u in this.imjoy_api[k]) {
          this.imjoy_api[k][u] = this.imjoy_api[k][u].bind(this);
        }
      }
    }

    imjoy_api.utils.showOpenFilePicker = async (plugin, ...args) => {
      if (window.showOpenFilePicker) {
        return await window.showOpenFilePicker(...args);
      } else {
        throw new Error("showOpenFilePicker is not available, please make sure you have Google Chrome 86+");
      }
    };

    imjoy_api.utils.showSaveFilePicker = async (plugin, ...args) => {
      if (window.showSaveFilePicker) {
        return await window.showSaveFilePicker(...args);
      } else {
        throw new Error("showSaveFilePicker is not available, please make sure you have Google Chrome 86+");
      }
    };

    imjoy_api.utils.showDirectoryPicker = async (plugin, ...args) => {
      if (window.showDirectoryPicker) {
        return await window.showDirectoryPicker(...args);
      } else {
        throw new Error("showDirectoryPicker is not available, please make sure you have Google Chrome 86+");
      }
    }; // merge imjoy api


    this.imjoy_api = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, this.imjoy_api, imjoy_api); // copy api utils make sure it was not overwritten

    if (api_utils_) {
      for (let k in api_utils_) {
        this.imjoy_api.utils[k] = api_utils_[k];
      }
    }

    this.imjoy_api.utils = this.imjoy_api.utils || {};

    this.imjoy_api.utils.openUrl = this.imjoy_api.utils.openUrl || ((_plugin, url) => {
      Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(url);
      Object.assign(document.createElement("a"), {
        target: "_blank",
        href: url
      }).click();
    });

    this.imjoy_api.utils.sleep = this.imjoy_api.utils.sleep || ((_plugin, seconds) => {
      Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(seconds);
      return new Promise(resolve => setTimeout(resolve, Math.round(seconds * 1000)));
    });

    this.imjoy_api.utils.$forceUpdate = this.imjoy_api.utils.$forceUpdate || function () {};

    this.event_bus.on("engine_connected", async engine => {
      for (let k in this.plugins) {
        const plugin = this.plugins[k]; // skip connection based plugins

        if (plugin._initialized_from_connection) continue;

        try {
          if (plugin.engine === engine) {
            await this.reloadPlugin(plugin);
          }

          if (plugin.config.engine_mode === "auto" && (plugin._disconnected || plugin.terminating)) {
            await this.reloadPlugin(plugin);
          }

          if (plugin.config.engine_mode === engine.name) {
            await this.reloadPlugin(plugin);
          }
        } catch (e) {
          this.showMessage(e);
        }
      }
    });
    this.event_bus.on("engine_disconnected", async engine => {
      for (let k in this.plugins) {
        const plugin = this.plugins[k];

        if (plugin.engine === engine) {
          this.unloadPlugin(plugin);
        }
      }
    });
  }

  getFileUrl(_plugin, config) {
    console.warn("\`api.getFileUrl\` is deprecated, please use \`api.getFileManager\` (https://imjoy.io/docs/#/api?id=apigetfilemanager) and access \`getFileUrl\` from the file manager.");

    if (typeof config !== "object" || !config.path) {
      throw "You must pass an object contains keys named \`path\` and \`engine\`";
    }

    _plugin = _plugin || this.root_plugin;

    if (config.engine) {
      console.warn("The \`engine\` option for \`api.getFileUrl\` is deprecated, please use \`file_manager\` instead of \`engine\`.");
      config.file_manager = config.engine;
      delete config.engine;
    }

    if (!config.file_manager) {
      throw "Please specify a file manager via the \`file_manager\` option.";
    }

    const manager = this.fm.getFileManagerByUrl(config.file_manager);

    if (!manager) {
      throw \`File manager \${config.file_manager} not found\`;
    }

    if (!manager.connected) {
      this.showMessage(\`File manager (\${manager.url}) is not connected.\`);
      throw \`File manager (\${manager.url}) is not connected.\`;
    }

    return manager.getFileUrl(config);
  }

  requestUploadUrl(_plugin, config) {
    console.warn("\`api.requestUploadUrl\` is deprecated, please use \`api.getFileManager\` (https://imjoy.io/docs/#/api?id=apigetfilemanager) and access \`requestUploadUrl\` from the file manager.");

    if (typeof config !== "object") {
      throw "You must pass an object contains keys named \`engine\` and \`path\` (or \`dir\`, optionally \`overwrite\`)";
    }

    _plugin = _plugin || this.root_plugin;

    if (config.engine) {
      console.warn("The \`engine\` option for \`api.requestUploadUrl\` is deprecated, please use \`file_manager\` instead of \`engine\`.");
      config.file_manager = config.engine;
      delete config.engine;
    }

    if (!config.file_manager) {
      throw "Please specify a file manager via the \`file_manager\` option.";
    }

    const manager = this.fm.getFileManagerByUrl(config.file_manager);

    if (!manager) {
      throw \`File manager \${config.file_manager} not found\`;
    }

    if (!manager.connected) {
      this.showMessage(\`File manager (\${manager.url}) is not connected.\`);
      throw \`File manager (\${manager.url}) is not connected.\`;
    }

    return manager.requestUploadUrl({
      path: config.path,
      overwrite: config.overwrite,
      dir: config.dir
    });
  }

  showMessage(msg) {
    this.event_bus.emit("show_message", msg);
  }

  async init() {
    const config = {};

    if (this.default_base_frame) {
      config.default_base_frame = this.default_base_frame;
    }

    if (this.default_rpc_base_url) {
      config.default_rpc_base_url = this.default_rpc_base_url;
    }

    config.debug = this.debug;

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.ready.then(() => {
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          console.log("Service worker is active and the controller is available, caching internal plugins...");

          for (let pn in this.internal_plugins) {
            this.normalizePluginUrl(this.internal_plugins[pn].uri).then(obj => {
              if (obj.uri) {
                Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["cacheUrlInServiceWorker"])(obj.uri).then(() => {
                  console.log("Internal plugin cached in the service worker", obj.uri);
                }).catch(e => {
                  console.error(e);
                });
              }
            });
          }
        });
      });
    } else {
      console.log("Service workers are not supported.");
    }

    Object(_jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["initializeJailed"])(config);
    this.root_plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"]({
      id: "imjoy-root",
      name: "ImJoy Root Plugin",
      type: "iframe"
    }, this.imjoy_api, null, true);
    this.plugins = {};
    this.plugin_names = {};
    this.registered = {
      ops: {},
      windows: {},
      extensions: {},
      internal_inputs: {},
      inputs: {},
      outputs: {},
      loaders: {},
      engines: {}
    };
  }

  loadRepositoryList() {
    return new Promise((resolve, reject) => {
      this.config_db.get("repository_list").then(doc => {
        this.repository_list = doc.list;

        for (let drep of this.default_repository_list) {
          let found = false;

          for (let repo of this.repository_list) {
            if (repo.url === drep.url && repo.name === drep.name) {
              found = repo;
              break;
            }
          }

          if (!found) {
            this.addRepository(drep);
          }
        }

        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        resolve(this.repository_list);
      }).catch(err => {
        if (err.name != "not_found") {
          console.error("Database Error", err);
        } else {
          console.log("Failed to load repository list", err);
        }

        this.repository_list = this.default_repository_list;
        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        this.config_db.put({
          _id: "repository_list",
          list: this.repository_list
        }, {
          force: true
        }).then(() => {
          resolve(this.repository_list);
        }).catch(() => {
          reject("Failed to load the repository list or save the default repositories.");
        });
        this.saveRepositoryList().then(() => {
          resolve(this.repository_list);
        }).catch(reject);
      });
    });
  }

  saveRepositoryList() {
    return new Promise((resolve, reject) => {
      let _rev = null;
      this.config_db.get("repository_list").then(doc => {
        _rev = doc._rev;
      }).finally(() => {
        this.config_db.put({
          _id: "repository_list",
          _rev: _rev || undefined,
          list: this.repository_list
        }, {
          force: true
        }).then(() => {
          resolve(this.repository_list);
        }).catch(err => {
          this.showMessage("Failed to save repository, database Error:" + err.toString());
          reject("Failed to save repository, database Error:" + err.toString());
        });
      });
    });
  }

  addRepository(repo) {
    return new Promise((resolve, reject) => {
      if (typeof repo === "string") {
        repo = {
          name: repo,
          url: repo,
          description: repo
        };
      }

      if (!(repo.name && repo.url)) {
        reject("You need to provide name and url");
        return;
      }

      this.reloadRepository(repo).then(manifest => {
        repo.name = manifest.name || repo.name;
        repo.description = manifest.description || repo.description;
        const normalizedUrl = repo.url && repo.url.replace("https://github.com/", "").replace("http://github.com/", ""); //remove existing repo if same url already exists

        for (let r of this.repository_list) {
          if (r.url && r.url.replace("https://github.com/", "").replace("http://github.com/", "") === normalizedUrl) {
            // remove it if already exists
            this.repository_list.splice(this.repository_list.indexOf(r), 1);
            this.showMessage("Repository with the same url already exists.");
          }
        } // use repo url if name exists


        for (let r of this.repository_list) {
          if (r.name === repo.name) {
            repo.name = normalizedUrl;
            break;
          }
        }

        if (!(repo.name && repo.url)) {
          reject("You need to provide name and url");
          return;
        }

        this.repository_list.push(repo);
        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        this.saveRepositoryList().then(() => {
          resolve(repo);
        }).catch(reject);
      }).catch(() => {
        if (this.repository_names.indexOf(repo.name) >= 0) this.repository_names.splice(this.repository_names.indexOf(repo.name), 1);
        this.showMessage("Failed to load repository from: " + repo.url);
        reject("Failed to load repository from: " + repo.url);
      });
    });
  }

  removeRepository(repo) {
    return new Promise((resolve, reject) => {
      if (!repo || !(repo.name && repo.url)) {
        reject("You need to provide name and url");
        return;
      }

      let found = false;

      for (let r of this.repository_list) {
        if (r.url === repo.url || r.name === repo.name) {
          found = r;
        }
      }

      if (found) {
        const index = this.repository_list.indexOf(found);
        this.repository_list.splice(index, 1);
        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        this.saveRepositoryList().then(() => {
          this.showMessage(\`Repository has been deleted.\`);
          resolve();
        }).catch(() => {
          this.showMessage(\`Error occured when removing repository.\`);
          reject(\`Error occured when removing repository.\`);
        });
      } else {
        reject("Repository not found: " + repo.name);
      }
    });
  }

  reloadRepository(repo) {
    repo = repo || this.selected_repository;
    return new Promise((resolve, reject) => {
      this.getRepoManifest(repo.url).then(manifest => {
        this.available_plugins = manifest.plugins;

        for (let i = 0; i < this.available_plugins.length; i++) {
          const ap = this.available_plugins[i];
          const ps = this.installed_plugins.filter(p => {
            return ap.name === p.name;
          }); // mark as installed

          if (ps.length > 0) {
            ap.installed = true;
            ap.tag = ps[0].tag;
          }
        }

        this.selected_repository = repo;
        resolve(manifest);
      }).catch(reject);
    });
  }

  loadWorkspaceList() {
    return new Promise((resolve, reject) => {
      this.config_db.get("workspace_list").then(doc => {
        this.workspace_list = doc.list;
        this.selected_workspace = this.workspace_list[0];
        resolve(this.workspace_list);
      }).catch(err => {
        if (err.name != "not_found") {
          console.error("Database Error", err);
        }

        this.workspace_list = ["default"];
        this.config_db.put({
          _id: "workspace_list",
          list: this.workspace_list
        }).then(() => {
          this.selected_workspace = this.workspace_list[0];
          resolve(this.workspace_list);
        }).catch(() => {
          reject("Failed to load Plugin Engine list, database Error:" + err.toString());
        });
      });
    });
  }

  loadWorkspace(selected_workspace) {
    return new Promise((resolve, reject) => {
      selected_workspace = selected_workspace || this.selected_workspace;

      const load_ = () => {
        try {
          this.event_bus.emit("workspace_list_updated", this.workspace_list);
          this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](selected_workspace + "_workspace", {
            revs_limit: 2,
            auto_compaction: true
          });
          this.selected_workspace = selected_workspace;
          resolve();
        } catch (e) {
          reject(e);
        }
      };

      if (!this.workspace_list.includes(selected_workspace)) {
        if (!this.workspace_list.includes(selected_workspace)) {
          this.workspace_list.push(selected_workspace);
        }

        this.saveWorkspaceList().then(() => {
          load_();
        }).catch(reject);
      } else {
        load_();
      }
    });
  }

  saveWorkspaceList() {
    return new Promise((resolve, reject) => {
      this.config_db.get("workspace_list").then(doc => {
        this.config_db.put({
          _id: doc._id,
          _rev: doc._rev,
          list: this.workspace_list,
          default: "default"
        }).then(resolve).catch(e => {
          reject(\`Failed to save workspace, database Error: \${e.toString()}\`);
        });
      }).catch(err => {
        reject(\`Failed to save workspaces, database Error: \${err.toString()}\`);
      });
    });
  }

  removeWorkspace(w) {
    return new Promise((resolve, reject) => {
      if (this.workspace_list.includes(w)) {
        const index = this.workspace_list.indexOf(w);
        this.workspace_list.splice(index, 1);
        this.saveWorkspaceList().then(() => {
          resolve();

          if (this.selected_workspace === w.name) {
            this.selected_workspace = null;
          }
        }).catch(reject);
      }
    });
  }

  saveWorkflow(joy) {
    // remove if exists
    const name = prompt("Please enter a name for the workflow", "default");

    if (!name) {
      return;
    }

    const data = {};
    data.name = name;
    data._id = name + "_workflow"; // delete data._references

    data.workflow = JSON.stringify(joy.top.data);
    this.db.get(data._id).then(doc => {
      data._rev = doc._rev;
    }).finally(() => {
      this.db.put(data).then(() => {
        this.workflow_list.push(data);
        this.showMessage(\`Workflow "\${name}" has been successfully saved.\`);
      }).catch(err => {
        this.showMessage("Failed to save the workflow.");
        console.error(err);
      });
    });
  }

  async removeWorkflow(w) {
    try {
      const doc = await this.db.get(w._id);
      await this.db.remove(doc);
      var index = this.workflow_list.indexOf(w);

      if (index > -1) {
        this.workflow_list.splice(index, 1);
      }

      this.showMessage(\`Workflow "\${w.name}" has been successfully removed.\`);
    } catch (err) {
      this.showMessage("Failed to remove the workflow.");
      console.error(err);
      throw err;
    }
  }

  reloadDB() {
    return new Promise((resolve, reject) => {
      try {
        if (this.db) {
          try {
            this.db.close().finally(() => {
              this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
                revs_limit: 2,
                auto_compaction: true
              });

              if (this.db) {
                if (this.selected_workspace === "sandbox") {
                  console.warn("All data in the sandbox stored workspace is going to be destroyed.");
                  if (!this.flags.includes("quiet")) debugger;
                  this.db.destroy().then(() => {
                    this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
                      revs_limit: 2,
                      auto_compaction: true
                    });
                    resolve();
                  }).catch(e => {
                    console.error(e);
                    reject(e);
                  });
                } else {
                  resolve();
                }
              } else {
                reject("Failed to reload database.");
              }
            });
          } catch (e) {
            console.error("Failed to reload database: ", e);
            this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
              revs_limit: 2,
              auto_compaction: true
            });

            if (this.db) {
              if (this.selected_workspace === "sandbox") {
                console.warn("All data in the sandbox stored workspace is going to be destroyed.");
                if (!this.flags.includes("quiet")) debugger;
                this.db.destroy().then(() => {
                  this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
                    revs_limit: 2,
                    auto_compaction: true
                  });
                  resolve();
                }).catch(e => {
                  console.error(e);
                  reject(e);
                });
              } else {
                resolve();
              }
            } else {
              reject("Failed to reload database.");
            }
          }
        } else {
          this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
            revs_limit: 2,
            auto_compaction: true
          });

          if (this.db) {
            resolve();
          } else {
            reject("Failed to reload database.");
          }
        }
      } catch (e) {
        console.error("Failed to reload database.");
        reject("Failed to reload database.");
      }
    });
  }

  setInputLoaders(input_loaders) {
    for (let inputs of input_loaders) {
      this.wm.registerInputLoader(inputs.loader_key, inputs, inputs.loader);
    }
  }

  reloadPlugins() {
    return new Promise((resolve, reject) => {
      if (this.plugins) {
        for (let k in this.plugins) {
          const plugin = this.plugins[k];

          if (typeof plugin.terminate === "function") {
            try {
              plugin.terminate().then(() => {
                this.event_bus.emit("update_ui");
              });
            } catch (e) {
              console.error(e);
            }
          }

          this.plugins[k] = null;
          this.plugin_names[plugin.name] = null;
        }
      }

      this.init().then(() => {
        this.reloadDB().then(() => {
          this.db.allDocs({
            include_docs: true,
            attachments: true,
            sort: "name"
          }).then(result => {
            this.workflow_list = [];
            this.installed_plugins = [];

            for (let i = 0; i < result.total_rows; i++) {
              const config = result.rows[i].doc;

              if (config.workflow) {
                this.workflow_list.push(config);
              } else {
                //verify hash
                if (config.hash) {
                  if (spark_md5__WEBPACK_IMPORTED_MODULE_3___default.a.hash(config.code) !== config.hash) {
                    console.error("Plugin source code signature mismatch, skip loading plugin", config);
                    continue;
                  }
                }

                config.installed = true;
                this.installed_plugins.push(config);

                try {
                  this.reloadPlugin(config);
                } catch (e) {
                  console.error(config, e);
                  this.showMessage(\`<\${config.name}>: \${e}\`);
                }
              }
            }

            this.reloadInternalPlugins(true).then(resolve).catch(reject);
          }).catch(err => {
            console.error(err);
            reject();
          });
        });
      }).catch(reject);
    });
  }

  async reloadInternalPlugins(skip_exist) {
    for (let pn in this.internal_plugins) {
      const config = this.internal_plugins[pn];

      if (config.startup) {
        if (skip_exist && this.plugin_names[pn]) {
          continue;
        }

        console.log(\`Loading internal plugin "\${pn}"...\`);

        try {
          await this.reloadPluginRecursively({
            uri: config.src
          }, null, "eval is evil");
          console.log(\`\${pn} plugin loaded.\`);
        } catch (e) {
          console.error(e);
        }
      }
    }
  }

  async normalizePluginUrl(uri, scoped_plugins) {
    let external = false;
    let selected_tag;
    scoped_plugins = scoped_plugins || this.available_plugins;
    const _uri = uri.split("?")[0];

    if (_uri.includes("github.com") && _uri.includes("/blob/") || _uri.includes("gist.github.com")) {
      uri = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubUrlRaw"])(uri);
    } // if the uri format is REPO_NAME:PLUGIN_NAME


    if (!/(http(s?)):\\/\\//i.test(uri) && uri.includes("/") && uri.includes(":")) {
      let [repo_name, plugin_name] = uri.split(":");
      selected_tag = plugin_name.split("@")[1];
      plugin_name = plugin_name.split("@")[0];
      plugin_name = plugin_name.trim();
      const repo_hashtag = repo_name.split("@")[1];
      repo_name = repo_name.split("@")[0];
      repo_name = repo_name.trim();
      Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(repo_name && plugin_name, 'Wrong URI format, it must be "REPO_NAME:PLUGIN_NAME"');
      const manifest = await this.getRepoManifest(repo_name, repo_hashtag);
      let found = null;

      for (let p of manifest.plugins) {
        if (p.name === plugin_name) {
          found = p;
          break;
        }
      }

      if (!found) {
        throw \`plugin not found \${repo_name}:\${plugin_name}\`;
      }

      uri = found.uri;
      scoped_plugins = manifest.plugins;
    } else if (!uri.match(_utils_js__WEBPACK_IMPORTED_MODULE_12__["url_regex"])) {
      let dep = uri.split("@");
      selected_tag = dep[1];
      const ps = scoped_plugins.filter(p => {
        return dep[0] && p.name === dep[0].trim();
      });

      if (ps.length <= 0) {
        throw \`Plugin "\${dep[0]}" cannot be found in the repository.\`;
      } else {
        uri = ps[0].uri;
      }
    } else {
      if (!_uri.endsWith(".imjoy.html")) {
        external = true;
      }

      selected_tag = uri.split(".imjoy.html@")[1];

      if (selected_tag) {
        uri = uri.split("@" + selected_tag)[0];
      }
    }

    return {
      uri,
      scoped_plugins,
      selected_tag,
      external
    };
  }

  async getPluginFromUrl(uri, scoped_plugins) {
    const obj = await this.normalizePluginUrl(uri, scoped_plugins);

    if (obj.external) {
      const pluginConfig = await Object(_jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["getExternalPluginConfig"])(uri);
      pluginConfig.badges = this.getBadges(pluginConfig);
      return pluginConfig;
    }

    uri = obj.uri;
    scoped_plugins = obj.scoped_plugins;
    const selected_tag = obj.selected_tag; // If the url has no query parameter, then add random query string to avoid browser caching

    if (uri.indexOf("?") === -1) {
      uri = uri + "?" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
    }

    const response = await axios__WEBPACK_IMPORTED_MODULE_4___default.a.get(uri);

    if (!response || !response.data || response.data === "") {
      alert("failed to get plugin code from " + uri);
      throw "failed to get code.";
    }

    const code = response.data;
    let config = this.parsePluginCode(code, {
      tag: selected_tag,
      origin: uri,
      uri: uri
    });
    config.scoped_plugins = scoped_plugins;
    return config;
  }

  reloadPluginRecursively(pconfig, tag, allow_evil) {
    return new Promise((resolve, reject) => {
      let uri = typeof pconfig === "string" ? pconfig : pconfig.uri;
      let scoped_plugins = this.available_plugins;

      if (pconfig.scoped_plugins) {
        scoped_plugins = pconfig.scoped_plugins;
        delete pconfig.scoped_plugins;
      } //use the has tag in the uri if no hash tag is defined.


      if (!uri) {
        reject("No url found for plugin " + pconfig.name);
        return;
      } // tag = tag || uri.split('@')[1]
      // uri = uri.split('@')[0]


      this.getPluginFromUrl(uri, scoped_plugins).then(async config => {
        if (pconfig.engine_mode) {
          config.engine_mode = pconfig.engine_mode;
        } else if (config.engine_mode) {
          const old_plugin = this.plugin_names[config.name];

          if (old_plugin) {
            config.engine_mode = old_plugin.config.engine_mode;
          }
        }

        config.origin = pconfig.origin || uri;
        config.namespace = pconfig.namespace;
        config.workspace = pconfig.workspace;

        if (!config) {
          console.error(\`Failed to fetch the plugin from "\${uri}".\`);
          reject(\`Failed to fetch the plugin from "\${uri}".\`);
          return;
        }

        if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(config.type)) {
          console.warn(\`Installed plugin \${config.name} with unsupported plugin type: \${config.type}\`);
        }

        config.tag = tag || this.plugin_names[config.name] && this.plugin_names[config.name].config.tag || config.tag;

        if (config.tag) {
          // remove existing tag
          const sp = config.origin.split(":");

          if (sp[1]) {
            if (sp[1].split("@")[1]) config.origin = sp[0] + ":" + sp[1].split("@")[0];
          } // add a new tag
          // config.origin = config.origin + "@" + config.tag;

        }

        config._id = config.name && config.name.replace(/ /g, "_") || Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        config.dependencies = config.dependencies || [];

        try {
          for (let i = 0; i < config.dependencies.length; i++) {
            await this.reloadPluginRecursively({
              uri: config.dependencies[i],
              scoped_plugins: config.scoped_plugins || scoped_plugins,
              namespace: pconfig.namespace,
              hot_reloading: pconfig.hot_reloading
            }, null, allow_evil);
          }

          this.reloadPlugin(config, allow_evil).then(plugin => {
            resolve(plugin);
          }).catch(reject);
        } catch (error) {
          //alert(\`Failed to load dependencies for \${config.name}: \${error}\`);
          reject(\`Failed to load dependencies for \${config.name}: \${error}\`);
        }
      }).catch(e => {
        console.error(e);
        reject(e);
      });
    });
  }

  installPlugin(pconfig, tag, do_not_load) {
    return new Promise((resolve, reject) => {
      let scoped_plugins = this.available_plugins;

      if (pconfig.scoped_plugins) {
        scoped_plugins = pconfig.scoped_plugins;
        delete pconfig.scoped_plugins;
      }

      if (!pconfig.src && !pconfig.uri) {
        reject("Please provide the source via the \`src\` key.");
        return;
      }

      pconfig.src = pconfig.src || pconfig.uri;
      tag = tag || pconfig.tag;

      if (pconfig.src.includes("\\n")) {
        const config = this.parsePluginCode(pconfig.src);
        const ps = [];
        config.dependencies = config.dependencies || [];

        for (let i = 0; i < config.dependencies.length; i++) {
          ps.push(this.installPlugin({
            src: config.dependencies[i],
            namespace: config.namespace,
            scoped_plugins: config.scoped_plugins || scoped_plugins
          }, null, do_not_load));
        }

        pconfig.code = pconfig.src;
        Promise.all(ps).then(() => {
          this.savePlugin(pconfig).then(async template => {
            this.showMessage(\`Plugin "\${template.name}" has been successfully installed.\`);
            this.event_bus.emit("plugin_installed", template);
            resolve(template);
            if (!do_not_load) this.reloadPlugin(template);
          }).catch(reject);
        }).catch(reject);
        return;
      }

      if ( // plugin URI
      !/(http(s?)):\\/\\//i.test(pconfig.src) && pconfig.src.includes("/") && pconfig.src.includes(":") || // plugin source url or rpc window
      /(http(s?)):\\/\\//i.test(pconfig.src)) {
        let uri = pconfig.src;
        this.getPluginFromUrl(uri, scoped_plugins).then(async config => {
          if (config.engine_mode) {
            const old_plugin = this.plugin_names[config.name];

            if (old_plugin) {
              config.engine_mode = old_plugin.config.engine_mode;
            }
          }

          config.origin = pconfig.origin || uri;

          if (!config) {
            console.error(\`Failed to fetch the plugin from "\${uri}".\`);
            reject(\`Failed to fetch the plugin from "\${uri}".\`);
            return;
          }

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(config.type)) {
            console.warn(\`Installed plugin \${config.name} with unsupported plugin type: \${config.type}\`);
          }

          config.tag = tag || this.plugin_names[config.name] && this.plugin_names[config.name].config.tag || config.tag;

          if (config.tag) {
            // remove existing tag
            const sp = config.origin.split(":");

            if (sp[1]) {
              if (sp[1].split("@")[1]) config.origin = sp[0] + ":" + sp[1].split("@")[0];
            } // add a new tag
            // config.origin = config.origin + "@" + config.tag;

          }

          config._id = config.name && config.name.replace(/ /g, "_") || Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
          config.dependencies = config.dependencies || [];

          try {
            for (let i = 0; i < config.dependencies.length; i++) {
              await this.installPlugin({
                src: config.dependencies[i],
                namespace: config.namespace,
                scoped_plugins: config.scoped_plugins || scoped_plugins
              }, null, do_not_load);
            }

            const template = await this.savePlugin(config);

            for (let p of this.available_plugins) {
              if (p.name === template.name && !p.installed) {
                p.installed = true;
                p.tag = tag;
              }
            }

            this.showMessage(\`Plugin "\${template.name}" has been successfully installed.\`);
            this.event_bus.emit("plugin_installed", template);
            resolve(template);
            if (!do_not_load) this.reloadPlugin(template);
          } catch (error) {
            reject(\`Failed to install dependencies for \${config.name}: \${error}\`);
          }
        }).catch(e => {
          console.error(e);
          reject(e);
        });
      }
    });
  }

  removePlugin(plugin_config) {
    // TODO: support removing by namespace
    return new Promise((resolve, reject) => {
      plugin_config._id = plugin_config._id || plugin_config.name.replace(/ /g, "_"); // remove if exists

      this.db.get(plugin_config._id).then(doc => {
        this.db.remove(doc).then(() => {
          for (let i = 0; i < this.installed_plugins.length; i++) {
            if (this.installed_plugins[i].name === plugin_config.name) {
              this.installed_plugins.splice(i, 1);
            }
          }

          for (let p of this.available_plugins) {
            if (p.name === plugin_config.name) {
              p.installed = false;
              p.tag = null;
            }
          }

          resolve();
          this.showMessage(\`"\${plugin_config.name}" has been removed.\`);
          this.unloadPlugin(plugin_config, true);
        }).catch(err => {
          this.showMessage(err.toString());
          console.error("Failed to remove plugin: ", plugin_config, err);
          reject(err);
        });
      }).catch(err => {
        this.unloadPlugin(plugin_config, true);
        this.showMessage(\`"\${plugin_config.name}" has been unloaded.\`);
        console.log("Plugin does not exist in the database", plugin_config, err);
        resolve(err);
      });
    });
  }

  getPluginDocs(plugin_id) {
    return new Promise((resolve, reject) => {
      this.db.get(plugin_id).then(doc => {
        const config = this.parsePluginCode(doc.code);
        const docs = config.docs;
        resolve(docs);
      }).catch(err => {
        reject(err);
      });
    });
  }

  getPluginSource(plugin_id) {
    return new Promise((resolve, reject) => {
      this.db.get(plugin_id).then(doc => {
        resolve(doc.code);
      }).catch(err => {
        reject(err);
      });
    });
  }

  unloadPlugin(_plugin, temp_remove) {
    const name = _plugin.name;

    for (let k in this.plugins) {
      const plugin = this.plugins[k];

      if (plugin.name === name) {
        try {
          if (temp_remove) {
            delete this.plugins[k];
            delete this.plugin_names[name];
          }

          plugin._unloaded = true;

          this._unregister(plugin);

          if (typeof plugin.terminate === "function") {
            plugin.terminate().then(() => {
              this.event_bus.emit("update_ui");
            });
          }

          this.event_bus.emit("update_ui");
        } catch (e) {
          console.error(e);
        }
      }
    }

    this._unregister(_plugin);

    if (typeof _plugin.terminate === "function") {
      _plugin.terminate().finally(() => {
        this.event_bus.emit("update_ui");
      });
    }

    this.event_bus.emit("update_ui");
    this.event_bus.emit("plugin_unloaded", _plugin);
  }

  connectPlugin(connection) {
    return new Promise((resolve, reject) => {
      Object(_jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["getExternalPluginConfig"])(connection).then(config => {
        config.runnable = config.runnable === false ? false : true;
        config.badges = this.getBadges(config);
        this.unloadPlugin(config, true);
        this.loadPlugin(config, {
          id: config.id
        }, false, connection).then(p => {
          resolve(p);
        }).catch(reject);
      }).catch(reject);
    });
  }

  async reloadPlugin(pconfig, allow_evil) {
    try {
      if (pconfig.hot_reloading) {
        let plugin;

        if (pconfig.id) {
          for (let pid of Object.keys(this.plugins)) {
            if (pid === pconfig.id) {
              plugin = this.plugins[pid];
              break;
            }
          }
        }

        const template = this.parsePluginCode(pconfig.code, {
          tag: pconfig.tag,
          _id: pconfig._id,
          origin: pconfig.origin,
          namespace: pconfig.namespace,
          hot_reloading: pconfig.hot_reloading,
          engine_mode: pconfig.engine_mode
        });
        pconfig.name = pconfig.name || template.name;

        if (!plugin && pconfig.name) {
          for (let pid of Object.keys(this.plugins)) {
            if (this.plugins[pid].name === pconfig.name) {
              plugin = this.plugins[pid];
              break;
            }
          }
        }

        if (plugin && plugin.type !== "window") {
          if (plugin.config.tag === template.tag && plugin.config.engine_mode === template.engine_mode && plugin.config.namespace === template.namespace) {
            plugin.config.requirements = template.requirements;
            plugin.config.scripts = template.scripts;
            plugin.config.styles = template.styles;
            plugin.config.links = template.links;
            plugin.config.windows = template.windows;

            try {
              await plugin.hotReload();

              if (template.type) {
                this._register(plugin, template);
              }

              if (plugin.api && plugin.api.setup) await plugin.api.setup();
              return plugin;
            } catch (e) {
              console.error("Failed to hot reload: ", e);
              this.showMessage(\`Failed to perform hot reloading, error: \${e}\`);
            }
          }
        }
      }

      if (pconfig instanceof _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"]) {
        pconfig = pconfig.config;
      }

      this.unloadPlugin(pconfig, true);
      const template = this.parsePluginCode(pconfig.code, {
        tag: pconfig.tag,
        _id: pconfig._id,
        origin: pconfig.origin,
        namespace: pconfig.namespace,
        hot_reloading: pconfig.hot_reloading,
        engine_mode: pconfig.engine_mode
      });
      template.engine = null;
      this.unloadPlugin(template, true); // if it's a collection, we only load the dependencies

      if (pconfig.load_dependencies || template.type === "collection") {
        template.dependencies = template.dependencies || [];

        for (let i = 0; i < template.dependencies.length; i++) {
          await this.reloadPluginRecursively({
            uri: template.dependencies[i],
            namespace: pconfig.namespace,
            hot_reloading: pconfig.hot_reloading
          }, null, allow_evil);
        }
      }

      if (template.type === "collection") {
        return;
      }

      let p;

      if (template.type === "rpc-window" || template.type === "window") {
        p = this.loadProxyPlugin(template);
      } else {
        if (allow_evil === "eval is evil") {
          this._allowed_evil_plugin[template.name] = template.code;
        } else {
          if (this._allowed_evil_plugin[template.name] === template.code) {
            allow_evil = "eval is evil";
          }
        }

        p = this.loadPlugin(template, null, allow_evil);
      }

      try {
        const plugin = await p;
        plugin._id = pconfig._id;
        pconfig.name = plugin.name;
        pconfig.type = plugin.type;
        pconfig.plugin = plugin;
        this.event_bus.emit("update_ui");
        return plugin;
      } catch (e) {
        pconfig.plugin = null;
        throw e;
      }
    } catch (e) {
      this.showMessage(e || "Error.", 15);
      console.error(e);
      throw e;
    }
  }

  savePlugin(pconfig) {
    return new Promise((resolve, reject) => {
      const code = pconfig.code;

      try {
        const template = this.parsePluginCode(code, {
          tag: pconfig.tag,
          origin: pconfig.origin,
          engine_mode: pconfig.engine_mode,
          namespace: pconfig.namespace
        });
        template.code = code;
        template._id = template.name.replace(/ /g, "_");
        template.hash = spark_md5__WEBPACK_IMPORTED_MODULE_3___default.a.hash(template.code);

        const addPlugin = template => {
          this.db.put(template).then(() => {
            for (let i = 0; i < this.installed_plugins.length; i++) {
              if (this.installed_plugins[i].name === template.name) {
                this.installed_plugins.splice(i, 1);
              }
            }

            template.installed = true;
            this.installed_plugins.push(template);
            resolve(template);
            this.showMessage(\`\${template.name} has been successfully saved.\`);
          }).catch(err => {
            this.showMessage("Failed to save the plugin.");
            console.error(err);
            reject("failed to save");
          });
        }; // remove if exists


        this.db.get(template._id).then(doc => {
          template._rev = doc._rev;
          addPlugin(template);
        }).catch(() => {
          addPlugin(template);
        });
      } catch (e) {
        this.showMessage(e || "Error.");
        reject(e);
      }
    });
  }

  getBadges(p) {
    const backend = Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(p.type);

    if (backend) {
      return backend.icon || "";
    } else {
      return "🚀";
    }
  }

  parsePluginCode(code, overwrite_config) {
    overwrite_config = overwrite_config || {};

    try {
      const pluginComp = Object(_pluginParser_js__WEBPACK_IMPORTED_MODULE_14__["parseComponent"])(code);
      let config;

      if (pluginComp.config[0].attrs.lang === "yaml") {
        config = js_yaml__WEBPACK_IMPORTED_MODULE_5___default.a.load(pluginComp.config[0].content);
      } else if (pluginComp.config[0].attrs.lang === "json") {
        config = JSON.parse(pluginComp.config[0].content);
      } else {
        config = JSON.parse(pluginComp.config[0].content);

        if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["compareVersions"])(config.api_version, ">", "0.1.5")) {
          throw \`Unsupported config language \${pluginComp.config[0].attrs.lang}, please set lang="json" or lang="yaml"\`;
        }
      }

      config.tag = overwrite_config.tag || config.tags && config.tags[0];
      config.hot_reloading = overwrite_config.hot_reloading, config.scripts = []; // try to match the script with current tag

      for (let i = 0; i < pluginComp.script.length; i++) {
        if (pluginComp.script[i].attrs.tag === config.tag) {
          config.script = pluginComp.script[i].content;
        } // exclude script with mismatched tag


        if (!pluginComp.script[i].attrs.tag || pluginComp.script[i].attrs.tag === config.tag) {
          config.scripts.push(pluginComp.script[i]);
        }
      }

      if (!config.script && pluginComp.script.length > 0) {
        config.script = pluginComp.script[0].content;
        config.lang = pluginComp.script[0].attrs.lang;
      }

      config.links = pluginComp.link || null;
      config.windows = pluginComp.window || null;
      config.styles = pluginComp.style || null;
      config.docs = pluginComp.docs && pluginComp.docs[0] || config.docs;
      config.attachments = pluginComp.attachment || null;
      config._id = overwrite_config._id || config.name.replace(/ /g, "_");
      config.uri = overwrite_config.uri;
      config.origin = overwrite_config.origin;
      config.namespace = overwrite_config.namespace;
      config.code = code;
      config.id = config.name.trim().replace(/ /g, "_") + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
      config.runnable = config.runnable === false ? false : true;
      config.requirements = config.requirements || [];

      for (let i = 0; i < _api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"].length; i++) {
        const obj = config[_api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"][i]];

        if (obj && typeof obj === "object" && !(obj instanceof Array)) {
          if (config.tag) {
            config[_api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"][i]] = obj[config.tag];

            if (!Object.prototype.hasOwnProperty.call(obj, config.tag)) {
              console.log("WARNING: " + _api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"][i] + " do not contain a tag named: " + config.tag);
            }
          } else {
            throw "You must use 'tags' with configurable fields.";
          }
        }
      }

      config.lang = config.lang || "javascript";
      config = Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["upgradePluginAPI"])(config);

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["PLUGIN_SCHEMA"])(config)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["PLUGIN_SCHEMA"].errors;
        console.error("Invalid plugin config: " + config.name, error);
        throw error;
      }

      const backend = Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(config.type);
      config.badges = this.getBadges(config);

      if (backend) {
        config.engine_mode = null;
      } else {
        config.engine_mode = overwrite_config.engine_mode || "auto";
      }

      if (config.flags && (config.flags.indexOf("engine") >= 0 || config.flags.indexOf("engine-factory") >= 0)) {
        config.badges = config.badges + "⚙";
      }

      if (config.flags && config.flags.indexOf("file-manager") >= 0) {
        config.badges = config.badges + "📁";
      }

      return config;
    } catch (e) {
      console.error(e);
      throw \`Failed to parse the plugin file, error: \${e}\`;
    }
  }

  validatePluginConfig(config) {
    if (config.name.indexOf("/") < 0) {
      return true;
    } else {
      throw "Plugin name should not contain '/'.";
    }
  }

  loadProxyPlugin(template, rplugin) {
    const config = {
      _id: template._id,
      name: template.name,
      type: template.type,
      ui: template.ui,
      tag: template.tag,
      inputs: template.inputs,
      outputs: template.outputs,
      docs: template.docs,
      attachments: template.attachments
    };
    this.validatePluginConfig(config); //generate a random id for the plugin

    return new Promise((resolve, reject) => {
      if (!rplugin) {
        config.id = template.name.trim().replace(/ /g, "_") + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        config.initialized = false;
      } else {
        config.id = rplugin.id;
        config.initialized = true;
      }

      const tconfig = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, template, config);

      tconfig.workspace = this.selected_workspace; // TODO: deprecate TAG and WORKSPACE, use \`config.tag\` and \`config.workspace\` instead

      const _interface = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({
        TAG: tconfig.tag,
        WORKSPACE: this.selected_workspace,
        config: {
          tag: tconfig.tag,
          workspace: this.selected_workspace
        }
      }, this.imjoy_api);

      try {
        // create a proxy plugin
        const plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"](tconfig, _interface, null, true);
        plugin.api = {
          _rintf: true,
          setup: async function () {},
          run: async my => {
            const c = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["_clone"])(template.defaults) || {};
            c.type = template.name;
            c.name = template.name;
            c.tag = template.tag; // c.op = my.op

            c.data = my && my.data || {};
            c.config = my && my.config || {};
            c.id = my && my.id;
            c.window_id = my && my.window_id;

            if (c.as_dialog && this.imjoy_api.showDialog) {
              // make sure there is a header and convert it to fullscreen dialog
              if (c.standalone) {
                c.fullscreen = true;
                c.standalone = false;
              }

              return await this.imjoy_api.showDialog(null, c);
            } else {
              return await this.imjoy_api.createWindow(null, c);
            }
          }
        };

        this._register(plugin, config);

        this.plugins[plugin.id] = plugin;
        this.plugin_names[plugin.name] = plugin;
        this.event_bus.emit("plugin_loaded", plugin);
        resolve(plugin);
      } catch (e) {
        reject(e);
      }
    });
  }

  loadPlugin(template, rplugin, allow_evil, connection) {
    template = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["_clone"])(template);
    this.validatePluginConfig(template); // Generate a random id for the plugin
    // eslint-disable-next-line no-async-promise-executor

    return new Promise(async (resolve, reject) => {
      const config = {};

      if (!rplugin) {
        config.id = template.name.trim().replace(/ /g, "_") + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        config.initialized = false;
      } else {
        config.id = rplugin.id;
        config.initialized = true;
      }

      config._id = template._id;
      let engine = null;

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(template.type)) {
        engine = await this.em.findEngine(template);

        if (!engine) {
          console.error(\`Plugin engine not found for plugin type=\${template.type}.\`);
        } else {
          this.showMessage(\`Running plugin with plugin engine: \${engine.name}\`);
        }
      }

      const tconfig = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, template, config);

      tconfig.workspace = this.selected_workspace;

      const _interface = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({
        TAG: tconfig.tag,
        WORKSPACE: this.selected_workspace,
        ENGINE_URL: engine && engine.url || undefined,
        config: {
          tag: tconfig.tag,
          workspace: this.selected_workspace,
          engine: engine && engine.url || undefined
        }
      }, this.imjoy_api);

      try {
        const plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"](tconfig, _interface, engine, false, allow_evil, connection);

        plugin._log_history.push(\`Loading plugin \${plugin.id} (config=\${_interface.config})\`);

        if (_interface.ENGINE_URL) plugin._log_history.push(\`ENGINE_URL=\${_interface.ENGINE_URL}\`);
        const plugin_loading_timer = setTimeout(() => {
          // plugin.terminate();
          plugin.initializing = false;
          console.warn(\`Plugin \${plugin.name} failed to load in 180s.\`);
        }, 180000);
        plugin.onConnected(async () => {
          clearTimeout(plugin_loading_timer);

          if (!plugin.api) {
            console.error("Error occured when loading plugin.");
            this.showMessage("Error occured when loading plugin.");
            reject("Error occured when loading plugin.");
            throw "Error occured when loading plugin.";
          }

          plugin._log_history.push(\`Plugin connected.\`);

          if (plugin._unloaded) {
            console.log("WARNING: this plugin is ready but unloaded: " + plugin.id);
            plugin.terminate().then(() => {
              this.event_bus.emit("update_ui");
            });
            return;
          }

          if (template.type) {
            this._register(plugin, template);
          } // if (template.extensions && template.extensions.length > 0) {
          //   this.registerExtension(template.extensions, plugin);
          // }


          if (plugin.config.flags && plugin.config.flags.includes("browserfs")) {
            const bfs = await this.getPlugin(null, {
              name: "BrowserFS"
            });
            bfs.attachWebWorker(plugin.webworker);
          }

          if (plugin.config.resumed && plugin.api.resume) {
            plugin._log_history.push(\`Resuming plugin.\`);

            plugin.api.resume().then(() => {
              this.event_bus.emit("plugin_loaded", plugin);
              resolve(plugin);
            }).catch(e => {
              console.error("error occured when loading plugin " + template.name + ": ", e);
              this.showMessage(\`<\${template.name}>: \${e}\`, 15);
              reject(e);
              plugin.terminate().then(() => {
                this.event_bus.emit("update_ui");
              });
            });
          } else if (plugin.api.setup) {
            plugin._log_history.push(\`Setting up plugin.\`);

            plugin.api.setup().then(() => {
              this.event_bus.emit("plugin_loaded", plugin);
              resolve(plugin);
            }).catch(e => {
              console.error("error occured when loading plugin " + template.name + ": ", e);
              this.showMessage(\`<\${template.name}>: \${e}\`, 15);
              reject(e);
              plugin.terminate().then(() => {
                this.event_bus.emit("update_ui");
              });
            });
          } else {
            console.warn(\`No "setup()" function is defined in plugin "\${plugin.name}".\`);
            resolve(plugin);
          }
        });
        plugin.onFailed(e => {
          clearTimeout(plugin_loading_timer);
          plugin.error(e);

          if (e) {
            this.showMessage(\`<\${template.name}>: \${e}\`);
          } else {
            this.showMessage(\`Error occured when loading \${template.name}.\`);
          }

          console.error("error occured when loading " + template.name + ": ", e);
          plugin.terminate().then(() => {
            this.event_bus.emit("update_ui");
          });
          reject(e);
        });
        plugin.docs = template.docs;
        plugin.attachments = template.attachments;
        this.plugins[plugin.id] = plugin;
        this.plugin_names[plugin.name] = plugin;
      } catch (e) {
        reject(e);
      }
    });
  }

  renderWindow(pconfig) {
    return new Promise((resolve, reject) => {
      const tconfig = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, pconfig.plugin, pconfig);

      tconfig.workspace = this.selected_workspace;

      const imjoy_api = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, this.imjoy_api); // copy window api functions to the plugin instance


      for (let k in pconfig.api) {
        if (Object.prototype.hasOwnProperty.call(pconfig.api, k)) {
          imjoy_api[k] = function () {
            var args = Array.prototype.slice.call(arguments, 1);
            pconfig.api[k].apply(pconfig, args);
          };
        }
      }

      const _interface = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({
        TAG: tconfig.tag,
        WORKSPACE: this.selected_workspace,
        config: {
          tag: tconfig.tag,
          workspace: this.selected_workspace
        }
      }, imjoy_api);

      try {
        const plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"](tconfig, _interface);
        plugin.onConnected(() => {
          if (!pconfig.standalone && pconfig.api.focus) pconfig.api.focus(); // copy window api to the plugin

          plugin.api = plugin.api || {};

          for (let k in pconfig.api) {
            if (Object.prototype.hasOwnProperty.call(pconfig.api, k)) {
              plugin.api[k] = pconfig.api[k];
            }
          }

          (plugin.api.setup || async function () {})().then(() => {
            this.event_bus.emit("plugin_loaded", plugin); //asuming the data._op is passed from last op

            pconfig.data = pconfig.data || {};
            pconfig.data._source_op = pconfig.data && pconfig.data._op;
            pconfig.data._op = plugin.name;
            pconfig.data._workflow_id = pconfig.data && pconfig.data._workflow_id;
            pconfig.plugin = plugin;
            pconfig.update = plugin.api.run;

            if (plugin.config.runnable && !plugin.api.run) {
              const warn_text = "You should define a \`run\` function for " + plugin.name + " or set its \`runnable\` field to false.";
              console.warn(warn_text);
            }

            if (plugin.api.run) {
              plugin.api.run(this.filter4plugin(pconfig)).then(result => {
                if (result) {
                  for (let k in result) {
                    pconfig[k] = result[k];
                  }
                }

                resolve(plugin);
              }).catch(e => {
                plugin.error(\`<\${plugin.name}>: (\${e && e.toString()} || "Error.")\`);
                reject(e);
              });
            } else {
              resolve(plugin);
            }
          }).catch(e => {
            plugin.error(\`Error occured when loading the window plugin \${pconfig.name}: \${e && e.toString()}\`);
            plugin.terminate().then(() => {
              this.event_bus.emit("update_ui");
            });
            reject(e);
          });
        });
        plugin.onFailed(e => {
          if (!pconfig.standalone && pconfig.focus) pconfig.focus();
          plugin.error(\`Error occured when loading \${pconfig.name}: \${e}.\`);
          plugin.terminate().then(() => {
            this.event_bus.emit("update_ui");
          });
          reject(e);
        });
      } catch (e) {
        reject(e);
      }
    });
  }

  plugin2joy(my) {
    if (!my) return null; //conver config--> data  data-->target

    const res = {};
    res._rintf = my._rintf;

    if (my.type && my.data) {
      res.data = my.config;
      res.target = my.data;
      res.target.name = my.name || "";
      res.target.type = my.type || "";
    } else {
      res.data = null;
      res.target = my;
    }

    res.target = res.target || {};

    if (Array.isArray(res.target) && res.target.length > 0) {
      if (my.select !== undefined && res.target[my.select]) {
        res.target = res.target[my.select];
      }
    }

    if (typeof res.target === "object") {
      res.target._variables = my._variables || {};
      res.target._workflow_id = my._workflow_id || null;
      res.target._op = my._op || null;
      res.target._source_op = my._source_op || null;
      res.target._transfer = my._transfer || false;

      if (Object.keys(res.target).length > 4) {
        return res;
      } else {
        return null;
      }
    } else {
      return res;
    }
  }

  filter4plugin(my) {
    return my && {
      _variables: my._variables || null,
      _op: my._op,
      _source_op: my._source_op,
      _transfer: my._transfer,
      _workflow_id: my._workflow_id,
      config: my.config,
      data: my.data
    };
  }

  joy2plugin(my) {
    //conver data-->config target--> data
    if (!my) return null;
    my.target = my.target || {};
    const ret = {
      _rintf: my._rintf,
      _variables: my.target._variables || null,
      _op: my.target._op,
      _source_op: my.target._source_op,
      _transfer: my.target._transfer,
      _workflow_id: my.target._workflow_id,
      config: my.data,
      data: my.target,
      name: my.target.name || "",
      type: my.target.type || ""
    };
    delete my.target._op;
    delete my.target._workflow_id;
    delete my.target._variables;
    delete my.target._source_op;
    delete my.target._transfer;
    return ret;
  }

  getRepoManifest(url, hashtag) {
    return new Promise((resolve, reject) => {
      const re = new RegExp("^[^/.]+/[^/.]+$");
      let repository_url;
      let repo_origin;

      if (url.match(re)) {
        repo_origin = url;

        if (hashtag) {
          url = url + "/tree/" + hashtag;
          repo_origin = repo_origin + "@" + hashtag;
        }

        repository_url = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubImJoyManifest"])("https://github.com/" + url);
      } else if (url.includes("github.com")) {
        repository_url = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubImJoyManifest"])(url);
        repo_origin = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubRepo"])(url);
      } else {
        repository_url = url;
        repo_origin = repository_url;
      }

      axios__WEBPACK_IMPORTED_MODULE_4___default.a.get(repository_url).then(response => {
        if (response && response.data && response.data.plugins) {
          const manifest = response.data;
          manifest.plugins = manifest.plugins.filter(p => {
            return !p.disabled;
          });

          if (!/(http(s?)):\\/\\//i.test(manifest.uri_root)) {
            manifest.uri_root = repository_url.replace(new RegExp("manifest.imjoy.json$"), lodash_trim__WEBPACK_IMPORTED_MODULE_0___default()(manifest.uri_root, "/"));
          }

          for (let i = 0; i < manifest.plugins.length; i++) {
            const p = manifest.plugins[i];
            p.uri = p.uri || p.name + ".imjoy.html";
            p.origin = repo_origin + ":" + p.name;

            if (!p.uri.startsWith(manifest.uri_root) && !/(http(s?)):\\/\\//i.test(p.uri)) {
              p.uri = manifest.uri_root + "/" + p.uri;
            }

            p._id = p._id || p.name.replace(/ /g, "_");
            p.badges = this.getBadges(p);
          }

          resolve(manifest);
        } else {
          reject("failed to load url: " + repository_url);
        }
      }).catch(reject);
    });
  }

  destroy() {
    for (let k in this.plugins) {
      const plugin = this.plugins[k];

      try {
        if (typeof plugin.terminate === "function") plugin.terminate();
      } catch (e) {}
    }
  }

  registerOp(plugin, config) {
    try {
      if (!plugin) throw "Plugin not found.";
      config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["_clone"])(config);
      config.name = config.name || plugin.name;
      config.show_panel = config.show_panel || false;

      if (plugin.name === config.name) {
        config.ui = config.ui || plugin.config.description;
      }

      config.inputs = config.inputs || null;
      config.outputs = config.outputs || null;
      config.run = config.run || null;
      config.run = config.run || plugin && plugin.api && plugin.api.run;

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["OP_SCHEMA"])(config)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["OP_SCHEMA"].errors;
        console.error("Error occured during registering " + config.name, error);
        throw error;
      }

      const plugin_name = plugin.name;
      const op_name = config.name;
      const op_key = op_name === plugin_name ? plugin_name : plugin_name + "/" + op_name;
      const joy_template = {
        name: config.name,
        tags: ["op", "plugin"],
        type: op_key,
        init: _joy_js__WEBPACK_IMPORTED_MODULE_6__["Joy"].normalizeUI(config.ui)
      }; // save type to tags

      if (config.type === "window") {
        joy_template.tags.push("window");
      } else if (config.type === "rpc-window") {
        joy_template.tags.push("rpc-window");
      } else if (config.type === "rpc-worker") {
        joy_template.tags.push("rpc-worker");
      } else if (config.type === "native-python") {
        joy_template.tags.push("python");
      } else if (config.type === "web-worker") {
        joy_template.tags.push("web-worker");
      } else if (config.type === "web-python") {
        joy_template.tags.push("web-python");
      } else if (config.type === "iframe") {
        joy_template.tags.push("iframe");
      }

      let run = config.run;

      if (!plugin || !run) {
        joy_template.onexecute = () => {
          plugin.log("WARNING: no run function defined.");
        };
      } else {
        const onexecute = async my => {
          // my.target._workflow_id = null;
          try {
            const result = await run(this.joy2plugin(my));
            return this.plugin2joy(result);
          } catch (e) {
            plugin.error(e && e.toString());
            throw e;
          }
        };

        joy_template.onexecute = onexecute;
      }

      if (config.update && typeof config.update === "function") {
        const onupdate = async my => {
          // my.target._workflow_id = null;
          const result = await config.update(this.joy2plugin(my));
          return this.plugin2joy(result);
        };

        joy_template.onupdate = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["debounce"])(onupdate, 300);
      } else if (plugin && plugin.api && plugin.api.update) {
        const onupdate = async my => {
          // my.target._workflow_id = null;
          const result = await plugin.api.update(this.joy2plugin(my));
          return this.plugin2joy(result);
        };

        joy_template.onupdate = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["debounce"])(onupdate, 300);
      }

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["JOY_SCHEMA"])(joy_template)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["JOY_SCHEMA"].errors;
        console.error("Error occured during registering op to joy " + joy_template.name, error);
        throw error;
      }

      _joy_js__WEBPACK_IMPORTED_MODULE_6__["Joy"].add(joy_template);
      const op_config = {
        plugin_id: plugin.id,
        name: joy_template.name,
        ui: "{id: '__op__', type: '" + joy_template.type + "'}",
        onexecute: joy_template.onexecute
      };
      plugin.ops = plugin.ops || {};
      plugin.ops[config.name] = op_config;

      if (config.inputs) {
        try {
          if ((config.inputs.type != "object" || !config.inputs.properties) && (config.inputs.type != "array" || !config.inputs.items)) {
            if (typeof config.inputs === "object") {
              config.inputs = {
                properties: config.inputs,
                type: "object"
              };
            } else {
              throw "inputs schema must be an object.";
            }
          } // set all the properties as required by default


          if (config.inputs.type === "object" && config.inputs.properties && !config.inputs.required) {
            config.inputs.required = Object.keys(config.inputs.properties);
          }

          const sch = _api_js__WEBPACK_IMPORTED_MODULE_10__["ajv"].compile(config.inputs);
          op_config.inputs_schema = sch;
          this.registered.inputs[op_key] = {
            loader_key: op_key,
            op_name: op_name,
            plugin_name: plugin_name,
            schema: sch
          };

          this.registered.loaders[op_key] = async target => {
            let config = {};

            if (plugin.config && plugin.config.ui) {
              config = await this.imjoy_api.showDialog(plugin, {
                type: "imjoy/joy",
                ui: plugin.config.ui,
                name: plugin.config.name
              });
            }

            target.transfer = target.transfer || false;
            target._source_op = target._op;
            target._op = op_name;
            target._workflow_id = target._workflow_id || "data_loader_" + op_name.trim().replace(/ /g, "_") + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
            const my = {
              op: {
                name: op_name
              },
              target: target,
              data: config
            };
            const result = await plugin.api.run(this.joy2plugin(my));

            if (result) {
              const res = this.plugin2joy(result); // if it's not a window

              if (res && !res._rintf) {
                const w = {};
                w.name = res.name || "result";
                w.type = res.type || "imjoy/generic";
                w.config = res.data || {};
                w.data = res.target || {};
                await this.imjoy_api.createWindow(plugin, w);
              }
            }
          };

          this.wm.registerInputLoader(op_key, this.registered.inputs[op_key], this.registered.loaders[op_key]);
        } catch (e) {
          console.error(\`error occured when parsing the inputs schema of "\${config.name}"\`, e);
        }
      }

      if (config.outputs) {
        try {
          if (config.outputs.type != "object" || !config.outputs.properties) {
            if (typeof config.outputs === "object") {
              config.outputs = {
                properties: config.outputs,
                type: "object"
              };
            } else {
              throw "inputs schema must be an object.";
            }
          } // set all the properties as required by default


          if (config.outputs.type === "object" && config.outputs.properties && !config.outputs.required) {
            config.outputs.required = Object.keys(config.outputs.properties);
          }

          const sch = _api_js__WEBPACK_IMPORTED_MODULE_10__["ajv"].compile(config.outputs);
          op_config.outputs_schema = sch;
          this.registered.outputs[op_key] = {
            op_name: config.name,
            plugin_name: plugin.name,
            schema: sch
          };
        } catch (e) {
          console.error(\`error occured when parsing the outputs schema of "\${config.name}"\`, e);
        }
      }

      this.registered.ops[op_key] = op_config;
      this.registered.windows[config.name] = plugin.config;
      this.event_bus.emit("op_registered", op_config);
      return true;
    } catch (e) {
      console.error(e);
      throw e;
    }
  }

  unregisterOp(plugin, config) {
    if (!plugin) throw "Plugin not found.";
    const plugin_name = plugin.name;

    if (!config) {
      if (plugin.ops && Object.keys(plugin.ops).length > 0) {
        for (let k in plugin.ops) {
          const op = plugin.ops[k];
          if (op.name) this.unregisterOp(plugin, op.name);
        }
      }

      if (plugin.name) this.unregisterOp(plugin, plugin.name);
      return;
    } else {
      const op_name = typeof config === "string" ? config : config.name;
      const op_key = op_name === plugin_name ? plugin_name : plugin_name + "/" + op_name;
      if (this.registered.inputs[op_key]) delete this.registered.inputs[op_key];
      if (this.registered.loaders[op_key]) delete this.registered.loaders[op_key];
      if (op_name === plugin_name && this.registered.windows[plugin_name]) delete this.registered.windows[plugin_name];
      if (this.registered.ops[op_key]) delete this.registered.ops[op_key];
      if (plugin.ops && plugin.ops[op_name]) delete plugin.ops[op_name];
      this.wm.unregisterInputLoader(op_key);
      _joy_js__WEBPACK_IMPORTED_MODULE_6__["Joy"].remove(op_key);
    }
  }

  async _register(plugin, config) {
    // config._id means this is a plugin config
    if (!config.type || config._id || config.type === "@operator" || config.type === "operator") {
      this.registerOp(plugin, config);
      this.service_registry[config.name] = {
        id: config.name,
        type: "@operator",
        name: config.name,
        ui: config.ui,
        inputs: config.inputs,
        outputs: config.outputs,
        run: config.run,
        provider: plugin.name,
        providerId: plugin.id
      };
      this.event_bus.emit("register", {
        config,
        plugin
      });
      return config.name;
    }

    config.id = config.id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
    config.provider = plugin.name;
    config.providerId = plugin.id;
    this.service_registry[config.id] = config;
    this.event_bus.emit("register", {
      config,
      plugin
    });
    return config.id;
  }

  _unregister(plugin, config) {
    if (!config || typeof config === "string" || config.type === "@operator" || config.type === "operator") {
      if (!config) {
        const services = this.getServices(plugin, {
          providerId: plugin.id
        });

        for (let s of services) {
          this._unregister(plugin, s);
        }
      }

      config = config || plugin;
      this.unregisterOp(plugin, config);
      delete this.service_registry[config.name];
    } else delete this.service_registry[config.id];

    this.event_bus.emit("unregister", {
      config,
      plugin
    });
    return true;
  } //#################ImJoy API functions##################


  async register(plugin, config) {
    console.warn("api.register is deprecated, please use \`api.registerService\` instead.");
    return await this.registerService(plugin, config);
  }

  async unregister(plugin, config) {
    console.warn("api.unregister is deprecated, please use \`api.registerService\` instead.");
    return await this.unregisterService(plugin, config);
  }

  async registerService(plugin, config) {
    plugin = plugin || {};

    if (!config.type || !config.name) {
      throw new Error("you must specify the service \`type\` and \`name\`.");
    } else if (config.type.startsWith("@")) {
      // registered service types
      if (compiledServiceSpec[config.type]) {
        const schema = compiledServiceSpec[config.type];

        if (!schema(config)) {
          const error = schema.errors;
          console.error("Failed to register service " + config.name || false, error);
          throw error;
        }
      } else {
        throw new Error(\`Registered service type "\${config.type}" not found, please consider submit your type definition to the imjoy-core repo, see https://imjoy.io/docs/#/api?id=apiregisterservice for more details\`);
      }
    }

    return this._register(plugin, config);
  }

  async unregisterService(plugin, config) {
    return this._unregister(plugin, config);
  }

  getServices(_plugin, sconfig) {
    sconfig = sconfig || {};
    return Object.values(this.service_registry).filter(s => {
      let match = true;

      for (let k of Object.keys(sconfig)) {
        if (sconfig[k] !== s[k]) {
          match = false;
          break;
        }
      }

      return match;
    });
  }

  createWindow(_plugin, cfg, extra_cfg) {
    let wconfig = {};

    if (typeof cfg === "string") {
      if (cfg.includes("\\n") || /(http(s?)):\\/\\//i.test(cfg) || cfg.includes("/") && cfg.includes(":")) {
        wconfig = {
          src: cfg
        };
      } else wconfig = {
        type: cfg
      };
    } else {
      wconfig = cfg;
    }

    if (extra_cfg) {
      wconfig = Object.assign(wconfig, extra_cfg);
    } // eslint-disable-next-line no-async-promise-executor


    return new Promise(async (resolve, reject) => {
      if (!wconfig.type) {
        if (wconfig.ui) {
          wconfig.type = "imjoy/joy";
        }
      }

      wconfig.data = wconfig.data || null;
      wconfig.panel = wconfig.panel || null;

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"])(wconfig)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"].errors;
        console.error("Error occured during creating window ", wconfig, error);
        throw error;
      }

      wconfig.name = wconfig.name || wconfig.type; // this is a unique id for the iframe to attach

      wconfig.window_id = wconfig.window_id || "plugin_window_" + wconfig.id + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])(); // window_type will be used for detaching the window

      wconfig.window_type = wconfig.type;

      if (wconfig.type && wconfig.type.startsWith("imjoy/")) {
        wconfig.id = "imjoy_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        this.wm.addWindow(wconfig).then(() => {
          wconfig.api.on("ready", () => {
            wconfig.refresh();
            wconfig.api = wconfig.api || {};
            wconfig.api = Object.assign(wconfig.api, {
              _rintf: true,
              run: new_config => {
                for (let k in new_config) {
                  wconfig[k] = new_config[k];
                }
              }
            });
            resolve(wconfig.api);
          }, true);
        }).catch(reject);
      } else {
        let window_config;

        if (wconfig.src) {
          // load window plugin from source code
          if (wconfig.src.includes("\\n")) {
            const wplugin = await this.reloadPlugin({
              code: wconfig.src,
              load_dependencies: true,
              namespace: wconfig.namespace,
              tag: wconfig.tag,
              hot_reloading: wconfig.hot_reloading
            });
            window_config = wplugin.config;
            wconfig.type = wplugin.config.type;
            wconfig.name = wconfig.name || wplugin.name || wconfig.type;
          } // load window plugin from source code url
          else if ( // plugin uri
            !/(http(s?)):\\/\\//i.test(wconfig.src) && wconfig.src.includes("/") && wconfig.src.includes(":") || // plugin source url
            /(http(s?)):\\/\\//i.test(wconfig.src) && (wconfig.src.endsWith(".imjoy.html") || wconfig.src.includes("github.com") && wconfig.src.includes("/blob/") || wconfig.src.includes("gist.github.com"))) {
              const wplugin = await this.reloadPluginRecursively({
                uri: wconfig.src,
                tag: wconfig.tag,
                namespace: wconfig.namespace,
                hot_reloading: wconfig.hot_reloading
              });
              window_config = wplugin.config;
              wconfig.type = wplugin.config.type;
              wconfig.name = wconfig.name || wplugin.name || wconfig.type;
            } // load as rpc-window
            else if (/(http(s?)):\\/\\//i.test(wconfig.src)) {
                wconfig.type = wconfig.type || wconfig.src.split("?")[0];
                wconfig.name = wconfig.name || wconfig.type;
                window_config = Object.assign({}, wconfig);
                delete window_config.data;
                delete window_config.config; // copy valid config options as external window plugin <config> block

                if (typeof wconfig.config === "object") {
                  for (let k of _api_js__WEBPACK_IMPORTED_MODULE_10__["PLUGIN_CONFIG_FIELDS"]) {
                    if (wconfig.config[k]) {
                      window_config[k] = wconfig.config[k];
                    }
                  }
                }

                window_config.type = "rpc-window";
                window_config.base_frame = wconfig.src;
                window_config.id = "rpc_window_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
              } else {
                reject(\`Unsupported window spec \${wconfig}\`);
                return;
              }
        } else {
          window_config = this.registered.windows[wconfig.type];
        }

        if (!window_config) {
          console.error("No plugin registered for window type: " + wconfig.type, this.registered.windows);
          reject("No plugin registered for window type: " + wconfig.type);
          throw "No plugin registered for window type: " + wconfig.type;
        }

        const pconfig = wconfig; //generate a new window id

        pconfig.id = pconfig.id || window_config.id + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])(); // assign plugin type ('window')

        pconfig.type = window_config.type;

        if (pconfig.type !== "rpc-window" && pconfig.type !== "window") {
          throw 'Window plugin must be with type "window"';
        }

        pconfig.plugin = window_config;

        if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"])(pconfig)) {
          const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"].errors;
          console.error("Error occured during creating window ", pconfig, error);
          throw error;
        }

        pconfig.loading = true;
        const loadingTimer = setTimeout(() => {
          pconfig.loading = false;
          console.warn(\`Failed to load window "\${pconfig.name}" in 10s.\`);
        }, 10000);
        this.wm.addWindow(pconfig).then(() => {
          setTimeout(() => {
            pconfig.refresh();
            const p = this.renderWindow(pconfig);

            if (pconfig.type === "rpc-window") {
              clearTimeout(loadingTimer);
              pconfig.loading = false;
            }

            if (pconfig.passive || window_config.passive) {
              resolve({
                passive: true,
                _rintf: true,
                setup: async function () {},
                on: async function () {},
                off: async function () {},
                emit: async function () {}
              });
              return;
            }

            p.then(wplugin => {
              pconfig.api.on("close", async () => {
                this.event_bus.emit("closing_window_plugin", wplugin);
                await wplugin.terminate();
              });
              pconfig.refresh();
              resolve(wplugin.api);
            }).catch(e => {
              pconfig.refresh();
              reject(e);
            }).finally(() => {
              clearTimeout(loadingTimer);
              pconfig.loading = false;
            });
          }, 0);
        });
      }
    });
  }

  async callPlugin(_plugin, plugin_name, function_name) {
    const target_plugin = this.plugin_names[plugin_name];

    if (target_plugin) {
      if (!target_plugin.api[function_name]) {
        throw \`function "\${function_name}" of \${plugin_name} is not available.\`;
      }

      return await target_plugin.api[function_name].apply(null, Array.prototype.slice.call(arguments, 3, arguments.length));
    } else {
      throw \`plugin with type \${plugin_name} not found.\`;
    }
  }

  async getPlugins(_plugin) {
    const ps = [];

    for (let k in this.plugins) {
      // if (this.plugins[k] === _plugin) continue;
      ps.push({
        name: this.plugins[k].name,
        config: this.plugins[k].config,
        api: this.plugins[k].api
      });
    }

    return ps;
  }

  async getPlugin(_plugin, cfg, extra_cfg) {
    let config = {};

    if (typeof cfg === "string") {
      if (/(http(s?)):\\/\\//i.test(cfg) || cfg.includes("\\n")) {
        config.src = cfg;
      } else {
        config.name = cfg;
      }
    } else {
      config = cfg;
    }

    if (extra_cfg) {
      config = Object.assign(config, extra_cfg);
    }

    if (config.src && config.src.includes("\\n")) {
      const p = await this.reloadPlugin({
        code: config.src,
        load_dependencies: true,
        namespace: config.namespace,
        tag: config.tag,
        hot_reloading: config.hot_reloading,
        engine_mode: config.engine_mode
      });
      console.log(\`\${p.name} loaded from source code\`);
      return p.api;
    } else if (config.src && (/(http(s?)):\\/\\//i.test(config.src) || config.src.includes("/") && config.src.includes(":"))) {
      // try to load from plugin uri
      const p = await this.reloadPluginRecursively({
        uri: config.src,
        tag: config.tag,
        namespace: config.namespace,
        hot_reloading: config.hot_reloading,
        engine_mode: config.engine_mode
      }, config.tag);
      console.log(\`\${p.name} loaded from \${config.src}\`);
      return p.api;
    } else if (config.id && this.plugins[config.id]) {
      return this.plugins[config.id].api;
    } else if (config.name) {
      if (this.plugin_names[config.name]) {
        return this.plugin_names[config.name].api;
      } else if (this.internal_plugins[config.name]) {
        const p = await this.reloadPluginRecursively({
          uri: this.internal_plugins[config.name].src,
          tag: config.tag,
          namespace: config.namespace,
          hot_reloading: config.hot_reloading,
          engine_mode: config.engine_mode
        }, null, "eval is evil");
        console.log(\`\${p.name} loaded.\`);
        return p.api;
      } else {
        throw \`Plugin not found: \${config.name}\`;
      }
    } else {
      throw \`Unsupported plugin spec: \${config}\`;
    }
  }

  async getWindow(_plugin, config) {
    if (typeof config === "string") {
      config = {
        name: config
      };
    }

    if (config.plugin_id) {
      for (let w of this.wm.windows) {
        if (w.plugin.id === config.plugin_id) {
          return w.plugin && w.plugin.api;
        }
      }
    }

    if (config.window_id) {
      for (let w of this.wm.windows) {
        if (w.window_id === config.window_id) {
          return w.plugin && w.plugin.api;
        }
      }
    }

    if (!config.name && !config.type) {
      return null;
    }

    for (let w of this.wm.windows) {
      if (config.name) {
        if (w.name !== config.name) {
          continue;
        }
      }

      if (config.type) {
        if (w.window_type !== config.type) {
          continue;
        }
      }

      return w.plugin && w.plugin.api;
    }

    return null;
  }

  async getFileManager(_plugin, file_manager_url) {
    const manager = this.fm.getFileManagerByUrl(file_manager_url);

    if (manager) {
      return manager.api;
    } else {
      throw \`file manager with url \${file_manager_url} not found.\`;
    }
  }

  async getEngine(_plugin, engine_url) {
    const engine = this.em.getEngineByUrl(engine_url);

    if (engine) {
      return engine.api;
    } else {
      throw \`engine with url \${engine_url} not found.\`;
    }
  }

  async getEngineFactory(_plugin, factory_name) {
    const factory = this.em.getFactory(factory_name);

    if (factory) {
      return factory.api;
    } else {
      throw \`engine factory with name \${factory_name} not found.\`;
    }
  }

  async runPlugin(_plugin, plugin_name, my) {
    if (!_plugin || !_plugin.id) {
      throw "source plugin is not available.";
    }

    const target_plugin = this.plugin_names[plugin_name];

    if (target_plugin) {
      return await target_plugin.api.run(my || {});
    } else {
      throw "plugin with type " + plugin_name + " not found.";
    }
  }

  setPluginConfig(plugin, name, value) {
    if (!plugin) throw "setConfig Error: Plugin not found.";

    if (name.startsWith("_") && plugin.config[name.slice(1)]) {
      throw \`'\${name.slice(1)}' is a readonly field defined in <config> block, please avoid using it\`;
    }

    if (value) {
      return localStorage.setItem("config_" + plugin.name + "_" + name, value);
    } else {
      return localStorage.removeItem("config_" + plugin.name + "_" + name);
    }
  }

  getPluginConfig(plugin, name) {
    if (!plugin) throw "getConfig Error: Plugin not found.";

    if (name.startsWith("_") && plugin.config[name.slice(1)]) {
      return plugin.config[name.slice(1)];
    } else {
      return localStorage.getItem("config_" + plugin.name + "_" + name);
    }
  }

  getAttachment(plugin, name) {
    if (plugin.config.attachments) {
      for (let i = 0; i < plugin.config.attachments.length; i++) {
        if (plugin.config.attachments[i].attrs.name === name) {
          return plugin.config.attachments[i].content;
        }
      }
    } else {
      return null;
    }
  }

  async checkPluginUpdate(plugin) {
    const pconfig = plugin.config;
    const config = await this.getPluginFromUrl(pconfig.origin, this.available_plugins);

    if (pconfig.hash) {
      if (pconfig.hash !== spark_md5__WEBPACK_IMPORTED_MODULE_3___default.a.hash(config.code)) {
        if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["compareVersions"])(pconfig.version, "<=", config.version)) {
          plugin.update_available = true;
        } else {
          plugin.update_available = false;
        }
      } else {
        plugin.update_available = false;
      }
    } else {
      if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["compareVersions"])(pconfig.version, "<", config.version)) {
        plugin.update_available = true;
      } else {
        plugin.update_available = false;
      }
    }

    this.event_bus.emit("update_ui");
  }

  checkUpdates() {
    for (let k in this.plugins) {
      const plugin = this.plugins[k];

      if (plugin.config.origin) {
        this.checkPluginUpdate(plugin);
      } else {
        const pc = this.available_plugins.find(p => {
          return plugin.name === p.name;
        });

        if (pc) {
          plugin.config.origin = pc.uri;
          this.checkPluginUpdate(plugin);
        }
      }
    }
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/pluginManager.js?`)},"./src/pluginParser.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseComponent", function() { return parseComponent; });
/* eslint-disable */
// Taken from https://github.com/vuejs/vue/blob/dev/packages/vue-template-compiler/browser.js
var splitRE = /\\r?\\n/g;
var emptyRE = /^\\s*$/;
var needFixRE = /^(\\r?\\n)*[\\t\\s]/;

var deIndent = function deindent(str) {
  if (!needFixRE.test(str)) {
    return str;
  }

  var lines = str.split(splitRE);
  var min = Infinity;
  var type, cur, c;

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];

    if (!emptyRE.test(line)) {
      if (!type) {
        c = line.charAt(0);

        if (c === " " || c === "\\t") {
          type = c;
          cur = count(line, type);

          if (cur < min) {
            min = cur;
          }
        } else {
          return str;
        }
      } else {
        cur = count(line, type);

        if (cur < min) {
          min = cur;
        }
      }
    }
  }

  return lines.map(function (line) {
    return line.slice(min);
  }).join("\\n");
};

function count(line, type) {
  var i = 0;

  while (line.charAt(i) === type) {
    i++;
  }

  return i;
}
/*  */


var emptyObject = Object.freeze({}); // these helpers produces better vm code in JS engines due to their
// explicitness and function inlining

function isUndef(v) {
  return v === undefined || v === null;
}
/**
 * Check if value is primitive
 */


function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || // $flow-disable-line
  typeof value === "symbol" || typeof value === "boolean";
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
/**
 * Get the raw type string of a value e.g. [object Object]
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === "[object Object]";
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}
/**
 * Convert a value to a string that is actually rendered.
 */

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(",");

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap("slot,component", true);
/**
 * Check if a attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
/**
 * Remove an item from an array
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether the object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});
/**
 * Capitalize a string.
 */

/**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

/**
 * Mix properties into target object.
 */

function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/**
 * Return same value
 */


var identity = function (_) {
  return _;
};
/**
 * Generate a static keys string from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(",");
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */

/**
 * Ensure a function is called only once.
 */

/*  */


var isUnaryTag = makeMap("area,base,br,col,embed,frame,hr,img,input,isindex,keygen," + "link,meta,param,source,track,wbr"); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap("address,article,aside,base,blockquote,body,caption,col,colgroup,dd," + "details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form," + "h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta," + "optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead," + "title,tr,track");
/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\\s*([^\\s"'<>\\/=]+)(?:\\s*(=)\\s*(?:"([^"]*)"+|'([^']*)'+|([^\\s"'=<>\`]+)))?/; // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset

var ncname = "[a-zA-Z_][\\\\w\\\\-\\\\.]*";
var qnameCapture = "((?:" + ncname + "\\\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\\s*(\\/?)>/;
var endTag = new RegExp("^<\\\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\\--/;
var conditionalComment = /^<!\\[/;
var IS_REGEX_CAPTURING_BROKEN = false;
"x".replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === "";
}); // Special Elements (can contain anything)

var isPlainTextElement = makeMap("script,style,textarea", true);
var reCache = {};
var decodingMap = {
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&amp;": "&",
  "&#10;": "\\n",
  "&#9;": "\\t"
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap("pre,textarea", true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === "\\n";
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf("<");

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf("-->");

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf("]>");

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf("<", 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = "";
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp("([\\\\s\\\\S]*?)(</" + stackedTag + "[^>]*>)", "i"));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== "noscript") {
          text = text.replace(/<!\\--([\\s\\S]*?)-->/g, "$1") // #7298
          .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, "$1");
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return "";
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if ( true && !stack.length && options.warn) {
        options.warn('Mal-formatted tag at end of template: "' + html + '"');
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === "p" && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i]; // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778

      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === "") {
          delete args[3];
        }

        if (args[4] === "") {
          delete args[4];
        }

        if (args[5] === "") {
          delete args[5];
        }
      }

      var value = args[3] || args[4] || args[5] || "";
      var shouldDecodeNewlines = tagName === "a" && args[1] === "href" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    } // Find the closest opened tag of the same type


    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === "br") {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === "p") {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var splitRE$1 = /\\r?\\n/g;
var replaceRE = /./g;
var isSpecialTag = makeMap("script,style,template", true);
/**
 * Parse a single-file component (*.vue) file into an SFC Descriptor Object.
 */

function parseComponent(content, options) {
  if (options === void 0) options = {};
  var sfc = {
    script: [],
    style: [],
    config: [],
    window: [],
    docs: [],
    attachment: [],
    link: [],
    others: []
  };
  var depth = 0;
  var currentBlock = null;

  function start(tag, attrs, unary, start, end) {
    if (depth === 0) {
      currentBlock = {
        type: tag,
        content: "",
        start: end,
        attrs: attrs.reduce(function (cumulated, ref) {
          var name = ref.name;
          var value = ref.value;
          cumulated[name] = value || true;
          return cumulated;
        }, {})
      };

      if (sfc[tag]) {
        checkAttrs(currentBlock, attrs);
        sfc[tag].push(currentBlock);
      } else {
        // custom blocks
        sfc.others.push(currentBlock);
      }
    }

    if (!unary) {
      depth++;
    }
  }

  function checkAttrs(block, attrs) {
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];

      if (attr.name === "lang") {
        block.lang = attr.value;
      }

      if (attr.name === "scoped") {
        block.scoped = true;
      }

      if (attr.name === "module") {
        block.module = attr.value || true;
      }

      if (attr.name === "src") {
        block.src = attr.value;
      }
    }
  }

  function end(tag, start, end) {
    if (depth === 1 && currentBlock) {
      currentBlock.end = start;
      var text = deIndent(content.slice(currentBlock.start, currentBlock.end)); // pad content so that linters and pre-processors can output correct
      // line numbers in errors and warnings

      if (currentBlock.type !== "template" && options.pad) {
        text = padContent(currentBlock, options.pad) + text;
      }

      currentBlock.content = text;
      currentBlock = null;
    }

    depth--;
  }

  function padContent(block, pad) {
    if (pad === "space") {
      return content.slice(0, block.start).replace(replaceRE, " ");
    } else {
      var offset = content.slice(0, block.start).split(splitRE$1).length;
      var padChar = block.type === "script" && !block.lang ? "//\\n" : "\\n";
      return Array(offset).join(padChar);
    }
  }

  parseHTML(content, {
    start: start,
    end: end
  });
  return sfc;
}

//# sourceURL=webpack://%5Bname%5D/./src/pluginParser.js?`)},"./src/serviceSpec.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serviceSpec", function() { return serviceSpec; });
const serviceSpec = {
  // add your service type schema here
  // you can use json-schema and additional keywords such as \`instanceof\`
  operator: {
    properties: {
      name: {
        type: "string"
      },
      ui: {
        type: ["null", "string", "array", "object"]
      },
      run: {
        instanceof: Function
      },
      inputs: {
        type: ["null", "object"]
      },
      outputs: {
        type: ["null", "object"]
      }
    }
  },
  "engine-factory": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["engine-factory"]
      },
      icon: {
        type: "string"
      },
      url: {
        type: "string"
      },
      config: {
        type: "object"
      },
      addEngine: {
        instanceof: Function
      },
      removeEngine: {
        instanceof: Function
      }
    }
  },
  engine: {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["engine"]
      },
      pluginType: {
        type: "string"
      },
      factory: {
        type: "string"
      },
      icon: {
        type: "string"
      },
      url: {
        type: "string"
      },
      config: {
        type: "object"
      },
      enable: {
        instanceof: Function
      },
      disable: {
        instanceof: Function
      },
      connect: {
        instanceof: Function
      },
      disconnect: {
        instanceof: Function
      },
      listPlugins: {
        instanceof: Function
      },
      startPlugin: {
        instanceof: Function
      },
      getPlugin: {
        instanceof: Function
      },
      getEngineStatus: {
        instanceof: Function
      },
      getEngineConfig: {
        instanceof: [Function, null]
      },
      heartbeat: {
        instanceof: [Function, null]
      },
      killPlugin: {
        instanceof: [Function, null]
      },
      killPluginProcess: {
        instanceof: [Function, null]
      },
      restartPlugin: {
        instanceof: [Function, null]
      },
      about: {
        instanceof: [Function, null]
      }
    }
  },
  "file-manager": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["file-manager"]
      },
      url: {
        type: "string"
      },
      shwoFileDialog: {
        instanceof: Function
      },
      listFiles: {
        instanceof: Function
      },
      getFile: {
        instanceof: Function
      },
      putFile: {
        instanceof: Function
      },
      requestUploadUrl: {
        instanceof: Function
      },
      getFileUrl: {
        instanceof: Function
      },
      removeFile: {
        instanceof: Function
      },
      heartbeat: {
        instanceof: [Function, null]
      }
    }
  },
  "@transformation": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["transformation"]
      },
      transform: {
        instanceof: Function
      },
      fit: {
        instanceof: Function
      },
      fit_transform: {
        instanceof: Function
      }
    },
    required: ["name", "type", "transform"]
  },
  "@model": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["model"]
      },
      predict: {
        instanceof: Function
      },
      fit: {
        instanceof: Function
      }
    },
    required: ["name", "type", "predict"]
  }
};

//# sourceURL=webpack://%5Bname%5D/./src/serviceSpec.js?`)},"./src/utils.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheUrlInServiceWorker", function() { return cacheUrlInServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "html2string", function() { return html2string; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchDevice", function() { return isTouchDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Whenable", function() { return Whenable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersions", function() { return compareVersions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathJoin", function() { return pathJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirName", function() { return dirName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "url_regex", function() { return url_regex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animalGenerator", function() { return animalGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colourGenerator", function() { return colourGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_clone", function() { return _clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Filters", function() { return Filters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUrl", function() { return isUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubUrlToObject", function() { return githubUrlToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubUrlRaw", function() { return githubUrlRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubImJoyManifest", function() { return githubImJoyManifest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubRepo", function() { return githubRepo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hot_lut", function() { return hot_lut; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pluginParser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginParser.js */ "./src/pluginParser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseComponent", function() { return _pluginParser_js__WEBPACK_IMPORTED_MODULE_1__["parseComponent"]; });

/*eslint no-useless-escape: "off"*/


function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}
function html2string(input) {
  return input && input.replace(/\\n/gm, "").replace(/<br>/gm, "\\n").replace(/<[^>]*>?/gm, "");
}
function assert(condition, message) {
  if (!condition) {
    message = message || "Assertion failed";

    if (typeof Error !== "undefined") {
      throw new Error(message);
    }

    throw message; // Fallback
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
/**
 * A special kind of event:
 *  - which can only be emitted once;
 *  - executes a set of subscribed handlers upon emission;
 *  - if a handler is subscribed after the event was emitted, it
 *    will be invoked immideately.
 *
 * Used for the events which only happen once (or do not happen at
 * all) during a single plugin lifecycle - connect, disconnect and
 * connection failure
 */

const Whenable = function (multi_emit) {
  this._multi_emit = multi_emit;
  this._emitted = false;
  this._handlers = [];
};
/**
 * Emits the Whenable event, calls all the handlers already
 * subscribed, switches the object to the 'emitted' state (when
 * all future subscibed listeners will be immideately issued
 * instead of being stored)
 */

Whenable.prototype.emit = function (e) {
  if (this._multi_emit) {
    this._emitted = true;
    this._e = e;

    for (let handler of this._handlers) {
      setTimeout(handler.bind(null, e), 0);
    }
  } else if (!this._emitted) {
    this._emitted = true;
    this._e = e;
    var handler;

    while (handler = this._handlers.pop()) {
      setTimeout(handler.bind(null, e), 0);
    }
  }
};
/**
 * Saves the provided function as a handler for the Whenable
 * event. This handler will then be called upon the event emission
 * (if it has not been emitted yet), or will be scheduled for
 * immediate issue (if the event has already been emmitted before)
 *
 * @param {Function} handler to subscribe for the event
 */


Whenable.prototype.whenEmitted = function (handler) {
  handler = this._checkHandler(handler);

  if (this._emitted) {
    setTimeout(handler.bind(null, this._e), 0);
  } else {
    this._handlers.push(handler);
  }
};
/**
 * Checks if the provided object is suitable for being subscribed
 * to the event (= is a function), throws an exception if not
 *
 * @param {Object} obj to check for being subscribable
 *
 * @throws {Exception} if object is not suitable for subscription
 *
 * @returns {Object} the provided object if yes
 */


Whenable.prototype._checkHandler = function (handler) {
  var type = typeof handler;

  if (type !== "function") {
    var msg = "A function may only be subsribed to the event, " + type + " was provided instead";
    throw new Error(msg);
  }

  return handler;
};

function compareVersions(v1, comparator, v2) {
  comparator = comparator == "=" ? "==" : comparator;

  if (["==", "===", "<", "<=", ">", ">=", "!=", "!=="].indexOf(comparator) == -1) {
    throw new Error("Invalid comparator. " + comparator);
  }

  var v1parts = v1.split("."),
      v2parts = v2.split(".");
  var maxLen = Math.max(v1parts.length, v2parts.length);
  var part1, part2;
  var cmp = 0;

  for (var i = 0; i < maxLen && !cmp; i++) {
    part1 = parseInt(v1parts[i], 10) || 0;
    part2 = parseInt(v2parts[i], 10) || 0;
    if (part1 < part2) cmp = 1;
    if (part1 > part2) cmp = -1;
  }

  return eval("0" + comparator + cmp);
}
function pathJoin()
/* path segments */
{
  // Split the inputs into a list of path commands.
  var parts = [];

  for (var i = 0, l = arguments.length; i < l; i++) {
    parts = parts.concat(arguments[i].split("/"));
  } // Interpret the path commands to get the new resolved path.


  var newParts = [];

  for (i = 0, l = parts.length; i < l; i++) {
    var part = parts[i]; // Remove leading and trailing slashes
    // Also remove "." segments

    if (!part || part === ".") continue; // Interpret ".." to pop the last segment

    if (part === "..") newParts.pop(); // Push new path segments.
    else newParts.push(part);
  } // Preserve the initial slash if there was one.


  if (parts[0] === "") newParts.unshift(""); // Turn back into a single string path.

  return newParts.join("/") || (newParts.length ? "/" : ".");
} // A simple function to get the dirname of a path
// Trailing slashes are ignored. Leading slash is preserved.

function dirName(path) {
  return pathJoin(path, "..");
} // wordgenjs from https://github.com/gurshabad/wordgenjs

const arrAnimals = ["Aardvark", "Albatross", "Alligator", "Alpaca", "Ant", "Anteater", "Antelope", "Ape", "Armadillo", "Ass_Donkey", "Baboon", "Badger", "Barracuda", "Bat", "Bear", "Beaver", "Bee", "Bison", "Boa", "Buffalo", "Butterfly", "Camel", "Capybara", "Caribou", "Cassowary", "Cat", "Caterpillar", "Cattle", "Chamois", "Cheetah", "Chicken", "Chimpanzee", "Chinchilla", "Chough", "Clam", "Cobra", "Cockroach", "Cod", "Cormorant", "Coyote", "Crab", "Crane", "Crocodile", "Crow", "Curlew", "Deer", "Dinosaur", "Dog", "Dogfish", "Dolphin", "Donkey", "Dotterel", "Dove", "Dragonfly", "Duck", "Dugong", "Dunlin", "Eagle", "Echidna", "Eel", "Eland", "Elephant", "Elephantseal", "Elk", "Emu", "Falcon", "Ferret", "Finch", "Fish", "Flamingo", "Fox", "Frog", "Gaur", "Gazelle", "Gerbil", "GiantPanda", "Giraffe", "Gnat", "Gnu", "Goat", "Goose", "Goldfinch", "Goldfish", "Gorilla", "Goshawk", "Grasshopper", "Grouse", "Guanaco", "Guineafowl", "Guineapig", "Gull", "Hamster", "Hare", "Hawk", "Hedgehog", "Heron", "Herring", "Hippopotamus", "Hornet", "Horse", "Human", "Hummingbird", "Hyena", "Ibex", "Ibis", "Jackal", "Jaguar", "Jay", "Jellyfish", "Kangaroo", "Kingfisher", "Koala", "Komodo", "Kookabura", "Kouprey", "Kudu", "Lapwing", "Lark", "Lemur", "Leopard", "Lion", "Llama", "Lobster", "Locust", "Loris", "Louse", "Lyrebird", "Magpie", "Mallard", "Manatee", "Mandrill", "Mantis", "Marten", "Meerkat", "Mink", "Mole", "Mongoose", "Monkey", "Moose", "Mouse", "Mosquito", "Mule", "Narwhal", "Newt", "Nightingale", "Octopus", "Okapi", "Opossum", "Oryx", "Ostrich", "Otter", "Owl", "Ox", "Oyster", "Panther", "Parrot", "Partridge", "Peafowl", "Pelican", "Penguin", "Pheasant", "Pig", "Pigeon", "PolarBear", "Pony", "Porcupine", "Porpoise", "PrairieDog", "Quail", "Quelea", "Quetzal", "Rabbit", "Raccoon", "Rail", "Ram", "Rat", "Raven", "Reddeer", "Redpanda", "Reindeer", "Rhinoceros", "Rook", "Salamander", "Salmon", "SandDollar", "Sandpiper", "Sardine", "Scorpion", "Sealion", "SeaUrchin", "Seahorse", "Seal", "Shark", "Sheep", "Shrew", "Skunk", "Snail", "Snake", "Sparrow", "Spider", "Spoonbill", "Squid", "Squirrel", "Starling", "Stingray", "Stinkbug", "Stork", "Swallow", "Swan", "Tapir", "Tarsier", "Termite", "Tiger", "Toad", "Trout", "Turkey", "Turtle", "Vicu�a", "Viper", "Vulture", "Wallaby", "Walrus", "Wasp", "Waterbuffalo", "Weasel", "Whale", "Wolf", "Wolverine", "Wombat", "Woodcock", "Woodpecker", "Worm", "Wren", "Yak", "Zebra"];
const arrColours = ["almond", "amaranthine", "amber", "amethyst", "antique", "apple", "apricot", "aqua", "aquamarine", "argent", "auburn", "avocado", "azure", "babyblue", "banana", "battleshipgray", "bay", "beige", "Bermudagreen", "beryl", "biceblue", "bicegreen", "bice", "biscuit", "bisque", "black", "blanchedalmond", "blazeorange", "blonde", "bloodred", "bluegreen", "blueviolet", "blue", "blueberry", "bone", "bottlegreen", "brass", "brickred", "bronzeyellow", "bronze", "brown", "buckskin", "buff", "burgundy", "burlywood", "burntorange", "burntsienna", "burntumber", "butterscotch", "cadetblue", "Cambridgeblue", "canary", "cardinal", "carmine", "carnation", "carnelian", "carroty", "celadon", "cerise", "cerulean", "chamois", "champagne", "charcoal", "chartreuse", "cherryred", "chestnut", "Chinesered", "chocolate", "cinereous", "cinnabar", "cinnamon", "citrine", "clairdelune", "claret", "coalblack", "cobaltblue", "cocoa", "coffee", "coolgray", "Copenhagenblue", "copper", "coral", "cornflowerblue", "cornflower", "cornsilk", "cream", "crimson", "cupreous", "cyan", "daffodil", "damask", "dandelion", "dovegray", "duckeggblue", "dun", "Dodgerblue", "eaudenil", "ebony", "ecru", "eggshellblue", "eggshell", "electricblue", "emeraldgreen", "emerald", "fawn", "federalyellow", "firebrick", "fireenginered", "flame", "flamingo", "flaxen", "flesh", "floralwhite", "forestgreen", "fuchsia", "fuscous", "gainsboro", "gamboge", "garnet", "gentianblue", "gentianviolet", "geranium", "ginger", "glaucous", "gold", "goldenbrown", "goldenrod", "goldochre", "grape", "grassgreen", "gray", "green", "grizzle", "gules", "gunmetalgray", "hazel", "heather", "heliotrope", "henna", "hepatic", "hoar", "honey", "honeydew", "hotpink", "huntergreen", "iceblue", "incarnadine", "Indianred", "indigo", "internationalorange", "irongray", "ivory", "jadegreen", "jade", "jet", "jonquil", "kellygreen", "Kendalgreen", "khaki", "khakigreen", "lapislazuli", "laurelgreen", "lavender", "lemonchiffon", "lemon", "lilac", "lime", "Lincolngreen", "linen", "liver", "loden", "lovat", "macaroniandcheese", "madder", "magenta", "magicmint", "magnolia", "mahogany", "malachite", "maroon", "mauve", "mazarine", "melon", "midnightblue", "mignonette", "militarygrey", "mint", "mintcream", "mistyrose", "moccasin", "mocha", "mossgreen", "mulberry", "mustard", "natural", "navajowhite", "navy", "Nileblue", "Nilegreen", "oak", "oatmeal", "oceangrey", "ochre", "offwhite", "oldgold", "oldlace", "olivedrab", "olive", "orange", "orchid", "outerspace", "oxblood", "Oxfordblue", "oyster", "pansy", "paprika", "Parisgreen", "patina", "peagreen", "peach", "peacockblue", "pearlgray", "pearly", "periwinkle", "perse", "petrolblue", "petunia", "pewter", "pillarboxred", "pinegreen", "pink", "pistachiogreen", "platinumblond", "platinum", "plum", "Pompeianred", "poppy", "powderblue", "primrose", "Prussianblue", "puce", "puke", "purple", "purpure", "quartz", "quince", "raspberry", "rawsienna", "redviolet", "red", "reseda", "riflegreen", "robin_seggblue", "rose", "rouge", "royalblue", "royalpurple", "ruby", "russet", "rust", "sable", "saddlebrown", "safetyorange", "saffron", "sagegreen", "salmon", "sand", "sandy", "sanguine", "sapphire", "sard", "saxeblue", "scarlet", "schoolbusyellow", "seagreen", "seashell", "sepia", "shockingpink", "sienna", "silver", "silvergray", "skyblue", "slate", "slateblack", "slateblue", "slategray", "smoke", "snow", "sorrel", "springgreen", "stammel", "steelblue", "stone", "straw", "strawberry", "sulfur", "sunflower", "tan", "tangerine", "taupe", "taxiyellow", "teak", "teal", "terracotta", "timberwolf", "titian", "topaz", "towcolored", "Turkeyred", "turquoise", "Tyrianpurple", "ultramarine", "umber", "Vandykebrown", "venetianred", "verdant", "vermilion", "vert", "violetred", "violet", "virid", "viridian", "vividorange", "walnut", "Wedgewoodblue", "wheat", "wheaten", "white", "wine", "xanthic", "yellow", "zaffre"];
const expression = /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9][^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})/gi;
const url_regex = new RegExp(expression);
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function () {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}
function animalGenerator() {
  const randAnimal = arrAnimals[Math.floor(Math.random() * arrAnimals.length)].toLowerCase();
  return randAnimal;
}
function colourGenerator() {
  const randColour = arrColours[Math.floor(Math.random() * arrColours.length)].toLowerCase();
  return randColour;
}
function randId() {
  return Math.random().toString(36).substr(2, 5) + Date.now();
} // Deep clone

function _clone(aObject) {
  if (!aObject) {
    return aObject;
  }

  var bObject, v, k;
  bObject = Array.isArray(aObject) ? [] : {};

  for (k in aObject) {
    v = aObject[k];
    bObject[k] = typeof v === "object" ? _clone(v) : v;
  }

  return bObject;
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}
const Filters = {};

Filters.getPixels = function (canvas) {
  var c = canvas;
  var ctx = c.getContext("2d");
  return ctx.getImageData(0, 0, c.width, c.height);
};

Filters.filterImage = function (pixels, filter) {
  var args = [pixels];

  for (var i = 2; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  return filter.apply(null, args);
};

Filters.grayscale = function (pixels) {
  var d = pixels.data;

  for (var i = 0; i < d.length; i += 4) {
    var r = d[i];
    var g = d[i + 1];
    var b = d[i + 2]; // CIE luminance for the RGB
    // The human eye is bad at seeing red and blue, so we de-emphasize them.

    var v = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    d[i] = d[i + 1] = d[i + 2] = v;
  }

  return pixels;
};

Filters.brightness = function (pixels, offset, ratio) {
  var d = pixels.data;
  var v;

  for (var i = 0; i < d.length; i += 4) {
    v = parseInt((d[i] - offset) * ratio);

    if (v > 255) {
      v = 255;
    } else if (v < 0) {
      v = 0;
    }

    d[i] = v;
    d[i + 1] = v;
    d[i + 2] = v;
    d[i + 3] = 255; // fully opaque
  }

  return pixels;
};

Filters.min_max = function (pixels) {
  var d = pixels.data;
  var min = Number.POSITIVE_INFINITY,
      max = Number.NEGATIVE_INFINITY,
      avg = 0;

  for (var i = 0; i < d.length; i += 4) {
    if (d[i] < min) min = d[i];
    if (d[i] > max) max = d[i];
    avg += d[i] / (d.length / 4);
  }

  return {
    min: min,
    max: max,
    avg: avg
  };
};

Filters.lut = function (pixels, lut) {
  var d = pixels.data;
  var v;

  for (var i = 0; i < d.length; i += 4) {
    v = d[i];
    d[i] = lut[v][0];
    d[i + 1] = lut[v][1];
    d[i + 2] = lut[v][2];
    d[i + 3] = 255; // fully opaque
  }

  return pixels;
}; // from https://github.com/segmentio/is-url

/**
 * RegExps.
 * A URL must match #1 and then at least one of #2/#3.
 * Use two levels of REs to avoid REDOS.
 */


const protocolAndDomainRE = /^(?:\\w+:)?\\/\\/([\\s\\S]+)$/;
const localhostDomainRE = /^localhost[\\:?\\d]*(?:[^\\:?\\d][\\s\\S]*)?$/;
const nonLocalhostDomainRE = /^[^\\s\\.]+\\.[\\s\\S]{2,}$/;
/**
 * Loosely validate a URL \`string\`.
 *
 * @param {String} string
 * @return {Boolean}
 */

function isUrl(string) {
  if (typeof string !== "string") {
    return false;
  }

  var match = string.match(protocolAndDomainRE);

  if (!match) {
    return false;
  }

  var everythingAfterProtocol = match[1];

  if (!everythingAfterProtocol) {
    return false;
  }

  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
    return true;
  }

  return false;
} //from: https://github.com/github-modules/github-url-to-object/blob/master/index.js

const laxUrlRegex = /(?:(?:[^:]+:)?[/][/])?(?:.+@)?([^/]+)([/][^?#]+)/;
function githubUrlToObject(repoUrl, opts) {
  var obj = {};
  opts = opts || {};
  if (!repoUrl) return null; // Allow an object with nested \`url\` string
  // (common practice in package.json files)

  if (repoUrl.url) repoUrl = repoUrl.url;
  if (typeof repoUrl !== "string") return null;
  var shorthand = repoUrl.match(/^([\\w-_]+)\\/([\\w-_\\.]+)(?:#([\\w-_\\.]+))?$/);
  var mediumhand = repoUrl.match(/^github:([\\w-_]+)\\/([\\w-_\\.]+)(?:#([\\w-_\\.]+))?$/);
  var antiquated = repoUrl.match(/^git@[\\w-_\\.]+:([\\w-_]+)\\/([\\w-_\\.]+)$/);

  if (shorthand) {
    obj.user = shorthand[1];
    obj.repo = shorthand[2];
    obj.branch = shorthand[3] || "master";
    obj.host = "github.com";
  } else if (mediumhand) {
    obj.user = mediumhand[1];
    obj.repo = mediumhand[2];
    obj.branch = mediumhand[3] || "master";
    obj.host = "github.com";
  } else if (antiquated) {
    obj.user = antiquated[1];
    obj.repo = antiquated[2].replace(/\\.git$/i, "");
    obj.branch = "master";
    obj.host = "github.com";
  } else {
    // Turn git+http URLs into http URLs
    repoUrl = repoUrl.replace(/^git\\+/, "");
    if (!isUrl(repoUrl)) return null;
    const [, hostname, pathname] = repoUrl.match(laxUrlRegex) || [];
    if (!hostname) return null;
    if (hostname !== "github.com" && hostname !== "www.github.com" && !opts.enterprise) return null;
    var parts = pathname.match(/^\\/([\\w-_]+)\\/([\\w-_\\.]+)(\\/tree\\/[\\w-_\\.\\/]+)?(\\/blob\\/[\\s\\w-_\\.\\/]+)?/); // ([\\w-_\\.]+)

    if (!parts) return null;
    obj.user = parts[1];
    obj.repo = parts[2].replace(/\\.git$/i, "");
    obj.host = hostname || "github.com";

    if (parts[3] && /^\\/tree\\/master\\//.test(parts[3])) {
      obj.branch = "master";
      obj.path = parts[3].replace(/\\/$/, "");
    } else if (parts[3]) {
      obj.branch = parts[3].replace(/^\\/tree\\//, "").match(/[\\w-_.]+\\/{0,1}[\\w-_]+/)[0];
    } else if (parts[4]) {
      obj.branch = parts[4].replace(/^\\/blob\\//, "").match(/[\\w-_.]+\\/{0,1}[\\w-_]+/)[0];
    } else {
      obj.branch = "master";
    }
  }

  if (obj.host === "github.com") {
    obj.apiHost = "api.github.com";
  } else {
    obj.apiHost = \`\${obj.host}/api/v3\`;
  }

  obj.tarball_url = \`https://\${obj.apiHost}/repos/\${obj.user}/\${obj.repo}/tarball/\${obj.branch}\`;
  obj.clone_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}\`;

  if (obj.branch === "master") {
    obj.https_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}\`;
    obj.travis_url = \`https://travis-ci.org/\${obj.user}/\${obj.repo}\`;
    obj.zip_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}/archive/master.zip\`;
  } else {
    obj.https_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}/blob/\${obj.branch}\`;
    obj.travis_url = \`https://travis-ci.org/\${obj.user}/\${obj.repo}?branch=\${obj.branch}\`;
    obj.zip_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}/archive/\${obj.branch}.zip\`;
  } // Support deep paths (like lerna-style repos)


  if (obj.path) {
    obj.https_url += obj.path;
  }

  obj.api_url = \`https://\${obj.apiHost}/repos/\${obj.user}/\${obj.repo}\`;
  return obj;
} // from: https://github.com/Elixirdoc/github-url-raw

async function githubUrlRaw(url) {
  if (url.includes("gist.github.com")) {
    const gistId = url.split("/").slice(-1)[0];
    const response = await axios__WEBPACK_IMPORTED_MODULE_0___default.a.get("https://api.github.com/gists/" + gistId);

    if (response.status === 200) {
      // TODO: handle multiple files, e.g.: display them all
      const plugin_file = Object.values(response.data.files).filter(file => {
        return file.filename.endsWith(".imjoy.html");
      })[0];
      return plugin_file.raw_url;
    } else {
      throw "Failed to fetch from Gist: " + response.statusText;
    }
  }

  if (!url.includes("blob") || !url.includes("github")) {
    return null;
  }

  var ghObj = githubUrlToObject(url);
  var githubUser = ghObj.user;
  var githubRepo = ghObj.repo; // var githubBranch = ghObj.branch;

  var re = new RegExp("^https://github.com/" + githubUser + "/" + githubRepo + "/blob/", "g");
  var regStr = url.replace(re, "");
  return "https://raw.githubusercontent.com/" + githubUser + "/" + githubRepo + "/" + regStr;
}
function githubImJoyManifest(url) {
  var ghObj = githubUrlToObject(url);
  var githubUser = ghObj.user;
  var githubRepo = ghObj.repo;
  var githubBranch = ghObj.branch;
  return "https://raw.githubusercontent.com/" + githubUser + "/" + githubRepo + "/" + githubBranch + "/manifest.imjoy.json";
}
function githubRepo(url) {
  var ghObj = githubUrlToObject(url);
  return ghObj.user + "/" + ghObj.repo;
}
const hot_lut = [[10, 0, 0], [13, 0, 0], [15, 0, 0], [18, 0, 0], [21, 0, 0], [23, 0, 0], [26, 0, 0], [28, 0, 0], [31, 0, 0], [34, 0, 0], [36, 0, 0], [39, 0, 0], [42, 0, 0], [44, 0, 0], [47, 0, 0], [49, 0, 0], [52, 0, 0], [55, 0, 0], [57, 0, 0], [60, 0, 0], [63, 0, 0], [65, 0, 0], [68, 0, 0], [70, 0, 0], [73, 0, 0], [76, 0, 0], [78, 0, 0], [81, 0, 0], [84, 0, 0], [86, 0, 0], [89, 0, 0], [91, 0, 0], [94, 0, 0], [97, 0, 0], [99, 0, 0], [102, 0, 0], [105, 0, 0], [107, 0, 0], [110, 0, 0], [112, 0, 0], [115, 0, 0], [118, 0, 0], [120, 0, 0], [123, 0, 0], [126, 0, 0], [128, 0, 0], [131, 0, 0], [133, 0, 0], [136, 0, 0], [139, 0, 0], [141, 0, 0], [144, 0, 0], [147, 0, 0], [149, 0, 0], [152, 0, 0], [154, 0, 0], [157, 0, 0], [160, 0, 0], [162, 0, 0], [165, 0, 0], [168, 0, 0], [170, 0, 0], [173, 0, 0], [175, 0, 0], [178, 0, 0], [181, 0, 0], [183, 0, 0], [186, 0, 0], [189, 0, 0], [191, 0, 0], [194, 0, 0], [196, 0, 0], [199, 0, 0], [202, 0, 0], [204, 0, 0], [207, 0, 0], [210, 0, 0], [212, 0, 0], [215, 0, 0], [217, 0, 0], [220, 0, 0], [223, 0, 0], [225, 0, 0], [228, 0, 0], [231, 0, 0], [233, 0, 0], [236, 0, 0], [238, 0, 0], [241, 0, 0], [244, 0, 0], [246, 0, 0], [249, 0, 0], [252, 0, 0], [254, 0, 0], [255, 2, 0], [255, 5, 0], [255, 7, 0], [255, 10, 0], [255, 12, 0], [255, 15, 0], [255, 18, 0], [255, 20, 0], [255, 23, 0], [255, 26, 0], [255, 28, 0], [255, 31, 0], [255, 33, 0], [255, 36, 0], [255, 39, 0], [255, 41, 0], [255, 44, 0], [255, 47, 0], [255, 49, 0], [255, 52, 0], [255, 54, 0], [255, 57, 0], [255, 60, 0], [255, 62, 0], [255, 65, 0], [255, 68, 0], [255, 70, 0], [255, 73, 0], [255, 75, 0], [255, 78, 0], [255, 81, 0], [255, 83, 0], [255, 86, 0], [255, 89, 0], [255, 91, 0], [255, 94, 0], [255, 96, 0], [255, 99, 0], [255, 102, 0], [255, 104, 0], [255, 107, 0], [255, 110, 0], [255, 112, 0], [255, 115, 0], [255, 117, 0], [255, 120, 0], [255, 123, 0], [255, 125, 0], [255, 128, 0], [255, 131, 0], [255, 133, 0], [255, 136, 0], [255, 138, 0], [255, 141, 0], [255, 144, 0], [255, 146, 0], [255, 149, 0], [255, 151, 0], [255, 154, 0], [255, 157, 0], [255, 159, 0], [255, 162, 0], [255, 165, 0], [255, 167, 0], [255, 170, 0], [255, 172, 0], [255, 175, 0], [255, 178, 0], [255, 180, 0], [255, 183, 0], [255, 186, 0], [255, 188, 0], [255, 191, 0], [255, 193, 0], [255, 196, 0], [255, 199, 0], [255, 201, 0], [255, 204, 0], [255, 207, 0], [255, 209, 0], [255, 212, 0], [255, 214, 0], [255, 217, 0], [255, 220, 0], [255, 222, 0], [255, 225, 0], [255, 228, 0], [255, 230, 0], [255, 233, 0], [255, 235, 0], [255, 238, 0], [255, 241, 0], [255, 243, 0], [255, 246, 0], [255, 249, 0], [255, 251, 0], [255, 254, 0], [255, 255, 2], [255, 255, 6], [255, 255, 10], [255, 255, 14], [255, 255, 18], [255, 255, 22], [255, 255, 26], [255, 255, 30], [255, 255, 34], [255, 255, 38], [255, 255, 42], [255, 255, 46], [255, 255, 50], [255, 255, 54], [255, 255, 58], [255, 255, 62], [255, 255, 65], [255, 255, 69], [255, 255, 73], [255, 255, 77], [255, 255, 81], [255, 255, 85], [255, 255, 89], [255, 255, 93], [255, 255, 97], [255, 255, 101], [255, 255, 105], [255, 255, 109], [255, 255, 113], [255, 255, 117], [255, 255, 121], [255, 255, 125], [255, 255, 128], [255, 255, 132], [255, 255, 136], [255, 255, 140], [255, 255, 144], [255, 255, 148], [255, 255, 152], [255, 255, 156], [255, 255, 160], [255, 255, 164], [255, 255, 168], [255, 255, 172], [255, 255, 176], [255, 255, 180], [255, 255, 184], [255, 255, 188], [255, 255, 191], [255, 255, 195], [255, 255, 199], [255, 255, 203], [255, 255, 207], [255, 255, 211], [255, 255, 215], [255, 255, 219], [255, 255, 223], [255, 255, 227], [255, 255, 231], [255, 255, 235], [255, 255, 239], [255, 255, 243], [255, 255, 247], [255, 255, 251], [255, 255, 255]];

//# sourceURL=webpack://%5Bname%5D/./src/utils.js?`)},"./src/windowManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindowManager", function() { return WindowManager; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");

class WindowManager {
  constructor({
    event_bus = null
  }) {
    this.event_bus = event_bus;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.event_bus);
    this.windows = [];
    this.window_ids = {};
    this.active_windows = [];
    this.selected_window = null;
    this.window_mode = "grid";
    this.registered_inputs = {};
    this.registered_loaders = {};
    this.default_window_pos = {
      x: 0,
      y: 0,
      w: 20,
      h: 10,
      index: 0
    };
  }

  generateGridPosition(config) {
    config.i = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    config.index = this.default_window_pos.index;
    config.w = config.w || this.default_window_pos.w;
    config.h = config.h || this.default_window_pos.h;

    if (config.x === undefined) {
      config.x = this.default_window_pos.x;
      this.default_window_pos.x = this.default_window_pos.x + this.default_window_pos.w;
    }

    if (config.y === undefined) {
      config.y = this.default_window_pos.y;
    }

    if (this.default_window_pos.x >= 20) {
      this.default_window_pos.x = 0;
      this.default_window_pos.y = this.default_window_pos.y + this.default_window_pos.h;
    }

    this.default_window_pos.index = this.default_window_pos.index + 1;
  }

  registerInputLoader(op_key, inputs, loader) {
    if (this.registered_inputs[op_key]) console.log(\`WARNING: input loader \${op_key} already exists, it will be replaced.\`);
    this.registered_inputs[op_key] = inputs;
    this.registered_loaders[op_key] = loader;
  }

  unregisterInputLoader(op_key) {
    delete this.registered_inputs[op_key];
    delete this.registered_loaders[op_key];
  }

  getDataLoaders(data) {
    const loaders = {}; // find all the plugins registered for this type

    for (let k in this.registered_inputs) {
      if (this.registered_inputs[k].loader_key && this.registered_inputs[k].schema(data)) {
        try {
          const loader_key = this.registered_inputs[k].loader_key;

          if (this.registered_loaders[loader_key]) {
            loaders[loader_key] = this.registered_loaders[loader_key];
          }
        } catch (e) {
          console.error("Failed to get loaders.", e);
        }
      }
    }

    return loaders;
  }

  closeWindow(w) {
    const index = this.windows.indexOf(w);

    if (index > -1) {
      this.windows.splice(index, 1);
      delete this.window_ids[w.id];
    }

    if (w.selected || this.selected_window === w) {
      w.selected = false;

      if (this.window_mode === "single") {
        this.selected_window = this.windows[0];
      } else {
        this.selected_window = null;
      }
    }

    this.event_bus.emit("close_window", w);
  }

  setupCallbacks(w) {
    w._callbacks = w._callbacks || {};
    w.api = w.api || {};

    w.api.on = (name, handler, fire_if_emitted) => {
      if (w._callbacks[name]) {
        w._callbacks[name].push(handler);
      } else {
        w._callbacks[name] = [handler];
      }

      if (fire_if_emitted && w._callbacks[name].emitted) {
        handler(w._callbacks[name].emitted_data);
      }
    };

    w.api.off = (name, handler) => {
      if (w._callbacks[name]) {
        if (handler) {
          const handlers = w._callbacks[name];
          const idx = handlers.indexOf(handler);

          if (idx >= 0) {
            handlers.splice(idx, 1);
          } else {
            console.warn(\`callback \${name} does not exist.\`);
          }
        } else {
          delete w._callbacks[name];
        }
      } else {
        console.warn(\`callback \${name} does not exist.\`);
      }
    };

    w.api.emit = (name, data) => {
      // eslint-disable-next-line no-async-promise-executor
      return new Promise(async (resolve, reject) => {
        const errors = [];

        try {
          if (w._callbacks[name]) {
            for (let cb of w._callbacks[name]) {
              try {
                await cb(data !== undefined ? data : undefined);
              } catch (e) {
                errors.push(e);
                console.error(e);
              }
            }
          } else {
            // if no handler set, store the data
            w._callbacks[name] = [];
            w._callbacks[name].emitted = true;
            w._callbacks[name].emitted_data = data;
          }

          if (errors.length <= 0) {
            resolve();
          } else {
            reject(errors);
          }
        } catch (e) {
          reject(e);
        }
      });
    };

    w._refresh_callbacks = [];

    w.api.refresh = w.refresh = async () => {
      await Promise.all(w._refresh_callbacks.map(item => item()));
    };

    w._resize_callbacks = [];

    w.api.resize = w.resize = async contentRect => {
      contentRect = contentRect || w.$el && w.$el.getBoundingClientRect();
      w.api.emit("resize", contentRect);
    };

    w.api.focus = w.focus = () => {
      w.api.emit("focus");
    };

    w.api.show = w.show = () => {
      this.selectWindow(w);
      w.api.emit("show");
    };

    w.api.hide = w.hide = () => {
      w.api.emit("hide");
    };

    w.api.close = w.close = () => {
      return new Promise(resolve => {
        w.api.emit("close"); // leave 800ms for handling close events

        setTimeout(() => {
          this.closeWindow(w);
          resolve();
        }, 800);
      });
    };
  }

  addWindow(w) {
    return new Promise((resolve, reject) => {
      try {
        w.id = w.id || w.name + Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
        if (!w.dialog) this.generateGridPosition(w);

        if (w.standalone) {
          w.h = 0;
          w.w = 0;
        }

        if (this.window_ids[w.id]) {
          this.windows.splice(this.windows.indexOf(this.window_ids[w.id]), 1);
        }

        this.windows.push(w);
        this.window_ids[w.id] = w;
        this.setupCallbacks(w);
        this.selectWindow(w);
        this.event_bus.emit("add_window", w);
        let checkingTimer = null;
        let count = 40;

        const checkWindowReady = function () {
          const window_id = document.getElementById(w.window_id);

          if (window_id) {
            clearInterval(checkingTimer);
            resolve(w.id);
          }

          if (count-- < 0) {
            clearInterval(checkingTimer);
            reject(\`Failed to create window (element with id=\${w.window_id} not detected in 2s).\`);
          }
        };

        checkingTimer = setInterval(checkWindowReady, 50); //hack for testing

        if (w.__test__mode__) {
          w.api.emit("ready");
        }
      } catch (e) {
        reject(e);
      }
    });
  }

  selectWindow(w) {
    if (!w) return;

    if (w.dialog) {
      w.selected = true;
      this.active_windows = [w];
    } else {
      for (let i = 0; i < this.active_windows.length; i++) {
        if (this.active_windows[i]) {
          this.active_windows[i].selected = false;
          this.active_windows[i].refresh();
        }
      }

      if (this.window_mode === "single" || w.standalone) {
        this.selected_window = w;
      } else {
        this.selected_window = null;
      }

      this.active_windows = [w];
      if (!w.standalone && w.focus) w.focus();
    }

    w.selected = true;

    if (w.refresh) {
      w.refresh();
    }
  }

  resizeAll() {
    for (var i = this.windows.length; i--;) {
      try {
        this.windows[i].resize();
      } catch (e) {}
    }
  }

  closeAll() {
    const current_index = this.default_window_pos && this.default_window_pos.index || 0;
    this.default_window_pos = {
      i: 0,
      x: 0,
      y: 0,
      w: 20,
      h: 10,
      index: current_index
    };
    this.status_text = "";

    for (var i = this.windows.length; i--;) {
      if (this.windows[i].type != "imjoy/plugin-editor") {
        // delete this.window_ids[this.windows[i].id]
        // this.windows.splice(i, 1);
        this.windows[i].close();
      }
    }

    if (this.windows.length === 0) {
      this.default_window_pos.index = 0;
    } //this.event_bus.emit('close_window')

  }

  destroy() {
    this.disconnect();
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/windowManager.js?`)},0:function(module,exports){eval(`/* (ignored) */

//# sourceURL=webpack://%5Bname%5D/./nextTick_(ignored)?`)}})})})(imjoyCore$1);var imjoyCoreExports=imjoyCore$1.exports,imjoyCore=imjoyCoreExports;function _createForOfIteratorHelper$1(n,t){var r=typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(!r){if(Array.isArray(n)||(r=_unsupportedIterableToArray$2$1(n))||t&&n&&typeof n.length=="number"){r&&(n=r);var i=0,s=function(){};return{s,n:function(){return i>=n.length?{done:!0}:{done:!1,value:n[i++]}},e:function(_){throw _},f:s}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var o=!0,l=!1,f;return{s:function(){r=r.call(n)},n:function(){var _=r.next();return o=_.done,_},e:function(_){l=!0,f=_},f:function(){try{!o&&r.return!=null&&r.return()}finally{if(l)throw f}}}}function _toConsumableArray$2$1(n){return _arrayWithoutHoles$2$1(n)||_iterableToArray$2$1(n)||_unsupportedIterableToArray$2$1(n)||_nonIterableSpread$2$1()}function _nonIterableSpread$2$1(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _iterableToArray$2$1(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function _arrayWithoutHoles$2$1(n){if(Array.isArray(n))return _arrayLikeToArray$2$1(n)}function _typeof$2$1(n){"@babel/helpers - typeof";return _typeof$2$1=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$2$1(n)}function _slicedToArray$1$1(n,t){return _arrayWithHoles$1$1(n)||_iterableToArrayLimit$1$1(n,t)||_unsupportedIterableToArray$2$1(n,t)||_nonIterableRest$1$1()}function _nonIterableRest$1$1(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$2$1(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$2$1(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$2$1(n,t)}}function _arrayLikeToArray$2$1(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}function _iterableToArrayLimit$1$1(n,t){var r=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(r!=null){var i,s,o,l,f=[],u=!0,_=!1;try{if(o=(r=r.call(n)).next,t===0){if(Object(r)!==r)return;u=!1}else for(;!(u=(i=o.call(r)).done)&&(f.push(i.value),f.length!==t);u=!0);}catch(g){_=!0,s=g}finally{try{if(!u&&r.return!=null&&(l=r.return(),Object(l)!==l))return}finally{if(_)throw s}}return f}}function _arrayWithHoles$1$1(n){if(Array.isArray(n))return n}var DomHandler={innerWidth:function n(t){if(t){var r=t.offsetWidth,i=getComputedStyle(t);return r+=parseFloat(i.paddingLeft)+parseFloat(i.paddingRight),r}return 0},width:function n(t){if(t){var r=t.offsetWidth,i=getComputedStyle(t);return r-=parseFloat(i.paddingLeft)+parseFloat(i.paddingRight),r}return 0},getWindowScrollTop:function n(){var t=document.documentElement;return(window.pageYOffset||t.scrollTop)-(t.clientTop||0)},getWindowScrollLeft:function n(){var t=document.documentElement;return(window.pageXOffset||t.scrollLeft)-(t.clientLeft||0)},getOuterWidth:function n(t,r){if(t){var i=t.offsetWidth;if(r){var s=getComputedStyle(t);i+=parseFloat(s.marginLeft)+parseFloat(s.marginRight)}return i}return 0},getOuterHeight:function n(t,r){if(t){var i=t.offsetHeight;if(r){var s=getComputedStyle(t);i+=parseFloat(s.marginTop)+parseFloat(s.marginBottom)}return i}return 0},getClientHeight:function n(t,r){if(t){var i=t.clientHeight;if(r){var s=getComputedStyle(t);i+=parseFloat(s.marginTop)+parseFloat(s.marginBottom)}return i}return 0},getViewport:function n(){var t=window,r=document,i=r.documentElement,s=r.getElementsByTagName("body")[0],o=t.innerWidth||i.clientWidth||s.clientWidth,l=t.innerHeight||i.clientHeight||s.clientHeight;return{width:o,height:l}},getOffset:function n(t){if(t){var r=t.getBoundingClientRect();return{top:r.top+(window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0),left:r.left+(window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0)}}return{top:"auto",left:"auto"}},index:function n(t){if(t)for(var r=t.parentNode.childNodes,i=0,s=0;s<r.length;s++){if(r[s]===t)return i;r[s].nodeType===1&&i++}return-1},addMultipleClasses:function n(t,r){var i=this;t&&r&&[r].flat().filter(Boolean).forEach(function(s){return s.split(" ").forEach(function(o){return i.addClass(t,o)})})},removeMultipleClasses:function n(t,r){var i=this;t&&r&&[r].flat().filter(Boolean).forEach(function(s){return s.split(" ").forEach(function(o){return i.removeClass(t,o)})})},addClass:function n(t,r){t&&r&&!this.hasClass(t,r)&&(t.classList?t.classList.add(r):t.className+=" "+r)},removeClass:function n(t,r){t&&r&&(t.classList?t.classList.remove(r):t.className=t.className.replace(new RegExp("(^|\\b)"+r.split(" ").join("|")+"(\\b|$)","gi")," "))},hasClass:function n(t,r){return t?t.classList?t.classList.contains(r):new RegExp("(^| )"+r+"( |$)","gi").test(t.className):!1},addStyles:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};t&&Object.entries(r).forEach(function(i){var s=_slicedToArray$1$1(i,2),o=s[0],l=s[1];return t.style[o]=l})},find:function n(t,r){return this.isElement(t)?t.querySelectorAll(r):[]},findSingle:function n(t,r){return this.isElement(t)?t.querySelector(r):null},createElement:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(t){var i=document.createElement(t);this.setAttributes(i,r);for(var s=arguments.length,o=new Array(s>2?s-2:0),l=2;l<s;l++)o[l-2]=arguments[l];return i.append.apply(i,o),i}},setAttribute:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",i=arguments.length>2?arguments[2]:void 0;this.isElement(t)&&i!==null&&i!==void 0&&t.setAttribute(r,i)},setAttributes:function n(t){var r=this,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(this.isElement(t)){var s=function o(l,f){var u,_,g=t!=null&&(u=t.$attrs)!==null&&u!==void 0&&u[l]?[t==null||(_=t.$attrs)===null||_===void 0?void 0:_[l]]:[];return[f].flat().reduce(function(a,m){if(m!=null){var b=_typeof$2$1(m);if(b==="string"||b==="number")a.push(m);else if(b==="object"){var v=Array.isArray(m)?o(l,m):Object.entries(m).map(function(c){var w=_slicedToArray$1$1(c,2),k=w[0],x=w[1];return l==="style"&&(x||x===0)?"".concat(k.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),":").concat(x):x?k:void 0});a=v.length?a.concat(v.filter(function(c){return!!c})):a}}return a},g)};Object.entries(i).forEach(function(o){var l=_slicedToArray$1$1(o,2),f=l[0],u=l[1];if(u!=null){var _=f.match(/^on(.+)/);_?t.addEventListener(_[1].toLowerCase(),u):f==="p-bind"?r.setAttributes(t,u):(u=f==="class"?_toConsumableArray$2$1(new Set(s("class",u))).join(" ").trim():f==="style"?s("style",u).join(";").trim():u,(t.$attrs=t.$attrs||{})&&(t.$attrs[f]=u),t.setAttribute(f,u))}})}},getAttribute:function n(t,r){if(this.isElement(t)){var i=t.getAttribute(r);return isNaN(i)?i==="true"||i==="false"?i==="true":i:+i}},isAttributeEquals:function n(t,r,i){return this.isElement(t)?this.getAttribute(t,r)===i:!1},isAttributeNotEquals:function n(t,r,i){return!this.isAttributeEquals(t,r,i)},getHeight:function n(t){if(t){var r=t.offsetHeight,i=getComputedStyle(t);return r-=parseFloat(i.paddingTop)+parseFloat(i.paddingBottom)+parseFloat(i.borderTopWidth)+parseFloat(i.borderBottomWidth),r}return 0},getWidth:function n(t){if(t){var r=t.offsetWidth,i=getComputedStyle(t);return r-=parseFloat(i.paddingLeft)+parseFloat(i.paddingRight)+parseFloat(i.borderLeftWidth)+parseFloat(i.borderRightWidth),r}return 0},absolutePosition:function n(t,r){if(t){var i=t.offsetParent?{width:t.offsetWidth,height:t.offsetHeight}:this.getHiddenElementDimensions(t),s=i.height,o=i.width,l=r.offsetHeight,f=r.offsetWidth,u=r.getBoundingClientRect(),_=this.getWindowScrollTop(),g=this.getWindowScrollLeft(),a=this.getViewport(),m,b;u.top+l+s>a.height?(m=u.top+_-s,t.style.transformOrigin="bottom",m<0&&(m=_)):(m=l+u.top+_,t.style.transformOrigin="top"),u.left+o>a.width?b=Math.max(0,u.left+g+f-o):b=u.left+g,t.style.top=m+"px",t.style.left=b+"px"}},relativePosition:function n(t,r){if(t){var i=t.offsetParent?{width:t.offsetWidth,height:t.offsetHeight}:this.getHiddenElementDimensions(t),s=r.offsetHeight,o=r.getBoundingClientRect(),l=this.getViewport(),f,u;o.top+s+i.height>l.height?(f=-1*i.height,t.style.transformOrigin="bottom",o.top+f<0&&(f=-1*o.top)):(f=s,t.style.transformOrigin="top"),i.width>l.width?u=o.left*-1:o.left+i.width>l.width?u=(o.left+i.width-l.width)*-1:u=0,t.style.top=f+"px",t.style.left=u+"px"}},nestedPosition:function n(t,r){if(t){var i=t.parentElement,s=this.getOffset(i),o=this.getViewport(),l=t.offsetParent?t.offsetWidth:this.getHiddenElementOuterWidth(t),f=this.getOuterWidth(i.children[0]),u;parseInt(s.left,10)+f+l>o.width-this.calculateScrollbarWidth()?parseInt(s.left,10)<l?r%2===1?u=parseInt(s.left,10)?"-"+parseInt(s.left,10)+"px":"100%":r%2===0&&(u=o.width-l-this.calculateScrollbarWidth()+"px"):u="-100%":u="100%",t.style.top="0px",t.style.left=u}},getParents:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];return t.parentNode===null?r:this.getParents(t.parentNode,r.concat([t.parentNode]))},getScrollableParents:function n(t){var r=[];if(t){var i=this.getParents(t),s=/(auto|scroll)/,o=function(w){try{var k=window.getComputedStyle(w,null);return s.test(k.getPropertyValue("overflow"))||s.test(k.getPropertyValue("overflowX"))||s.test(k.getPropertyValue("overflowY"))}catch{return!1}},l=_createForOfIteratorHelper$1(i),f;try{for(l.s();!(f=l.n()).done;){var u=f.value,_=u.nodeType===1&&u.dataset.scrollselectors;if(_){var g=_.split(","),a=_createForOfIteratorHelper$1(g),m;try{for(a.s();!(m=a.n()).done;){var b=m.value,v=this.findSingle(u,b);v&&o(v)&&r.push(v)}}catch(c){a.e(c)}finally{a.f()}}u.nodeType!==9&&o(u)&&r.push(u)}}catch(c){l.e(c)}finally{l.f()}}return r},getHiddenElementOuterHeight:function n(t){if(t){t.style.visibility="hidden",t.style.display="block";var r=t.offsetHeight;return t.style.display="none",t.style.visibility="visible",r}return 0},getHiddenElementOuterWidth:function n(t){if(t){t.style.visibility="hidden",t.style.display="block";var r=t.offsetWidth;return t.style.display="none",t.style.visibility="visible",r}return 0},getHiddenElementDimensions:function n(t){if(t){var r={};return t.style.visibility="hidden",t.style.display="block",r.width=t.offsetWidth,r.height=t.offsetHeight,t.style.display="none",t.style.visibility="visible",r}return 0},fadeIn:function n(t,r){if(t){t.style.opacity=0;var i=+new Date,s=0,o=function l(){s=+t.style.opacity+(new Date().getTime()-i)/r,t.style.opacity=s,i=+new Date,+s<1&&(window.requestAnimationFrame&&requestAnimationFrame(l)||setTimeout(l,16))};o()}},fadeOut:function n(t,r){if(t)var i=1,s=50,o=r,l=s/o,f=setInterval(function(){i-=l,i<=0&&(i=0,clearInterval(f)),t.style.opacity=i},s)},getUserAgent:function n(){return navigator.userAgent},appendChild:function n(t,r){if(this.isElement(r))r.appendChild(t);else if(r.el&&r.elElement)r.elElement.appendChild(t);else throw new Error("Cannot append "+r+" to "+t)},isElement:function n(t){return(typeof HTMLElement>"u"?"undefined":_typeof$2$1(HTMLElement))==="object"?t instanceof HTMLElement:t&&_typeof$2$1(t)==="object"&&t!==null&&t.nodeType===1&&typeof t.nodeName=="string"},scrollInView:function n(t,r){var i=getComputedStyle(t).getPropertyValue("borderTopWidth"),s=i?parseFloat(i):0,o=getComputedStyle(t).getPropertyValue("paddingTop"),l=o?parseFloat(o):0,f=t.getBoundingClientRect(),u=r.getBoundingClientRect(),_=u.top+document.body.scrollTop-(f.top+document.body.scrollTop)-s-l,g=t.scrollTop,a=t.clientHeight,m=this.getOuterHeight(r);_<0?t.scrollTop=g+_:_+m>a&&(t.scrollTop=g+_-a+m)},clearSelection:function n(){if(window.getSelection)window.getSelection().empty?window.getSelection().empty():window.getSelection().removeAllRanges&&window.getSelection().rangeCount>0&&window.getSelection().getRangeAt(0).getClientRects().length>0&&window.getSelection().removeAllRanges();else if(document.selection&&document.selection.empty)try{document.selection.empty()}catch{}},getSelection:function n(){return window.getSelection?window.getSelection().toString():document.getSelection?document.getSelection().toString():document.selection?document.selection.createRange().text:null},calculateScrollbarWidth:function n(){if(this.calculatedScrollbarWidth!=null)return this.calculatedScrollbarWidth;var t=document.createElement("div");this.addStyles(t,{width:"100px",height:"100px",overflow:"scroll",position:"absolute",top:"-9999px"}),document.body.appendChild(t);var r=t.offsetWidth-t.clientWidth;return document.body.removeChild(t),this.calculatedScrollbarWidth=r,r},calculateBodyScrollbarWidth:function n(){return window.innerWidth-document.documentElement.offsetWidth},getBrowser:function n(){if(!this.browser){var t=this.resolveUserAgent();this.browser={},t.browser&&(this.browser[t.browser]=!0,this.browser.version=t.version),this.browser.chrome?this.browser.webkit=!0:this.browser.webkit&&(this.browser.safari=!0)}return this.browser},resolveUserAgent:function n(){var t=navigator.userAgent.toLowerCase(),r=/(chrome)[ ]([\w.]+)/.exec(t)||/(webkit)[ ]([\w.]+)/.exec(t)||/(opera)(?:.*version|)[ ]([\w.]+)/.exec(t)||/(msie) ([\w.]+)/.exec(t)||t.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(t)||[];return{browser:r[1]||"",version:r[2]||"0"}},isVisible:function n(t){return t&&t.offsetParent!=null},invokeElementMethod:function n(t,r,i){t[r].apply(t,i)},isExist:function n(t){return!!(t!==null&&typeof t<"u"&&t.nodeName&&t.parentNode)},isClient:function n(){return!!(typeof window<"u"&&window.document&&window.document.createElement)},focus:function n(t,r){t&&document.activeElement!==t&&t.focus(r)},isFocusableElement:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"";return this.isElement(t)?t.matches('button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])'.concat(r,`,
                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r)):!1},getFocusableElements:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",i=this.find(t,'button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])'.concat(r,`,
                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r,`,
                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r)),s=[],o=_createForOfIteratorHelper$1(i),l;try{for(o.s();!(l=o.n()).done;){var f=l.value;getComputedStyle(f).display!="none"&&getComputedStyle(f).visibility!="hidden"&&s.push(f)}}catch(u){o.e(u)}finally{o.f()}return s},getFirstFocusableElement:function n(t,r){var i=this.getFocusableElements(t,r);return i.length>0?i[0]:null},getLastFocusableElement:function n(t,r){var i=this.getFocusableElements(t,r);return i.length>0?i[i.length-1]:null},getNextFocusableElement:function n(t,r,i){var s=this.getFocusableElements(t,i),o=s.length>0?s.findIndex(function(f){return f===r}):-1,l=o>-1&&s.length>=o+1?o+1:-1;return l>-1?s[l]:null},getPreviousElementSibling:function n(t,r){for(var i=t.previousElementSibling;i;){if(i.matches(r))return i;i=i.previousElementSibling}return null},getNextElementSibling:function n(t,r){for(var i=t.nextElementSibling;i;){if(i.matches(r))return i;i=i.nextElementSibling}return null},isClickable:function n(t){if(t){var r=t.nodeName,i=t.parentElement&&t.parentElement.nodeName;return r==="INPUT"||r==="TEXTAREA"||r==="BUTTON"||r==="A"||i==="INPUT"||i==="TEXTAREA"||i==="BUTTON"||i==="A"||!!t.closest(".p-button, .p-checkbox, .p-radiobutton")}return!1},applyStyle:function n(t,r){if(typeof r=="string")t.style.cssText=r;else for(var i in r)t.style[i]=r[i]},isIOS:function n(){return/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream},isAndroid:function n(){return/(android)/i.test(navigator.userAgent)},isTouchDevice:function n(){return"ontouchstart"in window||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0},hasCSSAnimation:function n(t){if(t){var r=getComputedStyle(t),i=parseFloat(r.getPropertyValue("animation-duration")||"0");return i>0}return!1},hasCSSTransition:function n(t){if(t){var r=getComputedStyle(t),i=parseFloat(r.getPropertyValue("transition-duration")||"0");return i>0}return!1},exportCSV:function n(t,r){var i=new Blob([t],{type:"application/csv;charset=utf-8;"});if(window.navigator.msSaveOrOpenBlob)navigator.msSaveOrOpenBlob(i,r+".csv");else{var s=document.createElement("a");s.download!==void 0?(s.setAttribute("href",URL.createObjectURL(i)),s.setAttribute("download",r+".csv"),s.style.display="none",document.body.appendChild(s),s.click(),document.body.removeChild(s)):(t="data:text/csv;charset=utf-8,"+t,window.open(encodeURI(t)))}},blockBodyScroll:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"p-overflow-hidden";document.body.style.setProperty("--scrollbar-width",this.calculateBodyScrollbarWidth()+"px"),this.addClass(document.body,t)},unblockBodyScroll:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"p-overflow-hidden";document.body.style.removeProperty("--scrollbar-width"),this.removeClass(document.body,t)}};function _typeof$1$2(n){"@babel/helpers - typeof";return _typeof$1$2=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$1$2(n)}function _classCallCheck(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}function _defineProperties(n,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,_toPropertyKey$a(i.key),i)}}function _createClass(n,t,r){return t&&_defineProperties(n.prototype,t),r&&_defineProperties(n,r),Object.defineProperty(n,"prototype",{writable:!1}),n}function _toPropertyKey$a(n){var t=_toPrimitive$a(n,"string");return _typeof$1$2(t)==="symbol"?t:String(t)}function _toPrimitive$a(n,t){if(_typeof$1$2(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$1$2(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var ConnectedOverlayScrollHandler=function(){function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:function(){};_classCallCheck(this,n),this.element=t,this.listener=r}return _createClass(n,[{key:"bindScrollListener",value:function(){this.scrollableParents=DomHandler.getScrollableParents(this.element);for(var r=0;r<this.scrollableParents.length;r++)this.scrollableParents[r].addEventListener("scroll",this.listener)}},{key:"unbindScrollListener",value:function(){if(this.scrollableParents)for(var r=0;r<this.scrollableParents.length;r++)this.scrollableParents[r].removeEventListener("scroll",this.listener)}},{key:"destroy",value:function(){this.unbindScrollListener(),this.element=null,this.listener=null,this.scrollableParents=null}}]),n}();function primebus(){var n=new Map;return{on:function(r,i){var s=n.get(r);s?s.push(i):s=[i],n.set(r,s)},off:function(r,i){var s=n.get(r);s&&s.splice(s.indexOf(i)>>>0,1)},emit:function(r,i){var s=n.get(r);s&&s.slice().map(function(o){o(i)})}}}function _slicedToArray$2(n,t){return _arrayWithHoles$2(n)||_iterableToArrayLimit$2(n,t)||_unsupportedIterableToArray$1$1(n,t)||_nonIterableRest$2()}function _nonIterableRest$2(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _iterableToArrayLimit$2(n,t){var r=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(r!=null){var i,s,o,l,f=[],u=!0,_=!1;try{if(o=(r=r.call(n)).next,t===0){if(Object(r)!==r)return;u=!1}else for(;!(u=(i=o.call(r)).done)&&(f.push(i.value),f.length!==t);u=!0);}catch(g){_=!0,s=g}finally{try{if(!u&&r.return!=null&&(l=r.return(),Object(l)!==l))return}finally{if(_)throw s}}return f}}function _arrayWithHoles$2(n){if(Array.isArray(n))return n}function _toConsumableArray$1$1(n){return _arrayWithoutHoles$1$1(n)||_iterableToArray$1$1(n)||_unsupportedIterableToArray$1$1(n)||_nonIterableSpread$1$1()}function _nonIterableSpread$1$1(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _iterableToArray$1$1(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function _arrayWithoutHoles$1$1(n){if(Array.isArray(n))return _arrayLikeToArray$1$1(n)}function _createForOfIteratorHelper$2(n,t){var r=typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(!r){if(Array.isArray(n)||(r=_unsupportedIterableToArray$1$1(n))||t&&n&&typeof n.length=="number"){r&&(n=r);var i=0,s=function(){};return{s,n:function(){return i>=n.length?{done:!0}:{done:!1,value:n[i++]}},e:function(_){throw _},f:s}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var o=!0,l=!1,f;return{s:function(){r=r.call(n)},n:function(){var _=r.next();return o=_.done,_},e:function(_){l=!0,f=_},f:function(){try{!o&&r.return!=null&&r.return()}finally{if(l)throw f}}}}function _unsupportedIterableToArray$1$1(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$1$1(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$1$1(n,t)}}function _arrayLikeToArray$1$1(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}function _typeof$a(n){"@babel/helpers - typeof";return _typeof$a=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$a(n)}var ObjectUtils={equals:function n(t,r,i){return i?this.resolveFieldData(t,i)===this.resolveFieldData(r,i):this.deepEquals(t,r)},deepEquals:function n(t,r){if(t===r)return!0;if(t&&r&&_typeof$a(t)=="object"&&_typeof$a(r)=="object"){var i=Array.isArray(t),s=Array.isArray(r),o,l,f;if(i&&s){if(l=t.length,l!=r.length)return!1;for(o=l;o--!==0;)if(!this.deepEquals(t[o],r[o]))return!1;return!0}if(i!=s)return!1;var u=t instanceof Date,_=r instanceof Date;if(u!=_)return!1;if(u&&_)return t.getTime()==r.getTime();var g=t instanceof RegExp,a=r instanceof RegExp;if(g!=a)return!1;if(g&&a)return t.toString()==r.toString();var m=Object.keys(t);if(l=m.length,l!==Object.keys(r).length)return!1;for(o=l;o--!==0;)if(!Object.prototype.hasOwnProperty.call(r,m[o]))return!1;for(o=l;o--!==0;)if(f=m[o],!this.deepEquals(t[f],r[f]))return!1;return!0}return t!==t&&r!==r},resolveFieldData:function n(t,r){if(!t||!r)return null;try{var i=t[r];if(this.isNotEmpty(i))return i}catch{}if(Object.keys(t).length){if(this.isFunction(r))return r(t);if(r.indexOf(".")===-1)return t[r];for(var s=r.split("."),o=t,l=0,f=s.length;l<f;++l){if(o==null)return null;o=o[s[l]]}return o}return null},getItemValue:function n(t){for(var r=arguments.length,i=new Array(r>1?r-1:0),s=1;s<r;s++)i[s-1]=arguments[s];return this.isFunction(t)?t.apply(void 0,i):t},filter:function n(t,r,i){var s=[];if(t){var o=_createForOfIteratorHelper$2(t),l;try{for(o.s();!(l=o.n()).done;){var f=l.value,u=_createForOfIteratorHelper$2(r),_;try{for(u.s();!(_=u.n()).done;){var g=_.value;if(String(this.resolveFieldData(f,g)).toLowerCase().indexOf(i.toLowerCase())>-1){s.push(f);break}}}catch(a){u.e(a)}finally{u.f()}}}catch(a){o.e(a)}finally{o.f()}}return s},reorderArray:function n(t,r,i){t&&r!==i&&(i>=t.length&&(i%=t.length,r%=t.length),t.splice(i,0,t.splice(r,1)[0]))},findIndexInList:function n(t,r){var i=-1;if(r){for(var s=0;s<r.length;s++)if(r[s]===t){i=s;break}}return i},contains:function n(t,r){if(t!=null&&r&&r.length){var i=_createForOfIteratorHelper$2(r),s;try{for(i.s();!(s=i.n()).done;){var o=s.value;if(this.equals(t,o))return!0}}catch(l){i.e(l)}finally{i.f()}}return!1},insertIntoOrderedArray:function n(t,r,i,s){if(i.length>0){for(var o=!1,l=0;l<i.length;l++){var f=this.findIndexInList(i[l],s);if(f>r){i.splice(l,0,t),o=!0;break}}o||i.push(t)}else i.push(t)},removeAccents:function n(t){return t&&t.search(/[\xC0-\xFF]/g)>-1&&(t=t.replace(/[\xC0-\xC5]/g,"A").replace(/[\xC6]/g,"AE").replace(/[\xC7]/g,"C").replace(/[\xC8-\xCB]/g,"E").replace(/[\xCC-\xCF]/g,"I").replace(/[\xD0]/g,"D").replace(/[\xD1]/g,"N").replace(/[\xD2-\xD6\xD8]/g,"O").replace(/[\xD9-\xDC]/g,"U").replace(/[\xDD]/g,"Y").replace(/[\xDE]/g,"P").replace(/[\xE0-\xE5]/g,"a").replace(/[\xE6]/g,"ae").replace(/[\xE7]/g,"c").replace(/[\xE8-\xEB]/g,"e").replace(/[\xEC-\xEF]/g,"i").replace(/[\xF1]/g,"n").replace(/[\xF2-\xF6\xF8]/g,"o").replace(/[\xF9-\xFC]/g,"u").replace(/[\xFE]/g,"p").replace(/[\xFD\xFF]/g,"y")),t},getVNodeProp:function n(t,r){var i=t.props;if(i){var s=r.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),o=Object.prototype.hasOwnProperty.call(i,s)?s:r;return t.type.extends.props[r].type===Boolean&&i[o]===""?!0:i[o]}return null},toFlatCase:function n(t){return this.isString(t)?t.replace(/(-|_)/g,"").toLowerCase():t},toKebabCase:function n(t){return this.isString(t)?t.replace(/(_)/g,"-").replace(/[A-Z]/g,function(r,i){return i===0?r:"-"+r.toLowerCase()}).toLowerCase():t},toCapitalCase:function n(t){return this.isString(t,{empty:!1})?t[0].toUpperCase()+t.slice(1):t},isEmpty:function n(t){return t==null||t===""||Array.isArray(t)&&t.length===0||!(t instanceof Date)&&_typeof$a(t)==="object"&&Object.keys(t).length===0},isNotEmpty:function n(t){return!this.isEmpty(t)},isFunction:function n(t){return!!(t&&t.constructor&&t.call&&t.apply)},isObject:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return t instanceof Object&&t.constructor===Object&&(r||Object.keys(t).length!==0)},isDate:function n(t){return t instanceof Date&&t.constructor===Date},isArray:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return Array.isArray(t)&&(r||t.length!==0)},isString:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return typeof t=="string"&&(r||t!=="")},isPrintableCharacter:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"";return this.isNotEmpty(t)&&t.length===1&&t.match(/\S| /)},findLast:function n(t,r){var i;if(this.isNotEmpty(t))try{i=t.findLast(r)}catch{i=_toConsumableArray$1$1(t).reverse().find(r)}return i},findLastIndex:function n(t,r){var i=-1;if(this.isNotEmpty(t))try{i=t.findLastIndex(r)}catch{i=t.lastIndexOf(_toConsumableArray$1$1(t).reverse().find(r))}return i},sort:function n(t,r){var i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1,s=arguments.length>3?arguments[3]:void 0,o=arguments.length>4&&arguments[4]!==void 0?arguments[4]:1,l=this.compare(t,r,s,i),f=i;return(this.isEmpty(t)||this.isEmpty(r))&&(f=o===1?i:o),f*l},compare:function n(t,r,i){var s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:1,o=-1,l=this.isEmpty(t),f=this.isEmpty(r);return l&&f?o=0:l?o=s:f?o=-s:typeof t=="string"&&typeof r=="string"?o=i(t,r):o=t<r?-1:t>r?1:0,o},localeComparator:function n(){return new Intl.Collator(void 0,{numeric:!0}).compare},nestedKeys:function n(){var t=this,r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"";return Object.entries(r).reduce(function(s,o){var l=_slicedToArray$2(o,2),f=l[0],u=l[1],_=i?"".concat(i,".").concat(f):f;return t.isObject(u)?s=s.concat(t.nestedKeys(u,_)):s.push(_),s},[])}},lastId=0;function UniqueComponentId(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"pv_id_";return lastId++,"".concat(n).concat(lastId)}function _toConsumableArray$3(n){return _arrayWithoutHoles$3(n)||_iterableToArray$3(n)||_unsupportedIterableToArray$6(n)||_nonIterableSpread$3()}function _nonIterableSpread$3(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$6(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$6(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$6(n,t)}}function _iterableToArray$3(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function _arrayWithoutHoles$3(n){if(Array.isArray(n))return _arrayLikeToArray$6(n)}function _arrayLikeToArray$6(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}function handler(){var n=[],t=function(f,u){var _=arguments.length>2&&arguments[2]!==void 0?arguments[2]:999,g=s(f,u,_),a=g.value+(g.key===f?0:_)+1;return n.push({key:f,value:a}),a},r=function(f){n=n.filter(function(u){return u.value!==f})},i=function(f,u){return s(f,u).value},s=function(f,u){var _=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0;return _toConsumableArray$3(n).reverse().find(function(g){return u?!0:g.key===f})||{key:f,value:_}},o=function(f){return f&&parseInt(f.style.zIndex,10)||0};return{get:o,set:function(f,u,_){u&&(u.style.zIndex=String(t(f,!0,_)))},clear:function(f){f&&(r(o(f)),f.style.zIndex="")},getCurrent:function(f){return i(f,!0)}}}var ZIndexUtils=handler(),FilterMatchMode={STARTS_WITH:"startsWith",CONTAINS:"contains",NOT_CONTAINS:"notContains",ENDS_WITH:"endsWith",EQUALS:"equals",NOT_EQUALS:"notEquals",IN:"in",LESS_THAN:"lt",LESS_THAN_OR_EQUAL_TO:"lte",GREATER_THAN:"gt",GREATER_THAN_OR_EQUAL_TO:"gte",BETWEEN:"between",DATE_IS:"dateIs",DATE_IS_NOT:"dateIsNot",DATE_BEFORE:"dateBefore",DATE_AFTER:"dateAfter"};function _createForOfIteratorHelper(n,t){var r=typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(!r){if(Array.isArray(n)||(r=_unsupportedIterableToArray$5(n))||t&&n&&typeof n.length=="number"){r&&(n=r);var i=0,s=function(){};return{s,n:function(){return i>=n.length?{done:!0}:{done:!1,value:n[i++]}},e:function(_){throw _},f:s}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}var o=!0,l=!1,f;return{s:function(){r=r.call(n)},n:function(){var _=r.next();return o=_.done,_},e:function(_){l=!0,f=_},f:function(){try{!o&&r.return!=null&&r.return()}finally{if(l)throw f}}}}function _unsupportedIterableToArray$5(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$5(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$5(n,t)}}function _arrayLikeToArray$5(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}var FilterService={filter:function n(t,r,i,s,o){var l=[];if(!t)return l;var f=_createForOfIteratorHelper(t),u;try{for(f.s();!(u=f.n()).done;){var _=u.value;if(typeof _=="string"){if(this.filters[s](_,i,o)){l.push(_);continue}}else{var g=_createForOfIteratorHelper(r),a;try{for(g.s();!(a=g.n()).done;){var m=a.value,b=ObjectUtils.resolveFieldData(_,m);if(this.filters[s](b,i,o)){l.push(_);break}}}catch(v){g.e(v)}finally{g.f()}}}}catch(v){f.e(v)}finally{f.f()}return l},filters:{startsWith:function n(t,r,i){if(r==null||r.trim()==="")return!0;if(t==null)return!1;var s=ObjectUtils.removeAccents(r.toString()).toLocaleLowerCase(i),o=ObjectUtils.removeAccents(t.toString()).toLocaleLowerCase(i);return o.slice(0,s.length)===s},contains:function n(t,r,i){if(r==null||typeof r=="string"&&r.trim()==="")return!0;if(t==null)return!1;var s=ObjectUtils.removeAccents(r.toString()).toLocaleLowerCase(i),o=ObjectUtils.removeAccents(t.toString()).toLocaleLowerCase(i);return o.indexOf(s)!==-1},notContains:function n(t,r,i){if(r==null||typeof r=="string"&&r.trim()==="")return!0;if(t==null)return!1;var s=ObjectUtils.removeAccents(r.toString()).toLocaleLowerCase(i),o=ObjectUtils.removeAccents(t.toString()).toLocaleLowerCase(i);return o.indexOf(s)===-1},endsWith:function n(t,r,i){if(r==null||r.trim()==="")return!0;if(t==null)return!1;var s=ObjectUtils.removeAccents(r.toString()).toLocaleLowerCase(i),o=ObjectUtils.removeAccents(t.toString()).toLocaleLowerCase(i);return o.indexOf(s,o.length-s.length)!==-1},equals:function n(t,r,i){return r==null||typeof r=="string"&&r.trim()===""?!0:t==null?!1:t.getTime&&r.getTime?t.getTime()===r.getTime():ObjectUtils.removeAccents(t.toString()).toLocaleLowerCase(i)==ObjectUtils.removeAccents(r.toString()).toLocaleLowerCase(i)},notEquals:function n(t,r,i){return r==null||typeof r=="string"&&r.trim()===""?!1:t==null?!0:t.getTime&&r.getTime?t.getTime()!==r.getTime():ObjectUtils.removeAccents(t.toString()).toLocaleLowerCase(i)!=ObjectUtils.removeAccents(r.toString()).toLocaleLowerCase(i)},in:function n(t,r){if(r==null||r.length===0)return!0;for(var i=0;i<r.length;i++)if(ObjectUtils.equals(t,r[i]))return!0;return!1},between:function n(t,r){return r==null||r[0]==null||r[1]==null?!0:t==null?!1:t.getTime?r[0].getTime()<=t.getTime()&&t.getTime()<=r[1].getTime():r[0]<=t&&t<=r[1]},lt:function n(t,r){return r==null?!0:t==null?!1:t.getTime&&r.getTime?t.getTime()<r.getTime():t<r},lte:function n(t,r){return r==null?!0:t==null?!1:t.getTime&&r.getTime?t.getTime()<=r.getTime():t<=r},gt:function n(t,r){return r==null?!0:t==null?!1:t.getTime&&r.getTime?t.getTime()>r.getTime():t>r},gte:function n(t,r){return r==null?!0:t==null?!1:t.getTime&&r.getTime?t.getTime()>=r.getTime():t>=r},dateIs:function n(t,r){return r==null?!0:t==null?!1:t.toDateString()===r.toDateString()},dateIsNot:function n(t,r){return r==null?!0:t==null?!1:t.toDateString()!==r.toDateString()},dateBefore:function n(t,r){return r==null?!0:t==null?!1:t.getTime()<r.getTime()},dateAfter:function n(t,r){return r==null?!0:t==null?!1:t.getTime()>r.getTime()}},register:function n(t,r){this.filters[t]=r}};function _typeof$9(n){"@babel/helpers - typeof";return _typeof$9=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$9(n)}function ownKeys$8(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$8(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$8(Object(r),!0).forEach(function(i){_defineProperty$9(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$8(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$9(n,t,r){return t=_toPropertyKey$9(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$9(n){var t=_toPrimitive$9(n,"string");return _typeof$9(t)==="symbol"?t:String(t)}function _toPrimitive$9(n,t){if(_typeof$9(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$9(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var defaultOptions={ripple:!1,inputStyle:"outlined",locale:{startsWith:"Starts with",contains:"Contains",notContains:"Not contains",endsWith:"Ends with",equals:"Equals",notEquals:"Not equals",noFilter:"No Filter",lt:"Less than",lte:"Less than or equal to",gt:"Greater than",gte:"Greater than or equal to",dateIs:"Date is",dateIsNot:"Date is not",dateBefore:"Date is before",dateAfter:"Date is after",clear:"Clear",apply:"Apply",matchAll:"Match All",matchAny:"Match Any",addRule:"Add Rule",removeRule:"Remove Rule",accept:"Yes",reject:"No",choose:"Choose",upload:"Upload",cancel:"Cancel",completed:"Completed",pending:"Pending",fileSizeTypes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],chooseYear:"Choose Year",chooseMonth:"Choose Month",chooseDate:"Choose Date",prevDecade:"Previous Decade",nextDecade:"Next Decade",prevYear:"Previous Year",nextYear:"Next Year",prevMonth:"Previous Month",nextMonth:"Next Month",prevHour:"Previous Hour",nextHour:"Next Hour",prevMinute:"Previous Minute",nextMinute:"Next Minute",prevSecond:"Previous Second",nextSecond:"Next Second",am:"am",pm:"pm",today:"Today",weekHeader:"Wk",firstDayOfWeek:0,showMonthAfterYear:!1,dateFormat:"mm/dd/yy",weak:"Weak",medium:"Medium",strong:"Strong",passwordPrompt:"Enter a password",emptyFilterMessage:"No results found",searchMessage:"{0} results are available",selectionMessage:"{0} items selected",emptySelectionMessage:"No selected item",emptySearchMessage:"No results found",emptyMessage:"No available options",aria:{trueLabel:"True",falseLabel:"False",nullLabel:"Not Selected",star:"1 star",stars:"{star} stars",selectAll:"All items selected",unselectAll:"All items unselected",close:"Close",previous:"Previous",next:"Next",navigation:"Navigation",scrollTop:"Scroll Top",moveTop:"Move Top",moveUp:"Move Up",moveDown:"Move Down",moveBottom:"Move Bottom",moveToTarget:"Move to Target",moveToSource:"Move to Source",moveAllToTarget:"Move All to Target",moveAllToSource:"Move All to Source",pageLabel:"Page {page}",firstPageLabel:"First Page",lastPageLabel:"Last Page",nextPageLabel:"Next Page",prevPageLabel:"Previous Page",rowsPerPageLabel:"Rows per page",jumpToPageDropdownLabel:"Jump to Page Dropdown",jumpToPageInputLabel:"Jump to Page Input",selectRow:"Row Selected",unselectRow:"Row Unselected",expandRow:"Row Expanded",collapseRow:"Row Collapsed",showFilterMenu:"Show Filter Menu",hideFilterMenu:"Hide Filter Menu",filterOperator:"Filter Operator",filterConstraint:"Filter Constraint",editRow:"Row Edit",saveEdit:"Save Edit",cancelEdit:"Cancel Edit",listView:"List View",gridView:"Grid View",slide:"Slide",slideNumber:"{slideNumber}",zoomImage:"Zoom Image",zoomIn:"Zoom In",zoomOut:"Zoom Out",rotateRight:"Rotate Right",rotateLeft:"Rotate Left"}},filterMatchModeOptions:{text:[FilterMatchMode.STARTS_WITH,FilterMatchMode.CONTAINS,FilterMatchMode.NOT_CONTAINS,FilterMatchMode.ENDS_WITH,FilterMatchMode.EQUALS,FilterMatchMode.NOT_EQUALS],numeric:[FilterMatchMode.EQUALS,FilterMatchMode.NOT_EQUALS,FilterMatchMode.LESS_THAN,FilterMatchMode.LESS_THAN_OR_EQUAL_TO,FilterMatchMode.GREATER_THAN,FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],date:[FilterMatchMode.DATE_IS,FilterMatchMode.DATE_IS_NOT,FilterMatchMode.DATE_BEFORE,FilterMatchMode.DATE_AFTER]},zIndex:{modal:1100,overlay:1e3,menu:1e3,tooltip:1100},pt:void 0,ptOptions:{mergeSections:!0,mergeProps:!1},unstyled:!1,csp:{nonce:void 0}},PrimeVueSymbol=Symbol();function switchTheme(n,t,r,i){if(n!==t){var s=document.getElementById(r),o=s.cloneNode(!0),l=s.getAttribute("href").replace(n,t);o.setAttribute("id",r+"-clone"),o.setAttribute("href",l),o.addEventListener("load",function(){s.remove(),o.setAttribute("id",r),i&&i()}),s.parentNode&&s.parentNode.insertBefore(o,s.nextSibling)}}var PrimeVue={install:function n(t,r){var i=r?_objectSpread$8(_objectSpread$8({},defaultOptions),r):_objectSpread$8({},defaultOptions),s={config:reactive(i),changeTheme:switchTheme};t.config.globalProperties.$primevue=s,t.provide(PrimeVueSymbol,s)}};function _typeof$8(n){"@babel/helpers - typeof";return _typeof$8=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$8(n)}function ownKeys$7(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$7(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$7(Object(r),!0).forEach(function(i){_defineProperty$8(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$7(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$8(n,t,r){return t=_toPropertyKey$8(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$8(n){var t=_toPrimitive$8(n,"string");return _typeof$8(t)==="symbol"?t:String(t)}function _toPrimitive$8(n,t){if(_typeof$8(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$8(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function tryOnMounted(n){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;getCurrentInstance()?onMounted(n):t?n():nextTick(n)}var _id=0;function useStyle(n){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=ref(!1),i=ref(n),s=ref(null),o=DomHandler.isClient()?window.document:void 0,l=t.document,f=l===void 0?o:l,u=t.immediate,_=u===void 0?!0:u,g=t.manual,a=g===void 0?!1:g,m=t.name,b=m===void 0?"style_".concat(++_id):m,v=t.id,c=v===void 0?void 0:v,w=t.media,k=w===void 0?void 0:w,x=t.nonce,E=x===void 0?void 0:x,O=t.props,A=O===void 0?{}:O,T=function(){},j=function($){var N=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(f){var M=_objectSpread$7(_objectSpread$7({},A),N),W=M.name||b,F=M.id||c,H=M.nonce||E;s.value=f.querySelector('style[data-primevue-style-id="'.concat(W,'"]'))||f.getElementById(F)||f.createElement("style"),s.value.isConnected||(i.value=$||n,DomHandler.setAttributes(s.value,{type:"text/css",id:F,media:k,nonce:H}),f.head.appendChild(s.value),DomHandler.setAttribute(s.value,"data-primevue-style-id",b),DomHandler.setAttributes(s.value,M)),!r.value&&(T=watch(i,function(q){s.value.textContent=q},{immediate:!0}),r.value=!0)}},I=function(){!f||!r.value||(T(),DomHandler.isExist(s.value)&&f.head.removeChild(s.value),r.value=!1)};return _&&!a&&tryOnMounted(j),{id:c,name:b,css:i,unload:I,load:j,isLoaded:readonly(r)}}function _typeof$7(n){"@babel/helpers - typeof";return _typeof$7=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$7(n)}function _slicedToArray$1(n,t){return _arrayWithHoles$1(n)||_iterableToArrayLimit$1(n,t)||_unsupportedIterableToArray$4(n,t)||_nonIterableRest$1()}function _nonIterableRest$1(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$4(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$4(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$4(n,t)}}function _arrayLikeToArray$4(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}function _iterableToArrayLimit$1(n,t){var r=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(r!=null){var i,s,o,l,f=[],u=!0,_=!1;try{if(o=(r=r.call(n)).next,t===0){if(Object(r)!==r)return;u=!1}else for(;!(u=(i=o.call(r)).done)&&(f.push(i.value),f.length!==t);u=!0);}catch(g){_=!0,s=g}finally{try{if(!u&&r.return!=null&&(l=r.return(),Object(l)!==l))return}finally{if(_)throw s}}return f}}function _arrayWithHoles$1(n){if(Array.isArray(n))return n}function ownKeys$6(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$6(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$6(Object(r),!0).forEach(function(i){_defineProperty$7(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$6(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$7(n,t,r){return t=_toPropertyKey$7(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$7(n){var t=_toPrimitive$7(n,"string");return _typeof$7(t)==="symbol"?t:String(t)}function _toPrimitive$7(n,t){if(_typeof$7(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$7(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var css$7=`
.p-hidden-accessible {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
}

.p-hidden-accessible input,
.p-hidden-accessible select {
    transform: scale(0);
}

.p-overflow-hidden {
    overflow: hidden;
    padding-right: var(--scrollbar-width);
}
`,classes$6={},inlineStyles={},BaseStyle={name:"base",css:css$7,classes:classes$6,inlineStyles,loadStyle:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return this.css?useStyle(this.css,_objectSpread$6({name:this.name},t)):{}},getStyleSheet:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(this.css){var i=Object.entries(r).reduce(function(s,o){var l=_slicedToArray$1(o,2),f=l[0],u=l[1];return s.push("".concat(f,'="').concat(u,'"'))&&s},[]).join(" ");return'<style type="text/css" data-primevue-style-id="'.concat(this.name,'" ').concat(i,">").concat(this.css).concat(t,"</style>")}return""},extend:function n(t){return _objectSpread$6(_objectSpread$6({},this),{},{css:void 0},t)}},css$6=`
@layer primevue {
    .p-badge {
        display: inline-block;
        border-radius: 10px;
        text-align: center;
        padding: 0 .5rem;
    }

    .p-overlay-badge {
        position: relative;
    }

    .p-overlay-badge .p-badge {
        position: absolute;
        top: 0;
        right: 0;
        transform: translate(50%,-50%);
        transform-origin: 100% 0;
        margin: 0;
    }

    .p-badge-dot {
        width: .5rem;
        min-width: .5rem;
        height: .5rem;
        border-radius: 50%;
        padding: 0;
    }

    .p-badge-no-gutter {
        padding: 0;
        border-radius: 50%;
    }
}
`,classes$5={root:function n(t){var r=t.props,i=t.instance;return["p-badge p-component",{"p-badge-no-gutter":ObjectUtils.isNotEmpty(r.value)&&String(r.value).length===1,"p-badge-dot":ObjectUtils.isEmpty(r.value)&&!i.$slots.default,"p-badge-lg":r.size==="large","p-badge-xl":r.size==="xlarge","p-badge-info":r.severity==="info","p-badge-success":r.severity==="success","p-badge-warning":r.severity==="warning","p-badge-danger":r.severity==="danger"}]}},BadgeStyle=BaseStyle.extend({name:"badge",css:css$6,classes:classes$5});function _typeof$1$1(n){"@babel/helpers - typeof";return _typeof$1$1=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$1$1(n)}function ownKeys$1$1(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$1$1(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$1$1(Object(r),!0).forEach(function(i){_defineProperty$1$1(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$1$1(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$1$1(n,t,r){return t=_toPropertyKey$1$1(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$1$1(n){var t=_toPrimitive$1$1(n,"string");return _typeof$1$1(t)==="symbol"?t:String(t)}function _toPrimitive$1$1(n,t){if(_typeof$1$1(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$1$1(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var buttonCSS=`
.p-button {
    display: inline-flex;
    cursor: pointer;
    user-select: none;
    align-items: center;
    vertical-align: bottom;
    text-align: center;
    overflow: hidden;
    position: relative;
}

.p-button-label {
    flex: 1 1 auto;
}

.p-button-icon-right {
    order: 1;
}

.p-button:disabled {
    cursor: default;
}

.p-button-icon-only {
    justify-content: center;
}

.p-button-icon-only .p-button-label {
    visibility: hidden;
    width: 0;
    flex: 0 0 auto;
}

.p-button-vertical {
    flex-direction: column;
}

.p-button-icon-bottom {
    order: 2;
}

.p-buttonset .p-button {
    margin: 0;
}

.p-buttonset .p-button:not(:last-child), .p-buttonset .p-button:not(:last-child):hover {
    border-right: 0 none;
}

.p-buttonset .p-button:not(:first-of-type):not(:last-of-type) {
    border-radius: 0;
}

.p-buttonset .p-button:first-of-type:not(:only-of-type) {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
}

.p-buttonset .p-button:last-of-type:not(:only-of-type) {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
}

.p-buttonset .p-button:focus {
    position: relative;
    z-index: 1;
}
`,checkboxCSS=`
.p-checkbox {
    display: inline-flex;
    cursor: pointer;
    user-select: none;
    vertical-align: bottom;
    position: relative;
}

.p-checkbox.p-checkbox-disabled {
    cursor: default;
}

.p-checkbox-box {
    display: flex;
    justify-content: center;
    align-items: center;
}
`,inputTextCSS=`
.p-fluid .p-inputtext {
    width: 100%;
}

/* InputGroup */
.p-inputgroup {
    display: flex;
    align-items: stretch;
    width: 100%;
}

.p-inputgroup-addon {
    display: flex;
    align-items: center;
    justify-content: center;
}

.p-inputgroup .p-float-label {
    display: flex;
    align-items: stretch;
    width: 100%;
}

.p-inputgroup .p-inputtext,
.p-fluid .p-inputgroup .p-inputtext,
.p-inputgroup .p-inputwrapper,
.p-fluid .p-inputgroup .p-input {
    flex: 1 1 auto;
    width: 1%;
}

/* Floating Label */
.p-float-label {
    display: block;
    position: relative;
}

.p-float-label label {
    position: absolute;
    pointer-events: none;
    top: 50%;
    margin-top: -.5rem;
    transition-property: all;
    transition-timing-function: ease;
    line-height: 1;
}

.p-float-label textarea ~ label {
    top: 1rem;
}

.p-float-label input:focus ~ label,
.p-float-label input.p-filled ~ label,
.p-float-label input:-webkit-autofill ~ label,
.p-float-label textarea:focus ~ label,
.p-float-label textarea.p-filled ~ label,
.p-float-label .p-inputwrapper-focus ~ label,
.p-float-label .p-inputwrapper-filled ~ label {
    top: -.75rem;
    font-size: 12px;
}


.p-float-label .p-placeholder,
.p-float-label input::placeholder,
.p-float-label .p-inputtext::placeholder {
    opacity: 0;
    transition-property: all;
    transition-timing-function: ease;
}

.p-float-label .p-focus .p-placeholder,
.p-float-label input:focus::placeholder,
.p-float-label .p-inputtext:focus::placeholder {
    opacity: 1;
    transition-property: all;
    transition-timing-function: ease;
}

.p-input-icon-left,
.p-input-icon-right {
    position: relative;
    display: inline-block;
}

.p-input-icon-left > i,
.p-input-icon-left > svg,
.p-input-icon-right > i,
.p-input-icon-right > svg {
    position: absolute;
    top: 50%;
    margin-top: -.5rem;
}

.p-fluid .p-input-icon-left,
.p-fluid .p-input-icon-right {
    display: block;
    width: 100%;
}
`,radioButtonCSS=`
.p-radiobutton {
    position: relative;
    display: inline-flex;
    cursor: pointer;
    user-select: none;
    vertical-align: bottom;
}

.p-radiobutton.p-radiobutton-disabled {
    cursor: default;
}

.p-radiobutton-box {
    display: flex;
    justify-content: center;
    align-items: center;
}

.p-radiobutton-icon {
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    transform: translateZ(0) scale(.1);
    border-radius: 50%;
    visibility: hidden;
}

.p-radiobutton-box.p-highlight .p-radiobutton-icon {
    transform: translateZ(0) scale(1.0, 1.0);
    visibility: visible;
}
`,css$5=`
@layer primevue {
.p-component, .p-component * {
    box-sizing: border-box;
}

.p-hidden-space {
    visibility: hidden;
}

.p-reset {
    margin: 0;
    padding: 0;
    border: 0;
    outline: 0;
    text-decoration: none;
    font-size: 100%;
    list-style: none;
}

.p-disabled, .p-disabled * {
    cursor: default !important;
    pointer-events: none;
    user-select: none;
}

.p-component-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.p-unselectable-text {
    user-select: none;
}

.p-sr-only {
    border: 0;
    clip: rect(1px, 1px, 1px, 1px);
    clip-path: inset(50%);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
    word-wrap: normal !important;
}

.p-link {
	text-align: left;
	background-color: transparent;
	margin: 0;
	padding: 0;
	border: none;
    cursor: pointer;
    user-select: none;
}

.p-link:disabled {
	cursor: default;
}

/* Non vue overlay animations */
.p-connected-overlay {
    opacity: 0;
    transform: scaleY(0.8);
    transition: transform .12s cubic-bezier(0, 0, 0.2, 1), opacity .12s cubic-bezier(0, 0, 0.2, 1);
}

.p-connected-overlay-visible {
    opacity: 1;
    transform: scaleY(1);
}

.p-connected-overlay-hidden {
    opacity: 0;
    transform: scaleY(1);
    transition: opacity .1s linear;
}

/* Vue based overlay animations */
.p-connected-overlay-enter-from {
    opacity: 0;
    transform: scaleY(0.8);
}

.p-connected-overlay-leave-to {
    opacity: 0;
}

.p-connected-overlay-enter-active {
    transition: transform .12s cubic-bezier(0, 0, 0.2, 1), opacity .12s cubic-bezier(0, 0, 0.2, 1);
}

.p-connected-overlay-leave-active {
    transition: opacity .1s linear;
}

/* Toggleable Content */
.p-toggleable-content-enter-from,
.p-toggleable-content-leave-to {
    max-height: 0;
}

.p-toggleable-content-enter-to,
.p-toggleable-content-leave-from {
    max-height: 1000px;
}

.p-toggleable-content-leave-active {
    overflow: hidden;
    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);
}

.p-toggleable-content-enter-active {
    overflow: hidden;
    transition: max-height 1s ease-in-out;
}
`.concat(buttonCSS,`
`).concat(checkboxCSS,`
`).concat(inputTextCSS,`
`).concat(radioButtonCSS,`
}
`),BaseComponentStyle=BaseStyle.extend({name:"common",css:css$5,loadGlobalStyle:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return useStyle(t,_objectSpread$1$1({name:"global"},r))}});function _typeof$6(n){"@babel/helpers - typeof";return _typeof$6=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$6(n)}function ownKeys$5(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$5(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$5(Object(r),!0).forEach(function(i){_defineProperty$6(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$5(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$6(n,t,r){return t=_toPropertyKey$6(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$6(n){var t=_toPrimitive$6(n,"string");return _typeof$6(t)==="symbol"?t:String(t)}function _toPrimitive$6(n,t){if(_typeof$6(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$6(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var script$f={name:"BaseComponent",props:{pt:{type:Object,default:void 0},ptOptions:{type:Object,default:void 0},unstyled:{type:Boolean,default:void 0}},inject:{$parentInstance:{default:void 0}},watch:{isUnstyled:{immediate:!0,handler:function n(t){if(!t){var r,i;BaseComponentStyle.loadStyle({nonce:(r=this.$config)===null||r===void 0||(r=r.csp)===null||r===void 0?void 0:r.nonce}),this.$options.style&&this.$style.loadStyle({nonce:(i=this.$config)===null||i===void 0||(i=i.csp)===null||i===void 0?void 0:i.nonce})}}}},beforeCreate:function n(){var t,r,i,s,o,l,f,u,_,g,a,m=(t=this.pt)===null||t===void 0?void 0:t._usept,b=m?(r=this.pt)===null||r===void 0||(r=r.originalValue)===null||r===void 0?void 0:r[this.$.type.name]:void 0,v=m?(i=this.pt)===null||i===void 0||(i=i.value)===null||i===void 0?void 0:i[this.$.type.name]:this.pt;(s=v||b)===null||s===void 0||(s=s.hooks)===null||s===void 0||(o=s.onBeforeCreate)===null||o===void 0||o.call(s);var c=(l=this.$config)===null||l===void 0||(l=l.pt)===null||l===void 0?void 0:l._usept,w=c?(f=this.$primevue)===null||f===void 0||(f=f.config)===null||f===void 0||(f=f.pt)===null||f===void 0?void 0:f.originalValue:void 0,k=c?(u=this.$primevue)===null||u===void 0||(u=u.config)===null||u===void 0||(u=u.pt)===null||u===void 0?void 0:u.value:(_=this.$primevue)===null||_===void 0||(_=_.config)===null||_===void 0?void 0:_.pt;(g=k||w)===null||g===void 0||(g=g[this.$.type.name])===null||g===void 0||(g=g.hooks)===null||g===void 0||(a=g.onBeforeCreate)===null||a===void 0||a.call(g)},created:function n(){this._hook("onCreated")},beforeMount:function n(){var t;BaseStyle.loadStyle({nonce:(t=this.$config)===null||t===void 0||(t=t.csp)===null||t===void 0?void 0:t.nonce}),this._loadGlobalStyles(),this._hook("onBeforeMount")},mounted:function n(){this._hook("onMounted")},beforeUpdate:function n(){this._hook("onBeforeUpdate")},updated:function n(){this._hook("onUpdated")},beforeUnmount:function n(){this._hook("onBeforeUnmount")},unmounted:function n(){this._hook("onUnmounted")},methods:{_hook:function n(t){if(!this.$options.hostName){var r=this._usePT(this._getPT(this.pt,this.$.type.name),this._getOptionValue,"hooks.".concat(t)),i=this._useDefaultPT(this._getOptionValue,"hooks.".concat(t));r==null||r(),i==null||i()}},_loadGlobalStyles:function n(){var t,r=this._useGlobalPT(this._getOptionValue,"global.css",this.$params);ObjectUtils.isNotEmpty(r)&&BaseComponentStyle.loadGlobalStyle(r,{nonce:(t=this.$config)===null||t===void 0||(t=t.csp)===null||t===void 0?void 0:t.nonce})},_getHostInstance:function n(t){return t?this.$options.hostName?t.$.type.name===this.$options.hostName?t:this._getHostInstance(t.$parentInstance):t.$parentInstance:void 0},_getPropValue:function n(t){var r;return this[t]||((r=this._getHostInstance(this))===null||r===void 0?void 0:r[t])},_getOptionValue:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},s=ObjectUtils.toFlatCase(r).split("."),o=s.shift();return o?ObjectUtils.isObject(t)?this._getOptionValue(ObjectUtils.getItemValue(t[Object.keys(t).find(function(l){return ObjectUtils.toFlatCase(l)===o})||""],i),s.join("."),i):void 0:ObjectUtils.getItemValue(t,i)},_getPTValue:function n(){var t,r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!0,l="data-pc-",f=/./g.test(i)&&!!s[i.split(".")[0]],u=this._getPropValue("ptOptions")||((t=this.$config)===null||t===void 0?void 0:t.ptOptions)||{},_=u.mergeSections,g=_===void 0?!0:_,a=u.mergeProps,m=a===void 0?!1:a,b=o?f?this._useGlobalPT(this._getPTClassValue,i,s):this._useDefaultPT(this._getPTClassValue,i,s):void 0,v=f?void 0:this._usePT(this._getPT(r,this.$name),this._getPTClassValue,i,_objectSpread$5(_objectSpread$5({},s),{},{global:b||{}})),c=i!=="transition"&&_objectSpread$5(_objectSpread$5({},i==="root"&&_defineProperty$6({},"".concat(l,"name"),ObjectUtils.toFlatCase(this.$.type.name))),{},_defineProperty$6({},"".concat(l,"section"),ObjectUtils.toFlatCase(i)));return g||!g&&v?m?mergeProps(b,v,c):_objectSpread$5(_objectSpread$5(_objectSpread$5({},b),v),c):_objectSpread$5(_objectSpread$5({},v),c)},_getPTClassValue:function n(){var t=this._getOptionValue.apply(this,arguments);return ObjectUtils.isString(t)||ObjectUtils.isArray(t)?{class:t}:t},_getPT:function n(t){var r=this,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",s=arguments.length>2?arguments[2]:void 0,o=function(f){var u,_=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,g=s?s(f):f,a=ObjectUtils.toFlatCase(i),m=ObjectUtils.toFlatCase(r.$name);return(u=_?a!==m?g==null?void 0:g[a]:void 0:g==null?void 0:g[a])!==null&&u!==void 0?u:g};return t!=null&&t.hasOwnProperty("_usept")?{_usept:t._usept,originalValue:o(t.originalValue),value:o(t.value)}:o(t,!0)},_usePT:function n(t,r,i,s){var o=function(c){return r(c,i,s)};if(t!=null&&t.hasOwnProperty("_usept")){var l,f=t._usept||((l=this.$config)===null||l===void 0?void 0:l.ptOptions)||{},u=f.mergeSections,_=u===void 0?!0:u,g=f.mergeProps,a=g===void 0?!1:g,m=o(t.originalValue),b=o(t.value);return m===void 0&&b===void 0?void 0:ObjectUtils.isString(b)?b:ObjectUtils.isString(m)?m:_||!_&&b?a?mergeProps(m,b):_objectSpread$5(_objectSpread$5({},m),b):b}return o(t)},_useGlobalPT:function n(t,r,i){return this._usePT(this.globalPT,t,r,i)},_useDefaultPT:function n(t,r,i){return this._usePT(this.defaultPT,t,r,i)},ptm:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return this._getPTValue(this.pt,t,_objectSpread$5(_objectSpread$5({},this.$params),r))},ptmo:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return this._getPTValue(t,r,_objectSpread$5({instance:this},i),!1)},cx:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return this.isUnstyled?void 0:this._getOptionValue(this.$style.classes,t,_objectSpread$5(_objectSpread$5({},this.$params),r))},sx:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(r){var s=this._getOptionValue(this.$style.inlineStyles,t,_objectSpread$5(_objectSpread$5({},this.$params),i)),o=this._getOptionValue(BaseComponentStyle.inlineStyles,t,_objectSpread$5(_objectSpread$5({},this.$params),i));return[o,s]}}},computed:{globalPT:function n(){var t,r=this;return this._getPT((t=this.$config)===null||t===void 0?void 0:t.pt,void 0,function(i){return ObjectUtils.getItemValue(i,{instance:r})})},defaultPT:function n(){var t,r=this;return this._getPT((t=this.$config)===null||t===void 0?void 0:t.pt,void 0,function(i){return r._getOptionValue(i,r.$name,_objectSpread$5({},r.$params))||ObjectUtils.getItemValue(i,_objectSpread$5({},r.$params))})},isUnstyled:function n(){var t;return this.unstyled!==void 0?this.unstyled:(t=this.$config)===null||t===void 0?void 0:t.unstyled},$params:function n(){var t=this.$parentInstance||this.$parent;return{instance:this,props:this.$props,state:this.$data,parent:{instance:t,props:t==null?void 0:t.$props,state:t==null?void 0:t.$data},parentInstance:t}},$style:function n(){return _objectSpread$5(_objectSpread$5({classes:void 0,inlineStyles:void 0,loadStyle:function(){},loadCustomStyle:function(){}},(this._getHostInstance(this)||{}).$style),this.$options.style)},$config:function n(){var t;return(t=this.$primevue)===null||t===void 0?void 0:t.config},$name:function n(){return this.$options.hostName||this.$.type.name}}},script$1$5={name:"BaseBadge",extends:script$f,props:{value:{type:[String,Number],default:null},severity:{type:String,default:null},size:{type:String,default:null}},style:BadgeStyle,provide:function n(){return{$parentInstance:this}}},script$e={name:"Badge",extends:script$1$5};function render$c(n,t,r,i,s,o){return openBlock(),createElementBlock("span",mergeProps({class:n.cx("root")},n.ptm("root"),{"data-pc-name":"badge"}),[renderSlot(n.$slots,"default",{},function(){return[createTextVNode(toDisplayString(n.value),1)]})],16)}script$e.render=render$c;var css$4=`
.p-icon {
    display: inline-block;
}

.p-icon-spin {
    -webkit-animation: p-icon-spin 2s infinite linear;
    animation: p-icon-spin 2s infinite linear;
}

@-webkit-keyframes p-icon-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}

@keyframes p-icon-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}
`,BaseIconStyle=BaseStyle.extend({name:"baseicon",css:css$4}),script$d={name:"BaseIcon",extends:script$f,props:{label:{type:String,default:void 0},spin:{type:Boolean,default:!1}},style:BaseIconStyle,beforeMount:function n(){var t;BaseIconStyle.loadStyle({nonce:(t=this.$config)===null||t===void 0||(t=t.csp)===null||t===void 0?void 0:t.nonce})},methods:{pti:function n(){var t=ObjectUtils.isEmpty(this.label);return{class:["p-icon",{"p-icon-spin":this.spin}],role:t?void 0:"img","aria-label":t?void 0:this.label,"aria-hidden":t}}},computed:{$config:function n(){var t;return(t=this.$primevue)===null||t===void 0?void 0:t.config}}},script$c={name:"SpinnerIcon",extends:script$d,computed:{pathId:function n(){return"pv_icon_clip_".concat(UniqueComponentId())}}},_hoisted_1$9=["clipPath"],_hoisted_2$6=createBaseVNode("path",{d:"M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",fill:"currentColor"},null,-1),_hoisted_3$2=[_hoisted_2$6],_hoisted_4$2=["id"],_hoisted_5$2=createBaseVNode("rect",{width:"14",height:"14",fill:"white"},null,-1),_hoisted_6$2=[_hoisted_5$2];function render$b(n,t,r,i,s,o){return openBlock(),createElementBlock("svg",mergeProps({width:"14",height:"14",viewBox:"0 0 14 14",fill:"none",xmlns:"http://www.w3.org/2000/svg"},n.pti()),[createBaseVNode("g",{clipPath:"url(#".concat(o.pathId,")")},_hoisted_3$2,8,_hoisted_1$9),createBaseVNode("defs",null,[createBaseVNode("clipPath",{id:"".concat(o.pathId)},_hoisted_6$2,8,_hoisted_4$2)])],16)}script$c.render=render$b;function _typeof$5(n){"@babel/helpers - typeof";return _typeof$5=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$5(n)}function _slicedToArray(n,t){return _arrayWithHoles(n)||_iterableToArrayLimit(n,t)||_unsupportedIterableToArray$3(n,t)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$3(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$3(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$3(n,t)}}function _arrayLikeToArray$3(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}function _iterableToArrayLimit(n,t){var r=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(r!=null){var i,s,o,l,f=[],u=!0,_=!1;try{if(o=(r=r.call(n)).next,t===0){if(Object(r)!==r)return;u=!1}else for(;!(u=(i=o.call(r)).done)&&(f.push(i.value),f.length!==t);u=!0);}catch(g){_=!0,s=g}finally{try{if(!u&&r.return!=null&&(l=r.return(),Object(l)!==l))return}finally{if(_)throw s}}return f}}function _arrayWithHoles(n){if(Array.isArray(n))return n}function ownKeys$4(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$4(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$4(Object(r),!0).forEach(function(i){_defineProperty$5(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$4(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$5(n,t,r){return t=_toPropertyKey$5(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$5(n){var t=_toPrimitive$5(n,"string");return _typeof$5(t)==="symbol"?t:String(t)}function _toPrimitive$5(n,t){if(_typeof$5(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$5(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var BaseDirective={_getMeta:function n(){return[ObjectUtils.isObject(arguments.length<=0?void 0:arguments[0])||arguments.length<=0?void 0:arguments[0],ObjectUtils.getItemValue(ObjectUtils.isObject(arguments.length<=0?void 0:arguments[0])?arguments.length<=0?void 0:arguments[0]:arguments.length<=1?void 0:arguments[1])]},_getConfig:function n(t,r){var i,s,o;return(i=(t==null||(s=t.instance)===null||s===void 0?void 0:s.$primevue)||(r==null||(o=r.ctx)===null||o===void 0||(o=o.appContext)===null||o===void 0||(o=o.config)===null||o===void 0||(o=o.globalProperties)===null||o===void 0?void 0:o.$primevue))===null||i===void 0?void 0:i.config},_getOptionValue:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},s=ObjectUtils.toFlatCase(r).split("."),o=s.shift();return o?ObjectUtils.isObject(t)?BaseDirective._getOptionValue(ObjectUtils.getItemValue(t[Object.keys(t).find(function(l){return ObjectUtils.toFlatCase(l)===o})||""],i),s.join("."),i):void 0:ObjectUtils.getItemValue(t,i)},_getPTValue:function n(){var t,r,i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},o=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"",l=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},f=arguments.length>4&&arguments[4]!==void 0?arguments[4]:!0,u=function(){var E=BaseDirective._getOptionValue.apply(BaseDirective,arguments);return ObjectUtils.isString(E)||ObjectUtils.isArray(E)?{class:E}:E},_="data-pc-",g=((t=i.binding)===null||t===void 0||(t=t.value)===null||t===void 0?void 0:t.ptOptions)||((r=i.$config)===null||r===void 0?void 0:r.ptOptions)||{},a=g.mergeSections,m=a===void 0?!0:a,b=g.mergeProps,v=b===void 0?!1:b,c=f?BaseDirective._useDefaultPT(i,i.defaultPT(),u,o,l):void 0,w=BaseDirective._usePT(i,BaseDirective._getPT(s,i.$name),u,o,_objectSpread$4(_objectSpread$4({},l),{},{global:c||{}})),k=_objectSpread$4(_objectSpread$4({},o==="root"&&_defineProperty$5({},"".concat(_,"name"),ObjectUtils.toFlatCase(i.$name))),{},_defineProperty$5({},"".concat(_,"section"),ObjectUtils.toFlatCase(o)));return m||!m&&w?v?mergeProps(c,w,k):_objectSpread$4(_objectSpread$4(_objectSpread$4({},c),w),k):_objectSpread$4(_objectSpread$4({},w),k)},_getPT:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",i=arguments.length>2?arguments[2]:void 0,s=function(l){var f,u=i?i(l):l,_=ObjectUtils.toFlatCase(r);return(f=u==null?void 0:u[_])!==null&&f!==void 0?f:u};return t!=null&&t.hasOwnProperty("_usept")?{_usept:t._usept,originalValue:s(t.originalValue),value:s(t.value)}:s(t)},_usePT:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0,i=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0,o=arguments.length>4?arguments[4]:void 0,l=function(w){return i(w,s,o)};if(r!=null&&r.hasOwnProperty("_usept")){var f,u=r._usept||((f=t.$config)===null||f===void 0?void 0:f.ptOptions)||{},_=u.mergeSections,g=_===void 0?!0:_,a=u.mergeProps,m=a===void 0?!1:a,b=l(r.originalValue),v=l(r.value);return b===void 0&&v===void 0?void 0:ObjectUtils.isString(v)?v:ObjectUtils.isString(b)?b:g||!g&&v?m?mergeProps(b,v):_objectSpread$4(_objectSpread$4({},b),v):v}return l(r)},_useDefaultPT:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},i=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0,o=arguments.length>4?arguments[4]:void 0;return BaseDirective._usePT(t,r,i,s,o)},_hook:function n(t,r,i,s,o,l){var f,u,_="on".concat(ObjectUtils.toCapitalCase(r)),g=BaseDirective._getConfig(s,o),a=i==null?void 0:i.$instance,m=BaseDirective._usePT(a,BaseDirective._getPT(s==null||(f=s.value)===null||f===void 0?void 0:f.pt,t),BaseDirective._getOptionValue,"hooks.".concat(_)),b=BaseDirective._useDefaultPT(a,g==null||(u=g.pt)===null||u===void 0||(u=u.directives)===null||u===void 0?void 0:u[t],BaseDirective._getOptionValue,"hooks.".concat(_)),v={el:i,binding:s,vnode:o,prevVnode:l};m==null||m(a,v),b==null||b(a,v)},_extend:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},i=function(o,l,f,u,_){var g,a;l._$instances=l._$instances||{};var m=BaseDirective._getConfig(f,u),b=l._$instances[t]||{},v=ObjectUtils.isEmpty(b)?_objectSpread$4(_objectSpread$4({},r),r==null?void 0:r.methods):{};l._$instances[t]=_objectSpread$4(_objectSpread$4({},b),{},{$name:t,$host:l,$binding:f,$modifiers:f==null?void 0:f.modifiers,$value:f==null?void 0:f.value,$el:b.$el||l||void 0,$style:_objectSpread$4({classes:void 0,inlineStyles:void 0,loadStyle:function(){}},r==null?void 0:r.style),$config:m,defaultPT:function(){return BaseDirective._getPT(m==null?void 0:m.pt,void 0,function(w){var k;return w==null||(k=w.directives)===null||k===void 0?void 0:k[t]})},isUnstyled:function(){var w,k;return((w=l.$instance)===null||w===void 0||(w=w.$binding)===null||w===void 0||(w=w.value)===null||w===void 0?void 0:w.unstyled)!==void 0?(k=l.$instance)===null||k===void 0||(k=k.$binding)===null||k===void 0||(k=k.value)===null||k===void 0?void 0:k.unstyled:m==null?void 0:m.unstyled},ptm:function(){var w,k=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",x=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return BaseDirective._getPTValue(l.$instance,(w=l.$instance)===null||w===void 0||(w=w.$binding)===null||w===void 0||(w=w.value)===null||w===void 0?void 0:w.pt,k,_objectSpread$4({},x))},ptmo:function(){var w=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},k=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"",x=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return BaseDirective._getPTValue(l.$instance,w,k,x,!1)},cx:function(){var w,k,x=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",E=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return(w=l.$instance)!==null&&w!==void 0&&w.isUnstyled()?void 0:BaseDirective._getOptionValue((k=l.$instance)===null||k===void 0||(k=k.$style)===null||k===void 0?void 0:k.classes,x,_objectSpread$4({},E))},sx:function(){var w,k=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",x=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,E=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return x?BaseDirective._getOptionValue((w=l.$instance)===null||w===void 0||(w=w.$style)===null||w===void 0?void 0:w.inlineStyles,k,_objectSpread$4({},E)):void 0}},v),l.$instance=l._$instances[t],(g=(a=l.$instance)[o])===null||g===void 0||g.call(a,l,f,u,_),BaseDirective._hook(t,o,l,f,u,_)};return{created:function(o,l,f,u){i("created",o,l,f,u)},beforeMount:function(o,l,f,u){var _,g,a,m,b=BaseDirective._getConfig(l,f);BaseStyle.loadStyle(void 0,{nonce:b==null||(_=b.csp)===null||_===void 0?void 0:_.nonce}),!((g=o.$instance)!==null&&g!==void 0&&g.isUnstyled())&&((a=o.$instance)===null||a===void 0||(a=a.$style)===null||a===void 0||a.loadStyle(void 0,{nonce:b==null||(m=b.csp)===null||m===void 0?void 0:m.nonce})),i("beforeMount",o,l,f,u)},mounted:function(o,l,f,u){i("mounted",o,l,f,u)},beforeUpdate:function(o,l,f,u){i("beforeUpdate",o,l,f,u)},updated:function(o,l,f,u){i("updated",o,l,f,u)},beforeUnmount:function(o,l,f,u){i("beforeUnmount",o,l,f,u)},unmounted:function(o,l,f,u){i("unmounted",o,l,f,u)}}},extend:function n(){var t=BaseDirective._getMeta.apply(BaseDirective,arguments),r=_slicedToArray(t,2),i=r[0],s=r[1];return _objectSpread$4({extend:function(){var l=BaseDirective._getMeta.apply(BaseDirective,arguments),f=_slicedToArray(l,2),u=f[0],_=f[1];return BaseDirective.extend(u,_objectSpread$4(_objectSpread$4(_objectSpread$4({},s),s==null?void 0:s.methods),_))}},BaseDirective._extend(i,s))}},css$3=`
@keyframes ripple {
    100% {
        opacity: 0;
        transform: scale(2.5);
    }
}

@layer primevue {
    .p-ripple {
        overflow: hidden;
        position: relative;
    }

    .p-ink {
        display: block;
        position: absolute;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 100%;
        transform: scale(0);
        pointer-events: none;
    }

    .p-ink-active {
        animation: ripple 0.4s linear;
    }

    .p-ripple-disabled .p-ink {
        display: none !important;
    }
}
`,classes$4={root:"p-ink"},RippleStyle=BaseStyle.extend({name:"ripple",css:css$3,classes:classes$4}),BaseRipple=BaseDirective.extend({style:RippleStyle});function _toConsumableArray$2(n){return _arrayWithoutHoles$2(n)||_iterableToArray$2(n)||_unsupportedIterableToArray$2(n)||_nonIterableSpread$2()}function _nonIterableSpread$2(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$2(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$2(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$2(n,t)}}function _iterableToArray$2(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function _arrayWithoutHoles$2(n){if(Array.isArray(n))return _arrayLikeToArray$2(n)}function _arrayLikeToArray$2(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}var Ripple=BaseRipple.extend("ripple",{mounted:function n(t){var r,i=t==null||(r=t.$instance)===null||r===void 0?void 0:r.$config;i&&i.ripple&&(this.create(t),this.bindEvents(t),t.setAttribute("data-pd-ripple",!0))},unmounted:function n(t){this.remove(t)},timeout:void 0,methods:{bindEvents:function n(t){t.addEventListener("mousedown",this.onMouseDown.bind(this))},unbindEvents:function n(t){t.removeEventListener("mousedown",this.onMouseDown.bind(this))},create:function n(t){var r=DomHandler.createElement("span",{role:"presentation","aria-hidden":!0,"data-p-ink":!0,"data-p-ink-active":!1,class:!this.isUnstyled()&&this.cx("root"),onAnimationEnd:this.onAnimationEnd.bind(this),"p-bind":this.ptm("root")});t.appendChild(r),this.$el=r},remove:function n(t){var r=this.getInk(t);r&&(this.unbindEvents(t),r.removeEventListener("animationend",this.onAnimationEnd),r.remove())},onMouseDown:function n(t){var r=this,i=t.currentTarget,s=this.getInk(i);if(!(!s||getComputedStyle(s,null).display==="none")){if(!this.isUnstyled()&&DomHandler.removeClass(s,"p-ink-active"),s.setAttribute("data-p-ink-active","false"),!DomHandler.getHeight(s)&&!DomHandler.getWidth(s)){var o=Math.max(DomHandler.getOuterWidth(i),DomHandler.getOuterHeight(i));s.style.height=o+"px",s.style.width=o+"px"}var l=DomHandler.getOffset(i),f=t.pageX-l.left+document.body.scrollTop-DomHandler.getWidth(s)/2,u=t.pageY-l.top+document.body.scrollLeft-DomHandler.getHeight(s)/2;s.style.top=u+"px",s.style.left=f+"px",!this.isUnstyled()&&DomHandler.addClass(s,"p-ink-active"),s.setAttribute("data-p-ink-active","true"),this.timeout=setTimeout(function(){s&&(!r.isUnstyled()&&DomHandler.removeClass(s,"p-ink-active"),s.setAttribute("data-p-ink-active","false"))},401)}},onAnimationEnd:function n(t){this.timeout&&clearTimeout(this.timeout),!this.isUnstyled()&&DomHandler.removeClass(t.currentTarget,"p-ink-active"),t.currentTarget.setAttribute("data-p-ink-active","false")},getInk:function n(t){return t&&t.children?_toConsumableArray$2(t.children).find(function(r){return DomHandler.getAttribute(r,"data-pc-name")==="ripple"}):void 0}}});function _typeof$4(n){"@babel/helpers - typeof";return _typeof$4=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$4(n)}function _defineProperty$4(n,t,r){return t=_toPropertyKey$4(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$4(n){var t=_toPrimitive$4(n,"string");return _typeof$4(t)==="symbol"?t:String(t)}function _toPrimitive$4(n,t){if(_typeof$4(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$4(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var classes$3={root:function n(t){var r=t.instance,i=t.props;return["p-button p-component",_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4(_defineProperty$4({"p-button-icon-only":r.hasIcon&&!i.label&&!i.badge,"p-button-vertical":(i.iconPos==="top"||i.iconPos==="bottom")&&i.label,"p-disabled":r.$attrs.disabled||r.$attrs.disabled===""||i.loading,"p-button-loading":i.loading,"p-button-loading-label-only":i.loading&&!r.hasIcon&&i.label,"p-button-link":i.link},"p-button-".concat(i.severity),i.severity),"p-button-raised",i.raised),"p-button-rounded",i.rounded),"p-button-text",i.text),"p-button-outlined",i.outlined),"p-button-sm",i.size==="small"),"p-button-lg",i.size==="large"),"p-button-plain",i.plain)]},loadingIcon:"p-button-loading-icon pi-spin",icon:function n(t){var r=t.props;return["p-button-icon",{"p-button-icon-left":r.iconPos==="left"&&r.label,"p-button-icon-right":r.iconPos==="right"&&r.label,"p-button-icon-top":r.iconPos==="top"&&r.label,"p-button-icon-bottom":r.iconPos==="bottom"&&r.label}]},label:"p-button-label"},ButtonStyle=BaseStyle.extend({name:"button",classes:classes$3}),script$1$4={name:"BaseButton",extends:script$f,props:{label:{type:String,default:null},icon:{type:String,default:null},iconPos:{type:String,default:"left"},iconClass:{type:String,default:null},badge:{type:String,default:null},badgeClass:{type:String,default:null},badgeSeverity:{type:String,default:null},loading:{type:Boolean,default:!1},loadingIcon:{type:String,default:void 0},link:{type:Boolean,default:!1},severity:{type:String,default:null},raised:{type:Boolean,default:!1},rounded:{type:Boolean,default:!1},text:{type:Boolean,default:!1},outlined:{type:Boolean,default:!1},size:{type:String,default:null},plain:{type:Boolean,default:!1}},style:ButtonStyle,provide:function n(){return{$parentInstance:this}}},script$b={name:"Button",extends:script$1$4,methods:{getPTOptions:function n(t){return this.ptm(t,{context:{disabled:this.disabled}})}},computed:{disabled:function n(){return this.$attrs.disabled||this.$attrs.disabled===""||this.loading},defaultAriaLabel:function n(){return this.label?this.label+(this.badge?" "+this.badge:""):this.$attrs.ariaLabel},hasIcon:function n(){return this.icon||this.$slots.icon}},components:{SpinnerIcon:script$c,Badge:script$e},directives:{ripple:Ripple}},_hoisted_1$8=["aria-label","disabled","data-pc-severity"];function render$a(n,t,r,i,s,o){var l=resolveComponent("SpinnerIcon"),f=resolveComponent("Badge"),u=resolveDirective("ripple");return withDirectives((openBlock(),createElementBlock("button",mergeProps({class:n.cx("root"),type:"button","aria-label":o.defaultAriaLabel,disabled:o.disabled},o.getPTOptions("root"),{"data-pc-name":"button","data-pc-severity":n.severity}),[renderSlot(n.$slots,"default",{},function(){return[n.loading?renderSlot(n.$slots,"loadingicon",{key:0,class:normalizeClass([n.cx("loadingIcon"),n.cx("icon")])},function(){return[n.loadingIcon?(openBlock(),createElementBlock("span",mergeProps({key:0,class:[n.cx("loadingIcon"),n.cx("icon"),n.loadingIcon]},n.ptm("loadingIcon")),null,16)):(openBlock(),createBlock(l,mergeProps({key:1,class:[n.cx("loadingIcon"),n.cx("icon")],spin:""},n.ptm("loadingIcon")),null,16,["class"]))]}):renderSlot(n.$slots,"icon",{key:1,class:normalizeClass([n.cx("icon")])},function(){return[n.icon?(openBlock(),createElementBlock("span",mergeProps({key:0,class:[n.cx("icon"),n.icon,n.iconClass]},n.ptm("icon")),null,16)):createCommentVNode("",!0)]}),createBaseVNode("span",mergeProps({class:n.cx("label")},n.ptm("label")),toDisplayString(n.label||" "),17),n.badge?(openBlock(),createBlock(f,mergeProps({key:2,value:n.badge,class:n.badgeClass,severity:n.badgeSeverity,unstyled:n.unstyled},n.ptm("badge")),null,16,["value","class","severity","unstyled"])):createCommentVNode("",!0)]})],16,_hoisted_1$8)),[[u]])}script$b.render=render$a;var script$a={name:"AngleDownIcon",extends:script$d},_hoisted_1$7=createBaseVNode("path",{d:"M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z",fill:"currentColor"},null,-1),_hoisted_2$5=[_hoisted_1$7];function render$9(n,t,r,i,s,o){return openBlock(),createElementBlock("svg",mergeProps({width:"14",height:"14",viewBox:"0 0 14 14",fill:"none",xmlns:"http://www.w3.org/2000/svg"},n.pti()),_hoisted_2$5,16)}script$a.render=render$9;var script$9={name:"AngleUpIcon",extends:script$d},_hoisted_1$6=createBaseVNode("path",{d:"M10.4134 9.49931C10.3148 9.49977 10.2172 9.48055 10.1262 9.44278C10.0352 9.405 9.95263 9.34942 9.88338 9.27931L6.88338 6.27931L3.88338 9.27931C3.73811 9.34946 3.57409 9.3709 3.41567 9.34044C3.25724 9.30999 3.11286 9.22926 3.00395 9.11025C2.89504 8.99124 2.82741 8.84028 2.8111 8.67978C2.79478 8.51928 2.83065 8.35781 2.91338 8.21931L6.41338 4.71931C6.55401 4.57886 6.74463 4.49997 6.94338 4.49997C7.14213 4.49997 7.33276 4.57886 7.47338 4.71931L10.9734 8.21931C11.1138 8.35994 11.1927 8.55056 11.1927 8.74931C11.1927 8.94806 11.1138 9.13868 10.9734 9.27931C10.9007 9.35315 10.8132 9.41089 10.7168 9.44879C10.6203 9.48669 10.5169 9.5039 10.4134 9.49931Z",fill:"currentColor"},null,-1),_hoisted_2$4=[_hoisted_1$6];function render$8(n,t,r,i,s,o){return openBlock(),createElementBlock("svg",mergeProps({width:"14",height:"14",viewBox:"0 0 14 14",fill:"none",xmlns:"http://www.w3.org/2000/svg"},n.pti()),_hoisted_2$4,16)}script$9.render=render$8;var classes$2={root:function n(t){var r=t.instance,i=t.props;return["p-inputtext p-component",{"p-filled":r.filled,"p-inputtext-sm":i.size==="small","p-inputtext-lg":i.size==="large"}]}},InputTextStyle=BaseStyle.extend({name:"inputtext",classes:classes$2}),script$1$3={name:"BaseInputText",extends:script$f,props:{modelValue:null,size:{type:String,default:null}},style:InputTextStyle,provide:function n(){return{$parentInstance:this}}},script$8={name:"InputText",extends:script$1$3,emits:["update:modelValue"],methods:{getPTOptions:function n(t){return this.ptm(t,{context:{filled:this.filled,disabled:this.$attrs.disabled||this.$attrs.disabled===""}})},onInput:function n(t){this.$emit("update:modelValue",t.target.value)}},computed:{filled:function n(){return this.modelValue!=null&&this.modelValue.toString().length>0}}},_hoisted_1$5=["value"];function render$7(n,t,r,i,s,o){return openBlock(),createElementBlock("input",mergeProps({class:n.cx("root"),value:n.modelValue,onInput:t[0]||(t[0]=function(){return o.onInput&&o.onInput.apply(o,arguments)})},o.getPTOptions("root"),{"data-pc-name":"inputtext"}),null,16,_hoisted_1$5)}script$8.render=render$7;var css$2=`
@layer primevue {
    .p-inputnumber {
        display: inline-flex;
    }

    .p-inputnumber-button {
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 0 0 auto;
    }

    .p-inputnumber-buttons-stacked .p-button.p-inputnumber-button .p-button-label,
    .p-inputnumber-buttons-horizontal .p-button.p-inputnumber-button .p-button-label {
        display: none;
    }

    .p-inputnumber-buttons-stacked .p-button.p-inputnumber-button-up {
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        padding: 0;
    }

    .p-inputnumber-buttons-stacked .p-inputnumber-input {
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
    }

    .p-inputnumber-buttons-stacked .p-button.p-inputnumber-button-down {
        border-top-left-radius: 0;
        border-top-right-radius: 0;
        border-bottom-left-radius: 0;
        padding: 0;
    }

    .p-inputnumber-buttons-stacked .p-inputnumber-button-group {
        display: flex;
        flex-direction: column;
    }

    .p-inputnumber-buttons-stacked .p-inputnumber-button-group .p-button.p-inputnumber-button {
        flex: 1 1 auto;
    }

    .p-inputnumber-buttons-horizontal .p-button.p-inputnumber-button-up {
        order: 3;
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
    }

    .p-inputnumber-buttons-horizontal .p-inputnumber-input {
        order: 2;
        border-radius: 0;
    }

    .p-inputnumber-buttons-horizontal .p-button.p-inputnumber-button-down {
        order: 1;
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
    }

    .p-inputnumber-buttons-vertical {
        flex-direction: column;
    }

    .p-inputnumber-buttons-vertical .p-button.p-inputnumber-button-up {
        order: 1;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        width: 100%;
    }

    .p-inputnumber-buttons-vertical .p-inputnumber-input {
        order: 2;
        border-radius: 0;
        text-align: center;
    }

    .p-inputnumber-buttons-vertical .p-button.p-inputnumber-button-down {
        order: 3;
        border-top-left-radius: 0;
        border-top-right-radius: 0;
        width: 100%;
    }

    .p-inputnumber-input {
        flex: 1 1 auto;
    }

    .p-fluid .p-inputnumber {
        width: 100%;
    }

    .p-fluid .p-inputnumber .p-inputnumber-input {
        width: 1%;
    }

    .p-fluid .p-inputnumber-buttons-vertical .p-inputnumber-input {
        width: 100%;
    }
}
`,classes$1={root:function n(t){var r=t.instance,i=t.props;return["p-inputnumber p-component p-inputwrapper",{"p-inputwrapper-filled":r.filled||i.allowEmpty===!1,"p-inputwrapper-focus":r.focused,"p-inputnumber-buttons-stacked":i.showButtons&&i.buttonLayout==="stacked","p-inputnumber-buttons-horizontal":i.showButtons&&i.buttonLayout==="horizontal","p-inputnumber-buttons-vertical":i.showButtons&&i.buttonLayout==="vertical"}]},input:"p-inputnumber-input",buttonGroup:"p-inputnumber-button-group",incrementButton:function n(t){var r=t.instance,i=t.props;return["p-inputnumber-button p-inputnumber-button-up",{"p-disabled":i.showButtons&&i.max!==null&&r.maxBoundry()}]},decrementButton:function n(t){var r=t.instance,i=t.props;return["p-inputnumber-button p-inputnumber-button-down",{"p-disabled":i.showButtons&&i.min!==null&&r.minBoundry()}]}},InputNumberStyle=BaseStyle.extend({name:"inputnumber",css:css$2,classes:classes$1}),script$1$2={name:"BaseInputNumber",extends:script$f,props:{modelValue:{type:Number,default:null},format:{type:Boolean,default:!0},showButtons:{type:Boolean,default:!1},buttonLayout:{type:String,default:"stacked"},incrementButtonClass:{type:String,default:null},decrementButtonClass:{type:String,default:null},incrementButtonIcon:{type:String,default:void 0},decrementButtonIcon:{type:String,default:void 0},locale:{type:String,default:void 0},localeMatcher:{type:String,default:void 0},mode:{type:String,default:"decimal"},prefix:{type:String,default:null},suffix:{type:String,default:null},currency:{type:String,default:void 0},currencyDisplay:{type:String,default:void 0},useGrouping:{type:Boolean,default:!0},minFractionDigits:{type:Number,default:void 0},maxFractionDigits:{type:Number,default:void 0},min:{type:Number,default:null},max:{type:Number,default:null},step:{type:Number,default:1},allowEmpty:{type:Boolean,default:!0},highlightOnFocus:{type:Boolean,default:!1},readonly:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},placeholder:{type:String,default:null},inputId:{type:String,default:null},inputClass:{type:[String,Object],default:null},inputStyle:{type:Object,default:null},inputProps:{type:null,default:null},incrementButtonProps:{type:null,default:null},decrementButtonProps:{type:null,default:null},ariaLabelledby:{type:String,default:null},ariaLabel:{type:String,default:null}},style:InputNumberStyle,provide:function n(){return{$parentInstance:this}}};function _typeof$3(n){"@babel/helpers - typeof";return _typeof$3=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$3(n)}function ownKeys$3(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$3(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$3(Object(r),!0).forEach(function(i){_defineProperty$3(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$3(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$3(n,t,r){return t=_toPropertyKey$3(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$3(n){var t=_toPrimitive$3(n,"string");return _typeof$3(t)==="symbol"?t:String(t)}function _toPrimitive$3(n,t){if(_typeof$3(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$3(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function _toConsumableArray$1(n){return _arrayWithoutHoles$1(n)||_iterableToArray$1(n)||_unsupportedIterableToArray$1(n)||_nonIterableSpread$1()}function _nonIterableSpread$1(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$1(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray$1(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray$1(n,t)}}function _iterableToArray$1(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function _arrayWithoutHoles$1(n){if(Array.isArray(n))return _arrayLikeToArray$1(n)}function _arrayLikeToArray$1(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}var script$7={name:"InputNumber",extends:script$1$2,emits:["update:modelValue","input","focus","blur"],numberFormat:null,_numeral:null,_decimal:null,_group:null,_minusSign:null,_currency:null,_suffix:null,_prefix:null,_index:null,groupChar:"",isSpecialChar:null,prefixChar:null,suffixChar:null,timer:null,data:function n(){return{d_modelValue:this.modelValue,focused:!1}},watch:{modelValue:function n(t){this.d_modelValue=t},locale:function n(t,r){this.updateConstructParser(t,r)},localeMatcher:function n(t,r){this.updateConstructParser(t,r)},mode:function n(t,r){this.updateConstructParser(t,r)},currency:function n(t,r){this.updateConstructParser(t,r)},currencyDisplay:function n(t,r){this.updateConstructParser(t,r)},useGrouping:function n(t,r){this.updateConstructParser(t,r)},minFractionDigits:function n(t,r){this.updateConstructParser(t,r)},maxFractionDigits:function n(t,r){this.updateConstructParser(t,r)},suffix:function n(t,r){this.updateConstructParser(t,r)},prefix:function n(t,r){this.updateConstructParser(t,r)}},created:function n(){this.constructParser()},methods:{getOptions:function n(){return{localeMatcher:this.localeMatcher,style:this.mode,currency:this.currency,currencyDisplay:this.currencyDisplay,useGrouping:this.useGrouping,minimumFractionDigits:this.minFractionDigits,maximumFractionDigits:this.maxFractionDigits}},constructParser:function n(){this.numberFormat=new Intl.NumberFormat(this.locale,this.getOptions());var t=_toConsumableArray$1(new Intl.NumberFormat(this.locale,{useGrouping:!1}).format(9876543210)).reverse(),r=new Map(t.map(function(i,s){return[i,s]}));this._numeral=new RegExp("[".concat(t.join(""),"]"),"g"),this._group=this.getGroupingExpression(),this._minusSign=this.getMinusSignExpression(),this._currency=this.getCurrencyExpression(),this._decimal=this.getDecimalExpression(),this._suffix=this.getSuffixExpression(),this._prefix=this.getPrefixExpression(),this._index=function(i){return r.get(i)}},updateConstructParser:function n(t,r){t!==r&&this.constructParser()},escapeRegExp:function n(t){return t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")},getDecimalExpression:function n(){var t=new Intl.NumberFormat(this.locale,_objectSpread$3(_objectSpread$3({},this.getOptions()),{},{useGrouping:!1}));return new RegExp("[".concat(t.format(1.1).replace(this._currency,"").trim().replace(this._numeral,""),"]"),"g")},getGroupingExpression:function n(){var t=new Intl.NumberFormat(this.locale,{useGrouping:!0});return this.groupChar=t.format(1e6).trim().replace(this._numeral,"").charAt(0),new RegExp("[".concat(this.groupChar,"]"),"g")},getMinusSignExpression:function n(){var t=new Intl.NumberFormat(this.locale,{useGrouping:!1});return new RegExp("[".concat(t.format(-1).trim().replace(this._numeral,""),"]"),"g")},getCurrencyExpression:function n(){if(this.currency){var t=new Intl.NumberFormat(this.locale,{style:"currency",currency:this.currency,currencyDisplay:this.currencyDisplay,minimumFractionDigits:0,maximumFractionDigits:0});return new RegExp("[".concat(t.format(1).replace(/\s/g,"").replace(this._numeral,"").replace(this._group,""),"]"),"g")}return new RegExp("[]","g")},getPrefixExpression:function n(){if(this.prefix)this.prefixChar=this.prefix;else{var t=new Intl.NumberFormat(this.locale,{style:this.mode,currency:this.currency,currencyDisplay:this.currencyDisplay});this.prefixChar=t.format(1).split("1")[0]}return new RegExp("".concat(this.escapeRegExp(this.prefixChar||"")),"g")},getSuffixExpression:function n(){if(this.suffix)this.suffixChar=this.suffix;else{var t=new Intl.NumberFormat(this.locale,{style:this.mode,currency:this.currency,currencyDisplay:this.currencyDisplay,minimumFractionDigits:0,maximumFractionDigits:0});this.suffixChar=t.format(1).split("1")[1]}return new RegExp("".concat(this.escapeRegExp(this.suffixChar||"")),"g")},formatValue:function n(t){if(t!=null){if(t==="-")return t;if(this.format){var r=new Intl.NumberFormat(this.locale,this.getOptions()),i=r.format(t);return this.prefix&&(i=this.prefix+i),this.suffix&&(i=i+this.suffix),i}return t.toString()}return""},parseValue:function n(t){var r=t.replace(this._suffix,"").replace(this._prefix,"").trim().replace(/\s/g,"").replace(this._currency,"").replace(this._group,"").replace(this._minusSign,"-").replace(this._decimal,".").replace(this._numeral,this._index);if(r){if(r==="-")return r;var i=+r;return isNaN(i)?null:i}return null},repeat:function n(t,r,i){var s=this;if(!this.readonly){var o=r||500;this.clearTimer(),this.timer=setTimeout(function(){s.repeat(t,40,i)},o),this.spin(t,i)}},spin:function n(t,r){if(this.$refs.input){var i=this.step*r,s=this.parseValue(this.$refs.input.$el.value)||0,o=this.validateValue(s+i);this.updateInput(o,null,"spin"),this.updateModel(t,o),this.handleOnInput(t,s,o)}},onUpButtonMouseDown:function n(t){this.disabled||(this.$refs.input.$el.focus(),this.repeat(t,null,1),t.preventDefault())},onUpButtonMouseUp:function n(){this.disabled||this.clearTimer()},onUpButtonMouseLeave:function n(){this.disabled||this.clearTimer()},onUpButtonKeyUp:function n(){this.disabled||this.clearTimer()},onUpButtonKeyDown:function n(t){(t.keyCode===32||t.keyCode===13)&&this.repeat(t,null,1)},onDownButtonMouseDown:function n(t){this.disabled||(this.$refs.input.$el.focus(),this.repeat(t,null,-1),t.preventDefault())},onDownButtonMouseUp:function n(){this.disabled||this.clearTimer()},onDownButtonMouseLeave:function n(){this.disabled||this.clearTimer()},onDownButtonKeyUp:function n(){this.disabled||this.clearTimer()},onDownButtonKeyDown:function n(t){(t.keyCode===32||t.keyCode===13)&&this.repeat(t,null,-1)},onUserInput:function n(){this.isSpecialChar&&(this.$refs.input.$el.value=this.lastValue),this.isSpecialChar=!1},onInputKeyDown:function n(t){if(!this.readonly){if(this.lastValue=t.target.value,t.shiftKey||t.altKey){this.isSpecialChar=!0;return}var r=t.target.selectionStart,i=t.target.selectionEnd,s=t.target.value,o=null;switch(t.altKey&&t.preventDefault(),t.code){case"ArrowUp":this.spin(t,1),t.preventDefault();break;case"ArrowDown":this.spin(t,-1),t.preventDefault();break;case"ArrowLeft":this.isNumeralChar(s.charAt(r-1))||t.preventDefault();break;case"ArrowRight":this.isNumeralChar(s.charAt(r))||t.preventDefault();break;case"Tab":case"Enter":case"NumpadEnter":o=this.validateValue(this.parseValue(s)),this.$refs.input.$el.value=this.formatValue(o),this.$refs.input.$el.setAttribute("aria-valuenow",o),this.updateModel(t,o);break;case"Backspace":{if(t.preventDefault(),r===i){var l=s.charAt(r-1),f=this.getDecimalCharIndexes(s),u=f.decimalCharIndex,_=f.decimalCharIndexWithoutPrefix;if(this.isNumeralChar(l)){var g=this.getDecimalLength(s);if(this._group.test(l))this._group.lastIndex=0,o=s.slice(0,r-2)+s.slice(r-1);else if(this._decimal.test(l))this._decimal.lastIndex=0,g?this.$refs.input.$el.setSelectionRange(r-1,r-1):o=s.slice(0,r-1)+s.slice(r);else if(u>0&&r>u){var a=this.isDecimalMode()&&(this.minFractionDigits||0)<g?"":"0";o=s.slice(0,r-1)+a+s.slice(r)}else _===1?(o=s.slice(0,r-1)+"0"+s.slice(r),o=this.parseValue(o)>0?o:""):o=s.slice(0,r-1)+s.slice(r)}this.updateValue(t,o,null,"delete-single")}else o=this.deleteRange(s,r,i),this.updateValue(t,o,null,"delete-range");break}case"Delete":if(t.preventDefault(),r===i){var m=s.charAt(r),b=this.getDecimalCharIndexes(s),v=b.decimalCharIndex,c=b.decimalCharIndexWithoutPrefix;if(this.isNumeralChar(m)){var w=this.getDecimalLength(s);if(this._group.test(m))this._group.lastIndex=0,o=s.slice(0,r)+s.slice(r+2);else if(this._decimal.test(m))this._decimal.lastIndex=0,w?this.$refs.input.$el.setSelectionRange(r+1,r+1):o=s.slice(0,r)+s.slice(r+1);else if(v>0&&r>v){var k=this.isDecimalMode()&&(this.minFractionDigits||0)<w?"":"0";o=s.slice(0,r)+k+s.slice(r+1)}else c===1?(o=s.slice(0,r)+"0"+s.slice(r+1),o=this.parseValue(o)>0?o:""):o=s.slice(0,r)+s.slice(r+1)}this.updateValue(t,o,null,"delete-back-single")}else o=this.deleteRange(s,r,i),this.updateValue(t,o,null,"delete-range");break;case"Home":this.min&&(this.updateModel(t,this.min),t.preventDefault());break;case"End":this.max&&(this.updateModel(t,this.max),t.preventDefault());break}}},onInputKeyPress:function n(t){if(!this.readonly){t.preventDefault();var r=t.which||t.keyCode,i=String.fromCharCode(r),s=this.isDecimalSign(i),o=this.isMinusSign(i);(48<=r&&r<=57||o||s)&&this.insert(t,i,{isDecimalSign:s,isMinusSign:o})}},onPaste:function n(t){t.preventDefault();var r=(t.clipboardData||window.clipboardData).getData("Text");if(r){var i=this.parseValue(r);i!=null&&this.insert(t,i.toString())}},allowMinusSign:function n(){return this.min===null||this.min<0},isMinusSign:function n(t){return this._minusSign.test(t)||t==="-"?(this._minusSign.lastIndex=0,!0):!1},isDecimalSign:function n(t){return this._decimal.test(t)?(this._decimal.lastIndex=0,!0):!1},isDecimalMode:function n(){return this.mode==="decimal"},getDecimalCharIndexes:function n(t){var r=t.search(this._decimal);this._decimal.lastIndex=0;var i=t.replace(this._prefix,"").trim().replace(/\s/g,"").replace(this._currency,""),s=i.search(this._decimal);return this._decimal.lastIndex=0,{decimalCharIndex:r,decimalCharIndexWithoutPrefix:s}},getCharIndexes:function n(t){var r=t.search(this._decimal);this._decimal.lastIndex=0;var i=t.search(this._minusSign);this._minusSign.lastIndex=0;var s=t.search(this._suffix);this._suffix.lastIndex=0;var o=t.search(this._currency);return this._currency.lastIndex=0,{decimalCharIndex:r,minusCharIndex:i,suffixCharIndex:s,currencyCharIndex:o}},insert:function n(t,r){var i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{isDecimalSign:!1,isMinusSign:!1},s=r.search(this._minusSign);if(this._minusSign.lastIndex=0,!(!this.allowMinusSign()&&s!==-1)){var o=this.$refs.input.$el.selectionStart,l=this.$refs.input.$el.selectionEnd,f=this.$refs.input.$el.value.trim(),u=this.getCharIndexes(f),_=u.decimalCharIndex,g=u.minusCharIndex,a=u.suffixCharIndex,m=u.currencyCharIndex,b;if(i.isMinusSign)o===0&&(b=f,(g===-1||l!==0)&&(b=this.insertText(f,r,0,l)),this.updateValue(t,b,r,"insert"));else if(i.isDecimalSign)_>0&&o===_?this.updateValue(t,f,r,"insert"):_>o&&_<l?(b=this.insertText(f,r,o,l),this.updateValue(t,b,r,"insert")):_===-1&&this.maxFractionDigits&&(b=this.insertText(f,r,o,l),this.updateValue(t,b,r,"insert"));else{var v=this.numberFormat.resolvedOptions().maximumFractionDigits,c=o!==l?"range-insert":"insert";if(_>0&&o>_){if(o+r.length-(_+1)<=v){var w=m>=o?m-1:a>=o?a:f.length;b=f.slice(0,o)+r+f.slice(o+r.length,w)+f.slice(w),this.updateValue(t,b,r,c)}}else b=this.insertText(f,r,o,l),this.updateValue(t,b,r,c)}}},insertText:function n(t,r,i,s){var o=r==="."?r:r.split(".");if(o.length===2){var l=t.slice(i,s).search(this._decimal);return this._decimal.lastIndex=0,l>0?t.slice(0,i)+this.formatValue(r)+t.slice(s):t||this.formatValue(r)}else return s-i===t.length?this.formatValue(r):i===0?r+t.slice(s):s===t.length?t.slice(0,i)+r:t.slice(0,i)+r+t.slice(s)},deleteRange:function n(t,r,i){var s;return i-r===t.length?s="":r===0?s=t.slice(i):i===t.length?s=t.slice(0,r):s=t.slice(0,r)+t.slice(i),s},initCursor:function n(){var t=this.$refs.input.$el.selectionStart,r=this.$refs.input.$el.value,i=r.length,s=null,o=(this.prefixChar||"").length;r=r.replace(this._prefix,""),t=t-o;var l=r.charAt(t);if(this.isNumeralChar(l))return t+o;for(var f=t-1;f>=0;)if(l=r.charAt(f),this.isNumeralChar(l)){s=f+o;break}else f--;if(s!==null)this.$refs.input.$el.setSelectionRange(s+1,s+1);else{for(f=t;f<i;)if(l=r.charAt(f),this.isNumeralChar(l)){s=f+o;break}else f++;s!==null&&this.$refs.input.$el.setSelectionRange(s,s)}return s||0},onInputClick:function n(){var t=this.$refs.input.$el.value;!this.readonly&&t!==DomHandler.getSelection()&&this.initCursor()},isNumeralChar:function n(t){return t.length===1&&(this._numeral.test(t)||this._decimal.test(t)||this._group.test(t)||this._minusSign.test(t))?(this.resetRegex(),!0):!1},resetRegex:function n(){this._numeral.lastIndex=0,this._decimal.lastIndex=0,this._group.lastIndex=0,this._minusSign.lastIndex=0},updateValue:function n(t,r,i,s){var o=this.$refs.input.$el.value,l=null;r!=null&&(l=this.parseValue(r),l=!l&&!this.allowEmpty?0:l,this.updateInput(l,i,s,r),this.handleOnInput(t,o,l))},handleOnInput:function n(t,r,i){this.isValueChanged(r,i)&&this.$emit("input",{originalEvent:t,value:i,formattedValue:r})},isValueChanged:function n(t,r){if(r===null&&t!==null)return!0;if(r!=null){var i=typeof t=="string"?this.parseValue(t):t;return r!==i}return!1},validateValue:function n(t){return t==="-"||t==null?null:this.min!=null&&t<this.min?this.min:this.max!=null&&t>this.max?this.max:t},updateInput:function n(t,r,i,s){r=r||"";var o=this.$refs.input.$el.value,l=this.formatValue(t),f=o.length;if(l!==s&&(l=this.concatValues(l,s)),f===0){this.$refs.input.$el.value=l,this.$refs.input.$el.setSelectionRange(0,0);var u=this.initCursor(),_=u+r.length;this.$refs.input.$el.setSelectionRange(_,_)}else{var g=this.$refs.input.$el.selectionStart,a=this.$refs.input.$el.selectionEnd;this.$refs.input.$el.value=l;var m=l.length;if(i==="range-insert"){var b=this.parseValue((o||"").slice(0,g)),v=b!==null?b.toString():"",c=v.split("").join("(".concat(this.groupChar,")?")),w=new RegExp(c,"g");w.test(l);var k=r.split("").join("(".concat(this.groupChar,")?")),x=new RegExp(k,"g");x.test(l.slice(w.lastIndex)),a=w.lastIndex+x.lastIndex,this.$refs.input.$el.setSelectionRange(a,a)}else if(m===f)i==="insert"||i==="delete-back-single"?this.$refs.input.$el.setSelectionRange(a+1,a+1):i==="delete-single"?this.$refs.input.$el.setSelectionRange(a-1,a-1):(i==="delete-range"||i==="spin")&&this.$refs.input.$el.setSelectionRange(a,a);else if(i==="delete-back-single"){var E=o.charAt(a-1),O=o.charAt(a),A=f-m,T=this._group.test(O);T&&A===1?a+=1:!T&&this.isNumeralChar(E)&&(a+=-1*A+1),this._group.lastIndex=0,this.$refs.input.$el.setSelectionRange(a,a)}else if(o==="-"&&i==="insert"){this.$refs.input.$el.setSelectionRange(0,0);var j=this.initCursor(),I=j+r.length+1;this.$refs.input.$el.setSelectionRange(I,I)}else a=a+(m-f),this.$refs.input.$el.setSelectionRange(a,a)}this.$refs.input.$el.setAttribute("aria-valuenow",t)},concatValues:function n(t,r){if(t&&r){var i=r.search(this._decimal);return this._decimal.lastIndex=0,this.suffixChar?i!==-1?t.replace(this.suffixChar,"").split(this._decimal)[0]+r.replace(this.suffixChar,"").slice(i)+this.suffixChar:t:i!==-1?t.split(this._decimal)[0]+r.slice(i):t}return t},getDecimalLength:function n(t){if(t){var r=t.split(this._decimal);if(r.length===2)return r[1].replace(this._suffix,"").trim().replace(/\s/g,"").replace(this._currency,"").length}return 0},updateModel:function n(t,r){this.d_modelValue=r,this.$emit("update:modelValue",r)},onInputFocus:function n(t){this.focused=!0,!this.disabled&&!this.readonly&&this.$refs.input.$el.value!==DomHandler.getSelection()&&this.highlightOnFocus&&t.target.select(),this.$emit("focus",t)},onInputBlur:function n(t){this.focused=!1;var r=t.target,i=this.validateValue(this.parseValue(r.value));this.$emit("blur",{originalEvent:t,value:r.value}),r.value=this.formatValue(i),r.setAttribute("aria-valuenow",i),this.updateModel(t,i)},clearTimer:function n(){this.timer&&clearInterval(this.timer)},maxBoundry:function n(){return this.d_modelValue>=this.max},minBoundry:function n(){return this.d_modelValue<=this.min}},computed:{filled:function n(){return this.modelValue!=null&&this.modelValue.toString().length>0},upButtonListeners:function n(){var t=this;return{mousedown:function(i){return t.onUpButtonMouseDown(i)},mouseup:function(i){return t.onUpButtonMouseUp(i)},mouseleave:function(i){return t.onUpButtonMouseLeave(i)},keydown:function(i){return t.onUpButtonKeyDown(i)},keyup:function(i){return t.onUpButtonKeyUp(i)}}},downButtonListeners:function n(){var t=this;return{mousedown:function(i){return t.onDownButtonMouseDown(i)},mouseup:function(i){return t.onDownButtonMouseUp(i)},mouseleave:function(i){return t.onDownButtonMouseLeave(i)},keydown:function(i){return t.onDownButtonKeyDown(i)},keyup:function(i){return t.onDownButtonKeyUp(i)}}},formattedValue:function n(){var t=!this.modelValue&&!this.allowEmpty?0:this.modelValue;return this.formatValue(t)},getFormatter:function n(){return this.numberFormat}},components:{INInputText:script$8,INButton:script$b,AngleUpIcon:script$9,AngleDownIcon:script$a}};function render$6(n,t,r,i,s,o){var l=resolveComponent("INInputText"),f=resolveComponent("INButton");return openBlock(),createElementBlock("span",mergeProps({class:n.cx("root")},n.ptm("root"),{"data-pc-name":"inputnumber"}),[createVNode(l,mergeProps({ref:"input",id:n.inputId,role:"spinbutton",class:[n.cx("input"),n.inputClass],style:n.inputStyle,value:o.formattedValue,"aria-valuemin":n.min,"aria-valuemax":n.max,"aria-valuenow":n.modelValue,disabled:n.disabled,readonly:n.readonly,placeholder:n.placeholder,"aria-labelledby":n.ariaLabelledby,"aria-label":n.ariaLabel,onInput:o.onUserInput,onKeydown:o.onInputKeyDown,onKeypress:o.onInputKeyPress,onPaste:o.onPaste,onClick:o.onInputClick,onFocus:o.onInputFocus,onBlur:o.onInputBlur},n.inputProps,{pt:n.ptm("input"),unstyled:n.unstyled,"data-pc-section":"input"}),null,16,["id","class","style","value","aria-valuemin","aria-valuemax","aria-valuenow","disabled","readonly","placeholder","aria-labelledby","aria-label","onInput","onKeydown","onKeypress","onPaste","onClick","onFocus","onBlur","pt","unstyled"]),n.showButtons&&n.buttonLayout==="stacked"?(openBlock(),createElementBlock("span",mergeProps({key:0,class:n.cx("buttonGroup")},n.ptm("buttonGroup")),[createVNode(f,mergeProps({class:[n.cx("incrementButton"),n.incrementButtonClass]},toHandlers(o.upButtonListeners),{disabled:n.disabled,tabindex:-1,"aria-hidden":"true"},n.incrementButtonProps,{pt:n.ptm("incrementButton"),unstyled:n.unstyled,"data-pc-section":"incrementbutton"}),{icon:withCtx(function(){return[renderSlot(n.$slots,"incrementbuttonicon",{},function(){return[(openBlock(),createBlock(resolveDynamicComponent(n.incrementButtonIcon?"span":"AngleUpIcon"),mergeProps({class:n.incrementButtonIcon},n.ptm("incrementButton").icon,{"data-pc-section":"incrementbuttonicon"}),null,16,["class"]))]})]}),_:3},16,["class","disabled","pt","unstyled"]),createVNode(f,mergeProps({class:[n.cx("decrementButton"),n.decrementButtonClass]},toHandlers(o.downButtonListeners),{disabled:n.disabled,tabindex:-1,"aria-hidden":"true"},n.decrementButtonProps,{pt:n.ptm("decrementButton"),unstyled:n.unstyled,"data-pc-section":"decrementbutton"}),{icon:withCtx(function(){return[renderSlot(n.$slots,"decrementbuttonicon",{},function(){return[(openBlock(),createBlock(resolveDynamicComponent(n.decrementButtonIcon?"span":"AngleDownIcon"),mergeProps({class:n.decrementButtonIcon},n.ptm("decrementButton").icon,{"data-pc-section":"decrementbuttonicon"}),null,16,["class"]))]})]}),_:3},16,["class","disabled","pt","unstyled"])],16)):createCommentVNode("",!0),n.showButtons&&n.buttonLayout!=="stacked"?(openBlock(),createBlock(f,mergeProps({key:1,class:[n.cx("incrementButton"),n.incrementButtonClass]},toHandlers(o.upButtonListeners),{disabled:n.disabled,tabindex:-1,"aria-hidden":"true"},n.incrementButtonProps,{pt:n.ptm("incrementButton"),unstyled:n.unstyled,"data-pc-section":"incrementbutton"}),{icon:withCtx(function(){return[renderSlot(n.$slots,"incrementbuttonicon",{},function(){return[(openBlock(),createBlock(resolveDynamicComponent(n.incrementButtonIcon?"span":"AngleUpIcon"),mergeProps({class:n.incrementButtonIcon},n.ptm("incrementButton").icon,{"data-pc-section":"incrementbuttonicon"}),null,16,["class"]))]})]}),_:3},16,["class","disabled","pt","unstyled"])):createCommentVNode("",!0),n.showButtons&&n.buttonLayout!=="stacked"?(openBlock(),createBlock(f,mergeProps({key:2,class:[n.cx("decrementButton"),n.decrementButtonClass]},toHandlers(o.downButtonListeners),{disabled:n.disabled,tabindex:-1,"aria-hidden":"true"},n.decrementButtonProps,{pt:n.ptm("decrementButton"),unstyled:n.unstyled,"data-pc-section":"decrementbutton"}),{icon:withCtx(function(){return[renderSlot(n.$slots,"decrementbuttonicon",{},function(){return[(openBlock(),createBlock(resolveDynamicComponent(n.decrementButtonIcon?"span":"AngleDownIcon"),mergeProps({class:n.decrementButtonIcon},n.ptm("decrementButton").icon,{"data-pc-section":"decrementbuttonicon"}),null,16,["class"]))]})]}),_:3},16,["class","disabled","pt","unstyled"])):createCommentVNode("",!0)],16)}script$7.render=render$6;var script$6={name:"ChevronDownIcon",extends:script$d},_hoisted_1$4=createBaseVNode("path",{d:"M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z",fill:"currentColor"},null,-1),_hoisted_2$3=[_hoisted_1$4];function render$5(n,t,r,i,s,o){return openBlock(),createElementBlock("svg",mergeProps({width:"14",height:"14",viewBox:"0 0 14 14",fill:"none",xmlns:"http://www.w3.org/2000/svg"},n.pti()),_hoisted_2$3,16)}script$6.render=render$5;var script$5={name:"FilterIcon",extends:script$d,computed:{pathId:function n(){return"pv_icon_clip_".concat(UniqueComponentId())}}},_hoisted_1$3=["clipPath"],_hoisted_2$2=createBaseVNode("path",{d:"M8.64708 14H5.35296C5.18981 13.9979 5.03395 13.9321 4.91858 13.8167C4.8032 13.7014 4.73745 13.5455 4.73531 13.3824V7L0.329431 0.98C0.259794 0.889466 0.217389 0.780968 0.20718 0.667208C0.19697 0.553448 0.219379 0.439133 0.271783 0.337647C0.324282 0.236453 0.403423 0.151519 0.500663 0.0920138C0.597903 0.0325088 0.709548 0.000692754 0.823548 0H13.1765C13.2905 0.000692754 13.4021 0.0325088 13.4994 0.0920138C13.5966 0.151519 13.6758 0.236453 13.7283 0.337647C13.7807 0.439133 13.8031 0.553448 13.7929 0.667208C13.7826 0.780968 13.7402 0.889466 13.6706 0.98L9.26472 7V13.3824C9.26259 13.5455 9.19683 13.7014 9.08146 13.8167C8.96609 13.9321 8.81022 13.9979 8.64708 14ZM5.97061 12.7647H8.02943V6.79412C8.02878 6.66289 8.07229 6.53527 8.15296 6.43177L11.9412 1.23529H2.05884L5.86355 6.43177C5.94422 6.53527 5.98773 6.66289 5.98708 6.79412L5.97061 12.7647Z",fill:"currentColor"},null,-1),_hoisted_3$1=[_hoisted_2$2],_hoisted_4$1=["id"],_hoisted_5$1=createBaseVNode("rect",{width:"14",height:"14",fill:"white"},null,-1),_hoisted_6$1=[_hoisted_5$1];function render$4(n,t,r,i,s,o){return openBlock(),createElementBlock("svg",mergeProps({width:"14",height:"14",viewBox:"0 0 14 14",fill:"none",xmlns:"http://www.w3.org/2000/svg"},n.pti()),[createBaseVNode("g",{clipPath:"url(#".concat(o.pathId,")")},_hoisted_3$1,8,_hoisted_1$3),createBaseVNode("defs",null,[createBaseVNode("clipPath",{id:"".concat(o.pathId)},_hoisted_6$1,8,_hoisted_4$1)])],16)}script$5.render=render$4;var script$4={name:"TimesIcon",extends:script$d},_hoisted_1$2=createBaseVNode("path",{d:"M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",fill:"currentColor"},null,-1),_hoisted_2$1=[_hoisted_1$2];function render$3(n,t,r,i,s,o){return openBlock(),createElementBlock("svg",mergeProps({width:"14",height:"14",viewBox:"0 0 14 14",fill:"none",xmlns:"http://www.w3.org/2000/svg"},n.pti()),_hoisted_2$1,16)}script$4.render=render$3;var OverlayEventBus=primebus(),script$3={name:"Portal",props:{appendTo:{type:String,default:"body"},disabled:{type:Boolean,default:!1}},data:function n(){return{mounted:!1}},mounted:function n(){this.mounted=DomHandler.isClient()},computed:{inline:function n(){return this.disabled||this.appendTo==="self"}}};function render$2(n,t,r,i,s,o){return o.inline?renderSlot(n.$slots,"default",{key:0}):s.mounted?(openBlock(),createBlock(Teleport,{key:1,to:r.appendTo},[renderSlot(n.$slots,"default")],8,["to"])):createCommentVNode("",!0)}script$3.render=render$2;var css$1=`
.p-virtualscroller {
    position: relative;
    overflow: auto;
    contain: strict;
    transform: translateZ(0);
    will-change: scroll-position;
    outline: 0 none;
}

.p-virtualscroller-content {
    position: absolute;
    top: 0;
    left: 0;
    /* contain: content; */
    min-height: 100%;
    min-width: 100%;
    will-change: transform;
}

.p-virtualscroller-spacer {
    position: absolute;
    top: 0;
    left: 0;
    height: 1px;
    width: 1px;
    transform-origin: 0 0;
    pointer-events: none;
}

.p-virtualscroller .p-virtualscroller-loader {
    position: sticky;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.p-virtualscroller-loader.p-component-overlay {
    display: flex;
    align-items: center;
    justify-content: center;
}

.p-virtualscroller-loading-icon {
    font-size: 2rem;
}

.p-virtualscroller-loading-icon.p-icon {
    width: 2rem;
    height: 2rem;
}

.p-virtualscroller-horizontal > .p-virtualscroller-content {
    display: flex;
}

/* Inline */
.p-virtualscroller-inline .p-virtualscroller-content {
    position: static;
}
`,VirtualScrollerStyle=BaseStyle.extend({name:"virtualscroller",css:css$1}),script$1$1={name:"BaseVirtualScroller",extends:script$f,props:{id:{type:String,default:null},style:null,class:null,items:{type:Array,default:null},itemSize:{type:[Number,Array],default:0},scrollHeight:null,scrollWidth:null,orientation:{type:String,default:"vertical"},numToleratedItems:{type:Number,default:null},delay:{type:Number,default:0},resizeDelay:{type:Number,default:10},lazy:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},loaderDisabled:{type:Boolean,default:!1},columns:{type:Array,default:null},loading:{type:Boolean,default:!1},showSpacer:{type:Boolean,default:!0},showLoader:{type:Boolean,default:!1},tabindex:{type:Number,default:0},inline:{type:Boolean,default:!1},step:{type:Number,default:0},appendOnly:{type:Boolean,default:!1},autoSize:{type:Boolean,default:!1}},style:VirtualScrollerStyle,provide:function n(){return{$parentInstance:this}},beforeMount:function n(){VirtualScrollerStyle.loadStyle()}};function _typeof$2(n){"@babel/helpers - typeof";return _typeof$2=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$2(n)}function ownKeys$2(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$2(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$2(Object(r),!0).forEach(function(i){_defineProperty$2(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$2(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$2(n,t,r){return t=_toPropertyKey$2(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$2(n){var t=_toPrimitive$2(n,"string");return _typeof$2(t)==="symbol"?t:String(t)}function _toPrimitive$2(n,t){if(_typeof$2(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$2(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var script$2={name:"VirtualScroller",extends:script$1$1,emits:["update:numToleratedItems","scroll","scroll-index-change","lazy-load"],data:function n(){return{first:this.isBoth()?{rows:0,cols:0}:0,last:this.isBoth()?{rows:0,cols:0}:0,page:this.isBoth()?{rows:0,cols:0}:0,numItemsInViewport:this.isBoth()?{rows:0,cols:0}:0,lastScrollPos:this.isBoth()?{top:0,left:0}:0,d_numToleratedItems:this.numToleratedItems,d_loading:this.loading,loaderArr:[],spacerStyle:{},contentStyle:{}}},element:null,content:null,lastScrollPos:null,scrollTimeout:null,resizeTimeout:null,defaultWidth:0,defaultHeight:0,defaultContentWidth:0,defaultContentHeight:0,isRangeChanged:!1,lazyLoadState:{},resizeListener:null,initialized:!1,watch:{numToleratedItems:function n(t){this.d_numToleratedItems=t},loading:function n(t){this.d_loading=t},items:function n(t,r){(!r||r.length!==(t||[]).length)&&(this.init(),this.calculateAutoSize())},itemSize:function n(){this.init(),this.calculateAutoSize()},orientation:function n(){this.lastScrollPos=this.isBoth()?{top:0,left:0}:0},scrollHeight:function n(){this.init(),this.calculateAutoSize()},scrollWidth:function n(){this.init(),this.calculateAutoSize()}},mounted:function n(){this.viewInit(),this.lastScrollPos=this.isBoth()?{top:0,left:0}:0,this.lazyLoadState=this.lazyLoadState||{}},updated:function n(){!this.initialized&&this.viewInit()},unmounted:function n(){this.unbindResizeListener(),this.initialized=!1},methods:{viewInit:function n(){DomHandler.isVisible(this.element)&&(this.setContentEl(this.content),this.init(),this.bindResizeListener(),this.defaultWidth=DomHandler.getWidth(this.element),this.defaultHeight=DomHandler.getHeight(this.element),this.defaultContentWidth=DomHandler.getWidth(this.content),this.defaultContentHeight=DomHandler.getHeight(this.content),this.initialized=!0)},init:function n(){this.disabled||(this.setSize(),this.calculateOptions(),this.setSpacerSize())},isVertical:function n(){return this.orientation==="vertical"},isHorizontal:function n(){return this.orientation==="horizontal"},isBoth:function n(){return this.orientation==="both"},scrollTo:function n(t){this.lastScrollPos=this.both?{top:0,left:0}:0,this.element&&this.element.scrollTo(t)},scrollToIndex:function n(t){var r=this,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"auto",s=this.isBoth(),o=this.isHorizontal(),l=this.first,f=this.calculateNumItems(),u=f.numToleratedItems,_=this.getContentPosition(),g=this.itemSize,a=function(){var k=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,x=arguments.length>1?arguments[1]:void 0;return k<=x?0:k},m=function(k,x,E){return k*x+E},b=function(){var k=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,x=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return r.scrollTo({left:k,top:x,behavior:i})},v=s?{rows:0,cols:0}:0,c=!1;s?(v={rows:a(t[0],u[0]),cols:a(t[1],u[1])},b(m(v.cols,g[1],_.left),m(v.rows,g[0],_.top)),c=v.rows!==l.rows||v.cols!==l.cols):(v=a(t,u),o?b(m(v,g,_.left),0):b(0,m(v,g,_.top)),c=v!==l),this.isRangeChanged=c,this.first=v},scrollInView:function n(t,r){var i=this,s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"auto";if(r){var o=this.isBoth(),l=this.isHorizontal(),f=this.getRenderedRange(),u=f.first,_=f.viewport,g=function(){var w=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,k=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return i.scrollTo({left:w,top:k,behavior:s})},a=r==="to-start",m=r==="to-end";if(a){if(o)_.first.rows-u.rows>t[0]?g(_.first.cols*this.itemSize[1],(_.first.rows-1)*this.itemSize[0]):_.first.cols-u.cols>t[1]&&g((_.first.cols-1)*this.itemSize[1],_.first.rows*this.itemSize[0]);else if(_.first-u>t){var b=(_.first-1)*this.itemSize;l?g(b,0):g(0,b)}}else if(m){if(o)_.last.rows-u.rows<=t[0]+1?g(_.first.cols*this.itemSize[1],(_.first.rows+1)*this.itemSize[0]):_.last.cols-u.cols<=t[1]+1&&g((_.first.cols+1)*this.itemSize[1],_.first.rows*this.itemSize[0]);else if(_.last-u<=t+1){var v=(_.first+1)*this.itemSize;l?g(v,0):g(0,v)}}}else this.scrollToIndex(t,s)},getRenderedRange:function n(){var t=function(a,m){return Math.floor(a/(m||a))},r=this.first,i=0;if(this.element){var s=this.isBoth(),o=this.isHorizontal(),l=this.element.scrollTop,f=l.scrollTop,u=l.scrollLeft;if(s)r={rows:t(f,this.itemSize[0]),cols:t(u,this.itemSize[1])},i={rows:r.rows+this.numItemsInViewport.rows,cols:r.cols+this.numItemsInViewport.cols};else{var _=o?u:f;r=t(_,this.itemSize),i=r+this.numItemsInViewport}}return{first:this.first,last:this.last,viewport:{first:r,last:i}}},calculateNumItems:function n(){var t=this.isBoth(),r=this.isHorizontal(),i=this.itemSize,s=this.getContentPosition(),o=this.element?this.element.offsetWidth-s.left:0,l=this.element?this.element.offsetHeight-s.top:0,f=function(m,b){return Math.ceil(m/(b||m))},u=function(m){return Math.ceil(m/2)},_=t?{rows:f(l,i[0]),cols:f(o,i[1])}:f(r?o:l,i),g=this.d_numToleratedItems||(t?[u(_.rows),u(_.cols)]:u(_));return{numItemsInViewport:_,numToleratedItems:g}},calculateOptions:function n(){var t=this,r=this.isBoth(),i=this.first,s=this.calculateNumItems(),o=s.numItemsInViewport,l=s.numToleratedItems,f=function(g,a,m){var b=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1;return t.getLast(g+a+(g<m?2:3)*m,b)},u=r?{rows:f(i.rows,o.rows,l[0]),cols:f(i.cols,o.cols,l[1],!0)}:f(i,o,l);this.last=u,this.numItemsInViewport=o,this.d_numToleratedItems=l,this.$emit("update:numToleratedItems",this.d_numToleratedItems),this.showLoader&&(this.loaderArr=r?Array.from({length:o.rows}).map(function(){return Array.from({length:o.cols})}):Array.from({length:o})),this.lazy&&Promise.resolve().then(function(){t.lazyLoadState={first:t.step?r?{rows:0,cols:i.cols}:0:i,last:Math.min(t.step?t.step:u,t.items.length)},t.$emit("lazy-load",t.lazyLoadState)})},calculateAutoSize:function n(){var t=this;this.autoSize&&!this.d_loading&&Promise.resolve().then(function(){if(t.content){var r=t.isBoth(),i=t.isHorizontal(),s=t.isVertical();t.content.style.minHeight=t.content.style.minWidth="auto",t.content.style.position="relative",t.element.style.contain="none";var o=[DomHandler.getWidth(t.content),DomHandler.getHeight(t.content)],l=o[0],f=o[1];l!==t.defaultContentWidth&&(t.element.style.width=""),f!==t.defaultContentHeight&&(t.element.style.height="");var u=[DomHandler.getWidth(t.element),DomHandler.getHeight(t.element)],_=u[0],g=u[1];(r||i)&&(t.element.style.width=_<t.defaultWidth?_+"px":t.scrollWidth||t.defaultWidth+"px"),(r||s)&&(t.element.style.height=g<t.defaultHeight?g+"px":t.scrollHeight||t.defaultHeight+"px"),t.content.style.minHeight=t.content.style.minWidth="",t.content.style.position="",t.element.style.contain=""}})},getLast:function n(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,r=arguments.length>1?arguments[1]:void 0;return this.items?Math.min(r?(this.columns||this.items[0]).length:this.items.length,t):0},getContentPosition:function n(){if(this.content){var t=getComputedStyle(this.content),r=parseFloat(t.paddingLeft)+Math.max(parseFloat(t.left)||0,0),i=parseFloat(t.paddingRight)+Math.max(parseFloat(t.right)||0,0),s=parseFloat(t.paddingTop)+Math.max(parseFloat(t.top)||0,0),o=parseFloat(t.paddingBottom)+Math.max(parseFloat(t.bottom)||0,0);return{left:r,right:i,top:s,bottom:o,x:r+i,y:s+o}}return{left:0,right:0,top:0,bottom:0,x:0,y:0}},setSize:function n(){var t=this;if(this.element){var r=this.isBoth(),i=this.isHorizontal(),s=this.element.parentElement,o=this.scrollWidth||"".concat(this.element.offsetWidth||s.offsetWidth,"px"),l=this.scrollHeight||"".concat(this.element.offsetHeight||s.offsetHeight,"px"),f=function(_,g){return t.element.style[_]=g};r||i?(f("height",l),f("width",o)):f("height",l)}},setSpacerSize:function n(){var t=this,r=this.items;if(r){var i=this.isBoth(),s=this.isHorizontal(),o=this.getContentPosition(),l=function(u,_,g){var a=arguments.length>3&&arguments[3]!==void 0?arguments[3]:0;return t.spacerStyle=_objectSpread$2(_objectSpread$2({},t.spacerStyle),_defineProperty$2({},"".concat(u),(_||[]).length*g+a+"px"))};i?(l("height",r,this.itemSize[0],o.y),l("width",this.columns||r[1],this.itemSize[1],o.x)):s?l("width",this.columns||r,this.itemSize,o.x):l("height",r,this.itemSize,o.y)}},setContentPosition:function n(t){var r=this;if(this.content&&!this.appendOnly){var i=this.isBoth(),s=this.isHorizontal(),o=t?t.first:this.first,l=function(g,a){return g*a},f=function(){var g=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return r.contentStyle=_objectSpread$2(_objectSpread$2({},r.contentStyle),{transform:"translate3d(".concat(g,"px, ").concat(a,"px, 0)")})};if(i)f(l(o.cols,this.itemSize[1]),l(o.rows,this.itemSize[0]));else{var u=l(o,this.itemSize);s?f(u,0):f(0,u)}}},onScrollPositionChange:function n(t){var r=this,i=t.target,s=this.isBoth(),o=this.isHorizontal(),l=this.getContentPosition(),f=function(N,M){return N?N>M?N-M:N:0},u=function(N,M){return Math.floor(N/(M||N))},_=function(N,M,W,F,H,q){return N<=H?H:q?W-F-H:M+H-1},g=function(N,M,W,F,H,q,Y){return N<=q?0:Math.max(0,Y?N<M?W:N-q:N>M?W:N-2*q)},a=function(N,M,W,F,H,q){var Y=M+F+2*H;return N>=H&&(Y+=H+1),r.getLast(Y,q)},m=f(i.scrollTop,l.top),b=f(i.scrollLeft,l.left),v=s?{rows:0,cols:0}:0,c=this.last,w=!1,k=this.lastScrollPos;if(s){var x=this.lastScrollPos.top<=m,E=this.lastScrollPos.left<=b;if(!this.appendOnly||this.appendOnly&&(x||E)){var O={rows:u(m,this.itemSize[0]),cols:u(b,this.itemSize[1])},A={rows:_(O.rows,this.first.rows,this.last.rows,this.numItemsInViewport.rows,this.d_numToleratedItems[0],x),cols:_(O.cols,this.first.cols,this.last.cols,this.numItemsInViewport.cols,this.d_numToleratedItems[1],E)};v={rows:g(O.rows,A.rows,this.first.rows,this.last.rows,this.numItemsInViewport.rows,this.d_numToleratedItems[0],x),cols:g(O.cols,A.cols,this.first.cols,this.last.cols,this.numItemsInViewport.cols,this.d_numToleratedItems[1],E)},c={rows:a(O.rows,v.rows,this.last.rows,this.numItemsInViewport.rows,this.d_numToleratedItems[0]),cols:a(O.cols,v.cols,this.last.cols,this.numItemsInViewport.cols,this.d_numToleratedItems[1],!0)},w=v.rows!==this.first.rows||c.rows!==this.last.rows||v.cols!==this.first.cols||c.cols!==this.last.cols||this.isRangeChanged,k={top:m,left:b}}}else{var T=o?b:m,j=this.lastScrollPos<=T;if(!this.appendOnly||this.appendOnly&&j){var I=u(T,this.itemSize),D=_(I,this.first,this.last,this.numItemsInViewport,this.d_numToleratedItems,j);v=g(I,D,this.first,this.last,this.numItemsInViewport,this.d_numToleratedItems,j),c=a(I,v,this.last,this.numItemsInViewport,this.d_numToleratedItems),w=v!==this.first||c!==this.last||this.isRangeChanged,k=T}}return{first:v,last:c,isRangeChanged:w,scrollPos:k}},onScrollChange:function n(t){var r=this.onScrollPositionChange(t),i=r.first,s=r.last,o=r.isRangeChanged,l=r.scrollPos;if(o){var f={first:i,last:s};if(this.setContentPosition(f),this.first=i,this.last=s,this.lastScrollPos=l,this.$emit("scroll-index-change",f),this.lazy&&this.isPageChanged(i)){var u={first:this.step?Math.min(this.getPageByFirst(i)*this.step,this.items.length-this.step):i,last:Math.min(this.step?(this.getPageByFirst(i)+1)*this.step:s,this.items.length)},_=this.lazyLoadState.first!==u.first||this.lazyLoadState.last!==u.last;_&&this.$emit("lazy-load",u),this.lazyLoadState=u}}},onScroll:function n(t){var r=this;if(this.$emit("scroll",t),this.delay&&this.isPageChanged()){if(this.scrollTimeout&&clearTimeout(this.scrollTimeout),!this.d_loading&&this.showLoader){var i=this.onScrollPositionChange(t),s=i.isRangeChanged,o=s||(this.step?this.isPageChanged():!1);o&&(this.d_loading=!0)}this.scrollTimeout=setTimeout(function(){r.onScrollChange(t),r.d_loading&&r.showLoader&&(!r.lazy||r.loading===void 0)&&(r.d_loading=!1,r.page=r.getPageByFirst())},this.delay)}else this.onScrollChange(t)},onResize:function n(){var t=this;this.resizeTimeout&&clearTimeout(this.resizeTimeout),this.resizeTimeout=setTimeout(function(){if(DomHandler.isVisible(t.element)){var r=t.isBoth(),i=t.isVertical(),s=t.isHorizontal(),o=[DomHandler.getWidth(t.element),DomHandler.getHeight(t.element)],l=o[0],f=o[1],u=l!==t.defaultWidth,_=f!==t.defaultHeight,g=r?u||_:s?u:i?_:!1;g&&(t.d_numToleratedItems=t.numToleratedItems,t.defaultWidth=l,t.defaultHeight=f,t.defaultContentWidth=DomHandler.getWidth(t.content),t.defaultContentHeight=DomHandler.getHeight(t.content),t.init())}},this.resizeDelay)},bindResizeListener:function n(){this.resizeListener||(this.resizeListener=this.onResize.bind(this),window.addEventListener("resize",this.resizeListener),window.addEventListener("orientationchange",this.resizeListener))},unbindResizeListener:function n(){this.resizeListener&&(window.removeEventListener("resize",this.resizeListener),window.removeEventListener("orientationchange",this.resizeListener),this.resizeListener=null)},getOptions:function n(t){var r=(this.items||[]).length,i=this.isBoth()?this.first.rows+t:this.first+t;return{index:i,count:r,first:i===0,last:i===r-1,even:i%2===0,odd:i%2!==0}},getLoaderOptions:function n(t,r){var i=this.loaderArr.length;return _objectSpread$2({index:t,count:i,first:t===0,last:t===i-1,even:t%2===0,odd:t%2!==0},r)},getPageByFirst:function n(t){return Math.floor(((t??this.first)+this.d_numToleratedItems*4)/(this.step||1))},isPageChanged:function n(t){return this.step?this.page!==this.getPageByFirst(t??this.first):!0},setContentEl:function n(t){this.content=t||this.content||DomHandler.findSingle(this.element,'[data-pc-section="content"]')},elementRef:function n(t){this.element=t},contentRef:function n(t){this.content=t}},computed:{containerClass:function n(){return["p-virtualscroller",this.class,{"p-virtualscroller-inline":this.inline,"p-virtualscroller-both p-both-scroll":this.isBoth(),"p-virtualscroller-horizontal p-horizontal-scroll":this.isHorizontal()}]},contentClass:function n(){return["p-virtualscroller-content",{"p-virtualscroller-loading":this.d_loading}]},loaderClass:function n(){return["p-virtualscroller-loader",{"p-component-overlay":!this.$slots.loader}]},loadedItems:function n(){var t=this;return this.items&&!this.d_loading?this.isBoth()?this.items.slice(this.appendOnly?0:this.first.rows,this.last.rows).map(function(r){return t.columns?r:r.slice(t.appendOnly?0:t.first.cols,t.last.cols)}):this.isHorizontal()&&this.columns?this.items:this.items.slice(this.appendOnly?0:this.first,this.last):[]},loadedRows:function n(){return this.d_loading?this.loaderDisabled?this.loaderArr:[]:this.loadedItems},loadedColumns:function n(){if(this.columns){var t=this.isBoth(),r=this.isHorizontal();if(t||r)return this.d_loading&&this.loaderDisabled?t?this.loaderArr[0]:this.loaderArr:this.columns.slice(t?this.first.cols:this.first,t?this.last.cols:this.last)}return this.columns}},components:{SpinnerIcon:script$c}},_hoisted_1$1=["tabindex"];function render$1(n,t,r,i,s,o){var l=resolveComponent("SpinnerIcon");return n.disabled?(openBlock(),createElementBlock(Fragment,{key:1},[renderSlot(n.$slots,"default"),renderSlot(n.$slots,"content",{items:n.items,rows:n.items,columns:o.loadedColumns})],64)):(openBlock(),createElementBlock("div",mergeProps({key:0,ref:o.elementRef,class:o.containerClass,tabindex:n.tabindex,style:n.style,onScroll:t[0]||(t[0]=function(){return o.onScroll&&o.onScroll.apply(o,arguments)})},n.ptm("root"),{"data-pc-name":"virtualscroller"}),[renderSlot(n.$slots,"content",{styleClass:o.contentClass,items:o.loadedItems,getItemOptions:o.getOptions,loading:s.d_loading,getLoaderOptions:o.getLoaderOptions,itemSize:n.itemSize,rows:o.loadedRows,columns:o.loadedColumns,contentRef:o.contentRef,spacerStyle:s.spacerStyle,contentStyle:s.contentStyle,vertical:o.isVertical(),horizontal:o.isHorizontal(),both:o.isBoth()},function(){return[createBaseVNode("div",mergeProps({ref:o.contentRef,class:o.contentClass,style:s.contentStyle},n.ptm("content")),[(openBlock(!0),createElementBlock(Fragment,null,renderList(o.loadedItems,function(f,u){return renderSlot(n.$slots,"item",{key:u,item:f,options:o.getOptions(u)})}),128))],16)]}),n.showSpacer?(openBlock(),createElementBlock("div",mergeProps({key:0,class:"p-virtualscroller-spacer",style:s.spacerStyle},n.ptm("spacer")),null,16)):createCommentVNode("",!0),!n.loaderDisabled&&n.showLoader&&s.d_loading?(openBlock(),createElementBlock("div",mergeProps({key:1,class:o.loaderClass},n.ptm("loader")),[n.$slots&&n.$slots.loader?(openBlock(!0),createElementBlock(Fragment,{key:0},renderList(s.loaderArr,function(f,u){return renderSlot(n.$slots,"loader",{key:u,options:o.getLoaderOptions(u,o.isBoth()&&{numCols:n.d_numItemsInViewport.cols})})}),128)):createCommentVNode("",!0),renderSlot(n.$slots,"loadingicon",{},function(){return[createVNode(l,mergeProps({spin:"",class:"p-virtualscroller-loading-icon"},n.ptm("loadingIcon")),null,16)]})],16)):createCommentVNode("",!0)],16,_hoisted_1$1))}script$2.render=render$1;var css=`
@layer primevue {
    .p-dropdown {
        display: inline-flex;
        cursor: pointer;
        position: relative;
        user-select: none;
    }

    .p-dropdown-clear-icon {
        position: absolute;
        top: 50%;
        margin-top: -0.5rem;
    }

    .p-dropdown-trigger {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }

    .p-dropdown-label {
        display: block;
        white-space: nowrap;
        overflow: hidden;
        flex: 1 1 auto;
        width: 1%;
        text-overflow: ellipsis;
        cursor: pointer;
    }

    .p-dropdown-label-empty {
        overflow: hidden;
        opacity: 0;
    }

    input.p-dropdown-label {
        cursor: default;
    }

    .p-dropdown .p-dropdown-panel {
        min-width: 100%;
    }

    .p-dropdown-panel {
        position: absolute;
        top: 0;
        left: 0;
    }

    .p-dropdown-items-wrapper {
        overflow: auto;
    }

    .p-dropdown-item {
        cursor: pointer;
        font-weight: normal;
        white-space: nowrap;
        position: relative;
        overflow: hidden;
    }

    .p-dropdown-item-group {
        cursor: auto;
    }

    .p-dropdown-items {
        margin: 0;
        padding: 0;
        list-style-type: none;
    }

    .p-dropdown-filter {
        width: 100%;
    }

    .p-dropdown-filter-container {
        position: relative;
    }

    .p-dropdown-filter-icon {
        position: absolute;
        top: 50%;
        margin-top: -0.5rem;
    }

    .p-fluid .p-dropdown {
        display: flex;
    }

    .p-fluid .p-dropdown .p-dropdown-label {
        width: 1%;
    }
}
`,classes={root:function n(t){var r=t.instance,i=t.props,s=t.state;return["p-dropdown p-component p-inputwrapper",{"p-disabled":i.disabled,"p-dropdown-clearable":i.showClear&&!i.disabled,"p-focus":s.focused,"p-inputwrapper-filled":r.hasSelectedOption,"p-inputwrapper-focus":s.focused||s.overlayVisible,"p-overlay-open":s.overlayVisible}]},input:function n(t){var r=t.instance,i=t.props;return["p-dropdown-label p-inputtext",{"p-placeholder":!i.editable&&r.label===i.placeholder,"p-dropdown-label-empty":!i.editable&&!r.$slots.value&&(r.label==="p-emptylabel"||r.label.length===0)}]},clearIcon:"p-dropdown-clear-icon",trigger:"p-dropdown-trigger",loadingicon:"p-dropdown-trigger-icon",dropdownIcon:"p-dropdown-trigger-icon",panel:function n(t){var r=t.instance;return["p-dropdown-panel p-component",{"p-input-filled":r.$primevue.config.inputStyle==="filled","p-ripple-disabled":r.$primevue.config.ripple===!1}]},header:"p-dropdown-header",filterContainer:"p-dropdown-filter-container",filterInput:"p-dropdown-filter p-inputtext p-component",filterIcon:"p-dropdown-filter-icon",wrapper:"p-dropdown-items-wrapper",list:"p-dropdown-items",itemGroup:"p-dropdown-item-group",item:function n(t){var r=t.instance,i=t.state,s=t.option,o=t.focusedOption;return["p-dropdown-item",{"p-highlight":r.isSelected(s),"p-focus":i.focusedOptionIndex===o,"p-disabled":r.isOptionDisabled(s)}]},emptyMessage:"p-dropdown-empty-message"},DropdownStyle=BaseStyle.extend({name:"dropdown",css,classes}),script$1={name:"BaseDropdown",extends:script$f,props:{modelValue:null,options:Array,optionLabel:[String,Function],optionValue:[String,Function],optionDisabled:[String,Function],optionGroupLabel:[String,Function],optionGroupChildren:[String,Function],scrollHeight:{type:String,default:"200px"},filter:Boolean,filterPlaceholder:String,filterLocale:String,filterMatchMode:{type:String,default:"contains"},filterFields:{type:Array,default:null},editable:Boolean,placeholder:{type:String,default:null},disabled:{type:Boolean,default:!1},dataKey:null,showClear:{type:Boolean,default:!1},inputId:{type:String,default:null},inputClass:{type:[String,Object],default:null},inputStyle:{type:Object,default:null},inputProps:{type:null,default:null},panelClass:{type:[String,Object],default:null},panelStyle:{type:Object,default:null},panelProps:{type:null,default:null},filterInputProps:{type:null,default:null},clearIconProps:{type:null,default:null},appendTo:{type:String,default:"body"},loading:{type:Boolean,default:!1},clearIcon:{type:String,default:void 0},dropdownIcon:{type:String,default:void 0},filterIcon:{type:String,default:void 0},loadingIcon:{type:String,default:void 0},resetFilterOnHide:{type:Boolean,default:!1},virtualScrollerOptions:{type:Object,default:null},autoOptionFocus:{type:Boolean,default:!0},autoFilterFocus:{type:Boolean,default:!1},selectOnFocus:{type:Boolean,default:!1},filterMessage:{type:String,default:null},selectionMessage:{type:String,default:null},emptySelectionMessage:{type:String,default:null},emptyFilterMessage:{type:String,default:null},emptyMessage:{type:String,default:null},tabindex:{type:Number,default:0},ariaLabel:{type:String,default:null},ariaLabelledby:{type:String,default:null}},style:DropdownStyle,provide:function n(){return{$parentInstance:this}}};function _typeof$1(n){"@babel/helpers - typeof";return _typeof$1=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof$1(n)}function _toConsumableArray(n){return _arrayWithoutHoles(n)||_iterableToArray(n)||_unsupportedIterableToArray(n)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray(n,t){if(n){if(typeof n=="string")return _arrayLikeToArray(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);if(r==="Object"&&n.constructor&&(r=n.constructor.name),r==="Map"||r==="Set")return Array.from(n);if(r==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return _arrayLikeToArray(n,t)}}function _iterableToArray(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function _arrayWithoutHoles(n){if(Array.isArray(n))return _arrayLikeToArray(n)}function _arrayLikeToArray(n,t){(t==null||t>n.length)&&(t=n.length);for(var r=0,i=new Array(t);r<t;r++)i[r]=n[r];return i}function ownKeys$1(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread$1(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys$1(Object(r),!0).forEach(function(i){_defineProperty$1(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys$1(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty$1(n,t,r){return t=_toPropertyKey$1(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey$1(n){var t=_toPrimitive$1(n,"string");return _typeof$1(t)==="symbol"?t:String(t)}function _toPrimitive$1(n,t){if(_typeof$1(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof$1(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var script={name:"Dropdown",extends:script$1,emits:["update:modelValue","change","focus","blur","before-show","before-hide","show","hide","filter"],outsideClickListener:null,scrollHandler:null,resizeListener:null,overlay:null,list:null,virtualScroller:null,searchTimeout:null,searchValue:null,isModelValueChanged:!1,focusOnHover:!1,data:function n(){return{id:this.$attrs.id,focused:!1,focusedOptionIndex:-1,filterValue:null,overlayVisible:!1}},watch:{"$attrs.id":function n(t){this.id=t||UniqueComponentId()},modelValue:function n(){this.isModelValueChanged=!0},options:function n(){this.autoUpdateModel()}},mounted:function n(){this.id=this.id||UniqueComponentId(),this.autoUpdateModel()},updated:function n(){this.overlayVisible&&this.isModelValueChanged&&this.scrollInView(this.findSelectedOptionIndex()),this.isModelValueChanged=!1},beforeUnmount:function n(){this.unbindOutsideClickListener(),this.unbindResizeListener(),this.scrollHandler&&(this.scrollHandler.destroy(),this.scrollHandler=null),this.overlay&&(ZIndexUtils.clear(this.overlay),this.overlay=null)},methods:{getOptionIndex:function n(t,r){return this.virtualScrollerDisabled?t:r&&r(t).index},getOptionLabel:function n(t){return this.optionLabel?ObjectUtils.resolveFieldData(t,this.optionLabel):t},getOptionValue:function n(t){return this.optionValue?ObjectUtils.resolveFieldData(t,this.optionValue):t},getOptionRenderKey:function n(t,r){return(this.dataKey?ObjectUtils.resolveFieldData(t,this.dataKey):this.getOptionLabel(t))+"_"+r},getPTItemOptions:function n(t,r,i,s){return this.ptm(s,{context:{selected:this.isSelected(t),focused:this.focusedOptionIndex===this.getOptionIndex(i,r),disabled:this.isOptionDisabled(t)}})},isOptionDisabled:function n(t){return this.optionDisabled?ObjectUtils.resolveFieldData(t,this.optionDisabled):!1},isOptionGroup:function n(t){return this.optionGroupLabel&&t.optionGroup&&t.group},getOptionGroupLabel:function n(t){return ObjectUtils.resolveFieldData(t,this.optionGroupLabel)},getOptionGroupChildren:function n(t){return ObjectUtils.resolveFieldData(t,this.optionGroupChildren)},getAriaPosInset:function n(t){var r=this;return(this.optionGroupLabel?t-this.visibleOptions.slice(0,t).filter(function(i){return r.isOptionGroup(i)}).length:t)+1},show:function n(t){this.$emit("before-show"),this.overlayVisible=!0,this.focusedOptionIndex=this.focusedOptionIndex!==-1?this.focusedOptionIndex:this.autoOptionFocus?this.findFirstFocusedOptionIndex():-1,t&&DomHandler.focus(this.$refs.focusInput)},hide:function n(t){var r=this,i=function(){r.$emit("before-hide"),r.overlayVisible=!1,r.focusedOptionIndex=-1,r.searchValue="",r.resetFilterOnHide&&(r.filterValue=null),t&&DomHandler.focus(r.$refs.focusInput)};setTimeout(function(){i()},0)},onFocus:function n(t){this.disabled||(this.focused=!0,this.focusedOptionIndex=this.focusedOptionIndex!==-1?this.focusedOptionIndex:this.overlayVisible&&this.autoOptionFocus?this.findFirstFocusedOptionIndex():-1,this.overlayVisible&&this.scrollInView(this.focusedOptionIndex),this.$emit("focus",t))},onBlur:function n(t){this.focused=!1,this.focusedOptionIndex=-1,this.searchValue="",this.$emit("blur",t)},onKeyDown:function n(t){if(this.disabled){t.preventDefault();return}var r=t.metaKey||t.ctrlKey;switch(t.code){case"ArrowDown":this.onArrowDownKey(t);break;case"ArrowUp":this.onArrowUpKey(t,this.editable);break;case"ArrowLeft":case"ArrowRight":this.onArrowLeftKey(t,this.editable);break;case"Delete":this.onDeleteKey(t);case"Home":this.onHomeKey(t,this.editable);break;case"End":this.onEndKey(t,this.editable);break;case"PageDown":this.onPageDownKey(t);break;case"PageUp":this.onPageUpKey(t);break;case"Space":this.onSpaceKey(t,this.editable);break;case"Enter":case"NumpadEnter":this.onEnterKey(t);break;case"Escape":this.onEscapeKey(t);break;case"Tab":this.onTabKey(t);break;case"Backspace":this.onBackspaceKey(t,this.editable);break;case"ShiftLeft":case"ShiftRight":break;default:!r&&ObjectUtils.isPrintableCharacter(t.key)&&(!this.overlayVisible&&this.show(),!this.editable&&this.searchOptions(t,t.key));break}},onEditableInput:function n(t){var r=t.target.value;this.searchValue="";var i=this.searchOptions(t,r);!i&&(this.focusedOptionIndex=-1),this.updateModel(t,r)},onContainerClick:function n(t){this.disabled||this.loading||t.target.tagName==="INPUT"||t.target.getAttribute("data-pc-section")==="clearicon"||t.target.closest('[data-pc-section="clearicon"]')||(!this.overlay||!this.overlay.contains(t.target))&&(this.overlayVisible?this.hide(!0):this.show(!0))},onClearClick:function n(t){this.updateModel(t,null)},onFirstHiddenFocus:function n(t){var r=t.relatedTarget===this.$refs.focusInput?DomHandler.getFirstFocusableElement(this.overlay,':not([data-p-hidden-focusable="true"])'):this.$refs.focusInput;DomHandler.focus(r)},onLastHiddenFocus:function n(t){var r=t.relatedTarget===this.$refs.focusInput?DomHandler.getLastFocusableElement(this.overlay,':not([data-p-hidden-focusable="true"])'):this.$refs.focusInput;DomHandler.focus(r)},onOptionSelect:function n(t,r){var i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0,s=this.getOptionValue(r);this.updateModel(t,s),i&&this.hide(!0)},onOptionMouseMove:function n(t,r){this.focusOnHover&&this.changeFocusedOptionIndex(t,r)},onFilterChange:function n(t){var r=t.target.value;this.filterValue=r,this.focusedOptionIndex=-1,this.$emit("filter",{originalEvent:t,value:r}),!this.virtualScrollerDisabled&&this.virtualScroller.scrollToIndex(0)},onFilterKeyDown:function n(t){switch(t.code){case"ArrowDown":this.onArrowDownKey(t);break;case"ArrowUp":this.onArrowUpKey(t,!0);break;case"ArrowLeft":case"ArrowRight":this.onArrowLeftKey(t,!0);break;case"Home":this.onHomeKey(t,!0);break;case"End":this.onEndKey(t,!0);break;case"Enter":this.onEnterKey(t);break;case"Escape":this.onEscapeKey(t);break;case"Tab":this.onTabKey(t,!0);break}},onFilterBlur:function n(){this.focusedOptionIndex=-1},onFilterUpdated:function n(){this.overlayVisible&&this.alignOverlay()},onOverlayClick:function n(t){OverlayEventBus.emit("overlay-click",{originalEvent:t,target:this.$el})},onOverlayKeyDown:function n(t){switch(t.code){case"Escape":this.onEscapeKey(t);break}},onDeleteKey:function n(t){this.showClear&&(this.updateModel(t,null),t.preventDefault())},onArrowDownKey:function n(t){var r=this.focusedOptionIndex!==-1?this.findNextOptionIndex(this.focusedOptionIndex):this.findFirstFocusedOptionIndex();this.changeFocusedOptionIndex(t,r),!this.overlayVisible&&this.show(),t.preventDefault()},onArrowUpKey:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(t.altKey&&!r)this.focusedOptionIndex!==-1&&this.onOptionSelect(t,this.visibleOptions[this.focusedOptionIndex]),this.overlayVisible&&this.hide(),t.preventDefault();else{var i=this.focusedOptionIndex!==-1?this.findPrevOptionIndex(this.focusedOptionIndex):this.findLastFocusedOptionIndex();this.changeFocusedOptionIndex(t,i),!this.overlayVisible&&this.show(),t.preventDefault()}},onArrowLeftKey:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;r&&(this.focusedOptionIndex=-1)},onHomeKey:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;r?(t.currentTarget.setSelectionRange(0,0),this.focusedOptionIndex=-1):(this.changeFocusedOptionIndex(t,this.findFirstOptionIndex()),!this.overlayVisible&&this.show()),t.preventDefault()},onEndKey:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(r){var i=t.currentTarget,s=i.value.length;i.setSelectionRange(s,s),this.focusedOptionIndex=-1}else this.changeFocusedOptionIndex(t,this.findLastOptionIndex()),!this.overlayVisible&&this.show();t.preventDefault()},onPageUpKey:function n(t){this.scrollInView(0),t.preventDefault()},onPageDownKey:function n(t){this.scrollInView(this.visibleOptions.length-1),t.preventDefault()},onEnterKey:function n(t){this.overlayVisible?(this.focusedOptionIndex!==-1&&this.onOptionSelect(t,this.visibleOptions[this.focusedOptionIndex]),this.hide()):this.onArrowDownKey(t),t.preventDefault()},onSpaceKey:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;!r&&this.onEnterKey(t)},onEscapeKey:function n(t){this.overlayVisible&&this.hide(!0),t.preventDefault()},onTabKey:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;r||(this.overlayVisible&&this.hasFocusableElements()?(DomHandler.focus(this.$refs.firstHiddenFocusableElementOnOverlay),t.preventDefault()):(this.focusedOptionIndex!==-1&&this.onOptionSelect(t,this.visibleOptions[this.focusedOptionIndex]),this.overlayVisible&&this.hide(this.filter)))},onBackspaceKey:function n(t){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;r&&!this.overlayVisible&&this.show()},onOverlayEnter:function n(t){ZIndexUtils.set("overlay",t,this.$primevue.config.zIndex.overlay),DomHandler.addStyles(t,{position:"absolute",top:"0",left:"0"}),this.alignOverlay(),this.scrollInView(),this.autoFilterFocus&&DomHandler.focus(this.$refs.filterInput)},onOverlayAfterEnter:function n(){this.bindOutsideClickListener(),this.bindScrollListener(),this.bindResizeListener(),this.$emit("show")},onOverlayLeave:function n(){this.unbindOutsideClickListener(),this.unbindScrollListener(),this.unbindResizeListener(),this.$emit("hide"),this.overlay=null},onOverlayAfterLeave:function n(t){ZIndexUtils.clear(t)},alignOverlay:function n(){this.appendTo==="self"?DomHandler.relativePosition(this.overlay,this.$el):(this.overlay.style.minWidth=DomHandler.getOuterWidth(this.$el)+"px",DomHandler.absolutePosition(this.overlay,this.$el))},bindOutsideClickListener:function n(){var t=this;this.outsideClickListener||(this.outsideClickListener=function(r){t.overlayVisible&&t.overlay&&!t.$el.contains(r.target)&&!t.overlay.contains(r.target)&&t.hide()},document.addEventListener("click",this.outsideClickListener))},unbindOutsideClickListener:function n(){this.outsideClickListener&&(document.removeEventListener("click",this.outsideClickListener),this.outsideClickListener=null)},bindScrollListener:function n(){var t=this;this.scrollHandler||(this.scrollHandler=new ConnectedOverlayScrollHandler(this.$refs.container,function(){t.overlayVisible&&t.hide()})),this.scrollHandler.bindScrollListener()},unbindScrollListener:function n(){this.scrollHandler&&this.scrollHandler.unbindScrollListener()},bindResizeListener:function n(){var t=this;this.resizeListener||(this.resizeListener=function(){t.overlayVisible&&!DomHandler.isTouchDevice()&&t.hide()},window.addEventListener("resize",this.resizeListener))},unbindResizeListener:function n(){this.resizeListener&&(window.removeEventListener("resize",this.resizeListener),this.resizeListener=null)},hasFocusableElements:function n(){return DomHandler.getFocusableElements(this.overlay,':not([data-p-hidden-focusable="true"])').length>0},isOptionMatched:function n(t){return this.isValidOption(t)&&this.getOptionLabel(t).toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale))},isValidOption:function n(t){return ObjectUtils.isNotEmpty(t)&&!(this.isOptionDisabled(t)||this.isOptionGroup(t))},isValidSelectedOption:function n(t){return this.isValidOption(t)&&this.isSelected(t)},isSelected:function n(t){return this.isValidOption(t)&&ObjectUtils.equals(this.modelValue,this.getOptionValue(t),this.equalityKey)},findFirstOptionIndex:function n(){var t=this;return this.visibleOptions.findIndex(function(r){return t.isValidOption(r)})},findLastOptionIndex:function n(){var t=this;return ObjectUtils.findLastIndex(this.visibleOptions,function(r){return t.isValidOption(r)})},findNextOptionIndex:function n(t){var r=this,i=t<this.visibleOptions.length-1?this.visibleOptions.slice(t+1).findIndex(function(s){return r.isValidOption(s)}):-1;return i>-1?i+t+1:t},findPrevOptionIndex:function n(t){var r=this,i=t>0?ObjectUtils.findLastIndex(this.visibleOptions.slice(0,t),function(s){return r.isValidOption(s)}):-1;return i>-1?i:t},findSelectedOptionIndex:function n(){var t=this;return this.hasSelectedOption?this.visibleOptions.findIndex(function(r){return t.isValidSelectedOption(r)}):-1},findFirstFocusedOptionIndex:function n(){var t=this.findSelectedOptionIndex();return t<0?this.findFirstOptionIndex():t},findLastFocusedOptionIndex:function n(){var t=this.findSelectedOptionIndex();return t<0?this.findLastOptionIndex():t},searchOptions:function n(t,r){var i=this;this.searchValue=(this.searchValue||"")+r;var s=-1,o=!1;return this.focusedOptionIndex!==-1?(s=this.visibleOptions.slice(this.focusedOptionIndex).findIndex(function(l){return i.isOptionMatched(l)}),s=s===-1?this.visibleOptions.slice(0,this.focusedOptionIndex).findIndex(function(l){return i.isOptionMatched(l)}):s+this.focusedOptionIndex):s=this.visibleOptions.findIndex(function(l){return i.isOptionMatched(l)}),s!==-1&&(o=!0),s===-1&&this.focusedOptionIndex===-1&&(s=this.findFirstFocusedOptionIndex()),s!==-1&&this.changeFocusedOptionIndex(t,s),this.searchTimeout&&clearTimeout(this.searchTimeout),this.searchTimeout=setTimeout(function(){i.searchValue="",i.searchTimeout=null},500),o},changeFocusedOptionIndex:function n(t,r){this.focusedOptionIndex!==r&&(this.focusedOptionIndex=r,this.scrollInView(),this.selectOnFocus&&this.onOptionSelect(t,this.visibleOptions[r],!1))},scrollInView:function n(){var t=this,r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:-1,i=r!==-1?"".concat(this.id,"_").concat(r):this.focusedOptionId,s=DomHandler.findSingle(this.list,'li[id="'.concat(i,'"]'));s?s.scrollIntoView&&s.scrollIntoView({block:"nearest",inline:"start"}):this.virtualScrollerDisabled||setTimeout(function(){t.virtualScroller&&t.virtualScroller.scrollToIndex(r!==-1?r:t.focusedOptionIndex)},0)},autoUpdateModel:function n(){this.selectOnFocus&&this.autoOptionFocus&&!this.hasSelectedOption&&(this.focusedOptionIndex=this.findFirstFocusedOptionIndex(),this.onOptionSelect(null,this.visibleOptions[this.focusedOptionIndex],!1))},updateModel:function n(t,r){this.$emit("update:modelValue",r),this.$emit("change",{originalEvent:t,value:r})},flatOptions:function n(t){var r=this;return(t||[]).reduce(function(i,s,o){i.push({optionGroup:s,group:!0,index:o});var l=r.getOptionGroupChildren(s);return l&&l.forEach(function(f){return i.push(f)}),i},[])},overlayRef:function n(t){this.overlay=t},listRef:function n(t,r){this.list=t,r&&r(t)},virtualScrollerRef:function n(t){this.virtualScroller=t}},computed:{visibleOptions:function n(){var t=this,r=this.optionGroupLabel?this.flatOptions(this.options):this.options||[];if(this.filterValue){var i=FilterService.filter(r,this.searchFields,this.filterValue,this.filterMatchMode,this.filterLocale);if(this.optionGroupLabel){var s=this.options||[],o=[];return s.forEach(function(l){var f=t.getOptionGroupChildren(l),u=f.filter(function(_){return i.includes(_)});u.length>0&&o.push(_objectSpread$1(_objectSpread$1({},l),{},_defineProperty$1({},typeof t.optionGroupChildren=="string"?t.optionGroupChildren:"items",_toConsumableArray(u))))}),this.flatOptions(o)}return i}return r},hasSelectedOption:function n(){return ObjectUtils.isNotEmpty(this.modelValue)},label:function n(){var t=this.findSelectedOptionIndex();return t!==-1?this.getOptionLabel(this.visibleOptions[t]):this.placeholder||"p-emptylabel"},editableInputValue:function n(){var t=this.findSelectedOptionIndex();return t!==-1?this.getOptionLabel(this.visibleOptions[t]):this.modelValue||""},equalityKey:function n(){return this.optionValue?null:this.dataKey},searchFields:function n(){return this.filterFields||[this.optionLabel]},filterResultMessageText:function n(){return ObjectUtils.isNotEmpty(this.visibleOptions)?this.filterMessageText.replaceAll("{0}",this.visibleOptions.length):this.emptyFilterMessageText},filterMessageText:function n(){return this.filterMessage||this.$primevue.config.locale.searchMessage||""},emptyFilterMessageText:function n(){return this.emptyFilterMessage||this.$primevue.config.locale.emptySearchMessage||this.$primevue.config.locale.emptyFilterMessage||""},emptyMessageText:function n(){return this.emptyMessage||this.$primevue.config.locale.emptyMessage||""},selectionMessageText:function n(){return this.selectionMessage||this.$primevue.config.locale.selectionMessage||""},emptySelectionMessageText:function n(){return this.emptySelectionMessage||this.$primevue.config.locale.emptySelectionMessage||""},selectedMessageText:function n(){return this.hasSelectedOption?this.selectionMessageText.replaceAll("{0}","1"):this.emptySelectionMessageText},focusedOptionId:function n(){return this.focusedOptionIndex!==-1?"".concat(this.id,"_").concat(this.focusedOptionIndex):null},ariaSetSize:function n(){var t=this;return this.visibleOptions.filter(function(r){return!t.isOptionGroup(r)}).length},virtualScrollerDisabled:function n(){return!this.virtualScrollerOptions}},directives:{ripple:Ripple},components:{VirtualScroller:script$2,Portal:script$3,TimesIcon:script$4,ChevronDownIcon:script$6,SpinnerIcon:script$c,FilterIcon:script$5}};function _typeof(n){"@babel/helpers - typeof";return _typeof=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof(n)}function ownKeys(n,t){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),r.push.apply(r,i)}return r}function _objectSpread(n){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?ownKeys(Object(r),!0).forEach(function(i){_defineProperty(n,i,r[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):ownKeys(Object(r)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(r,i))})}return n}function _defineProperty(n,t,r){return t=_toPropertyKey(t),t in n?Object.defineProperty(n,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[t]=r,n}function _toPropertyKey(n){var t=_toPrimitive(n,"string");return _typeof(t)==="symbol"?t:String(t)}function _toPrimitive(n,t){if(_typeof(n)!=="object"||n===null)return n;var r=n[Symbol.toPrimitive];if(r!==void 0){var i=r.call(n,t||"default");if(_typeof(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}var _hoisted_1=["id"],_hoisted_2=["id","value","placeholder","tabindex","disabled","aria-label","aria-labelledby","aria-expanded","aria-controls","aria-activedescendant"],_hoisted_3=["id","tabindex","aria-label","aria-labelledby","aria-expanded","aria-controls","aria-activedescendant","aria-disabled"],_hoisted_4=["value","placeholder","aria-owns","aria-activedescendant"],_hoisted_5=["id"],_hoisted_6=["id"],_hoisted_7=["id","aria-label","aria-selected","aria-disabled","aria-setsize","aria-posinset","onClick","onMousemove","data-p-highlight","data-p-focused","data-p-disabled"];function render(n,t,r,i,s,o){var l=resolveComponent("SpinnerIcon"),f=resolveComponent("VirtualScroller"),u=resolveComponent("Portal"),_=resolveDirective("ripple");return openBlock(),createElementBlock("div",mergeProps({ref:"container",id:s.id,class:n.cx("root"),onClick:t[15]||(t[15]=function(){return o.onContainerClick&&o.onContainerClick.apply(o,arguments)})},n.ptm("root"),{"data-pc-name":"dropdown"}),[n.editable?(openBlock(),createElementBlock("input",mergeProps({key:0,ref:"focusInput",id:n.inputId,type:"text",class:[n.cx("input"),n.inputClass],style:n.inputStyle,value:o.editableInputValue,placeholder:n.placeholder,tabindex:n.disabled?-1:n.tabindex,disabled:n.disabled,autocomplete:"off",role:"combobox","aria-label":n.ariaLabel,"aria-labelledby":n.ariaLabelledby,"aria-haspopup":"listbox","aria-expanded":s.overlayVisible,"aria-controls":s.id+"_list","aria-activedescendant":s.focused?o.focusedOptionId:void 0,onFocus:t[0]||(t[0]=function(){return o.onFocus&&o.onFocus.apply(o,arguments)}),onBlur:t[1]||(t[1]=function(){return o.onBlur&&o.onBlur.apply(o,arguments)}),onKeydown:t[2]||(t[2]=function(){return o.onKeyDown&&o.onKeyDown.apply(o,arguments)}),onInput:t[3]||(t[3]=function(){return o.onEditableInput&&o.onEditableInput.apply(o,arguments)})},_objectSpread(_objectSpread({},n.inputProps),n.ptm("input"))),null,16,_hoisted_2)):(openBlock(),createElementBlock("span",mergeProps({key:1,ref:"focusInput",id:n.inputId,class:[n.cx("input"),n.inputClass],style:n.inputStyle,tabindex:n.disabled?-1:n.tabindex,role:"combobox","aria-label":n.ariaLabel||(o.label==="p-emptylabel"?void 0:o.label),"aria-labelledby":n.ariaLabelledby,"aria-haspopup":"listbox","aria-expanded":s.overlayVisible,"aria-controls":s.id+"_list","aria-activedescendant":s.focused?o.focusedOptionId:void 0,"aria-disabled":n.disabled,onFocus:t[4]||(t[4]=function(){return o.onFocus&&o.onFocus.apply(o,arguments)}),onBlur:t[5]||(t[5]=function(){return o.onBlur&&o.onBlur.apply(o,arguments)}),onKeydown:t[6]||(t[6]=function(){return o.onKeyDown&&o.onKeyDown.apply(o,arguments)})},_objectSpread(_objectSpread({},n.inputProps),n.ptm("input"))),[renderSlot(n.$slots,"value",{value:n.modelValue,placeholder:n.placeholder},function(){return[createTextVNode(toDisplayString(o.label==="p-emptylabel"?" ":o.label||"empty"),1)]})],16,_hoisted_3)),n.showClear&&n.modelValue!=null?renderSlot(n.$slots,"clearicon",{key:2,class:normalizeClass(n.cx("clearIcon")),onClick:o.onClearClick,clearCallback:o.onClearClick},function(){return[(openBlock(),createBlock(resolveDynamicComponent(n.clearIcon?"i":"TimesIcon"),mergeProps({ref:"clearIcon",class:[n.cx("clearIcon"),n.clearIcon],onClick:o.onClearClick},_objectSpread(_objectSpread({},n.clearIconProps),n.ptm("clearIcon")),{"data-pc-section":"clearicon"}),null,16,["class","onClick"]))]}):createCommentVNode("",!0),createBaseVNode("div",mergeProps({class:n.cx("trigger")},n.ptm("trigger")),[n.loading?renderSlot(n.$slots,"loadingicon",{key:0,class:normalizeClass(n.cx("loadingIcon"))},function(){return[n.loadingIcon?(openBlock(),createElementBlock("span",mergeProps({key:0,class:[n.cx("loadingIcon"),"pi-spin",n.loadingIcon],"aria-hidden":"true"},n.ptm("loadingIcon")),null,16)):(openBlock(),createBlock(l,mergeProps({key:1,class:n.cx("loadingIcon"),spin:"","aria-hidden":"true"},n.ptm("loadingIcon")),null,16,["class"]))]}):renderSlot(n.$slots,"dropdownicon",{key:1,class:normalizeClass(n.cx("dropdownIcon"))},function(){return[(openBlock(),createBlock(resolveDynamicComponent(n.dropdownIcon?"span":"ChevronDownIcon"),mergeProps({class:[n.cx("dropdownIcon"),n.dropdownIcon],"aria-hidden":"true"},n.ptm("dropdownIcon")),null,16,["class"]))]})],16),createVNode(u,{appendTo:n.appendTo},{default:withCtx(function(){return[createVNode(Transition,mergeProps({name:"p-connected-overlay",onEnter:o.onOverlayEnter,onAfterEnter:o.onOverlayAfterEnter,onLeave:o.onOverlayLeave,onAfterLeave:o.onOverlayAfterLeave},n.ptm("transition")),{default:withCtx(function(){return[s.overlayVisible?(openBlock(),createElementBlock("div",mergeProps({key:0,ref:o.overlayRef,class:[n.cx("panel"),n.panelClass],style:n.panelStyle,onClick:t[13]||(t[13]=function(){return o.onOverlayClick&&o.onOverlayClick.apply(o,arguments)}),onKeydown:t[14]||(t[14]=function(){return o.onOverlayKeyDown&&o.onOverlayKeyDown.apply(o,arguments)})},_objectSpread(_objectSpread({},n.panelProps),n.ptm("panel"))),[createBaseVNode("span",mergeProps({ref:"firstHiddenFocusableElementOnOverlay",role:"presentation","aria-hidden":"true",class:"p-hidden-accessible p-hidden-focusable",tabindex:0,onFocus:t[7]||(t[7]=function(){return o.onFirstHiddenFocus&&o.onFirstHiddenFocus.apply(o,arguments)})},n.ptm("hiddenFirstFocusableEl"),{"data-p-hidden-accessible":!0,"data-p-hidden-focusable":!0}),null,16),renderSlot(n.$slots,"header",{value:n.modelValue,options:o.visibleOptions}),n.filter?(openBlock(),createElementBlock("div",mergeProps({key:0,class:n.cx("header")},n.ptm("header")),[createBaseVNode("div",mergeProps({class:n.cx("filterContainer")},n.ptm("filterContainer")),[createBaseVNode("input",mergeProps({ref:"filterInput",type:"text",value:s.filterValue,onVnodeMounted:t[8]||(t[8]=function(){return o.onFilterUpdated&&o.onFilterUpdated.apply(o,arguments)}),class:n.cx("filterInput"),placeholder:n.filterPlaceholder,role:"searchbox",autocomplete:"off","aria-owns":s.id+"_list","aria-activedescendant":o.focusedOptionId,onKeydown:t[9]||(t[9]=function(){return o.onFilterKeyDown&&o.onFilterKeyDown.apply(o,arguments)}),onBlur:t[10]||(t[10]=function(){return o.onFilterBlur&&o.onFilterBlur.apply(o,arguments)}),onInput:t[11]||(t[11]=function(){return o.onFilterChange&&o.onFilterChange.apply(o,arguments)})},_objectSpread(_objectSpread({},n.filterInputProps),n.ptm("filterInput"))),null,16,_hoisted_4),renderSlot(n.$slots,"filtericon",{class:normalizeClass(n.cx("filterIcon"))},function(){return[(openBlock(),createBlock(resolveDynamicComponent(n.filterIcon?"span":"FilterIcon"),mergeProps({class:[n.cx("filterIcon"),n.filterIcon]},n.ptm("filterIcon")),null,16,["class"]))]})],16),createBaseVNode("span",mergeProps({role:"status","aria-live":"polite",class:"p-hidden-accessible"},n.ptm("hiddenFilterResult"),{"data-p-hidden-accessible":!0}),toDisplayString(o.filterResultMessageText),17)],16)):createCommentVNode("",!0),createBaseVNode("div",mergeProps({class:n.cx("wrapper"),style:{"max-height":o.virtualScrollerDisabled?n.scrollHeight:""}},n.ptm("wrapper")),[createVNode(f,mergeProps({ref:o.virtualScrollerRef},n.virtualScrollerOptions,{items:o.visibleOptions,style:{height:n.scrollHeight},tabindex:-1,disabled:o.virtualScrollerDisabled,pt:n.ptm("virtualScroller")}),createSlots({content:withCtx(function(g){var a=g.styleClass,m=g.contentRef,b=g.items,v=g.getItemOptions,c=g.contentStyle,w=g.itemSize;return[createBaseVNode("ul",mergeProps({ref:function(x){return o.listRef(x,m)},id:s.id+"_list",class:[n.cx("list"),a],style:c,role:"listbox"},n.ptm("list")),[(openBlock(!0),createElementBlock(Fragment,null,renderList(b,function(k,x){return openBlock(),createElementBlock(Fragment,{key:o.getOptionRenderKey(k,o.getOptionIndex(x,v))},[o.isOptionGroup(k)?(openBlock(),createElementBlock("li",mergeProps({key:0,id:s.id+"_"+o.getOptionIndex(x,v),style:{height:w?w+"px":void 0},class:n.cx("itemGroup"),role:"option"},n.ptm("itemGroup")),[renderSlot(n.$slots,"optiongroup",{option:k.optionGroup,index:o.getOptionIndex(x,v)},function(){return[createTextVNode(toDisplayString(o.getOptionGroupLabel(k.optionGroup)),1)]})],16,_hoisted_6)):withDirectives((openBlock(),createElementBlock("li",mergeProps({key:1,id:s.id+"_"+o.getOptionIndex(x,v),class:n.cx("item",{option:k,focusedOption:o.getOptionIndex(x,v)}),style:{height:w?w+"px":void 0},role:"option","aria-label":o.getOptionLabel(k),"aria-selected":o.isSelected(k),"aria-disabled":o.isOptionDisabled(k),"aria-setsize":o.ariaSetSize,"aria-posinset":o.getAriaPosInset(o.getOptionIndex(x,v)),onClick:function(O){return o.onOptionSelect(O,k)},onMousemove:function(O){return o.onOptionMouseMove(O,o.getOptionIndex(x,v))},"data-p-highlight":o.isSelected(k),"data-p-focused":s.focusedOptionIndex===o.getOptionIndex(x,v),"data-p-disabled":o.isOptionDisabled(k)},o.getPTItemOptions(k,v,x,"item")),[renderSlot(n.$slots,"option",{option:k,index:o.getOptionIndex(x,v)},function(){return[createTextVNode(toDisplayString(o.getOptionLabel(k)),1)]})],16,_hoisted_7)),[[_]])],64)}),128)),s.filterValue&&(!b||b&&b.length===0)?(openBlock(),createElementBlock("li",mergeProps({key:0,class:n.cx("emptyMessage"),role:"option"},n.ptm("emptyMessage"),{"data-p-hidden-accessible":!0}),[renderSlot(n.$slots,"emptyfilter",{},function(){return[createTextVNode(toDisplayString(o.emptyFilterMessageText),1)]})],16)):!n.options||n.options&&n.options.length===0?(openBlock(),createElementBlock("li",mergeProps({key:1,class:n.cx("emptyMessage"),role:"option"},n.ptm("emptyMessage"),{"data-p-hidden-accessible":!0}),[renderSlot(n.$slots,"empty",{},function(){return[createTextVNode(toDisplayString(o.emptyMessageText),1)]})],16)):createCommentVNode("",!0)],16,_hoisted_5)]}),_:2},[n.$slots.loader?{name:"loader",fn:withCtx(function(g){var a=g.options;return[renderSlot(n.$slots,"loader",{options:a})]}),key:"0"}:void 0]),1040,["items","style","disabled","pt"])],16),renderSlot(n.$slots,"footer",{value:n.modelValue,options:o.visibleOptions}),!n.options||n.options&&n.options.length===0?(openBlock(),createElementBlock("span",mergeProps({key:1,role:"status","aria-live":"polite",class:"p-hidden-accessible"},n.ptm("hiddenEmptyMessage"),{"data-p-hidden-accessible":!0}),toDisplayString(o.emptyMessageText),17)):createCommentVNode("",!0),createBaseVNode("span",mergeProps({role:"status","aria-live":"polite",class:"p-hidden-accessible"},n.ptm("hiddenSelectedMessage"),{"data-p-hidden-accessible":!0}),toDisplayString(o.selectedMessageText),17),createBaseVNode("span",mergeProps({ref:"lastHiddenFocusableElementOnOverlay",role:"presentation","aria-hidden":"true",class:"p-hidden-accessible p-hidden-focusable",tabindex:0,onFocus:t[12]||(t[12]=function(){return o.onLastHiddenFocus&&o.onLastHiddenFocus.apply(o,arguments)})},n.ptm("hiddenLastFocusableEl"),{"data-p-hidden-accessible":!0,"data-p-hidden-focusable":!0}),null,16)],16)):createCommentVNode("",!0)]}),_:3},16,["onEnter","onAfterEnter","onLeave","onAfterLeave"])]}),_:3},8,["appendTo"])],16,_hoisted_1)}script.render=render;const imjoy=new imjoyCore.ImJoy({imjoy_api:{}});window.app={};imjoy.start({workspace:"default"}).then(async()=>{console.log("ImJoy started"),window.app.imjoy=imjoy});const app=createApp(_sfc_main);app.use(PrimeVue,{unstyled:!1});app.component("Button",script$b);app.component("InputNumber",script$7);app.component("Dropdown",script);app.component("InputText",script$8);app.mount("#app");
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}